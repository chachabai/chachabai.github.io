<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>dna049 的 C++ 模板 | dna049</title><meta name="description" content="此处只包含通用代码块，以下为其它内容：  C++ 代码规范 C++ 万能模板 STL 和 C++17 学习记录   欢迎使用或转载代码块，唯一要求添加一行注释: https:&#x2F;&#x2F;dna049.com  编译器比你想象中的聪明，所以尽量写 编译器好优化 并且 易读 的代码，很多位运算，除法都是可以被优化的！优质的代码本身就是一种解释，添加完全不必要的注释只会让人恶心以后尽量使用 vector 而非数"><meta name="keywords" content="C++"><meta name="author" content="dna049"><meta name="copyright" content="dna049"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/dna049.png"><link rel="canonical" href="https://dna049.com/templateOfCpp/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="dna049 的 C++ 模板"><meta property="og:url" content="https://dna049.com/templateOfCpp/"><meta property="og:site_name" content="dna049"><meta property="og:description" content="此处只包含通用代码块，以下为其它内容：  C++ 代码规范 C++ 万能模板 STL 和 C++17 学习记录   欢迎使用或转载代码块，唯一要求添加一行注释: https:&#x2F;&#x2F;dna049.com  编译器比你想象中的聪明，所以尽量写 编译器好优化 并且 易读 的代码，很多位运算，除法都是可以被优化的！优质的代码本身就是一种解释，添加完全不必要的注释只会让人恶心以后尽量使用 vector 而非数"><meta property="og:image" content="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><meta property="article:published_time" content="2020-07-17T17:20:02.000Z"><meta property="article:modified_time" content="2021-01-22T23:55:13.937Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = '2'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?79cbe4231606af28625413fd5210e0b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '4.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"18px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-01-23 07:55:13'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="dna049" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/dna049.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">83</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">23</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/templateOfCpp"><i class="fa-fw fas fa-heart"></i><span> C++模板</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-calendar"></i><span> 工具类网站</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#通用代码块"><span class="toc-number">1.</span> <span class="toc-text">通用代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#佛祖保佑，永无-bug"><span class="toc-number">1.1.</span> <span class="toc-text">佛祖保佑，永无 bug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VScode-下-debeg"><span class="toc-number">1.2.</span> <span class="toc-text">VScode 下 debeg</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归程序防止爆栈"><span class="toc-number">1.3.</span> <span class="toc-text">递归程序防止爆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类中静态成员定义时初始化"><span class="toc-number">1.4.</span> <span class="toc-text">类中静态成员定义时初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitset-高端压位卡常"><span class="toc-number">1.5.</span> <span class="toc-text">bitset 高端压位卡常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算的关系"><span class="toc-number">1.6.</span> <span class="toc-text">位运算的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Meet-in-Middle-拆半搜索法"><span class="toc-number">1.7.</span> <span class="toc-text">Meet in Middle(拆半搜索法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int128-的使用"><span class="toc-number">1.8.</span> <span class="toc-text">int128 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#交互式题目模板"><span class="toc-number">1.9.</span> <span class="toc-text">交互式题目模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#负数下标技巧"><span class="toc-number">1.10.</span> <span class="toc-text">负数下标技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优雅的输出技巧"><span class="toc-number">1.11.</span> <span class="toc-text">优雅的输出技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模正数向下取整：-lfloor-frac-a-n-rfloor-和-模正数向下取整：-lceil-frac-a-n-rceil"><span class="toc-number">1.12.</span> <span class="toc-text">模正数向下取整：$\lfloor \frac{a}{n} \rfloor$ 和 模正数向下取整：$\lceil \frac{a}{n} \rceil$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floor-sum-displaystyle-sum-i-0-n-1-lfloor-frac-a-cdot-i-b-m-rfloor"><span class="toc-number">1.13.</span> <span class="toc-text">Floor_sum : $\displaystyle \sum_{i &#x3D; 0}^{n - 1} \lfloor \frac{a \cdot i + b}{m} \rfloor$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带取整的函数取最值的技巧"><span class="toc-number">1.14.</span> <span class="toc-text">带取整的函数取最值的技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释"><span class="toc-number">1.15.</span> <span class="toc-text">Barrent reduction 快速模，弃用，因为并不会变快… ：wiki 镜像解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出全排列"><span class="toc-number">1.16.</span> <span class="toc-text">输出全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出全排列的原理"><span class="toc-number">1.17.</span> <span class="toc-text">输出全排列的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初等数论"><span class="toc-number">2.</span> <span class="toc-text">初等数论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Greatest-Common-divisor"><span class="toc-number">2.1.</span> <span class="toc-text">Greatest Common divisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n"><span class="toc-number">2.2.</span> <span class="toc-text">Sum of least common multiple  $s_n &#x3D;  \sum_{i&#x3D;1} ^n lcm(i,n)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-lcm-i-j"><span class="toc-number">2.3.</span> <span class="toc-text">Double sum of least common multiple $ds_n &#x3D; \sum_{1 \leq i \leq j \leq n} lcm(i,j)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模乘法逆元"><span class="toc-number">2.4.</span> <span class="toc-text">模乘法逆元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速模乘法"><span class="toc-number">2.5.</span> <span class="toc-text">快速模乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速模加法（弃用，利用-int128-即可）"><span class="toc-number">2.6.</span> <span class="toc-text">快速模加法（弃用，利用 __int128 即可）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速模加法下的快速模乘法（弃用，利用-int128-即可）"><span class="toc-number">2.7.</span> <span class="toc-text">快速模加法下的快速模乘法（弃用，利用 __int128 即可）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阶乘、组合数、Lucas-定理"><span class="toc-number">2.8.</span> <span class="toc-text">阶乘、组合数、Lucas 定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用组合数公式"><span class="toc-number">2.9.</span> <span class="toc-text">常用组合数公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#乞丐版素数判断"><span class="toc-number">2.10.</span> <span class="toc-text">乞丐版素数判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-n-log-n-素数筛"><span class="toc-number">2.11.</span> <span class="toc-text">$O(n \log n)$ 素数筛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧拉线性素数筛（弃用）"><span class="toc-number">2.12.</span> <span class="toc-text">欧拉线性素数筛（弃用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧拉线性素数筛（正式使用版）"><span class="toc-number">2.13.</span> <span class="toc-text">欧拉线性素数筛（正式使用版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-1-（执行）时间复杂度判断一个数是否为素数"><span class="toc-number">2.14.</span> <span class="toc-text">$O(1)$ （执行）时间复杂度判断一个数是否为素数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大素数-Miller-Rabin-概率判别法"><span class="toc-number">2.15.</span> <span class="toc-text">大素数 Miller-Rabin 概率判别法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大整数的最小素因子"><span class="toc-number">2.16.</span> <span class="toc-text">大整数的最小素因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大整数的最小素因子-1"><span class="toc-number">2.17.</span> <span class="toc-text">大整数的最小素因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-n-最小素因子预处理"><span class="toc-number">2.18.</span> <span class="toc-text">$O(n)$ 最小素因子预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mobius-function"><span class="toc-number">2.19.</span> <span class="toc-text">Mobius function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mobius-function-前缀和"><span class="toc-number">2.20.</span> <span class="toc-text">Mobius function 前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Euler’s-totient-function"><span class="toc-number">2.21.</span> <span class="toc-text">Euler’s totient function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pi-x-函数"><span class="toc-number">2.22.</span> <span class="toc-text">$\pi(x)$ 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pi-x-函数计算的另一种做法"><span class="toc-number">2.23.</span> <span class="toc-text">$\pi(x)$ 函数计算的另一种做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求奇素数的一个原根"><span class="toc-number">2.24.</span> <span class="toc-text">求奇素数的一个原根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数论函数的-Dirichlet-乘积"><span class="toc-number">2.25.</span> <span class="toc-text">数论函数的 Dirichlet 乘积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#"><span class="toc-number">2.26.</span> <span class="toc-text">中国剩余定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#离散对数"><span class="toc-number">2.27.</span> <span class="toc-text">离散对数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模素数开根号"><span class="toc-number">2.28.</span> <span class="toc-text">模素数开根号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自然数方幂和-O-k-算法"><span class="toc-number">2.29.</span> <span class="toc-text">自然数方幂和 $O(k)$ 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自然数方幂和精确版"><span class="toc-number">2.30.</span> <span class="toc-text">自然数方幂和精确版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生成函数"><span class="toc-number">3.</span> <span class="toc-text">生成函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多项式取对数和指数"><span class="toc-number">3.1.</span> <span class="toc-text">多项式取对数和指数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NFT-正式可用版-last-updated-2020-7-9"><span class="toc-number">3.2.</span> <span class="toc-text">NFT 正式可用版(last updated: 2020&#x2F;7&#x2F;9)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#siyuan-的-FWT-模板-（弃用）"><span class="toc-number">3.3.</span> <span class="toc-text">siyuan 的 FWT 模板 （弃用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FMT-模板"><span class="toc-number">3.4.</span> <span class="toc-text">FMT 模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#矩阵类"><span class="toc-number">3.5.</span> <span class="toc-text">矩阵类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gauss-消元法浮点版"><span class="toc-number">3.6.</span> <span class="toc-text">Gauss 消元法浮点版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gauss-消元法有限域版"><span class="toc-number">3.7.</span> <span class="toc-text">Gauss 消元法有限域版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#：例题"><span class="toc-number">3.8.</span> <span class="toc-text">线性规划单纯形法：例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法"><span class="toc-number">3.9.</span> <span class="toc-text">求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">4.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并查集（Disjoint-Set-Union）"><span class="toc-number">4.1.</span> <span class="toc-text">并查集（Disjoint Set Union）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#离散化"><span class="toc-number">4.2.</span> <span class="toc-text">离散化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逆序数"><span class="toc-number">4.3.</span> <span class="toc-text">逆序数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树状数组（单点更新，从-1-到某个位置的最小值）"><span class="toc-number">4.4.</span> <span class="toc-text">树状数组（单点更新，从 1 到某个位置的最小值）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树状数组（单点更新，区间求和，编号从-1-开始）"><span class="toc-number">4.5.</span> <span class="toc-text">树状数组（单点更新，区间求和，编号从 1 开始）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树状数组（区间更新，区间求和，编号从-1-开始）"><span class="toc-number">4.6.</span> <span class="toc-text">树状数组（区间更新，区间求和，编号从 1 开始）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线段树（正式版）"><span class="toc-number">4.7.</span> <span class="toc-text">线段树（正式版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线段树-（弃用版）"><span class="toc-number">4.8.</span> <span class="toc-text">线段树 （弃用版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMQ-求区间最大值（弃用）"><span class="toc-number">4.9.</span> <span class="toc-text">RMQ 求区间最大值（弃用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三分法简单版"><span class="toc-number">4.10.</span> <span class="toc-text">三分法简单版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准三分法用黄金分割的原因"><span class="toc-number">4.11.</span> <span class="toc-text">标准三分法用黄金分割的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三分法黄金分割版（可用版）"><span class="toc-number">4.12.</span> <span class="toc-text">三分法黄金分割版（可用版）)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长（严格）递增子序列"><span class="toc-number">4.13.</span> <span class="toc-text">最长（严格）递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#背包"><span class="toc-number">4.14.</span> <span class="toc-text">背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆与-STL-优先队列"><span class="toc-number">4.15.</span> <span class="toc-text">堆与 STL 优先队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序反字典序输出"><span class="toc-number">4.16.</span> <span class="toc-text">拓扑排序反字典序输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑树-red-black-tree"><span class="toc-number">4.17.</span> <span class="toc-text">红黑树 red-black tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图论"><span class="toc-number">5.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图论模板"><span class="toc-number">5.1.</span> <span class="toc-text">图论模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存边方式"><span class="toc-number">5.2.</span> <span class="toc-text">存边方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图的匹配算法"><span class="toc-number">5.3.</span> <span class="toc-text">图的匹配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链式前向星-（弃用）"><span class="toc-number">5.4.</span> <span class="toc-text">链式前向星 （弃用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#知乎上看到-YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）"><span class="toc-number">5.5.</span> <span class="toc-text">知乎上看到 YYYYLLL 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd-带路径-—-未测试"><span class="toc-number">5.6.</span> <span class="toc-text">Floyd 带路径 —- 未测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有根树的-dfs-序-和-Euler-序列"><span class="toc-number">5.7.</span> <span class="toc-text">有根树的 dfs 序 和 Euler 序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#每个节点仅标记一次的-Euler-序列"><span class="toc-number">5.8.</span> <span class="toc-text">每个节点仅标记一次的 Euler 序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进入记录一次，出去记录一次的-Euler-序列"><span class="toc-number">5.9.</span> <span class="toc-text">进入记录一次，出去记录一次的 Euler 序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无根树的-Prufer-序列"><span class="toc-number">5.10.</span> <span class="toc-text">无根树的 Prufer 序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的直径：先从任意点开始寻找最远距离点（bfs-遍历一下），然后再找一次就是了（易证）"><span class="toc-number">5.11.</span> <span class="toc-text">树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的中心-：所有点到该点的最大值最小（直径的中点）"><span class="toc-number">5.12.</span> <span class="toc-text">[树的中心]：所有点到该点的最大值最小（直径的中点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的重心：去掉这个点后连通分支的节点数量的最大值最小"><span class="toc-number">5.13.</span> <span class="toc-text">树的重心：去掉这个点后连通分支的节点数量的最大值最小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最近公共祖先简称-LCA（Lowest-Common-Ancestor）"><span class="toc-number">5.14.</span> <span class="toc-text">最近公共祖先简称 LCA（Lowest Common Ancestor）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有向图的拓扑排序之-Kahn-算法"><span class="toc-number">5.15.</span> <span class="toc-text">有向图的拓扑排序之 Kahn 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#笛卡尔树-：我去，竟然是-O-n-复杂度的建树"><span class="toc-number">5.16.</span> <span class="toc-text">笛卡尔树 ：我去，竟然是 $O(n)$ 复杂度的建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小生成树-prim-算法"><span class="toc-number">5.17.</span> <span class="toc-text">最小生成树 prim 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小树形图的-O-nm-刘朱算法"><span class="toc-number">5.18.</span> <span class="toc-text">最小树形图的 $O(nm)$ 刘朱算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短路：堆优化-Dijkstra"><span class="toc-number">5.19.</span> <span class="toc-text">最短路：堆优化 Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短路：堆优化-Dijkstra-弃用"><span class="toc-number">5.20.</span> <span class="toc-text">最短路：堆优化 Dijkstra (弃用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-color"><span class="toc-number">5.21.</span> <span class="toc-text">2-color</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Chromatic-Polynomial"><span class="toc-number">5.22.</span> <span class="toc-text">The Chromatic Polynomial</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kosaraju-算法缩点"><span class="toc-number">5.23.</span> <span class="toc-text">Kosaraju 算法缩点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SAT"><span class="toc-number">5.24.</span> <span class="toc-text">2-SAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#割点（无向图中删除该点使得连通分量数量增多的节点）"><span class="toc-number">5.25.</span> <span class="toc-text">割点（无向图中删除该点使得连通分量数量增多的节点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#割边（无向图中删除该边使得连通分量数量增多的边）"><span class="toc-number">5.26.</span> <span class="toc-text">割边（无向图中删除该边使得连通分量数量增多的边）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有向图-S-T-最大流-Dinic-算法-O-n-2-m-（对偶问题：S-T-最大流等于-S-T-最小割）"><span class="toc-number">5.27.</span> <span class="toc-text">有向图 S-T 最大流 Dinic 算法 $O(n^2 m)$（对偶问题：S-T 最大流等于 S-T 最小割）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-unordered-map-直接存边的-Dinic-算法（注意结果是否超-int）"><span class="toc-number">5.28.</span> <span class="toc-text">使用 unordered_map 直接存边的 Dinic 算法（注意结果是否超 int）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有向图-S-T-最大流-ISAP-算法-弃用"><span class="toc-number">5.29.</span> <span class="toc-text">有向图 S-T 最大流 ISAP 算法 (弃用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有向图-S-T-最大流的最高标号预流推进算法（HLPP）-O-n-2-sqrt-m-算法"><span class="toc-number">5.30.</span> <span class="toc-text">有向图 S-T 最大流的最高标号预流推进算法（HLPP） $O(n^2 \sqrt{m})$ 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无向图全局最小割-Stoer-Wagner-算法"><span class="toc-number">5.31.</span> <span class="toc-text">无向图全局最小割 Stoer-Wagner 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无向图全局最小割-Stoer-Wagner-算法，邻接矩阵-O-n-3-实现"><span class="toc-number">5.32.</span> <span class="toc-text">无向图全局最小割 Stoer-Wagner 算法，邻接矩阵 $O(n^3)$ 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无向图全局最小割-Stoer-Wagner-算法，邻接-unorded-map-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法）"><span class="toc-number">5.33.</span> <span class="toc-text">无向图全局最小割 Stoer-Wagner 算法，邻接 unorded_map + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无向图全局最小割-Stoer-Wagner-算法，邻接表-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法还是-TLE-属实可惜）"><span class="toc-number">5.34.</span> <span class="toc-text">无向图全局最小割 Stoer-Wagner 算法，邻接表 + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法还是 TLE 属实可惜）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小费用最大流"><span class="toc-number">5.35.</span> <span class="toc-text">最小费用最大流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维凸包正式版"><span class="toc-number">5.36.</span> <span class="toc-text">二维凸包正式版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维凸包（弃用版）"><span class="toc-number">5.37.</span> <span class="toc-text">二维凸包（弃用版）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几类根号算法"><span class="toc-number">6.</span> <span class="toc-text">几类根号算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#s-n-sum-i-1-n-lfloor-frac-n-i-rfloor"><span class="toc-number">6.1.</span> <span class="toc-text">$ s(n) &#x3D; \sum_{i&#x3D;1}^{n} \lfloor \frac{n}{i} \rfloor $</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i"><span class="toc-number">6.2.</span> <span class="toc-text">$\sum_{i&#x3D;1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor"><span class="toc-number">6.3.</span> <span class="toc-text">$h(n) &#x3D; \frac{n(n-1)(n-2)}{3} - \sum_{i&#x3D;2}^n h(\lfloor \frac{n}{i} \rfloor)$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归算法复杂度分析"><span class="toc-number">7.</span> <span class="toc-text">递归算法复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#To-Be-Continue"><span class="toc-number">8.</span> <span class="toc-text">To Be Continue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日常表白-zly"><span class="toc-number">9.</span> <span class="toc-text">日常表白 zly</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">dna049</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/templateOfCpp"><i class="fa-fw fas fa-heart"></i><span> C++模板</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-calendar"></i><span> 工具类网站</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">dna049 的 C++ 模板</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-17T17:20:02.000Z" title="发表于 2020-07-18 01:20:02">2020-07-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-22T23:55:13.937Z" title="更新于 2021-01-23 07:55:13">2021-01-23</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>140分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>此处只包含通用代码块，以下为其它内容：</p>
<ul>
<li><a href="/codeStyle/" title="C++ 代码规范">C++ 代码规范</a></li>
<li><a href="/allTemplate/" title="C++ 万能模板">C++ 万能模板</a></li>
<li><a href="/stl/" title="STL 和 C++17 学习记录">STL 和 C++17 学习记录</a>
</li>
</ul>
<p><strong>欢迎使用或转载代码块，唯一要求添加一行注释</strong>: <code>https://dna049.com</code></p>
<blockquote>
<p>编译器比你想象中的聪明，所以尽量写 <strong>编译器好优化</strong> 并且 <strong>易读</strong> 的代码，很多位运算，除法都是可以被优化的！<br>优质的代码本身就是一种解释，添加完全不必要的注释只会让人恶心<br>以后尽量使用 <code>vector</code> 而非数组，结合 <code>C++17</code> 特征，可以简化代码且便于编译器优化！<br>以前觉得 <code>main</code> 函数 <code>return 0</code> 只是标准写法，现在(2020/5/22)才知道能返回就能提前优雅的结束，并且可以判断是否正常结束！<br>全局变量数组元素自动默认初始化为 0，局部变量要加 <code>= {}</code> 才会初始化为 0</p>
</blockquote>
<a id="more"></a>
<h2 id="通用代码块"><a href="#通用代码块" class="headerlink" title="通用代码块"></a>通用代码块</h2><h3 id="佛祖保佑，永无-bug"><a href="#佛祖保佑，永无-bug" class="headerlink" title="佛祖保佑，永无 bug"></a>佛祖保佑，永无 bug</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="comment">// #define print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl </span></span><br><span class="line"><span class="comment">// #define println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">auto</span> start = <span class="built_in">std</span>::clock();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time used: "</span> &lt;&lt; (<span class="built_in">std</span>::clock() - start) &lt;&lt; <span class="string">"ms"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">------ Welcome to my blog: http://dna049.com ------</span></span><br><span class="line"><span class="comment">                   _ooOoo_</span></span><br><span class="line"><span class="comment">                  o8888888o</span></span><br><span class="line"><span class="comment">                  88" . "88</span></span><br><span class="line"><span class="comment">                  (| -_- |)</span></span><br><span class="line"><span class="comment">                  O\  =  /O</span></span><br><span class="line"><span class="comment">               ____/`---'\____</span></span><br><span class="line"><span class="comment">             .'  \\|     |//  `.</span></span><br><span class="line"><span class="comment">            /  \\|||  :  |||//  \</span></span><br><span class="line"><span class="comment">           /  _||||| -:- |||||-  \</span></span><br><span class="line"><span class="comment">           |   | \\\  -  /// |   |</span></span><br><span class="line"><span class="comment">           | \_|  ''\---/''  |   |</span></span><br><span class="line"><span class="comment">           \  .-\__  `-`  ___/-. /</span></span><br><span class="line"><span class="comment">         ___`. .'  /--.--\  `. . __</span></span><br><span class="line"><span class="comment">      ."" '&lt;  `.___\_&lt;|&gt;_/___.'  &gt;'"".</span></span><br><span class="line"><span class="comment">     | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span></span><br><span class="line"><span class="comment">     \  \ `-.   \_ __\ /__ _/   .-` /  /</span></span><br><span class="line"><span class="comment">======`-.____`-.___\_____/___.-`____.-'======</span></span><br><span class="line"><span class="comment">                   `=---='</span></span><br><span class="line"><span class="comment">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line"><span class="comment">            佛祖保佑       永无BUG</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐</span></span><br><span class="line"><span class="comment"> * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐</span></span><br><span class="line"><span class="comment"> * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘</span></span><br><span class="line"><span class="comment"> * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐</span></span><br><span class="line"><span class="comment"> * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │</span></span><br><span class="line"><span class="comment"> * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤</span></span><br><span class="line"><span class="comment"> * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │</span></span><br><span class="line"><span class="comment"> * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │</span></span><br><span class="line"><span class="comment"> * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter  │               │ 4 │ 5 │ 6 │   │</span></span><br><span class="line"><span class="comment"> * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤</span></span><br><span class="line"><span class="comment"> * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │</span></span><br><span class="line"><span class="comment"> * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││</span></span><br><span class="line"><span class="comment"> * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│</span></span><br><span class="line"><span class="comment"> * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="VScode-下-debeg"><a href="#VScode-下-debeg" class="headerlink" title="VScode 下 debeg"></a>VScode 下 debeg</h3><p>需要在默认生成的 task.json 中在 <code>&quot;args&quot;:</code> 下添加一行 <code>&quot;-std=c++17&quot;,</code> 不然要报 warning 很烦。另外要使用绝对路径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能使用相对路径 debug，也可能是设置问题</span></span><br><span class="line">freopen(<span class="string">"C:/Users/dna049/cf/in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure>
<h3 id="递归程序防止爆栈"><a href="#递归程序防止爆栈" class="headerlink" title="递归程序防止爆栈"></a>递归程序防止爆栈</h3><p>在 Windows 上，通常的方法是在 <strong>编译选项</strong> 中加入 <code>-Wl,--stack=1000000000</code><br>在 Linux 上，通常的方法是在运行程序前 <strong>在终端内</strong> 执行 <code>ulimit -s unlimited</code> （WSL 下无法设置可惜）</p>
<h3 id="类中静态成员定义时初始化"><a href="#类中静态成员定义时初始化" class="headerlink" title="类中静态成员定义时初始化"></a>类中静态成员定义时初始化</h3><p>在前面加 inline 即可，最后都加，否则在配合 STL 的时候就会链接出错，从而无法编译通过例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Flow</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	Flow(<span class="keyword">int</span> _n) : n(_n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		d.assign(n, INF);</span><br><span class="line">		<span class="keyword">return</span> INF;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Flow <span class="title">g</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g.test() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bitset-高端压位卡常"><a href="#bitset-高端压位卡常" class="headerlink" title="bitset 高端压位卡常"></a><a href="https://www.cnblogs.com/RabbitHu/p/bitset.html" target="_blank" rel="noopener">bitset 高端压位卡常</a></h3><h3 id="位运算的关系"><a href="#位运算的关系" class="headerlink" title="位运算的关系"></a>位运算的关系</h3><ul>
<li>异或 <code>1</code> 改变，异或 <code>0</code> 不变</li>
<li>某位异或位 0，表示此位相等，反之不等。</li>
<li>$a \oplus b = (a \mid b) \oplus (a \And b)$</li>
<li>$a \oplus b = (a \mid b) - (a \And b)$</li>
<li>$a + b = (a \mid b) + (a \And b)$</li>
<li>$a + b = (a \oplus b) + 2 (a \And b)$</li>
<li><code>(a &amp; b) | c = (a | b) &amp; (a | c)</code></li>
<li><code>(a | b) &amp; c = (a &amp; b) | (a &amp; c)</code></li>
<li><code>(a | b) ^ 1 = (a ^ 1) &amp; (b ^ 1)</code></li>
<li><code>(a &amp; b) ^ 1 = (a ^ 1) | (b ^ 1)</code></li>
<li><code>(a | b) ^ c</code> 和 <code>(a &amp; b) ^ c</code> 可以逐位转化，因此任何一个数 x 经过任意多次的<code>&amp;, |, ^</code> 运算最终都可以写成 <code>((x ^ a) &amp; b) | c</code>。</li>
</ul>
<h3 id="Meet-in-Middle-拆半搜索法"><a href="#Meet-in-Middle-拆半搜索法" class="headerlink" title="Meet in Middle(拆半搜索法)"></a>Meet in Middle(拆半搜索法)</h3><blockquote>
<p>类似于动态规划，是一种思想。特别适合处理指数复杂度。</p>
</blockquote>
<p>例题：<a href="https://atcoder.jp/contests/abc184/tasks/abc184_f" target="_blank" rel="noopener">AtCoder abc184F</a>，当然针对此题可以深搜剪枝法。</p>
<h3 id="int128-的使用"><a href="#int128-的使用" class="headerlink" title="int128 的使用"></a>int128 的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int128 <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	__int128 x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printS</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) printS(x / <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">		x = -x;</span><br><span class="line">	&#125;</span><br><span class="line">	printS(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	__int128 a = <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">print</span>(a * a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交互式题目模板"><a href="#交互式题目模板" class="headerlink" title="交互式题目模板"></a><a href="https://codeforces.com/blog/entry/45307" target="_blank" rel="noopener">交互式题目模板</a></h3><p><a href="https://codeforces.com/gym/101021/problem/1" target="_blank" rel="noopener">gym101021: Guess the Number</a><br>需要 <code>fflush(stdout);</code>（对于 <code>scanf/printf</code>） 或 <code>std:::cout &lt;&lt; std::flush</code> （对于 <code>std::cin/std::cout</code>） 来刷新缓冲区，不过 <code>std::endl</code> 会自动刷新一次缓冲区，所以此时可以省略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1e6</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'&lt;'</span>) r = m - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>交互题测试例子：先假设一组答案，按照自己的程序计算出每次 query 的答案，最好用文件输入输出测试。</p>
</blockquote>
<h3 id="负数下标技巧"><a href="#负数下标技巧" class="headerlink" title="负数下标技巧"></a>负数下标技巧</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> aa[N];</span><br><span class="line"><span class="keyword">int</span> *a = (aa + N / <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可用于 $O(1)$ 首尾插入或删除元素，访问第 $i$ 个元素。<br>当然也可以用 <code>std::deque</code> 加一个标号，实现上述操作</p>
</blockquote>
<h3 id="优雅的输出技巧"><a href="#优雅的输出技巧" class="headerlink" title="优雅的输出技巧"></a>优雅的输出技巧</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" \n"</span>[i == n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模正数向下取整：-lfloor-frac-a-n-rfloor-和-模正数向下取整：-lceil-frac-a-n-rceil"><a href="#模正数向下取整：-lfloor-frac-a-n-rfloor-和-模正数向下取整：-lceil-frac-a-n-rceil" class="headerlink" title="模正数向下取整：$\lfloor \frac{a}{n} \rfloor$ 和 模正数向下取整：$\lceil \frac{a}{n} \rceil$"></a>模正数向下取整：$\lfloor \frac{a}{n} \rfloor$ 和 模正数向下取整：$\lceil \frac{a}{n} \rceil$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">floor</span><span class="params">(LL a, LL n)</span> </span>&#123; <span class="comment">// n &gt; 0</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; <span class="number">0</span> ? (a - n + <span class="number">1</span>) / n : a / n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ceil</span><span class="params">(LL a, LL n)</span> </span>&#123; <span class="comment">// n &gt; 0</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; <span class="number">0</span> ? a / n : (a + n - <span class="number">1</span>) / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到 C/C++ 中 ，整数除法 <code>/</code> 是向 <code>0</code> 取整(<code>int(x)</code>也是向 0 取整)，但是 Python（Sagemath） 整数除法 <code>//</code> 是向下取整。在 C++ 中一定不要用 <code>(x - 1) / n + 1</code> 的姿势向上取整！！！</p>
</blockquote>
<h3 id="Floor-sum-displaystyle-sum-i-0-n-1-lfloor-frac-a-cdot-i-b-m-rfloor"><a href="#Floor-sum-displaystyle-sum-i-0-n-1-lfloor-frac-a-cdot-i-b-m-rfloor" class="headerlink" title="Floor_sum : $\displaystyle \sum_{i = 0}^{n - 1} \lfloor \frac{a \cdot i + b}{m} \rfloor$"></a>Floor_sum : $\displaystyle \sum_{i = 0}^{n - 1} \lfloor \frac{a \cdot i + b}{m} \rfloor$</h3><blockquote>
<p>注意到这个求和式表示由直线 $x = 0, x = n, y = 0, y = \frac{a}{m}x + \frac{b}{m}$ 构成的梯形内部（仅包含上边界）的整点个数。</p>
</blockquote>
<p>显然我们可以先预处理，使得 $a &lt; m$ 且 $b &lt; m$，此时我们考虑 $y_{\max} = \lfloor \frac{a \cdot n + b}{m} \rfloor$，定义 $x_{\max} = y_{\max} \cdot m - b$，那么 $[\lceil \frac{x_{\max}}{a} \rceil, n)$ 的纵坐标取整值都相等为 $y_{\max}$，然后我们横纵坐标互换（在一张相对透明的纸上画图，然后在另一面看就是）由直线 $x = 0, x = y_{\max}, y = 0, y = \frac{m}{a}x + \frac{b’}{a}$ 构成的梯形内部（不包含边界）的整点个数。其中 $b’ = \lceil \frac{x_{\max}}{a} \rceil \cdot a - x_{\max}$（表示直线 $y = y_{\max}$ 与 $y = \frac{a}{m}x + \frac{b}{m}$ 以及 $x = \lceil \frac{x_{\max}}{a} \rceil$ 相交的长度）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">floorSum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (a &gt;= m) &#123;</span><br><span class="line">		r += LL(a / m) * (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">		a %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b &gt;= m) &#123;</span><br><span class="line">		r += LL(b / m) * n;</span><br><span class="line">		b %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> yMax = (LL(a) * n + b) / m;</span><br><span class="line">	<span class="keyword">if</span> (yMax == <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	LL xMax = LL(yMax) * m - b;</span><br><span class="line">	r += (n - (xMax + a - <span class="number">1</span>) / a) * yMax;</span><br><span class="line">	r += floorSum(yMax, a, m, (a - (xMax % a)) % a);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们可以考虑用长方形整点数减去上部分的整点数（要往上平移一个单位）<strong>这样搞更快</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">floorSum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (a &gt;= m) &#123;</span><br><span class="line">		r += LL(a / m) * (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">		a %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b &gt;= m) &#123;</span><br><span class="line">		r += LL(b / m) * n;</span><br><span class="line">		b %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> yMax = (LL(a) * n + b) / m;</span><br><span class="line">	<span class="keyword">if</span> (yMax == <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	r += LL(n - <span class="number">1</span>) * yMax;</span><br><span class="line">	r -= floorSum(yMax, a, m, m - b - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://atcoder.jp/contests/practice2/tasks/practice2_c" target="_blank" rel="noopener">模板例题</a> 和 <a href="https://atcoder.jp/contests/arc111/tasks/arc111_e" target="_blank" rel="noopener">应用例题</a></p>
<h3 id="带取整的函数取最值的技巧"><a href="#带取整的函数取最值的技巧" class="headerlink" title="带取整的函数取最值的技巧"></a>带取整的函数取最值的技巧</h3><ul>
<li>先考虑不取整的情况，然后一般这个值是可能的最小值或者最大值</li>
<li>然后通过循环看是否满足取整的情况</li>
</ul>
<h3 id="Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释"><a href="#Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释" class="headerlink" title="Barrent reduction 快速模，弃用，因为并不会变快… ：wiki 镜像解释"></a><a href="https://en.wikipedia.org/wiki/Barrett_reduction" target="_blank" rel="noopener"><del>Barrent reduction 快速模</del>，弃用，因为并不会变快…</a> ：<a href="https://en.jinzhao.wiki/wiki/Barrett_reduction" target="_blank" rel="noopener">wiki 镜像解释</a></h3><blockquote>
<p>对于给定常数 $M$ 求 <code>a % M</code>，并要求 $ 0 \leq a &lt; M^2$，并且 $a &lt; 2^k$。因此下面 $k$ 的取值还是需要注意的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> LL M  = <span class="number">1e9</span> + <span class="number">7</span>; <span class="comment">// too big, M should satisfy M * M &lt; int</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span>  k = <span class="built_in">std</span>::__lg(M) + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> LL m = (<span class="number">1L</span>L &lt;&lt; k) / M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> mod = [&amp;](<span class="keyword">int</span> a) &#123;</span><br><span class="line">	LL r = a - ((a * m) &gt;&gt; k) * M;</span><br><span class="line">	<span class="keyword">return</span> r &gt;= M ? r - M : r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="输出全排列"><a href="#输出全排列" class="headerlink" title="输出全排列"></a>输出全排列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">std</span>::for_each(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(),[](<span class="keyword">int</span> i)&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="built_in">std</span>::next_permutation(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出全排列的原理"><a href="#输出全排列的原理" class="headerlink" title="输出全排列的原理"></a>输出全排列的原理</h3><p>首先初始状态从小到大排列，然后对每一个状态考虑它的后缀，如果后缀是从大到小排列，再考虑向前一位的后缀，直到不是从大到小排列，然后找比第一个位置大的最小值放在开头，其它位置排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(n)</span>:</span></span><br><span class="line">	ans = []</span><br><span class="line">	cnt = math.factorial(n);</span><br><span class="line">	r = list(range(<span class="number">1</span>, n + <span class="number">1</span>))</span><br><span class="line">	ans.append(r.copy())</span><br><span class="line">	cnt -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">		i = n - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> r[i - <span class="number">1</span>] &gt; r[i]: i -= <span class="number">1</span></span><br><span class="line">		r[i:] = r[i:][::<span class="number">-1</span>]</span><br><span class="line">		j = i</span><br><span class="line">		<span class="keyword">while</span> r[j] &lt; r[i - <span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">		r[i - <span class="number">1</span>], r[j] = r[j], r[i - <span class="number">1</span>]</span><br><span class="line">		ans.append(r.copy())</span><br><span class="line">		cnt -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> ans	</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">	print(permutation(i))</span><br></pre></td></tr></table></figure>
<h2 id="初等数论"><a href="#初等数论" class="headerlink" title="初等数论"></a>初等数论</h2><h3 id="Greatest-Common-divisor"><a href="#Greatest-Common-divisor" class="headerlink" title="Greatest Common divisor"></a>Greatest Common divisor</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简洁写法，不推荐，推荐使用内建 __gcd</span></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lambda 表达式写法，开头不能是auto因为递归</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; gcd = [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 快速版本 https://cp-algorithms.com/algebra/euclid-algorithm.html 也没啥用，仅仅记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!a || !b) <span class="keyword">return</span> a | b;</span><br><span class="line">	<span class="keyword">unsigned</span> shift = __builtin_ctz(a | b);</span><br><span class="line">	a &gt;&gt;= __builtin_ctz(a);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		b &gt;&gt;= __builtin_ctz(b);</span><br><span class="line">		<span class="keyword">if</span> (a &gt; b) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">		b -= a;</span><br><span class="line">	&#125; <span class="keyword">while</span> (b);</span><br><span class="line">	<span class="keyword">return</span> a &lt;&lt; shift;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通版拓展GCD</span></span><br><span class="line"><span class="function">LL <span class="title">exGcd</span><span class="params">(LL a, LL b, LL&amp; x, LL&amp; y)</span></span>&#123;  <span class="comment">// ax + by = gcd(a,b)</span></span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">		x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	LL d = exgcd(b, a % b, y, x);</span><br><span class="line">	y -= a / b * x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++17版拓展GCD，优雅了不少!</span></span><br><span class="line">std::tuple&lt;LL, LL, LL&gt; exGcd(LL a, LL b) &#123;  // ax + by = gcd(a,b)</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> &#123;a, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> [d, y, x] = exGcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> &#123;d, x, y - a / b * x&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n"><a href="#Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n" class="headerlink" title="Sum of least common multiple  $s_n =  \sum_{i=1} ^n lcm(i,n)$"></a>Sum of least common multiple  $s_n =  \sum_{i=1} ^n lcm(i,n)$</h3><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1} ^n lcm(i,n) 
&= \sum_{i=1} ^n \frac{i \cdot n}{\gcd(i,n)} \\
&= n \sum_{d|n} \sum_{\gcd(i,\frac{n}{d})= 1} i \\
&= \frac{n}{2} \sum_{d|n} \frac{n}{d} \psi(\frac{n}{d}) \\
&= \frac{n}{2} \sum_{d|n} d \psi(d)
\end{aligned}</script><p>所以，我们可以在 $O(n \log n)$ 处理好 $s_n$ 的前 $n$ 项。</p>
<h3 id="Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-lcm-i-j"><a href="#Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-lcm-i-j" class="headerlink" title="Double sum of least common multiple $ds_n = \sum_{1 \leq i \leq j \leq n} lcm(i,j)$"></a>Double sum of least common multiple $ds_n = \sum_{1 \leq i \leq j \leq n} lcm(i,j)$</h3><p>本来这个也挺麻烦，但是可以借助 $s_n$ 计算：$ds_n =  \sum_{j=1} ^n s_j$，所以复杂度就一致了。当然也可以直接化简成：</p>
<script type="math/tex; mode=display">
\sum_{1 \leq i \leq j \leq n} lcm(i,j) = \sum_{i = 1} ^ n \frac{i}{4} \psi(i) \lfloor \frac{n}{i} \rfloor (\lfloor \frac{n}{i} \rfloor + 1)</script><blockquote>
<p>不借助 $s_n$ 其实也能暴力搞出来的。</p>
</blockquote>
<h3 id="模乘法逆元"><a href="#模乘法逆元" class="headerlink" title="模乘法逆元"></a>模乘法逆元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a, LL p)</span></span>&#123; <span class="comment">// 0 &lt; a &lt; p and gcd(a,p) = 1</span></span><br><span class="line">	<span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (p - p / a) * inv(p % a, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码主要用于线性时间预处理所有$p$以内的逆元，对于较小的常数$a$, 可以直接试除 <code>b p mod a == 1</code><br>用下面快速幂也可以求逆，<code>inv</code> 的步数平均下面显著的比快速幂小，但是由于用到了递归，因此最终它们的平均效率是一致的。<br>可以通过预处理小部分值达到快速的效果。</p>
</blockquote>
<h3 id="快速模乘法"><a href="#快速模乘法" class="headerlink" title="快速模乘法"></a>快速模乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">powMod</span><span class="params">(T x,U n,T p)</span></span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) r = r * x % p;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; x = x * x % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以用for循环写的更短一点，但没必要</span></span><br></pre></td></tr></table></figure>
<h3 id="快速模加法（弃用，利用-int128-即可）"><a href="#快速模加法（弃用，利用-int128-即可）" class="headerlink" title="快速模加法（弃用，利用 __int128 即可）"></a>快速模加法（弃用，利用 <code>__int128</code> 即可）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mulMod</span><span class="params">(LL x, LL n, LL p)</span> </span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	x %= p;</span><br><span class="line">	<span class="keyword">auto</span> inc = [&amp;](LL x, LL y) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((x += y) &gt;= p) x-=p;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) inc(r,x);</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; inc(x,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速模加法下的快速模乘法（弃用，利用-int128-即可）"><a href="#快速模加法下的快速模乘法（弃用，利用-int128-即可）" class="headerlink" title="快速模加法下的快速模乘法（弃用，利用 __int128 即可）"></a>快速模加法下的快速模乘法（弃用，利用 <code>__int128</code> 即可）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n, LL p)</span></span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) r = mulmod(r, x, p);</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; x = mulmod(x, x, p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阶乘、组合数、Lucas-定理"><a href="#阶乘、组合数、Lucas-定理" class="headerlink" title="阶乘、组合数、Lucas 定理"></a>阶乘、组合数、Lucas 定理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">2</span>;</span><br><span class="line">LL fac[N], ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">	ifac[N - <span class="number">1</span>] = inv(fac[N - <span class="number">1</span>], M);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; --i) ifac[i - <span class="number">1</span>] = ifac[i] * i % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//if (n &lt; k || n &lt; 0) return 0;</span></span><br><span class="line">	<span class="keyword">return</span> fac[n] * ifac[k] % M * ifac[n - k] % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lucas</span><span class="params">(LL n, LL m, LL p)</span> </span>&#123; <span class="comment">// C(n,m)%p, 仅在p较少时发挥作用</span></span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n &amp;&amp; m) &#123;</span><br><span class="line">		LL np = n % p, mp = m % p;</span><br><span class="line">		<span class="keyword">if</span> (np &lt; mp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		r = binom(np, mp);</span><br><span class="line">		n /= p, m /= p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用组合数公式"><a href="#常用组合数公式" class="headerlink" title="常用组合数公式"></a>常用组合数公式</h3><script type="math/tex; mode=display">
\binom{n + 1}{k + 1} = \binom{n}{k} + \binom{n}{k + 1}</script><blockquote>
<p>最后一个数，先还是不选，这是一个问题。</p>
</blockquote>
<script type="math/tex; mode=display">
{n \choose k}{k \choose i}  = {n \choose i} {n - i \choose k - i}</script><blockquote>
<p>组合意义理解：$n$ 个人中选出 $i$ 个一流人才， $k - i$ 个二流人才。</p>
</blockquote>
<script type="math/tex; mode=display">{n + m \choose k} = \sum_{i + j = k} {n \choose i} {m \choose j}</script><blockquote>
<p>组合意义理解：$n, m$ 两个堆选出 $k$ 个人。</p>
</blockquote>
<h3 id="乞丐版素数判断"><a href="#乞丐版素数判断" class="headerlink" title="乞丐版素数判断"></a>乞丐版素数判断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span> || n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-n-log-n-素数筛"><a href="#O-n-log-n-素数筛" class="headerlink" title="$O(n \log n)$ 素数筛"></a>$O(n \log n)$ 素数筛</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =  <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> isP[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(isP[<span class="number">2</span>]) <span class="keyword">return</span>;</span><br><span class="line">	isP[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isP[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isP[i]) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span> * i; j &lt; N; j += i * <span class="number">2</span>) &#123;</span><br><span class="line">			isP[j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性素数筛（弃用）"><a href="#欧拉线性素数筛（弃用）" class="headerlink" title="欧拉线性素数筛（弃用）"></a>欧拉线性素数筛（弃用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrimeP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	p.emplace_back(<span class="number">2</span>);</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) p.emplace_back(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j != p.<span class="built_in">size</span>() &amp;&amp; p[j] &lt; t; ++j) &#123; <span class="comment">// 用除号是防止溢出</span></span><br><span class="line">			isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="comment">// 不要下面的一步的话，复杂度 O(nloglogn), 但是不用除法，常数小</span></span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性素数筛（正式使用版）"><a href="#欧拉线性素数筛（正式使用版）" class="headerlink" title="欧拉线性素数筛（正式使用版）"></a>欧拉线性素数筛（正式使用版）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initPrimeP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	p.emplace_back(<span class="number">2</span>);</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> sq = <span class="keyword">int</span>(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(N + <span class="number">0.1</span>))|<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= sq; i += <span class="number">2</span>) <span class="keyword">if</span> (isp[i]) &#123;</span><br><span class="line">		p.emplace_back(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; N; j += i &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">			isp[j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = sq + <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isp[i]) p.emplace_back(i);</span><br><span class="line">	<span class="keyword">return</span> p.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-1-（执行）时间复杂度判断一个数是否为素数"><a href="#O-1-（执行）时间复杂度判断一个数是否为素数" class="headerlink" title="$O(1)$ （执行）时间复杂度判断一个数是否为素数"></a>$O(1)$ （执行）时间复杂度判断一个数是否为素数</h3><blockquote>
<p>奇技淫巧来源：<a href="https://codeforces.com/blog/entry/79941#comment-659202" target="_blank" rel="noopener">https://codeforces.com/blog/entry/79941#comment-659202</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sieve</span> &#123;</span></span><br><span class="line">	<span class="keyword">bool</span> isP[N];</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">Sieve</span><span class="params">()</span>: <span class="title">isP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		isP[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isP[i] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isP[i]) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span> * i; j &lt; N; j += i * <span class="number">2</span>) &#123;</span><br><span class="line">					isP[j] = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// MAXN 默认最大值为1&lt;&lt;18=262144, 调节参数 -fconstexpr-loop-limit= 例如：</span></span><br><span class="line"><span class="comment">// g++ main.cpp -std=c++17 -fconstexpr-loop-limit=12345678 -fconstexpr-ops-limit=1234567890</span></span><br><span class="line"><span class="comment">// 使得 MAXN = 1e7+2</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fast_is_prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> Sieve&lt;MAXN&gt; s;</span><br><span class="line">	<span class="keyword">return</span> s.isP[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大素数-Miller-Rabin-概率判别法"><a href="#大素数-Miller-Rabin-概率判别法" class="headerlink" title="大素数 Miller-Rabin 概率判别法"></a>大素数 Miller-Rabin 概率判别法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::mt19937 <span class="title">rnd</span><span class="params">(<span class="built_in">std</span>::chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">witness</span><span class="params">(LL a, LL n, LL m, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	LL x = powMod(a, m, n);</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		x = mulMod(x, x, n);</span><br><span class="line">		<span class="keyword">if</span> (x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(n &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LL m = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>, cnt = <span class="number">33</span>;</span><br><span class="line">	<span class="keyword">while</span> (!(m &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">		++t;</span><br><span class="line">		m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">		LL a = rnd() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (Witness(a, n, m, t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大整数的最小素因子"><a href="#大整数的最小素因子" class="headerlink" title="大整数的最小素因子"></a>大整数的最小素因子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">witness</span><span class="params">(LL a, LL n, LL m, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	LL x = powMod(a, m, n);</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		x = __int128(x) * x %  n;</span><br><span class="line">		<span class="keyword">if</span> (x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(n &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LL m = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>, cnt = <span class="number">33</span>;</span><br><span class="line">	<span class="keyword">while</span> (!(m &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">		++t;</span><br><span class="line">		m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">		LL a = <span class="built_in">std</span>::rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (witness(a, n, m, t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大整数的最小素因子-1"><a href="#大整数的最小素因子-1" class="headerlink" title="大整数的最小素因子"></a>大整数的最小素因子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">pollardrho</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	LL x = <span class="built_in">std</span>::rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	LL y = x, i = <span class="number">1</span>, k = <span class="number">2</span>, c = <span class="built_in">std</span>::rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		x = (__int128(x) * x + c) % n;</span><br><span class="line">		LL d = <span class="built_in">std</span>::__gcd(y - x + n, n);</span><br><span class="line">		<span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">		<span class="keyword">if</span> (++i == k) &#123;</span><br><span class="line">			y = x;</span><br><span class="line">			<span class="keyword">if</span> (k &gt; n) <span class="keyword">return</span> n;</span><br><span class="line">			k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">findp</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rabin(n)) <span class="keyword">return</span> n;</span><br><span class="line">	LL p = n;</span><br><span class="line">	<span class="keyword">while</span> (p == n) p = pollardrho(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">min</span>(findp(p), findp(n/p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-n-最小素因子预处理"><a href="#O-n-最小素因子预处理" class="headerlink" title="$O(n)$ 最小素因子预处理"></a>$O(n)$ 最小素因子预处理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e8</span>; <span class="comment">// 再大内存吃不消了 </span></span><br><span class="line"><span class="keyword">int</span> sp[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt;= sp[i] &amp;&amp; i * p[j] &lt; N; ++j) &#123; <span class="comment">//防止乘法溢出</span></span><br><span class="line">			sp[i * p[j]] = p[j]; <span class="comment">// 注意到sp只被赋值一次</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mobius-function"><a href="#Mobius-function" class="headerlink" title="Mobius function"></a>Mobius function</h3><blockquote>
<p>另类递推公式： $ \mu(i) = - \sum_{d \mid i, d &lt; i} \mu(d) $。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 乞丐版</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line">		n /= <span class="number">2</span>;</span><br><span class="line">		r = -r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">			n /= i;</span><br><span class="line">			<span class="keyword">if</span>(n % i  == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			r = -r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n &gt; <span class="number">1</span> ? -r : r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(n log n) 预处理版本</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e6</span> +<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt; N; j += i) &#123;</span><br><span class="line">			mu[j] -= mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n) 预处理版</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e6</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="keyword">int</span> p[N], mu[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(mu[<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) mu[i] = <span class="number">-1</span>, p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j) &#123;</span><br><span class="line">			isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			mu[i * p[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">4</span>) mu[i] = -mu[i &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mobius-function-前缀和"><a href="#Mobius-function-前缀和" class="headerlink" title="Mobius function 前缀和"></a>Mobius function 前缀和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sumMu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSumMu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mu[<span class="number">1</span>] != <span class="number">1</span>) initmu();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) sumMu[i] = sumMu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSumMu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// M(n) = M(n-1) + mu(n)</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> sumMu[n];</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= (j - i + <span class="number">1</span>) * sumMu(n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Mobius function 绝对值前缀和</span></span><br><span class="line"><span class="function">LL <span class="title">getSumAbsMu</span><span class="params">(LL n)</span> </span>&#123; <span class="comment">// Q(n) = Q(n-1) + |mu(n)|</span></span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>, t; (t = i * i) &lt; n; ++i) &#123;</span><br><span class="line">		r += mu[i] * (n / t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Euler’s-totient-function"><a href="#Euler’s-totient-function" class="headerlink" title="Euler’s totient function"></a>Euler’s totient function</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> phi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPhi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (phi[<span class="number">2</span>] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) phi[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) phi[i] = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (phi[i] != i) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j += i) phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPhi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = (n % <span class="number">2</span> == <span class="number">0</span> ? n/<span class="number">2</span> : n);</span><br><span class="line">	<span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>) n/=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i  == <span class="number">0</span>) &#123;</span><br><span class="line">			r = r / i *(i<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">while</span> (n % i == <span class="number">0</span>) n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>) r = r / n * (n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">LL sumPhi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSumphi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (phi[<span class="number">2</span>] != <span class="number">1</span>) initPhi();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) sumPhi[i] = sumPhi[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, LL&gt; mp;</span><br><span class="line"><span class="function">LL <span class="title">getSumphi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> (LL) sumPhi[n];</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	LL r = LL(n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= (j - i + <span class="number">1</span>) * getSumphi(n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pi-x-函数"><a href="#pi-x-函数" class="headerlink" title="$\pi(x)$ 函数"></a>$\pi(x)$ 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span> * <span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">11</span> * <span class="number">13</span> * <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM + <span class="number">1</span>][M + <span class="number">1</span>], sz[M + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	initprime();</span><br><span class="line">	pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		pi[i] = pi[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) ++pi[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sz[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= PM; ++i) phi[i][<span class="number">0</span>] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">		sz[i] = p[i] * sz[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= PM; ++j) &#123;</span><br><span class="line">			phi[j][i] = phi[j][i - <span class="number">1</span>] - phi[j / p[i]][i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s &lt;= M) <span class="keyword">return</span> phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];</span><br><span class="line">	<span class="keyword">if</span> (x / p[s] &lt;= p[s]) <span class="keyword">return</span> primepi(x) - s + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x / p[s] / p[s] &lt;= p[s] &amp;&amp; x &lt; N) &#123;</span><br><span class="line">		<span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>))];</span><br><span class="line">		LL ans = pi[x] - (s2x + s - <span class="number">2</span>) * (s2x - s + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt;= s2x; ++i) &#123;</span><br><span class="line">			ans += pi[x / p[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> primephi(x, s - <span class="number">1</span>) - primephi(x / p[s], s - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; N) <span class="keyword">return</span> pi[x];</span><br><span class="line">	<span class="keyword">int</span> ps2x = primepi(<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>)));</span><br><span class="line">	<span class="keyword">int</span> ps3x = primepi(<span class="keyword">int</span>(cbrt(x + <span class="number">0.2</span>)));</span><br><span class="line">	LL ans = primephi(x, ps3x) + LL(ps2x + ps3x - <span class="number">2</span>) * (ps2x - ps3x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = ps3x + <span class="number">1</span>, ed = ps2x; i &lt;= ed; ++i) &#123;</span><br><span class="line">		ans -= primepi(x / p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pi-x-函数计算的另一种做法"><a href="#pi-x-函数计算的另一种做法" class="headerlink" title="$\pi(x)$ 函数计算的另一种做法"></a>$\pi(x)$ 函数计算的另一种做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">2</span>;</span><br><span class="line">LL L[N], R[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	LL rn = (LL) <span class="built_in">sqrt</span>(n + <span class="number">0.2</span>);</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= rn; ++i) R[i] = n / i - <span class="number">1</span>;</span><br><span class="line">	LL ln = n / (rn + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= ln; ++i) L[i] = i - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL p = <span class="number">2</span>; p &lt;= rn; ++p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L[p] == L[p - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (LL i = <span class="number">1</span>, tn = <span class="built_in">std</span>::<span class="built_in">min</span>(n / (p * p), rn); i &lt;= tn; ++i) &#123;</span><br><span class="line">			R[i] -= (i * p &lt;= rn ? R[i * p] : L[n / (i * p)]) - L[p - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (LL i = ln; i &gt;= p * p; --i) &#123;</span><br><span class="line">			L[i] -= L[i / p] - L[p - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求奇素数的一个原根"><a href="#求奇素数的一个原根" class="headerlink" title="求奇素数的一个原根"></a>求奇素数的一个原根</h3><blockquote>
<p>代码懒得贴，实际上暴力就可以了</p>
</blockquote>
<p>首先，模 $m$ 有原根的充要条件是：$m=2,4,p^a,2p^a$，其中 $p$ 为奇素数。</p>
<p>对于求模 $p$ 的原根方法：对 $p-1$ 素因子分解：$p-1 = p_1^{a_1} \cdots p_s^{a_s}$ 若恒有 </p>
<script type="math/tex; mode=display">
g^{\frac{p-1}{p_i}} \neq 1(\mod \; p)</script><p>则 $g$ 是 模 $p$ 的原根。对于 $p^a$ 可以用 $p$ 的原根简单构造，而 $2p^a$ 的原根为 $p^a$ 的原根与 $p^a$ 的原根和 $p^a$的和中奇数者。(证明见 P150《数论基础》潘承洞)</p>
<blockquote>
<p>求所有原根见 </p>
</blockquote>
<h3 id="数论函数的-Dirichlet-乘积"><a href="#数论函数的-Dirichlet-乘积" class="headerlink" title="数论函数的 Dirichlet 乘积"></a>数论函数的 Dirichlet 乘积</h3><p>以前的代码不想贴了，不优雅，下次有题做的时候补上。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><a href="/chineseRemainTheorem/" title="中国剩余定理">中国剩余定理</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;LL,LL&gt; crt2(LL a1,LL m1,LL a2,LL m2)&#123; // x = ai mod mi, m_i &gt;0</span><br><span class="line">	LL t1,t2,ans = a2-a1;</span><br><span class="line">	LL d = exgcd(m1,m2,t1,t2);</span><br><span class="line">	assert(ans%d == <span class="number">0</span>);</span><br><span class="line">	LL m = m1/d*m2;</span><br><span class="line">	ans = (a1+ans/d*t1%m2*m1)%m; <span class="comment">// %m2 是避免溢出</span></span><br><span class="line">	<span class="keyword">return</span> make_pair(ans&gt;<span class="number">0</span>?ans:ans+m,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span>;</span><br><span class="line">LL a[N],m[N];</span><br><span class="line">pair&lt;LL,LL&gt; crt(int n)&#123; // x = a[i] mod m[i], m[i] &gt;0</span><br><span class="line">	pair&lt;LL,LL&gt; ans = make_pair(a[<span class="number">0</span>]%m[<span class="number">0</span>],m[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">		ans = crt2(ans.first,ans.second,a[i],m[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a><a href="http: //blog.miskcoo.com/2015/05/discrete-logarithm-problem">离散对数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">baby_step_giant_step</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123; <span class="comment">// a^x = b mod p</span></span><br><span class="line">	a %= p, b %= p;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b % p ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LL cnt = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL g = <span class="built_in">std</span>::__gcd(a, p); g != <span class="number">1</span>; g = <span class="built_in">std</span>::__gcd(a, p)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		p /= g, b /= g, t = t * (a / g) % p;</span><br><span class="line">		++cnt;</span><br><span class="line">		<span class="keyword">if</span> (b == t) <span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;LL, LL&gt; mp;</span><br><span class="line">	LL m = LL(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(p + <span class="number">0.1</span>) + <span class="number">1</span>);</span><br><span class="line">	LL base = b;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">0</span>; i != m; ++i) &#123;</span><br><span class="line">		mp[base] = i;</span><br><span class="line">		base = base * a % p;</span><br><span class="line">	&#125;</span><br><span class="line">	base = powMod(a, m, p);</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		t = t * base % p;</span><br><span class="line">		<span class="keyword">if</span> (mp.count(t)) <span class="keyword">return</span> i * m - mp[t] + cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模素数开根号"><a href="#模素数开根号" class="headerlink" title="模素数开根号"></a>模素数开根号</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">modsqrt</span><span class="params">(LL a, LL p)</span> </span>&#123; <span class="comment">// find x s.t x*x=a mod p;</span></span><br><span class="line">	a = (p + a % p) % p;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">2</span>) <span class="keyword">return</span> (a &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	LL q = (p - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (powMod(a, q, p) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (q &amp; <span class="number">1</span>) <span class="keyword">return</span> powMod(a, (q + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line">	LL b, cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (powMod(b = rand() % p, q, p) == <span class="number">1</span>); <span class="comment">//find a non quadratic residue</span></span><br><span class="line">	<span class="keyword">while</span> (!(q &amp; <span class="number">1</span>)) ++cnt, q &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	b = powMod(b, q, p);</span><br><span class="line">	LL x = powMod(a, (q + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line">	<span class="keyword">for</span> (LL s = <span class="number">1</span>, t = powMod(a, q, p); t != <span class="number">1</span>; s = <span class="number">1</span>) &#123; <span class="comment">//keep x*x=t*a;t^&#123;2^&#123;cnt-1&#125;&#125;=1</span></span><br><span class="line">		<span class="keyword">for</span> (LL tt = t * t % p; s &lt; cnt &amp;&amp; tt != <span class="number">1</span>; ++s) tt = tt * tt % p;</span><br><span class="line">		LL d = powMod(b, <span class="number">1</span> &lt;&lt; (cnt - s - <span class="number">1</span>), p);</span><br><span class="line">		x = (x * d) % p;</span><br><span class="line">		b = d * d % p;</span><br><span class="line">		t = t * b % p;</span><br><span class="line">		cnt = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mod_sqrt</span><span class="params">(LL a, LL p, <span class="keyword">int</span> k = <span class="number">1</span>)</span> </span>&#123; <span class="comment">//find smallest x&gt;=0 s.t x*x=a mod p^k</span></span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ka = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (a % p == <span class="number">0</span>) a /= p, ++ka, --k;</span><br><span class="line">	<span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ka &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">auto</span> <span class="built_in">pow</span> = [](LL x, <span class="keyword">int</span> n) &#123;</span><br><span class="line">		LL r=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, x *= x)  <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r *= x;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	LL n = <span class="built_in">pow</span>(p, k), x;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">1</span> || k == <span class="number">2</span>) x = a == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a % <span class="number">8</span> != <span class="number">1</span>) x = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			x = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((x * x) % (<span class="number">1</span> &lt;&lt; i) == a % (<span class="number">1</span> &lt;&lt; i)) <span class="keyword">continue</span>;</span><br><span class="line">				x += <span class="number">1</span> &lt;&lt; (i - <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> x = mod_sqrt_p(a, n, p, k);</span><br><span class="line">	<span class="keyword">return</span> x == <span class="number">-1</span> ? <span class="number">-1</span> : <span class="built_in">pow</span>(p, ka &gt;&gt; <span class="number">1</span>) * (x &lt; n - x ? x : n - x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于模一般的 $n$，先素因子分解分别求出答案，然后用中国剩余定理求最终解。</p>
</blockquote>
<h3 id="自然数方幂和-O-k-算法"><a href="#自然数方幂和-O-k-算法" class="headerlink" title="自然数方幂和 $O(k)$ 算法"></a>自然数方幂和 $O(k)$ 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> sp[N], p[N];</span><br><span class="line">LL inv[N], AP[N], AS[N], f[N];</span><br><span class="line"><span class="function">LL <span class="title">getPowSum</span><span class="params">(LL n, <span class="keyword">int</span> k, LL mod)</span> </span>&#123; <span class="comment">// mod &gt; k</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> n % mod;</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">2</span>) spf();</span><br><span class="line">	<span class="keyword">int</span> nk = k + <span class="number">1</span>;</span><br><span class="line">	LL tmp = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk; ++i) tmp = tmp * i % mod;</span><br><span class="line">	inv[nk] = powMod(tmp, mod - <span class="number">2</span>, mod);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) f[i] = powMod(i, k, mod);</span><br><span class="line">		<span class="keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]] % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (f[i] &gt;= mod) f[i] -= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= nk) <span class="keyword">return</span> f[n];</span><br><span class="line">	AP[<span class="number">0</span>] = AS[nk] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) AP[i] = AP[i - <span class="number">1</span>] * (n + <span class="number">1</span> - i) % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) AS[i] = AS[i + <span class="number">1</span>] * (n - i - <span class="number">1</span>) % mod;</span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) &#123; <span class="comment">// because f(i)=0</span></span><br><span class="line">		LL x = f[i] * AP[i] % mod * AS[i] % mod * inv[i] % mod * inv[nk - i] % mod;</span><br><span class="line">		<span class="keyword">if</span> ((nk - i) &amp; <span class="number">1</span>) res -= x; <span class="comment">// be careful</span></span><br><span class="line">		<span class="keyword">else</span> res += x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res % mod + mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自然数方幂和精确版"><a href="#自然数方幂和精确版" class="headerlink" title="自然数方幂和精确版"></a>自然数方幂和精确版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> BINT = boost::multiprecision::cpp_int;</span><br><span class="line"></span><br><span class="line">BINT f[N];</span><br><span class="line"><span class="function">BINT <span class="title">getPowSum</span><span class="params">(LL n, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// k&lt;1000</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> BINT(n);</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="number">2</span>) spf();</span><br><span class="line">	<span class="keyword">int</span> nk = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> bPow = [](BINT x, <span class="keyword">int</span> n) -&gt; BINT &#123;</span><br><span class="line">		BINT r(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (; n; x *= x, n &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r *= x;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) f[i] = bPow(BINT(i), k);</span><br><span class="line">		<span class="keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= nk) <span class="keyword">return</span> f[n];</span><br><span class="line">	BINT res = <span class="number">0</span>, tl = <span class="number">1</span>, tr = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) tr = tr * (n - i - <span class="number">1</span>) / (nk - i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((nk - i) &amp; <span class="number">1</span>) res -= f[i] * tl * tr;</span><br><span class="line">		<span class="keyword">else</span> res += f[i] * tl * tr;</span><br><span class="line">		tl = tl * (n - i) / (i + <span class="number">1</span>);</span><br><span class="line">		tr = tr * (nk - i) / (n - i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要下载<a href="https://www.boost.org/" target="_blank" rel="noopener">boost 包</a> 类似的包还有 NTL，GMP</p>
</blockquote>
<h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><p>在 codeforces 上 <code>zscoder</code> 大佬给了一个 <a href="https://codeforces.com/blog/entry/77468" target="_blank" rel="noopener">入门教程</a> 和 <a href="https://codeforces.com/blog/entry/77551" target="_blank" rel="noopener">进阶教程</a> 还有 <code>MiFaFaOvO</code> 的 <a href="https://codeforces.com/blog/entry/76447" target="_blank" rel="noopener">终极教程</a></p>
<p>生成函数分两种：Original generating function，Expentional generating function，选择哪一种是看问题中是否牵扯组合数。无论哪一种都能保存原数列的全部信息，并且由于级数可以使用微积分和常微分方程的技术，所以会变得更好处理。然后大概率可以优化算法复杂度 $O(n^2) \to O(n \log n)$ </p>
<p>关于生成函数多项式的处理：<a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">https://cp-algorithms.com/algebra/polynomial.html</a></p>
<p>多项式高效运算模板：<a href="https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp" target="_blank" rel="noopener">https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp</a></p>
<p><strong>生成函数一般的处理思路</strong>：计算生成函数，分解成有分母不超过二次的分式之和，然后每一个二次的分母部分找一个递推数列来搞定。</p>
<p><a href="https://oi-wiki.org/math/poly/intro/" target="_blank" rel="noopener">OI-wiki 多项式运算</a></p>
<h3 id="多项式取对数和指数"><a href="#多项式取对数和指数" class="headerlink" title="多项式取对数和指数"></a>多项式取对数和指数</h3><p>$B(z) = e^{A(z)}$，即 $A(z) = \ln B(z)$ (不妨假设 $A(0) = 0$ 或等价地 $B(0) = 1$)</p>
<p>那么 $B’(z) = A’(z) \cdot B(z)$, 所以 $[z^{n - 1}] B’(z) = \sum_{k = 0}^{n - 1} [z^k] A’(z) \cdot B(z) [z^{n - 1 - k}] = \sum_{k = 1}^{n} [z^{k - 1}] A’(z) \cdot B(z) [z^{n-k}]$，从而</p>
<script type="math/tex; mode=display">
n [z^n] B(z) = \sum_{k = 1}^n k [z^k] A(z) \cdot B(z) [z^{n - k}]</script><p>上式等价于</p>
<script type="math/tex; mode=display">
n [z^n] A(z) = n [z^n] B(z) - \sum_{k = 1}^{n - 1} k [z^k] A(z) \cdot B(z) [z^{n - k}]</script><blockquote>
<p>参考：<a href="https://www.cnblogs.com/Soulist/p/13758388.html" target="_blank" rel="noopener">Soulist</a></p>
</blockquote>
<h3 id="NFT-正式可用版-last-updated-2020-7-9"><a href="#NFT-正式可用版-last-updated-2020-7-9" class="headerlink" title="NFT 正式可用版(last updated: 2020/7/9)"></a>NFT 正式可用版(last updated: 2020/7/9)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>, ROOT = <span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; j) <span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = a.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			(j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a, <span class="keyword">bool</span> isInverse = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">	LL g = powMod(ROOT, (M - <span class="number">1</span>) / a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span> (isInverse) &#123;</span><br><span class="line">		g = powMod(g, M - <span class="number">2</span>);</span><br><span class="line">		LL invLen = powMod(LL(a.<span class="built_in">size</span>()), M - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) x = x * invLen % M;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(a);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != w.<span class="built_in">size</span>(); ++i) w[i] = w[i - <span class="number">1</span>] * g % M;</span><br><span class="line">	<span class="keyword">auto</span> addMod = [](LL x, LL y) &#123;</span><br><span class="line">		<span class="keyword">return</span> (x += y) &gt;= M ? x -= M : x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">2</span>, half = <span class="number">1</span>; half != a.<span class="built_in">size</span>(); <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>, half &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, wstep = a.<span class="built_in">size</span>() / <span class="built_in">step</span>; i != a.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j != i + half; ++j) &#123;</span><br><span class="line">				LL t = (a[j + half] * w[wstep * (j - i)]) % M;</span><br><span class="line">				a[j + half] = addMod(a[j], M - t);</span><br><span class="line">				a[j] = addMod(a[j], t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&amp; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (sz &lt; tot) sz *= <span class="number">2</span>;</span><br><span class="line">	a.resize(sz);</span><br><span class="line">	b.resize(sz);</span><br><span class="line">	nft(a);</span><br><span class="line">	nft(b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != sz; ++i) a[i] = a[i] * b[i] % M;</span><br><span class="line">	nft(a, <span class="number">1</span>);</span><br><span class="line">	a.resize(tot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="siyuan-的-FWT-模板-（弃用）"><a href="#siyuan-的-FWT-模板-（弃用）" class="headerlink" title="siyuan 的 FWT 模板 （弃用）"></a><a href="https://blog.orzsiyuan.com/archives/Fast-Walsh-Hadamard-Transform/" target="_blank" rel="noopener">siyuan 的 FWT 模板</a> （弃用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x += y) &gt;= P &amp;&amp; (x -= P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FWT</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; N &lt; n; N &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j + m], a[i + j]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j + m], a[i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j], a[i + j + m]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j], a[i + j + m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTxor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), inv2 = (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = a[i + j + m];</span><br><span class="line">                <span class="keyword">if</span> (!rev) &#123;</span><br><span class="line">                    a[i + j] = (x + y) % P;</span><br><span class="line">                    a[i + j + m] = (x - y + P) % P;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[i + j] = <span class="number">1L</span>L * (x + y) * inv2 % P;</span><br><span class="line">                    a[i + j + m] = <span class="number">1L</span>L * (x - y + P) * inv2 % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Or</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">And</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTand(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTand(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTand(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Xor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTxor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTxor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTxor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; fwt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    std::vector&lt;int&gt; a1(n), a2(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a2[i]);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    A = fwt.Or(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A = fwt.And(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A = fwt.Xor(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FWT 和 FMT 本质上是一致的，只是写法姿势不同。FWT 是用递归的思想写的，FMT 是用逐位计算写的。别人的总归用起来不舒服，还是用下面自己写的 FMT 模板吧！</p>
</blockquote>
<h3 id="FMT-模板"><a href="#FMT-模板" class="headerlink" title="FMT 模板"></a>FMT 模板</h3><blockquote>
<p>考虑数论函数的 <a href="/dirichletProduct/" title="Dirichlet 积">Dirichlet 积</a> 中的 Mobius 变换（本质就是带条件的求和）这里的变换也就是的各个位上的带条件求和。<br>例题：<a href="https://www.luogu.com.cn/problem/P6097" target="_blank" rel="noopener">洛谷 P6097</a>， 参考：<a href="https://www.cnblogs.com/yijan/p/12387352.html" target="_blank" rel="noopener">yijan</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FMT &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2 = (M + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">	(x += y) &gt;= M &amp;&amp; (x -= M);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> sub = [](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">	(x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += M);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> extend = [](<span class="keyword">int</span> n) &#123;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="built_in">std</span>::<span class="built_in">log</span>(n);</span><br><span class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; r) &lt; n) ++r;</span><br><span class="line">	<span class="keyword">return</span> r; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> FMTor = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> isRev) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(a.<span class="built_in">size</span>());</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRev) sub(a[j], a[j ^ (<span class="number">1</span> &lt;&lt; i)]);</span><br><span class="line">			<span class="keyword">else</span> add(a[j], a[j ^ (<span class="number">1</span> &lt;&lt; i)]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> FMTand = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> isRev) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(a.<span class="built_in">size</span>());</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRev) sub(a[j ^ (<span class="number">1</span> &lt;&lt; i)], a[j]);</span><br><span class="line">			<span class="keyword">else</span> add(a[j ^ (<span class="number">1</span> &lt;&lt; i)], a[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> FMTxor = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> isRev) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(a.<span class="built_in">size</span>());</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = a[j], v = a[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">			a[j] = (v - u + M) % M;</span><br><span class="line">			a[j ^ (<span class="number">1</span> &lt;&lt; i)] = (u + v) % M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isRev) <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) x = LL(inv2) * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> fun = [](<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;, <span class="keyword">bool</span>)&gt; f, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(<span class="built_in">std</span>::<span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()));</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n); b.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	f(a, <span class="number">0</span>); f(b, <span class="number">0</span>);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) c[i] = LL(a[i]) * b[i] % M;</span><br><span class="line">	f(c, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> Or = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">return</span> fun(FMTor, a, b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> And = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">return</span> fun(FMTand, a, b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> Xor = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">return</span> fun(FMTxor, a, b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// i = j | k and j &amp; k = 0</span></span><br><span class="line"><span class="keyword">auto</span> OrAnd = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(<span class="built_in">std</span>::<span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()));</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n); b.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">sa</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; n))</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> sb = sa, sc = sa;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) sa[__builtin_popcount(i)][i] = a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) sb[__builtin_popcount(i)][i] = b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		FMTor(sa[i], <span class="number">0</span>);FMTor(sb[i], <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; n); ++k) &#123;</span><br><span class="line">				add(sc[i][k], LL(sa[j][k]) * sb[i - j][k] % M);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		FMTor(sc[i], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) c[i] = sc[__builtin_popcount(i)][i];</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>namespace 真香！</p>
</blockquote>
<h3 id="矩阵类"><a href="#矩阵类" class="headerlink" title="矩阵类"></a>矩阵类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">LL mod;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line">	LL a[N][N];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	Matrix() &#123;&#125;</span><br><span class="line">	Matrix(<span class="keyword">int</span> _n, <span class="keyword">int</span> x = <span class="number">0</span>): n(_n) &#123; <span class="comment">// xIn</span></span><br><span class="line">		all(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			a[i][i] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">all</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				a[i][j] = x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> Matrix &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">Matrix <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				R.a[i][j] = a[i][j] + A.a[i][j];</span><br><span class="line">				<span class="keyword">if</span> (R.a[i][j] &gt;= mod) R.a[i][j] -= mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">Matrix <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">					R.a[i][j] = (R.a[i][j] + a[i][k] * A.a[k][j]) % mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function">Matrix <span class="title">R</span><span class="params">(A.n, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) R = R * A;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; A = A * A;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到，矩阵乘法一定要写成上面的循环形式，这样利用高速缓存执行时间是原有的 $\frac{1}{4}$</p>
<p>另外有序数组的累和要比无序的快很多，也是因为高速缓存（这个不太懂原理）</p>
</blockquote>
<h3 id="Gauss-消元法浮点版"><a href="#Gauss-消元法浮点版" class="headerlink" title="Gauss 消元法浮点版"></a>Gauss 消元法浮点版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">Gauss</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; A, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-12</span>;</span><br><span class="line">	<span class="keyword">auto</span> findNonZero = [&amp;](<span class="keyword">int</span> i) &#123; <span class="comment">// 实际上找最大的比较好</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i; row &lt; n; ++row) <span class="keyword">if</span> (<span class="built_in">fabs</span>(A[row][i]) &gt; eps) <span class="keyword">return</span> row;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> triangleGauss = [&amp;](<span class="keyword">int</span> sz) &#123; <span class="comment">// A[i][i] = 1</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x(sz);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">			x[i] = b[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; i; ++row) b[row] -= A[row][i] * x[i];</span><br><span class="line">		&#125;</span><br><span class="line">		x.resize(A[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> sz = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, row; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">			row = findNonZero(i);</span><br><span class="line">			<span class="keyword">if</span> (row != n) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) A[j][i] = A[j][m - <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">std</span>::swap(p[i], p[--m]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = m; row &lt; n; ++row) <span class="keyword">if</span> (<span class="built_in">fabs</span>(b[row])) &#123;</span><br><span class="line">				<span class="comment">// std::cout &lt;&lt; "\nNo answer\n";</span></span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			sz = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (row != i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(A[row], A[i]);</span><br><span class="line">			<span class="built_in">std</span>::swap(b[row], b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		b[i] /= A[i][i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) A[i][j] /= A[i][i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i + <span class="number">1</span>; row &lt; n; ++row) &#123;</span><br><span class="line">			b[row] -= A[row][i] * b[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">				A[row][j] -= A[row][i] * A[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if (sz != A[0].size()) std::cout &lt;&lt; "\nInfinite answer\n";</span></span><br><span class="line">	<span class="keyword">auto</span> xt = triangleGauss(sz);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); ++t) x[p[t]] = xt[t];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Gauss-消元法有限域版"><a href="#Gauss-消元法有限域版" class="headerlink" title="Gauss 消元法有限域版"></a>Gauss 消元法有限域版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make sure 0 &lt;= A[i][j], b[i] &lt; M</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">Gauss</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&gt; A, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;LL(LL)&gt; inv = [&amp;](LL a) -&gt; LL &#123;</span><br><span class="line">		<span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (M - M / a) * inv(M % a) % M; </span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> sub = [](LL &amp;x, LL y) &#123;</span><br><span class="line">		(x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += M);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> triangleGauss = [&amp;](<span class="keyword">int</span> sz) &#123; <span class="comment">// A[i][i] = 1</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; x(sz);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">			x[i] = (b[i] + M) % M;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; i; ++row) sub(b[row], A[row][i] * x[i] % M);</span><br><span class="line">		&#125;</span><br><span class="line">		x.resize(A[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> findNonZero = [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i; row &lt; n; ++row) <span class="keyword">if</span> (A[row][i]) <span class="keyword">return</span> row;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> sz = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, row; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">			row = findNonZero(i);</span><br><span class="line">			<span class="keyword">if</span> (row != n) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) A[j][i] = A[j][m - <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">std</span>::swap(p[i], p[--m]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = m; row &lt; n; ++row) <span class="keyword">if</span> (b[row]) &#123;</span><br><span class="line">				<span class="comment">// std::cout &lt;&lt; "\nNo answer\n";</span></span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			sz = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (row != i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(A[i], A[row]);</span><br><span class="line">			<span class="built_in">std</span>::swap(b[i], b[row]);</span><br><span class="line">		&#125;</span><br><span class="line">		LL inva = inv(A[i][i]);</span><br><span class="line">		(b[i] *= inva) %= M;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) (A[i][j] *= inva) %= M;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i + <span class="number">1</span>; row &lt; n; ++row) &#123;</span><br><span class="line">			sub(b[row], A[row][i] * b[i] % M);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">				sub(A[row][j], A[row][i] * A[i][j] % M);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if (sz != A[0].size()) std::cout &lt;&lt; "\nInfinite answer\n";</span></span><br><span class="line">	<span class="keyword">auto</span> xt = triangleGauss(sz);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); ++t) x[p[t]] = xt[t];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="：例题"><a href="#：例题" class="headerlink" title="：例题"></a><a href="/simplex/" title="线性规划单纯形法">线性规划单纯形法</a>：<a href="https://vjudge.net/problem/Kattis-cheeseifyouplease" target="_blank" rel="noopener">例题</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> VD = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1e10</span>;</span><br><span class="line"><span class="comment">// make sure that A = (I, A') and b &gt;= 0, compute max cx</span></span><br><span class="line"><span class="function">VD <span class="title">simplexCore</span><span class="params">(VD c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; A, VD b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i].emplace_back(b[i]);</span><br><span class="line">	c.emplace_back(<span class="number">0</span>);</span><br><span class="line">	A.emplace_back(c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			A[n][j] -= A[n][i] * A[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> check = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt; m; ++j) <span class="keyword">if</span> (A[n][j] &gt; eps) &#123;</span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (A[i][j] &gt; eps) &#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> ch = <span class="built_in">std</span>::max_element(A[n].<span class="built_in">begin</span>() + n, A[n].<span class="built_in">begin</span>() + m) - A[n].<span class="built_in">begin</span>(), hc;</span><br><span class="line">		<span class="keyword">if</span> (A[n][ch] &lt; eps) <span class="keyword">break</span>;	</span><br><span class="line">		assert(check()); <span class="comment">// otherwise unbounded, no max solution</span></span><br><span class="line">		<span class="keyword">double</span> theta = DBL_MAX;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (A[i][ch] &gt; eps &amp;&amp; A[i].back() / A[i][ch] &lt; theta) &#123;</span><br><span class="line">			theta = A[i].back() / A[i][ch];</span><br><span class="line">			hc = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::swap(p[ch], p[hc]);</span><br><span class="line">		<span class="keyword">double</span> tmp = <span class="number">1</span> / A[hc][ch];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) A[hc][j] *= tmp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="keyword">if</span> (i != hc) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) <span class="keyword">if</span> (j != ch) &#123;</span><br><span class="line">				A[i][j] -= A[i][ch] * A[hc][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) A[i][ch] *= -tmp;</span><br><span class="line">		A[hc][ch] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">VD <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) x[p[i]] = A[i].back();</span><br><span class="line">	<span class="comment">// watch(-A.back().back()); // max_val</span></span><br><span class="line">	<span class="keyword">return</span> x; <span class="comment">// point Corresponds to max_val</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// compute max cx, with Aqx = bq and Alq x &lt;= blq, end of 0 can be ommit in A and Aq</span></span><br><span class="line"><span class="function">VD <span class="title">simplex</span><span class="params">(VD c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; Aq, VD bq, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; Alq, VD blq)</span> </span>&#123;</span><br><span class="line">	assert(Aq.<span class="built_in">size</span>() == bq.<span class="built_in">size</span>());</span><br><span class="line">	assert(Alq.<span class="built_in">size</span>() == blq.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">int</span> n = Aq.<span class="built_in">size</span>() + Alq.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> m = c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bq.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (bq[i] &lt; -eps) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : Aq[i]) x = -x;</span><br><span class="line">		bq[i] = -bq[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blq.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (blq[i] &lt; -eps) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : Alq[i]) x = -x;</span><br><span class="line">		++m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; <span class="title">A</span><span class="params">(n, VD(n + m))</span></span>;</span><br><span class="line">	VD f(n + m), b(n);</span><br><span class="line">	<span class="keyword">int</span> now = n + c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Aq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Aq[i].<span class="built_in">size</span>(); ++j) A[i][n + j] = Aq[i][j];</span><br><span class="line">		b[i] = bq[i];</span><br><span class="line">		f[i] = -inf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Alq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Alq[i].<span class="built_in">size</span>(); ++j) A[i + Aq.<span class="built_in">size</span>()][n + j] = Alq[i][j];</span><br><span class="line">		<span class="keyword">if</span> (blq[i] &lt; -eps) &#123;</span><br><span class="line">			A[i + Aq.<span class="built_in">size</span>()][now++] = <span class="number">-1</span>;</span><br><span class="line">			f[i + Aq.<span class="built_in">size</span>()] = -inf;</span><br><span class="line">		&#125;</span><br><span class="line">		b[i + Aq.<span class="built_in">size</span>()] = <span class="built_in">fabs</span>(blq[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); ++i) f[n + i] = c[i];</span><br><span class="line">	<span class="keyword">auto</span> x = simplexCore(f, A, b);</span><br><span class="line">	<span class="keyword">return</span> VD(x.<span class="built_in">begin</span>() + n, x.<span class="built_in">begin</span>() + n + c.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法"><a href="#求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法" class="headerlink" title="求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法"></a>求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1003</span>;</span><br><span class="line">LL c[M], ans[<span class="number">2</span> * M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecSeq</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LL a[<span class="number">2</span> * M];</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	RecSeq(<span class="keyword">int</span> _m, LL x = <span class="number">0</span>): m(_m) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> (a));</span><br><span class="line">		a[<span class="number">0</span>] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	RecSeq <span class="keyword">operator</span> * (<span class="keyword">const</span> RecSeq &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">RecSeq <span class="title">R</span><span class="params">(m)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">				R.a[i + j] = (R.a[i + j] + a[i] * A.a[j]) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * m - <span class="number">2</span>; i &gt;= m; --i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">				R.a[i - m + j] += (R.a[i] * c[j]) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">			R.a[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			R.a[i] %= mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">	<span class="function">T <span class="title">tPow</span><span class="params">(T &amp; A, LL n)</span> </span>&#123;</span><br><span class="line">		<span class="function">T <span class="title">R</span><span class="params">(A.m, <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n &amp; <span class="number">1</span>) R = R * A;</span><br><span class="line">			n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			A = A * A;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initC</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> (c));</span><br><span class="line">	c[<span class="number">0</span>] = c[m - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		ans[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[m] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt; <span class="number">2</span> * m; ++i) &#123;</span><br><span class="line">		ans[i] = ans[i - <span class="number">1</span>] + ans[i - m];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(LL n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	initC(m);</span><br><span class="line">	<span class="function">RecSeq <span class="title">A</span><span class="params">(m)</span></span>;</span><br><span class="line">	A.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	RecSeq R = tPow(A, n - m);</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		r += (R.a[i] * ans[i + m]) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用<a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">多项式带模除法：Division with remainder</a>的 $O(m \log m)$ 算法，可优化到 $O(m \log m \log n)$，</p>
<p>但是如果递推关系中仅有常数个不为 0，比如通常是两个，也可以不用多项式带模除法来搞，只需 NFT 就可以优化到 $O(m \log m \log n + m^2)$ （暂时不知道如何去掉 $m^2$）</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="并查集（Disjoint-Set-Union）"><a href="#并查集（Disjoint-Set-Union）" class="headerlink" title="并查集（Disjoint Set Union）"></a>并查集（Disjoint Set Union）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始情形: p[i] = i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = x;</span><br><span class="line">	<span class="keyword">while</span> (ans != p[ans]) ans = p[ans];</span><br><span class="line">	<span class="keyword">while</span> (x != ans) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = p[x];</span><br><span class="line">		p[x] = ans;</span><br><span class="line">		x = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// p[find(j)] = p[find(i)];</span></span><br><span class="line">	<span class="comment">// In general we should write below</span></span><br><span class="line">	<span class="comment">// int fi = find(i), fj = find(j);</span></span><br><span class="line">	<span class="comment">// if (fi != fj) p[fi] = fj;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回的是离散化之后的数组值对应的原始值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">discrete</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> b = a;</span><br><span class="line">	<span class="built_in">std</span>::sort(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">	b.erase(<span class="built_in">std</span>::unique(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">r</span><span class="params">(b.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : a) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="built_in">std</span>::lower_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), x) - b.<span class="built_in">begin</span>();</span><br><span class="line">		r[id] = x;</span><br><span class="line">		x = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h3><ol>
<li>直接求 $O(n^2)$ 没啥好写的。</li>
<li>把原数组每个位置进行编号，排序，然后每次把最大的数的编号丢进树状数组中，丢进去先看这个编号前面有多少个数，累加一下就可以了，$O(n^2)$，结合下面树状数组的知识还是很简单的。</li>
<li>带离散化的树状数组（就是如果里面的数组特别大，树状数组内存就不够了，所以需要离散化一下）</li>
<li>归并的求（不会也不想搞 0.0）</li>
<li>逐位处理（代码如下）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// all number in a are nonegetive</span></span><br><span class="line"><span class="function">LL <span class="title">inverseNumber</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> dn = <span class="built_in">std</span>::<span class="built_in">log</span>(*<span class="built_in">std</span>::max_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>())) + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= dn; ++d) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(),[&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">			<span class="keyword">return</span> (a[i] &gt;&gt; d) &lt; (a[j] &gt;&gt; d) || ((a[i] &gt;&gt; d) == (a[j] &gt;&gt; d) &amp;&amp; i &lt; j);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i = j) &#123;</span><br><span class="line">			<span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; n &amp;&amp; (a[p[i]] &gt;&gt; d) == (a[p[j]] &gt;&gt; d)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[p[j]] &gt;&gt; (d - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">					++x1;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					r += x1;</span><br><span class="line">				&#125;</span><br><span class="line">				++j;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组（单点更新，从-1-到某个位置的最小值）"><a href="#树状数组（单点更新，从-1-到某个位置的最小值）" class="headerlink" title="树状数组（单点更新，从 1 到某个位置的最小值）"></a>树状数组（单点更新，从 1 到某个位置的最小值）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArrayMin</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	TreeArrayMin() &#123;&#125;</span><br><span class="line">	TreeArrayMin(<span class="keyword">int</span> n) : s(n + <span class="number">1</span>, INT_MAX) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			s[id] = <span class="built_in">std</span>::<span class="built_in">min</span>(s[id], p);</span><br><span class="line">			id += lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算区间 [1, id] 的最小值</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> r = INT_MAX;</span><br><span class="line">		<span class="keyword">while</span> (id) &#123;</span><br><span class="line">			r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, s[id]);</span><br><span class="line">			id -= lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组（单点更新，区间求和，编号从-1-开始）"><a href="#树状数组（单点更新，区间求和，编号从-1-开始）" class="headerlink" title="树状数组（单点更新，区间求和，编号从 1 开始）"></a>树状数组（单点更新，区间求和，编号从 1 开始）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; s;</span><br><span class="line">	TreeArray() &#123;&#125;</span><br><span class="line">	TreeArray(<span class="keyword">int</span> n) : s(n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			s[id] += p;</span><br><span class="line">			id += lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (id) &#123;</span><br><span class="line">			r += s[id];</span><br><span class="line">			id -= lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find minimal index s.t. sum(id) &gt;= x, sum must be increased</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(LL val)</span> </span>&#123;</span><br><span class="line">		LL sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">std</span>::__lg(s.<span class="built_in">size</span>()); ~i; --i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (id + (<span class="number">1</span> &lt;&lt; i) &lt; s.<span class="built_in">size</span>() &amp;&amp; sum + s[id + (<span class="number">1</span> &lt;&lt; i)] &lt; val) &#123;</span><br><span class="line">				id += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">				sum += s[id];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ++id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组（区间更新，区间求和，编号从-1-开始）"><a href="#树状数组（区间更新，区间求和，编号从-1-开始）" class="headerlink" title="树状数组（区间更新，区间求和，编号从 1 开始）"></a>树状数组（区间更新，区间求和，编号从 1 开始）</h3><p>有了单点更新的树状数组，只需简单利用差分就可以变成区间的更新了。<br>设原始数组为 <code>a[1 ~ n]</code>， 定义 <code>c[i] = a[i] - a[i - 1], (a[0] = 0)</code> 显然</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^m a_i = \sum_{i = 1}^m (m - i + 1) c_i = m \sum_{i = 1}^m c_i - \sum_{i = 1}^m (i - 1) c_i</script><p>比如对区间 <code>[l, r]</code> 做更新，那么就只需更新两点：<code>r + 1, l</code> ，套用之前的类就行了。</p>
<blockquote>
<p>注意在树状数组中搜索本来应该是 $O(\log ^2 n)$，但是因为在 $2^i$ 的位置搜索时，一步到位。所以复杂度会降到 $O(\log n)$：<a href="https://codeforces.com/blog/entry/61364" target="_blank" rel="noopener">理论依据</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray2</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	TreeArray B, C;</span><br><span class="line">	TreeArray2() &#123;&#125;</span><br><span class="line">	TreeArray2(<span class="keyword">int</span> _n) : n(_n), B(n), C(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		C.add(id, p);</span><br><span class="line">		B.add(id, (id - <span class="number">1</span>) * p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		add(l, p);</span><br><span class="line">		<span class="keyword">if</span> (r + <span class="number">1</span> &lt; n) add(r + <span class="number">1</span>, -p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id * C.sum(id) - B.sum(id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find minimal index s.t. sum(id) &gt;= x, sum must be increased</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(LL val)</span> </span>&#123;</span><br><span class="line">		LL sumB = <span class="number">0</span>, sumC = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">std</span>::__lg(n); ~i; --i) <span class="keyword">if</span> (<span class="keyword">int</span> idi = id + (<span class="number">1</span> &lt;&lt; i); idi &lt;= n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (idi * (sumC +  C.s[idi]) - B.s[idi] - sumB &lt; val) &#123;</span><br><span class="line">				id = idi;</span><br><span class="line">				sumB += B.s[id];</span><br><span class="line">				sumC += C.s[id];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ++id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="线段树（正式版）"><a href="#线段树（正式版）" class="headerlink" title="线段树（正式版）"></a>线段树（正式版）</h3><p>首先显然总节点 $m$ 上界为 $4n$，并且可以证明 $\frac{m}{n}$ 的上确界为 $4$，下确界为 $2$ 注意到如果 $n = 2^k + 2^{j + 1}$ 时，则 $m = 2 ^{k + 1} + 2^k + \cdots 2^{k - j} + 1$，所以 $\frac{m}{n} = \frac{4 - 2^{-j} + 2^{-k}}{1 + 2^{j + 1 - k}}$，对任意 $\epsilon &gt; 0$ 存在 $j$ 使得 $4 - 2 ^{-j} &gt; 4 - \epsilon$， 然后让 $k$ 趋于无穷，那么显然 $\frac{m}{n}$ 上极限为 $4$.（$n = 40$ 时， $\frac{m}{n} &gt; 3$，$n = 2^20 + 2^10 = 1049600$ 时，$\frac{m}{n} &gt; 3.99$）</p>
<blockquote>
<p>和与最大值的线段树模板（如果单纯求和，可以用树状数组）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mn, tag;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; sm;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lson l, m, 2 * p</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, 2 * p + 1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mn.resize(<span class="number">4</span> * n);</span><br><span class="line">		tag.resize(<span class="number">4</span> * n);</span><br><span class="line">		sm.resize(<span class="number">4</span> * n);</span><br><span class="line">	&#125;</span><br><span class="line">	SegmentTree(<span class="keyword">int</span> _n) : n(_n) &#123;</span><br><span class="line">		resize();</span><br><span class="line">	&#125;</span><br><span class="line">	SegmentTree(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a) &#123;</span><br><span class="line">		n = a.<span class="built_in">size</span>();</span><br><span class="line">		resize();</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; build = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p) &#123;</span><br><span class="line">			<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">				mn[p] = sm[p] = a[l - <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">			build(lson);</span><br><span class="line">			build(rson);</span><br><span class="line">			pull(p);</span><br><span class="line">		&#125;;</span><br><span class="line">		build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		mn[p] = <span class="built_in">std</span>::<span class="built_in">min</span>(mn[<span class="number">2</span> * p], mn[<span class="number">2</span> * p + <span class="number">1</span>]);</span><br><span class="line">		sm[p] = sm[<span class="number">2</span> * p] + sm[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (tag[p]) &#123;</span><br><span class="line">			<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">			<span class="built_in">set</span>(lson, tag[p]);</span><br><span class="line">			<span class="built_in">set</span>(rson, tag[p]);</span><br><span class="line">			tag[p] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		tag[p] = mn[p] = v;</span><br><span class="line">		sm[p] = LL(r - l + <span class="number">1</span>) * v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rangeSet</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;</span><br><span class="line">			<span class="built_in">set</span>(l, r, p, v);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		push(l, r, p);</span><br><span class="line">		<span class="keyword">if</span> (L &lt;= m) rangeSet(L, R, v, lson);</span><br><span class="line">		<span class="keyword">if</span> (R &gt; m) rangeSet(L, R, v, rson);</span><br><span class="line">		pull(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以下内容根据需要修改</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>&amp; y, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mn[p] &gt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= l &amp;&amp; sm[p] &lt;= y) &#123;</span><br><span class="line">			y -= sm[p];</span><br><span class="line">			<span class="keyword">return</span> r - l + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		push(l, r, p);</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= m) ans += query(x, y, lson); </span><br><span class="line">		ans += query(x, y, rson);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">bounded</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mn[p] &gt;= v) <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (mn[<span class="number">2</span> * p] &gt;= v) <span class="keyword">return</span> bounded(v, rson);</span><br><span class="line">		<span class="keyword">return</span> bounded(v, lson);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = bounded(y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (l &lt;= x) rangeSet(l, x, y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> query(x, y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码参考了 Jiangly 的模板，他的是左闭右开的。</p>
</blockquote>
<h3 id="线段树-（弃用版）"><a href="#线段树-（弃用版）" class="headerlink" title="线段树 （弃用版）"></a>线段树 （弃用版）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, lrt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rrt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">LL sum[N * <span class="number">3</span>], col[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	sum[rt] = sum[lrt] + sum[rrt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (col[rt]) &#123;</span><br><span class="line">		col[lrt] += col[rt];</span><br><span class="line">		col[rrt] += col[rt];</span><br><span class="line">		sum[lrt] += (m - (m &gt;&gt; <span class="number">1</span>)) * col[rt];</span><br><span class="line">		sum[rrt] += (m &gt;&gt; <span class="number">1</span>) * col[rt];</span><br><span class="line">		col[rt] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp; sum[rt]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	col[rt] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(lson);</span><br><span class="line">	build(rson);</span><br><span class="line">	pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;</span><br><span class="line">		sum[rt] += p * (r - l + <span class="number">1</span>);</span><br><span class="line">		col[rt] += p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= m) update(L, R, p, lson);</span><br><span class="line">	<span class="keyword">if</span> (R &gt; m) update(L, R, p, rson);</span><br><span class="line">	pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> sum[rt];</span><br><span class="line">	pushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= m) ans += query(L, R, lson);</span><br><span class="line">	<span class="keyword">if</span> (R &gt; m) ans += query(L, R, rson);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>吊打线段树的 <a href="https://blog.csdn.net/CC_dsm/article/details/98166835" target="_blank" rel="noopener">珂朵莉树（Chtholly Tree）</a></p>
</blockquote>
<h3 id="RMQ-求区间最大值（弃用）"><a href="#RMQ-求区间最大值（弃用）" class="headerlink" title="RMQ 求区间最大值（弃用）"></a>RMQ 求区间最大值（弃用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMQ</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> a[N][<span class="number">20</span>]; <span class="comment">//a[i][j]=max(s[i]---s[i+2^j-1])</span></span><br><span class="line">	RMQ(<span class="keyword">int</span> * s, <span class="keyword">int</span> _n): n(_n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) a[i][<span class="number">0</span>] = s[i];</span><br><span class="line">		<span class="keyword">int</span> len = (<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(n)) / <span class="built_in">log</span>(<span class="number">2.0</span>)) + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != len; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - (<span class="number">1</span> &lt;&lt; i); ++j) &#123;</span><br><span class="line">				a[j][i] = <span class="built_in">max</span>(a[j][i - <span class="number">1</span>], a[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 0 &lt;= l &lt;= r &lt; n</span></span><br><span class="line">		<span class="keyword">int</span> len = (<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(r - l + <span class="number">1</span>)) / <span class="built_in">log</span>(<span class="number">2.0</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(a[l][len], a[r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们经常用二分答案的思想， 但是其实二分答案是仅仅知道其单调的情况下的策略，实际上，对于具体的问题， 我们完全可以对 $m$ 的值进行不同的处理， 而非单纯的 $m = (l + r) &gt;&gt; 1 $。</p>
</blockquote>
<h3 id="三分法简单版"><a href="#三分法简单版" class="headerlink" title="三分法简单版"></a><a href="https://codeforces.com/contest/439/problem/D" target="_blank" rel="noopener">三分法简单版</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for a given covex function f: (f(a) + f(b)) / 2 &gt;= f((a + b) / 2)</span></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span> (l + <span class="number">2</span> &lt; r) &#123;</span><br><span class="line">	<span class="keyword">int</span> lm = (<span class="number">2l</span>l * l + r) / <span class="number">3</span>, rm = (l + <span class="number">2l</span>l * r + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (f(lm) &lt; f(rm)) r = rm;</span><br><span class="line">	<span class="keyword">else</span> l = lm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">	<span class="keyword">if</span> (f(l) &lt; f(r)) --r;</span><br><span class="line">	<span class="keyword">else</span> ++l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标准三分法用黄金分割的原因"><a href="#标准三分法用黄金分割的原因" class="headerlink" title="标准三分法用黄金分割的原因"></a>标准三分法用黄金分割的原因</h3><p>我们不妨设原始区间为 <code>[0, 1]</code>，我们在其中选两个点 <code>0 &lt; a &lt; b &lt; 1</code>，然后比较 <code>f(a)</code> 和 <code>f(b)</code>，然后再相应改变区间。然后重复上述过程。如果我们能充分利用计算过的值，也就是说假设更新后的区间为 <code>[0, b]</code> 那么我们自然想让 <code>a</code> 的计算值充分被利用，所以我们想再选的两个点的其中一个是 <code>a</code>，如果更新后区间为 <code>[a, 1]</code> 同理。也就是说我们有策略</p>
<script type="math/tex; mode=display">
\frac{a}{b} = b, \frac{b - a}{1 - a} = a</script><p>化简可得 $b(1 + b) = 1$，即 $b = \frac{\sqrt{5} - 1}{2}, a = b ^ 2 = \frac{3 - \sqrt{5}}{2} = 1 - b$。</p>
<blockquote>
<p>注意到上述 $b$ 的值正好是黄金分割 0.618…</p>
</blockquote>
<h3 id="三分法黄金分割版（可用版）"><a href="#三分法黄金分割版（可用版）" class="headerlink" title="三分法黄金分割版（可用版）)"></a><a href="(https://codeforces.com/contest/439/problem/D">三分法黄金分割版（可用版）</a>)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for a given covex function f: (f(a) + f(b)) / 2 &gt;= f((a + b) / 2)</span></span><br><span class="line"><span class="keyword">auto</span> tupleCut = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> phiL = (<span class="number">3</span> - <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">5</span>)) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> phiR = (<span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">5</span>) - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">auto</span> getLeft = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l + (r - l) * phiL;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> getRight = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l + (r - l) * phiR;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> lm = getLeft(l, r), rm = getRight(l, r);</span><br><span class="line">	LL fl = f(lm), fr = f(rm);</span><br><span class="line">	<span class="keyword">while</span> (r - l &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fl &lt; fr) &#123;</span><br><span class="line">			r = rm;</span><br><span class="line">			rm = lm;</span><br><span class="line">			fr = fl;</span><br><span class="line">			fl = f(lm = getRight(l, rm));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			l = lm;</span><br><span class="line">			lm = rm;</span><br><span class="line">			fl = fr;</span><br><span class="line">			fr = f(rm = getLeft(lm, r));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fl = f(l), fr = f(r);</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fl &lt; fr) fr = f(--r);</span><br><span class="line">		<span class="keyword">else</span> fl = f(++l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意返回的是最值而不是最值点</p>
<p>注意到一定要用上述写法，由于取整带来的误差，所以必须充分利用“左分点”是“右分点”的“右分点”，“右分点”是“左分点”的“左分点”（用来保证 $l \leq lm \leq rm \leq r$），然后如果单次求 $f$ 的复杂度特别高，两段各自最后一步也是可以优化一下，少算一次 $f$，但是会很不优雅，所以还是算了。</p>
</blockquote>
<h3 id="最长（严格）递增子序列"><a href="#最长（严格）递增子序列" class="headerlink" title="最长（严格）递增子序列"></a>最长（严格）递增子序列</h3><blockquote>
<p>下面数组 <code>b</code> 的意义：<code>b[i]</code> 表示当前长为 <code>i</code> 的子列的末位的最小值。<br>这个子序列还能给附加限制（比如都要大于某个值）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123; <span class="comment">// length of longest increasing subsquence</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::lower_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), x); it == b.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			b.emplace_back(x);</span><br><span class="line">		&#125; <span class="keyword">else</span> *it = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LNDS</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123; <span class="comment">// length of longest increasing subsquence</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::upper_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), x); it == b.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			b.emplace_back(x);</span><br><span class="line">		&#125; <span class="keyword">else</span> *it = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LISP</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123; <span class="comment">// longest increasing subsquence</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b, pb, pa(a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">std</span>::iota(pa.<span class="built_in">begin</span>(), pa.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::upper_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), a[i]); it == b.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!pb.empty()) pa[i] = pb.back();</span><br><span class="line">			b.emplace_back(a[i]);</span><br><span class="line">			pb.emplace_back(i);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			*it = a[i];</span><br><span class="line">			<span class="keyword">int</span> t = it - b.<span class="built_in">begin</span>();</span><br><span class="line">			pb[t] = i;</span><br><span class="line">			<span class="keyword">if</span> (t &gt; <span class="number">0</span>) pa[i] = pb[t - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">	<span class="keyword">int</span> now = pb.back();</span><br><span class="line">	c.push(a[now]);</span><br><span class="line">	<span class="keyword">while</span> (now != pa[now]) &#123;</span><br><span class="line">		now = pa[now];</span><br><span class="line">		c.push(a[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lower_bound(first,end,val) 表示在单增 [frist,end) 中首次大于等于 val 的位置</span></span><br><span class="line"><span class="comment">// upper_bound(first,end,val) 表示在单增 [frist,end) 中首次大于 val 的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> r[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pack</span><span class="params">(<span class="keyword">int</span> cash, <span class="keyword">int</span> num, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">0</span> || w == <span class="number">0</span> || v == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">1</span>) &#123; <span class="comment">//  0-1背包</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = cash; i &gt;= v; --i)</span><br><span class="line">			r[i] = <span class="built_in">max</span>(r[i], r[i - v] + w);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num * v &gt;= cash - v + <span class="number">1</span>) &#123; <span class="comment">//完全背包</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = v; i &lt;= cash; ++i)</span><br><span class="line">			r[i] = <span class="built_in">max</span>(r[i], r[i - v] + w);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> q[MAX], s[MAX], head, tail;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123; <span class="comment">//多重背包</span></span><br><span class="line">		q[<span class="number">0</span>] = r[j];</span><br><span class="line">		s[<span class="number">0</span>] = head = tail = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = j + v; k &lt;= cash; ++i, k += v) &#123;</span><br><span class="line">			q[i] = r[k] - i * w;</span><br><span class="line">			<span class="keyword">while</span> (s[head] &lt; i - num) ++head;</span><br><span class="line">			<span class="keyword">while</span> (head &lt;= tail &amp;&amp; q[tail] &lt; q[i]) --tail;</span><br><span class="line">			s[++tail] = i;</span><br><span class="line">			q[tail] = q[i];</span><br><span class="line">			r[k] = q[head] + i * w;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆与-STL-优先队列"><a href="#堆与-STL-优先队列" class="headerlink" title="堆与 STL 优先队列"></a>堆与 STL 优先队列</h3><p>可以使用 <a href="http: //www.cplusplus.com/reference/">C++STL</a> 的 priority_queue，查找可用 lower_bound 和 upper_bound。C++ STL 中优先队列是用堆来实现的。用途十分广泛，例如加速最小生成树，拓扑排序，等等。<br>堆的实现一般是用数组。 我们可以用 1 作为树的根， 对每一个节点 $x$， 它的两个节点分别就是 $2x$ 和 $2x + 1$ 平时都用 <code>x &lt;&lt; 1, x &lt;&lt; 1 | 1</code> 表示。 堆只支持三个操作:</p>
<ol>
<li>插入一个节点(我们实现时是插入最尾部， 这样保证了是一个完全二叉树) $O(\log n)$ </li>
<li>删除最大键值节点（ 删除根元素的值） $O(\log n)$ </li>
<li>输出最大键值节点（ 查看根元素的值） $O(1)$</li>
</ol>
<blockquote>
<p>我掌握的也很喜欢的几个数据结构：<code>单调队列，单调栈，树状数组，堆，线段树，红黑树</code></p>
</blockquote>
<h3 id="拓扑排序反字典序输出"><a href="#拓扑排序反字典序输出" class="headerlink" title="拓扑排序反字典序输出"></a>拓扑排序反字典序输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], sc, d[N], ans[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ed;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">&#125;</span><br><span class="line">e[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	e[sc].ed = y;</span><br><span class="line">	e[sc].next = head[x];</span><br><span class="line">	head[x] = sc++;</span><br><span class="line">	++d[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	sc = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		head[i] = <span class="number">-1</span>;</span><br><span class="line">		d[i] = <span class="number">0</span>;</span><br><span class="line">		v[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// after read data</span></span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span> &gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (d[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span> (v[u]) <span class="keyword">continue</span>;</span><br><span class="line">		v[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (--d[e[i].ed] == <span class="number">0</span>) q.push(e[i].ed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树-red-black-tree"><a href="#红黑树-red-black-tree" class="headerlink" title="红黑树 red-black tree"></a>红黑树 red-black tree</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBT</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span> elemType;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> RED = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> BLACK = <span class="number">1</span>;</span><br><span class="line">		Node * ch[<span class="number">2</span>], * fa; <span class="comment">// x-&gt;fa-&gt;ch[x-&gt;rs] = x</span></span><br><span class="line">		<span class="keyword">int</span> sz;</span><br><span class="line">		elemType key;</span><br><span class="line">		<span class="keyword">bool</span> color, rs; <span class="comment">// is rightson</span></span><br><span class="line">	&#125;;</span><br><span class="line">	Node * root; <span class="comment">// root has no father</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">faSon</span><span class="params">(Node * x, Node * y, <span class="keyword">bool</span> rs)</span> </span>&#123;</span><br><span class="line">		y-&gt;fa = x;</span><br><span class="line">		y-&gt;rs = rs;</span><br><span class="line">		x-&gt;ch[rs] = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">newNode</span><span class="params">(Node * x, elemType val, <span class="keyword">bool</span> rs)</span> </span>&#123; <span class="comment">// x-&gt;ch[rs]=null</span></span><br><span class="line">		Node * p = <span class="keyword">new</span> Node;</span><br><span class="line">		p-&gt;ch[<span class="number">0</span>] = p-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">		p-&gt;sz = <span class="number">1</span>;</span><br><span class="line">		p-&gt;key = val;</span><br><span class="line">		p-&gt;color = Node::RED;</span><br><span class="line">		faSon(x, p, rs);</span><br><span class="line">		++x-&gt;sz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node * x, <span class="keyword">bool</span> rs)</span> </span>&#123; <span class="comment">// x must not null</span></span><br><span class="line">		Node * y = x-&gt;ch[!rs];</span><br><span class="line">		<span class="keyword">if</span> (y == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x == root) root = y;</span><br><span class="line">		<span class="keyword">else</span> faSon(x-&gt;fa, y, x-&gt;rs);</span><br><span class="line">		faSon(x, y-&gt;ch[rs], !rs);</span><br><span class="line">		faSon(y, x, rs);</span><br><span class="line">		y-&gt;sz = x-&gt;sz;</span><br><span class="line">		x-&gt;sz = x-&gt;ch[<span class="number">0</span>]-&gt;sz + x-&gt;ch[<span class="number">1</span>]-&gt;sz + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insMaintain</span><span class="params">(Node * x)</span> </span>&#123; <span class="comment">// x-&gt;color is RED</span></span><br><span class="line">		<span class="keyword">if</span> (x == root || x-&gt;fa-&gt;color == Node::BLACK) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;fa-&gt;fa-&gt;ch[!x-&gt;fa-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;rs ^ x-&gt;fa-&gt;rs) rotate(x-&gt;fa, x-&gt;fa-&gt;rs);</span><br><span class="line">			<span class="keyword">else</span> x = x-&gt;fa;</span><br><span class="line">			x-&gt;color = Node::BLACK;</span><br><span class="line">			x-&gt;fa-&gt;color = Node::RED;</span><br><span class="line">			rotate(x-&gt;fa, !x-&gt;rs);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			x = x-&gt;fa-&gt;fa;</span><br><span class="line">			x-&gt;color = Node::RED;</span><br><span class="line">			x-&gt;ch[<span class="number">0</span>]-&gt;color = x-&gt;ch[<span class="number">1</span>]-&gt;color = Node::BLACK;</span><br><span class="line">			insMaintain(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase1</span><span class="params">(Node * x, Node * y)</span> </span>&#123;</span><br><span class="line">		y-&gt;color = Node::BLACK;</span><br><span class="line">		y-&gt;fa-&gt;color = Node::RED;</span><br><span class="line">		y = y-&gt;ch[!y-&gt;rs];</span><br><span class="line">		rotate(x-&gt;fa, x-&gt;rs);</span><br><span class="line">		delCase2(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase2</span><span class="params">(Node * x, Node * y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;ch[y-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (y-&gt;ch[!y-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">				y-&gt;color = Node::RED;</span><br><span class="line">				delMaintain(y-&gt;fa);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				y-&gt;color = Node::RED;</span><br><span class="line">				y-&gt;ch[!y-&gt;rs]-&gt;color = Node::BLACK;</span><br><span class="line">				rotate(y, y-&gt;rs);</span><br><span class="line">				delCase3(y-&gt;fa);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> delCase3(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase3</span><span class="params">(Node * y)</span> </span>&#123;</span><br><span class="line">		y-&gt;color = y-&gt;fa-&gt;color;</span><br><span class="line">		y-&gt;ch[y-&gt;rs]-&gt;color = y-&gt;fa-&gt;color = Node::BLACK;</span><br><span class="line">		rotate(y-&gt;fa, !y-&gt;rs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delMaintain</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == root || x == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;color == Node::RED) &#123;</span><br><span class="line">			x-&gt;color = Node::BLACK;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node * y = x-&gt;fa-&gt;ch[!x-&gt;rs];</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;color == Node::RED) delCase1(x, y);</span><br><span class="line">		<span class="keyword">else</span> delCase2(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">pred</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// max elem &lt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &gt; val) <span class="keyword">return</span> pred(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] == null) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">return</span> pred(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">succ</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// min elem &gt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &lt; val) <span class="keyword">return</span> succ(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] == null) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">return</span> succ(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// count elem &lt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &gt; val) <span class="keyword">return</span> rank(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">		<span class="keyword">return</span> x-&gt;ch[<span class="number">0</span>]-&gt;sz + <span class="number">1</span> + rank(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">select</span><span class="params">(Node * x, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// k-th smallest elem</span></span><br><span class="line">		<span class="keyword">if</span> (x == null || x-&gt;sz &lt; k) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">int</span> sz = x-&gt;ch[<span class="number">0</span>]-&gt;sz + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (sz == k) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">if</span> (sz &lt; k) <span class="keyword">return</span> select(x-&gt;ch[<span class="number">1</span>], k - sz);</span><br><span class="line">		<span class="keyword">return</span> select(x-&gt;ch[<span class="number">0</span>], k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) <span class="built_in">clear</span>(x-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) <span class="built_in">clear</span>(x-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x != null) <span class="keyword">delete</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"key = %d, sz = %d "</span>, x-&gt;key, x-&gt;sz);</span><br><span class="line">		<span class="built_in">puts</span>(x-&gt;color == Node::RED ? <span class="string">"RED"</span> : <span class="string">"BLACK"</span>);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) <span class="built_in">print</span>(x-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) <span class="built_in">print</span>(x-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	Node * null;</span><br><span class="line">	RBT() &#123;</span><br><span class="line">		null = <span class="keyword">new</span> Node; <span class="comment">// no key, rs, father</span></span><br><span class="line">		null-&gt;ch[<span class="number">0</span>] = null-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">		null-&gt;sz = <span class="number">0</span>;</span><br><span class="line">		null-&gt;color = Node::BLACK;</span><br><span class="line">		root = null;</span><br><span class="line">		null-&gt;key = INF; <span class="comment">// for convenient</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">search</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		Node * x = root;</span><br><span class="line">		<span class="keyword">while</span> (x != null) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val == x-&gt;key) <span class="keyword">return</span> x;</span><br><span class="line">			x = x-&gt;ch[val &gt;= x-&gt;key];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> null;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">			root = <span class="keyword">new</span> Node; <span class="comment">// no father, rs</span></span><br><span class="line">			root-&gt;ch[<span class="number">0</span>] = root-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">			root-&gt;sz = <span class="number">1</span>;</span><br><span class="line">			root-&gt;color = Node::BLACK;</span><br><span class="line">			root-&gt;key = val;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node * x = root;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;ch[val &gt;= x-&gt;key] != null) &#123;</span><br><span class="line">			++x-&gt;sz;</span><br><span class="line">			x = x-&gt;ch[val &gt;= x-&gt;key];</span><br><span class="line">		&#125;</span><br><span class="line">		newNode(x, val, val &gt;= x-&gt;key);</span><br><span class="line">		insMaintain(x-&gt;ch[val &gt;= x-&gt;key]);</span><br><span class="line">		root-&gt;color = Node::BLACK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		Node * x = search(val), * y;</span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;ch[<span class="number">0</span>] != null || x-&gt;ch[<span class="number">1</span>] != null) &#123;</span><br><span class="line">			<span class="keyword">bool</span> rs = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;ch[rs] == null) rs = !rs;</span><br><span class="line">			y = x-&gt;ch[rs];</span><br><span class="line">			<span class="keyword">while</span> (y-&gt;ch[!rs] != null) y = y-&gt;ch[!rs];</span><br><span class="line">			<span class="built_in">std</span>::swap(x-&gt;key, y-&gt;key);</span><br><span class="line">			x = y;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;color == Node::RED) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		delMaintain(x);</span><br><span class="line">		root-&gt;color = Node::BLACK;</span><br><span class="line">		y = x;</span><br><span class="line">		<span class="keyword">while</span> (y != root) &#123;</span><br><span class="line">			y = y-&gt;fa;</span><br><span class="line">			--y-&gt;sz;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x == root) root = null;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) faSon(x-&gt;fa, x-&gt;ch[<span class="number">0</span>], x-&gt;rs);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) faSon(x-&gt;fa, x-&gt;ch[<span class="number">1</span>], x-&gt;rs);</span><br><span class="line">		<span class="keyword">else</span> x-&gt;fa-&gt;ch[x-&gt;rs] = null;</span><br><span class="line">		<span class="keyword">delete</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">pred</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pred(root, val)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">succ</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> succ(root, val)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rank(root, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> select(root, k)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">clear</span>(root);</span><br><span class="line">		root = null;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> root-&gt;sz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root != null) <span class="built_in">print</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// for particular use</span></span><br><span class="line">		<span class="keyword">return</span> select(root, rank(root, a) + k)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><blockquote>
<p>图论还是一个特别强的工具。 为什么没有图论的 STL？</p>
</blockquote>
<h3 id="图论模板"><a href="#图论模板" class="headerlink" title="图论模板"></a>图论模板</h3><ul>
<li><a href="https://uoj.ac/submission/160478" target="_blank" rel="noopener">Nisiyama_Suzune</a> 的图论模板</li>
<li><a href="https://github.com/DQ9911/icpc_template_2020" target="_blank" rel="noopener">DQ9911</a> 的模板</li>
<li><a href="HDU_ACM-ICPC_Templates.pdf">HDU 模板</a> 也可以作为参考</li>
</ul>
<h3 id="存边方式"><a href="#存边方式" class="headerlink" title="存边方式"></a>存边方式</h3><ul>
<li>不涉及删边和反边（最简单常用的情况），可以直接用 vector 邻接表 <code>std::vector&lt;std::vector&lt;std::pair&lt;int, T&gt;&gt;&gt;</code></li>
<li>仅涉及反向边，不涉及删边（如网络流问题），可以使用 vector 版本的链式前向星（写法特别简洁）</li>
<li>不涉及重边（即使涉及重边也可以！其它操作随意，无向图其实也可以操作），都可以使用 vector 邻接表 <code>std::vector&lt;std::unordered_map&lt;int, int&gt;&gt;</code>（更快）或<code>std::vector&lt;std::map&lt;int, T&gt;&gt;</code>，当然了各种操作都要带个 log </li>
<li>如果涉及重边（逻辑上没法合并的那种），就不存在反边的概念了。此时可以用链式前向星，也可以使用 最简单情况的 vector 邻接表（也支持删边，只是比较慢）无论怎么，即使不用链式前向星，这种思想还是值得学习的。</li>
</ul>
<h3 id="图的匹配算法"><a href="#图的匹配算法" class="headerlink" title="图的匹配算法"></a><a href="https://oi-wiki.org/topic/graph-matching/graph-match/" target="_blank" rel="noopener">图的匹配算法</a></h3><p>OI-wiki 上有专题专门讲这个的，分最大匹配和最大权匹配，对于特殊的图（例如二分图）有<a href="https://oi-wiki.org/topic/graph-matching/bigraph-match/" target="_blank" rel="noopener">特殊的算法</a>，例如可以增加源点和汇点转化成网络流问题，用 Dinic 算法在 $O(\sqrt{n} m)$ 解决。</p>
<blockquote>
<p>其中一般图的最大匹配可以参考 <a href="https://uoj.ac/submission/221981" target="_blank" rel="noopener">Min_25 的模板</a></p>
</blockquote>
<h3 id="链式前向星-（弃用）"><a href="#链式前向星-（弃用）" class="headerlink" title="链式前向星 （弃用）"></a>链式前向星 （弃用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head, nxt, to;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; w;</span><br><span class="line">	LinkStar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		nxt.<span class="built_in">clear</span>();</span><br><span class="line">		to.<span class="built_in">clear</span>();</span><br><span class="line">		head = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL val)</span> </span>&#123;</span><br><span class="line">		nxt.emplace_back(head[u]);</span><br><span class="line">		head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">		to.emplace_back(v);</span><br><span class="line">		w.emplace_back(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="知乎上看到-YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）"><a href="#知乎上看到-YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）" class="headerlink" title="知乎上看到 YYYYLLL 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）"></a>知乎上看到 <a href="https://www.zhihu.com/people/yyyylll-37" target="_blank" rel="noopener">YYYYLLL</a> 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">j</span>] 表示只经过 1～k 号节点优化，i 点到 j 点的最短路径长度。</span><br><span class="line">则 DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">j</span>] = min( DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">j</span>], DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">k</span>]+DP[<span class="string">k-1</span>][<span class="symbol">k</span>][<span class="string">j</span>] ) </span><br><span class="line">= min( DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">j</span>], DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">k</span>]+DP[<span class="string">k</span>][<span class="symbol">k</span>][<span class="string">j</span>] ) </span><br><span class="line">DP[<span class="string">0</span>][<span class="symbol"></span>][<span class="string"></span>] 是初始图的邻接矩阵，DP[<span class="string">n</span>][<span class="symbol"></span>][<span class="string"></span>] 就是最终求得的最短路长度矩阵了</span><br></pre></td></tr></table></figure>
<p>本来一开始是没法做空间优化的， 但是第二个等式， 就保证了可以做空间优化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1003</span>;</span><br><span class="line">LL dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> cmin = [](<span class="keyword">auto</span> &amp;x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; y) x = y;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != n; ++k)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j != n; ++j)</span><br><span class="line">				cmin(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd-带路径-—-未测试"><a href="#Floyd-带路径-—-未测试" class="headerlink" title="Floyd 带路径 —- 未测试"></a>Floyd 带路径 —- 未测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1003</span>;</span><br><span class="line">LL dp[N][N], path[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(path, <span class="number">-1</span>, <span class="keyword">sizeof</span>(path));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != n; ++k)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j != n; ++j) <span class="keyword">if</span> (dp[i][j] &gt; dp[i][k] + dp[k][j]) &#123;</span><br><span class="line">				path[i][j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path[x][y] == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;x&#125;;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;x, y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> left = getPath(x, path[x][y]);</span><br><span class="line">	<span class="keyword">auto</span> now = getPath(path[x][y], y);</span><br><span class="line">	left.insert(left.<span class="built_in">end</span>(), now.<span class="built_in">begin</span>(), now.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有根树的-dfs-序-和-Euler-序列"><a href="#有根树的-dfs-序-和-Euler-序列" class="headerlink" title="有根树的 dfs 序 和 Euler 序列"></a>有根树的 <strong>dfs 序</strong> 和 <strong>Euler 序列</strong></h3><blockquote>
<p>本质作用： 将树上问题转化成序列问题</p>
</blockquote>
<p>树节点按 dfs 过程中的访问顺序排序，称为 dfs 序。<br>树在 dfs 过程中的节点访问顺序称为 Euler 序。欧拉序列有很多种，按照实际需要选择合适的 Euler 序列。</p>
<p><a href="https://www.cnblogs.com/bytebull/p/5929137.html" target="_blank" rel="noopener">这里</a> 给出了 dfs 序的一些应用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DfsTour</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, cnt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l, r;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DfsTour(<span class="keyword">int</span> _n) : n(_n), e(n), l(n), r(n), cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">		l[u] = ++cnt;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			dfs(v, u);</span><br><span class="line">		&#125;</span><br><span class="line">		r[u] = cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 u 的子树的编号正好是区间 $[l_u, r_u]$</p>
</blockquote>
<h3 id="每个节点仅标记一次的-Euler-序列"><a href="#每个节点仅标记一次的-Euler-序列" class="headerlink" title="每个节点仅标记一次的 Euler 序列"></a>每个节点仅标记一次的 Euler 序列</h3><p>问题 1：求某个点到根节点的权值和。</p>
<p>方法：先求 Euler 序列，需要在进的点处做加法，出的点处做减法，查询某点就只需要查询对应的前缀即可。</p>
<p>问题 2：求某个子树的权值和。</p>
<p>方法：需要在进的点处做加法，求某个点最后一次出现的位置的前缀和减去第一次出现的位置的前一个位置的前缀和即可。</p>
<h3 id="进入记录一次，出去记录一次的-Euler-序列"><a href="#进入记录一次，出去记录一次的-Euler-序列" class="headerlink" title="进入记录一次，出去记录一次的 Euler 序列"></a>进入记录一次，出去记录一次的 Euler 序列</h3><p>用途：LCA，RMQ 等。<br>求 Euler 序列时，求出根节点和其它点的距离，树上任意两点 $a, b$ 的距离就是 <code>d[a] + d[b] - d[lca(a, b)]</code></p>
<p>如果求树上任意两点距离之和：只需统计每条边经过多少次就行，显然等价于每条边左右两边节点个数。</p>
<h3 id="无根树的-Prufer-序列"><a href="#无根树的-Prufer-序列" class="headerlink" title="无根树的 Prufer 序列"></a>无根树的 Prufer 序列</h3><blockquote>
<p>A.Cayley 在 1889 年首先公布并证明 $n$ 个节点的无根树和长度为 $n-2$，数值在 $1 \to n$ 的序列有一一对应</p>
<p>构造方式：删除编号最小的叶子节点，并记录它的父节点。</p>
</blockquote>
<p>曾在 <a href="/catWithPy/" title="猫咪状态数">猫咪状态数</a> 中有记录过。<a href="https://cp-algorithms.com/graph/pruefer_code.html" target="_blank" rel="noopener">CP-algorithm</a> 中有详细的讲解和代码 无根树 和 Prufer 序列 互转的 $O(n \log n)$ 和 $O(n)$ 两类代码</p>
<h3 id="树的直径：先从任意点开始寻找最远距离点（bfs-遍历一下），然后再找一次就是了（易证）"><a href="#树的直径：先从任意点开始寻找最远距离点（bfs-遍历一下），然后再找一次就是了（易证）" class="headerlink" title="树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）"></a>树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）</h3><p>例题：<a href="https://codeforces.com/contest/1405/problem/D" target="_blank" rel="noopener">1405D</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> bfs = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	d[x] = <span class="number">0</span>;</span><br><span class="line">	Q.push(x);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (d[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">			d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">			Q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::max_element(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>()) - d.<span class="built_in">begin</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树的中心-：所有点到该点的最大值最小（直径的中点）"><a href="#树的中心-：所有点到该点的最大值最小（直径的中点）" class="headerlink" title="[树的中心]：所有点到该点的最大值最小（直径的中点）"></a>[树的中心]：所有点到该点的最大值最小（直径的中点）</h3><h3 id="树的重心：去掉这个点后连通分支的节点数量的最大值最小"><a href="#树的重心：去掉这个点后连通分支的节点数量的最大值最小" class="headerlink" title="树的重心：去掉这个点后连通分支的节点数量的最大值最小"></a><a href="https://oi-wiki.org/graph/tree-centroid/" target="_blank" rel="noopener">树的重心</a>：去掉这个点后连通分支的节点数量的最大值最小</h3><p>根据 DFS 子树的大小和“向上”的子树大小就可以知道所有子树中最大的子树节点数。：<a href="https://codeforces.com/contest/1406/problem/C" target="_blank" rel="noopener">例题 1406C</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中 e 表示树的边，n 为数的数量</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; degree = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">	d[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (d[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">		d[u] += degree(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[u];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> barycenter = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">int</span> cnt = degree(x);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n, n)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(x);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		w[u] = cnt - d[u];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (w[v] == n) &#123;</span><br><span class="line">			w[u] = <span class="built_in">std</span>::<span class="built_in">max</span>(w[u], d[v]);</span><br><span class="line">			Q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="built_in">std</span>::min_element(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>()) - w.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::make_pair(r, w[r]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最近公共祖先简称-LCA（Lowest-Common-Ancestor）"><a href="#最近公共祖先简称-LCA（Lowest-Common-Ancestor）" class="headerlink" title="最近公共祖先简称 LCA（Lowest Common Ancestor）"></a>最近公共祖先简称 LCA（Lowest Common Ancestor）</h3><ul>
<li>策略 1：其中一个节点一直往上标记父辈到根，然后另一个节点往上找父辈，直到找到首次被标记过的节点</li>
<li>策略 2：标记没个节点的深度，深度高的往上到同一层，然后一起一步步上去，直到是公共节点</li>
<li>策略 3：做一次 DFS 得到 Euler 序列，然后就变成找区间最小值问题了（可以使用线段树）</li>
<li>其他：倍增（记录 <code>fa[u][i]</code>：表示 <code>u</code> 的第$2^i$祖先），Tarjan 算法，动态树<br><a href="https://oi-wiki.org/graph/lca/" target="_blank" rel="noopener">OI-wiki</a> 给了很多做法，竟然有标准 $O(N)$ 时空复杂度的 RMQ 做法还支持在线，太强了，太强了，mark 一下，有模板，但是并不想学。以下是 <a href="https://cp-algorithms.com/graph/lca.html" target="_blank" rel="noopener">CP-algorithm</a> 中写好的类。$O(n)$ 预处理，单次查询 $O(\log n)$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCA</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">height</span>, euler, first, segtree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    LCA(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;adj, <span class="keyword">int</span> root = <span class="number">0</span>) &#123;</span><br><span class="line">        n = adj.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">height</span>.resize(n);</span><br><span class="line">        first.resize(n);</span><br><span class="line">        euler.reserve(n * <span class="number">2</span>);</span><br><span class="line">        visited.assign(n, <span class="literal">false</span>);</span><br><span class="line">        dfs(adj, root);</span><br><span class="line">        <span class="keyword">int</span> m = euler.<span class="built_in">size</span>();</span><br><span class="line">        segtree.resize(m * <span class="number">4</span>);</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">0</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;adj, <span class="keyword">int</span> node, <span class="keyword">int</span> h = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">height</span>[node] = h;</span><br><span class="line">        first[node] = euler.<span class="built_in">size</span>();</span><br><span class="line">        euler.push_back(node);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> to : adj[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[to]) &#123;</span><br><span class="line">                dfs(adj, to, h + <span class="number">1</span>);</span><br><span class="line">                euler.push_back(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == e) &#123;</span><br><span class="line">            segtree[node] = euler[b];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (b + e) / <span class="number">2</span>;</span><br><span class="line">            build(node &lt;&lt; <span class="number">1</span>, b, mid);</span><br><span class="line">            build(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, e);</span><br><span class="line">            <span class="keyword">int</span> l = segtree[node &lt;&lt; <span class="number">1</span>], r = segtree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">            segtree[node] = (<span class="built_in">height</span>[l] &lt; <span class="built_in">height</span>[r]) ? l : r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; R || e &lt; L)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= L &amp;&amp; e &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> segtree[node];</span><br><span class="line">        <span class="keyword">int</span> mid = (b + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = query(node &lt;&lt; <span class="number">1</span>, b, mid, L, R);</span><br><span class="line">        <span class="keyword">int</span> right = query(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, e, L, R);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">-1</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>[left] &lt; <span class="built_in">height</span>[right] ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = first[u], right = first[v];</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">            swap(left, right);</span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">1</span>, <span class="number">0</span>, euler.<span class="built_in">size</span>() - <span class="number">1</span>, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="有向图的拓扑排序之-Kahn-算法"><a href="#有向图的拓扑排序之-Kahn-算法" class="headerlink" title="有向图的拓扑排序之 Kahn 算法"></a><a href="https://oi-wiki.org/graph/topo/" target="_blank" rel="noopener">有向图的拓扑排序之 Kahn 算法</a></h3><p>给定有向图，然后把节点按照顺序排列，使得任意有向边的起点在终点前。</p>
<p>做法：维护一个入度为 0 的节点集合，一次删除节点（加入拓扑序列），删除的时候它连接的所有点入度减 1，为 0 就加入节点集合。</p>
<blockquote>
<p>一个有向图是无环图，当且仅当它存在拓扑排序。</p>
</blockquote>
<h3 id="笛卡尔树-：我去，竟然是-O-n-复杂度的建树"><a href="#笛卡尔树-：我去，竟然是-O-n-复杂度的建树" class="headerlink" title="笛卡尔树 ：我去，竟然是 $O(n)$ 复杂度的建树"></a><a href="https://oi-wiki.org/ds/cartesian-tree/" target="_blank" rel="noopener">笛卡尔树</a> ：我去，竟然是 $O(n)$ 复杂度的建树</h3><blockquote>
<p>从<a href="https://oi-wiki.org/ds/cartesian-tree/" target="_blank" rel="noopener">OI - wiki</a> 中看到的讲解和复杂度分析!，注意到右链是从尾巴往上查找的。<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506" target="_blank" rel="noopener"><strong>hdu 1506</strong></a><br>这就给出了一个 $O(n)$ 复杂度求出包含 <code>i</code>且以 <code>a[i]</code> 为最大值的区间的方法（最小值保存的时候取负数即可），太强了！<br>求上述对应的最大值区间，需要修改 0 节点的值，以及 build 的大于号改成小于号。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id, val, par, ch[<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _id, <span class="keyword">int</span> _val, <span class="keyword">int</span> _par)</span> </span>&#123;</span><br><span class="line">		id = _id, val = _val, par = _par, ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cartesian_build</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; &amp;tree, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (tree[k].val &lt; tree[i].val) k = tree[k].par;</span><br><span class="line">		tree[i].ch[<span class="number">0</span>] = tree[k].ch[<span class="number">1</span>];</span><br><span class="line">		tree[k].ch[<span class="number">1</span>] = i;</span><br><span class="line">		tree[i].par = k;</span><br><span class="line">		tree[tree[i].ch[<span class="number">0</span>]].par = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree[<span class="number">0</span>].ch[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; <span class="title">tree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">		tree[<span class="number">0</span>].init(<span class="number">0</span>, INT_MAX, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			tree[i].init(i, x, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> root = cartesian_build(tree, n);</span><br><span class="line">		LL ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> sz = dfs(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">			sz += dfs(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">			ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, LL(sz + <span class="number">1</span>) * tree[x].val);</span><br><span class="line">			<span class="keyword">return</span> sz + <span class="number">1</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		dfs(root);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 下面是求以 a[i] 为最大值且包含 i 的最大区间</span></span><br><span class="line">		std::vector&lt;int&gt; l(n + 1), r(n + 1);</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; getinterval = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (tree[tree[x].par].ch[<span class="number">0</span>] == x) &#123;</span><br><span class="line">				r[x] = tree[x].par - <span class="number">1</span>;</span><br><span class="line">				l[x] = l[tree[x].par];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l[x] = tree[x].par + <span class="number">1</span>;</span><br><span class="line">				r[x] = r[tree[x].par];</span><br><span class="line">			&#125;</span><br><span class="line">			getinterval(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">			getinterval(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">		&#125;;</span><br><span class="line">		l[root] = <span class="number">1</span>;</span><br><span class="line">		r[root] = n;</span><br><span class="line">		getinterval(tree[root].ch[<span class="number">0</span>]);</span><br><span class="line">		getinterval(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">		<span class="comment">// 要考虑有相同值的情形，必须要分两次搞，不然有bug</span></span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; updateinterval = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (tree[tree[x].par].ch[<span class="number">0</span>] == x) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tree[x].val == tree[tree[x].par].val) r[x] = r[tree[x].par];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (tree[x].val == tree[tree[x].par].val) l[x] = l[tree[x].par];</span><br><span class="line">			&#125;</span><br><span class="line">			updateinterval(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">			updateinterval(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">		&#125;;</span><br><span class="line">		updateinterval(tree[root].ch[<span class="number">0</span>]);</span><br><span class="line">		updateinterval(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; l[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; r[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>洛谷 T126268 「SWTR-05」Subsequence 有一个典型的应用</p>
</blockquote>
<h3 id="最小生成树-prim-算法"><a href="#最小生成树-prim-算法" class="headerlink" title="最小生成树 prim 算法"></a>最小生成树 prim 算法</h3><p>任取一个节点，然后开始找相邻边中边最小的节点加入，然后继续。<a href="https://baike.baidu.com/item/Prim/10242166" target="_blank" rel="noopener">百度百科</a>里的图解一看就懂，怎么明确证明正确性呢？（在保证连通的前提下每次删除图中最大的边，不会影响最终结果，而我们每步得到的是当前节点构成的子图的最小生成树）当然了堆优化常规操作，另外不连通输出 <code>INT64_MAX</code>, 例题：<a href="https://www.luogu.com.cn/problem/P3366" target="_blank" rel="noopener">LOJ3366</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function">LL <span class="title">Prim</span><span class="params">(<span class="keyword">const</span> edge &amp;e)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">	Q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [w, u] = Q.top();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		++cnt;</span><br><span class="line">		r -= w;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : e[u]) <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">			Q.push(&#123;-c, v&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt == n ? r : INT64_MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小树形图的-O-nm-刘朱算法"><a href="#最小树形图的-O-nm-刘朱算法" class="headerlink" title="最小树形图的 $O(nm)$ 刘朱算法"></a>最小树形图的 $O(nm)$ <a href="https://www.luogu.com.cn/blog/i207M/shu-xing-tu-shu-liu-suan-fa-xue-xi-bi-ji-xie-ti-bao-gao-p4716-post" target="_blank" rel="noopener">刘朱算法</a></h3><ol>
<li>对每个点，找入边权值最小的边构成集合。</li>
<li>如果这些边构成有向环，缩点后进入 1，否则结束，找到了。</li>
</ol>
<p>例题：<a href="https://www.luogu.com.cn/problem/P4716" target="_blank" rel="noopener">LOJ4716</a></p>
<p><strong>问题变形</strong>：如果不指定根节点，那么可以建一个根节点，然后它和所有其它点连特别大的边即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Edge = <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function">LL <span class="title">LiuZhu</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; e, <span class="keyword">int</span> n, <span class="keyword">int</span> rt)</span> </span>&#123; <span class="comment">// e 中无自环</span></span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 寻找入边权值最小的边</span></span><br><span class="line">		std::vector&lt;int&gt; in(n, INT_MAX), pre(n, -1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [u, v, w] : e) <span class="keyword">if</span> (u != v &amp;&amp; in[v] &gt; w) &#123;</span><br><span class="line">			in[v] = w;</span><br><span class="line">			pre[v] = u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判定是否无解</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i != rt &amp;&amp; pre[i] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判定是否有环</span></span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		std::vector&lt;int&gt; vis(n, -1), id(n, -1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i != rt) &#123;</span><br><span class="line">			ans += in[i];</span><br><span class="line">			<span class="keyword">int</span> v = i;</span><br><span class="line">			<span class="comment">// 注意到可能出现 6 型的路径，所以两个指标很必要</span></span><br><span class="line">			<span class="keyword">while</span> (vis[v] != i &amp;&amp; id[v] == <span class="number">-1</span> &amp;&amp; v != rt) &#123;</span><br><span class="line">				vis[v] = i;</span><br><span class="line">				v = pre[v];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (id[v] == <span class="number">-1</span> &amp;&amp; v != rt) &#123;</span><br><span class="line">				<span class="keyword">int</span> u = v;</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					id[u] = cnt;</span><br><span class="line">					u = pre[u];</span><br><span class="line">				&#125; <span class="keyword">while</span> (u != v);</span><br><span class="line">				++cnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 更新节点和边，也可以重开一个 vector，然后 swap 一下</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (id[i] == <span class="number">-1</span>) id[i] = cnt++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v, w] : e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (id[u] != id[v]) w -= in[v];</span><br><span class="line">			u = id[u];</span><br><span class="line">			v = id[v];</span><br><span class="line">		&#125;</span><br><span class="line">		rt = id[rt];</span><br><span class="line">		n = cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路：堆优化-Dijkstra"><a href="#最短路：堆优化-Dijkstra" class="headerlink" title="最短路：堆优化 Dijkstra"></a>最短路：堆优化 Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> edge &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;LL, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">d</span><span class="params">(e.<span class="built_in">size</span>(), INT64_MAX)</span></span>;</span><br><span class="line">	d[s] = <span class="number">0</span>;</span><br><span class="line">	Q.push(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [du, u] = Q.top();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">if</span> (d[u] != -du) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : e[u]) <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">			d[v] = d[u] + w;</span><br><span class="line">			Q.emplace(-d[v], v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路：堆优化-Dijkstra-弃用"><a href="#最短路：堆优化-Dijkstra-弃用" class="headerlink" title="最短路：堆优化 Dijkstra (弃用)"></a>最短路：堆优化 Dijkstra (弃用)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> edge &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;LL, <span class="keyword">int</span>&gt;&gt; h;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">dist</span><span class="params">(e.<span class="built_in">size</span>(), INT64_MAX)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(e.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">	dist[s] = <span class="number">0</span>;</span><br><span class="line">	h.push(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!h.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [d, u] = h.top();</span><br><span class="line">		h.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		dist[u] = -d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : e[u]) h.emplace(d - w, v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-color"><a href="#2-color" class="headerlink" title="2-color"></a>2-color</h3><blockquote>
<p>仅用两种颜色给无向图染色，使得相邻节点不同色，每个连通块考虑即可，每个连通块要么是 2，要么是 0（判断依据有无奇圈）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// 图以 0 开始编号</span></span><br><span class="line"><span class="function">LL <span class="title">color2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">val</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> bfs = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		Q.push(x);</span><br><span class="line">		val[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (val[v]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (val[v] != -val[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					val[v] = -val[u];</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (val[i] == <span class="number">0</span>) &#123;</span><br><span class="line">		r = r * bfs(i) % M;</span><br><span class="line">		<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Chromatic-Polynomial"><a href="#The-Chromatic-Polynomial" class="headerlink" title="The Chromatic Polynomial"></a><a href="https://www.whitman.edu/mathematics/cgt_online/book/section05.09.html" target="_blank" rel="noopener">The Chromatic Polynomial</a></h3><blockquote>
<p>对于一般的 $n$-color 问题对应的 <a href="https://www.whitman.edu/mathematics/cgt_online/book/section05.09.html" target="_blank" rel="noopener">The Chromatic Polynomial</a> 可在书 <a href="https://www.whitman.edu/mathematics/cgt_online/book/" target="_blank" rel="noopener">Combinatorics and Graph Theory</a> 中找到。思想就是破圈和缩点的做法。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> BINT = boost::multiprecision::cpp_int;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chromaticPoly of a tree with n node</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">chromaticPoly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">r</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	BINT now&#123;n % <span class="number">2</span> == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		r[i + <span class="number">1</span>] = now;</span><br><span class="line">		now = -now * (n - <span class="number">1</span> - i) / (i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">colorConnect</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	std::vector&lt;bool&gt; v1(n), v2(n);</span><br><span class="line">	<span class="keyword">auto</span> r = chromaticPoly(n); <span class="comment">// 可以先预处理出来</span></span><br><span class="line">	<span class="keyword">auto</span> subtract = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; &amp;a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; b) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != b.<span class="built_in">size</span>(); ++i) a[i] -= b[i];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(<span class="number">0</span>);</span><br><span class="line">	v1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> enow = e;</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		v2[u] = <span class="number">1</span>;</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!v2[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v1[v]) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; ed;</span><br><span class="line">				<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, now = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">					<span class="keyword">if</span> (i != u &amp;&amp; i != v) &#123;</span><br><span class="line">						p[i] = now++;</span><br><span class="line">					&#125; <span class="keyword">else</span> p[i] = n - <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i != u &amp;&amp; i != v) &#123;</span><br><span class="line">					<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">auto</span> x : enow[i]) tmp.insert(p[x]);</span><br><span class="line">					ed.emplace_back(tmp);</span><br><span class="line">				&#125;</span><br><span class="line">				enow[u].erase(v);</span><br><span class="line">				enow[v].erase(u);</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> x : enow[u]) tmp.insert(p[x]);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> x : enow[v]) tmp.insert(p[x]);</span><br><span class="line">				ed.emplace_back(tmp);</span><br><span class="line">				subtract(r, colorConnect(ed));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				Q.push(v);</span><br><span class="line">				v1[v] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		e = enow;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">color</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> <span class="built_in">connect</span> = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visc(n);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		Q.push(x);</span><br><span class="line">		visc[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!visc[v]) &#123;</span><br><span class="line">				visc[v] = <span class="number">1</span>;</span><br><span class="line">				Q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, now = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (visc[i]) &#123;</span><br><span class="line">			p[i] = now++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; ec;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (visc[i]) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : e[i]) tmp.insert(p[x]);</span><br><span class="line">			ec.emplace_back(tmp);</span><br><span class="line">			vis[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ec;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> mul = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; &amp;a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; b) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; c(a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != b.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">				c[i + j] += a[i] * b[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">		r = mul(r, colorConnect(<span class="built_in">connect</span>(i)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">			<span class="keyword">int</span> u, v;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			--u; --v;</span><br><span class="line">			e[u].insert(v);</span><br><span class="line">			e[v].insert(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : color(e)) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kosaraju-算法缩点"><a href="#Kosaraju-算法缩点" class="headerlink" title="Kosaraju 算法缩点"></a>Kosaraju 算法缩点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Scc</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, nScc;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis, color, order;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; e, e2;</span><br><span class="line">	Scc(<span class="keyword">int</span> _n) : n(_n * <span class="number">2</span>) &#123;</span><br><span class="line">		nScc = <span class="number">0</span>;</span><br><span class="line">		e.resize(n);</span><br><span class="line">		e2.resize(n);</span><br><span class="line">		vis.resize(n);</span><br><span class="line">		color.resize(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e2[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!vis[v]) dfs(v);</span><br><span class="line">		order.emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		color[u] = nScc;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e2[u]) <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!vis[i]) dfs(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = order.rbegin(); it != order.rend(); ++it) <span class="keyword">if</span> (!color[*it]) &#123;</span><br><span class="line">			++nScc;</span><br><span class="line">			dfs2(*it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h3><p>Kosaraju 算法通过两次 dfs，给强连通分量进行染色，染色数就是强联通分量数，最后缩点后得到的就是一个有向无环图(DAG)，如果有相邻（仅取一个）节点在同一个强连通分量中，那么显然不存在解，否则我们取颜色编号大的连通分量（一定有解！）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n / 2 对 (2i, 2i + 1)，每对选出一个元素，使得无矛盾</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twoSAT</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, nScc;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis, color, order;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; e, e2;</span><br><span class="line">	twoSAT(<span class="keyword">int</span> _n) : n(_n * <span class="number">2</span>) &#123;</span><br><span class="line">		nScc = <span class="number">0</span>;</span><br><span class="line">		e.resize(n);</span><br><span class="line">		e2.resize(n);</span><br><span class="line">		vis.resize(n);</span><br><span class="line">		color.resize(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e2[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!vis[v]) dfs(v);</span><br><span class="line">		order.emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		color[u] = nScc;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e2[u]) <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!vis[i]) dfs(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = order.rbegin(); it != order.rend(); ++it) <span class="keyword">if</span> (!color[*it]) &#123;</span><br><span class="line">			++nScc;</span><br><span class="line">			dfs2(*it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Kosaraju();</span><br><span class="line">		<span class="comment">// 选择颜色编号大的强连通分量</span></span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">choose</span><span class="params">(nScc + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> c1 = color[i], c2 = color[i + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (c1 == c2) <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">			<span class="keyword">if</span> (choose[c1] || choose[c2]) <span class="keyword">continue</span>;</span><br><span class="line">			choose[<span class="built_in">std</span>::<span class="built_in">max</span>(c1, c2)] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(n / <span class="number">2</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * <span class="number">2</span> &lt; n; ++i) r[i] = (choose[color[i * <span class="number">2</span>]] ? <span class="number">1</span> : <span class="number">-1</span>); </span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此内容包含 <a href="https://oi-wiki.org/graph/scc/" target="_blank" rel="noopener">强连通分量</a>，采用其中的 Kosaraju 算法缩点。参考 <a href="https://oi-wiki.org/graph/2-sat/" target="_blank" rel="noopener">OI-wiki</a> 和 <a href="https://wenku.baidu.com/view/31fd7200bed5b9f3f90f1ce2.html" target="_blank" rel="noopener">百度文库</a>。<a href="https://codeforces.com/contest/1239/problem/D" target="_blank" rel="noopener">例题 1</a>：<a href="https://codeforces.com/contest/1239/submission/98425115" target="_blank" rel="noopener">答案</a>，<a href="https://codeforces.com/gym/101987" target="_blank" rel="noopener">例题 2: K-TV Show Game</a>：<a href="https://codeforces.com/gym/101987/submission/98427737" target="_blank" rel="noopener">答案</a>，有些特殊的 2-SAT 可以用奇偶性解决，例如: <a href="https://codeforces.com/contest/1438/problem/C" target="_blank" rel="noopener">1438C</a></p>
</blockquote>
<p><a href="https://oi-wiki.org/graph/cut/" target="_blank" rel="noopener">OI-wiki 割点割边讲解</a></p>
<h3 id="割点（无向图中删除该点使得连通分量数量增多的节点）"><a href="#割点（无向图中删除该点使得连通分量数量增多的节点）" class="headerlink" title="割点（无向图中删除该点使得连通分量数量增多的节点）"></a>割点（无向图中删除该点使得连通分量数量增多的节点）</h3><p>首先 dfs 序给出每个节点的编号记作 <code>dfs[i]</code>，再来一个数组 low，表示不经过父节点能够到达的编号最小的点。显然如果至少有一个儿子满足的 low 值不超过它的 dfs 值，那么此节点就是割点（但是根节点除外，根节点始终满足，如果根节点有大于一个真儿子，那么必然是割点）。不难看出这是割点的冲要条件，因此问题就转化成求 dfs 和 low 了。</p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/P3388" target="_blank" rel="noopener">LOJ3388</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cutVertex</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">	std::vector&lt;int&gt; dfs(n), low(n), flag(n), r;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; Tarjan = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		low[u] = dfs[u] = ++cnt;</span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dfs[v] == <span class="number">0</span>) &#123;</span><br><span class="line">				++ch;</span><br><span class="line">				Tarjan(v, u);</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">				<span class="keyword">if</span> (u != fa &amp;&amp; low[v] &gt;= dfs[u]) flag[u] = <span class="number">1</span>; </span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], dfs[v]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (u == fa &amp;&amp; ch &gt; <span class="number">1</span>) flag[u] = <span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (dfs[i] == <span class="number">0</span>) Tarjan(i, i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (flag[i]) r.emplace_back(i);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="割边（无向图中删除该边使得连通分量数量增多的边）"><a href="#割边（无向图中删除该边使得连通分量数量增多的边）" class="headerlink" title="割边（无向图中删除该边使得连通分量数量增多的边）"></a>割边（无向图中删除该边使得连通分量数量增多的边）</h3><p>与割点处理同理，只是不用特判根节点。注意到做一次 dfs 后，—<strong>不在 dfs 路径上的边不可能为割边</strong>！但是为了处理重边的情况，没办法只能用 vector 版链式前向星存边了。</p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/T103481" target="_blank" rel="noopener">LOJ T103481</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CutEdge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, cnt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e, flag, dfs, low;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> inEdgeNum)</span> </span>&#123;</span><br><span class="line">		low[u] = dfs[u] = ++cnt;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i];</span><br><span class="line">			<span class="keyword">if</span> (dfs[v] == <span class="number">0</span>) &#123;</span><br><span class="line">				Tarjan(v, i);</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">				<span class="keyword">if</span> (low[v] &gt; dfs[u]) flag[i] = flag[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((i ^ <span class="number">1</span>) != inEdgeNum) &#123;</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], dfs[v]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CutEdge(<span class="keyword">int</span> _n) : n(_n), g(_n), dfs(n), low(n), cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v);</span><br><span class="line">		flag.emplace_back(<span class="number">0</span>);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u);</span><br><span class="line">		flag.emplace_back(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (dfs[i] == <span class="number">0</span>) Tarjan(i, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : flag) r += x;</span><br><span class="line">		<span class="keyword">return</span> r / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="有向图-S-T-最大流-Dinic-算法-O-n-2-m-（对偶问题：S-T-最大流等于-S-T-最小割）"><a href="#有向图-S-T-最大流-Dinic-算法-O-n-2-m-（对偶问题：S-T-最大流等于-S-T-最小割）" class="headerlink" title="有向图 S-T 最大流 Dinic 算法 $O(n^2 m)$（对偶问题：S-T 最大流等于 S-T 最小割）"></a>有向图 S-T 最大流 Dinic 算法 $O(n^2 m)$（对偶问题：S-T 最大流等于 S-T 最小割）</h3><p>参考资料：<a href="https://oi-wiki.org/graph/flow/max-flow/" target="_blank" rel="noopener">OI-wiki</a> 和 <a href="https://www.cnblogs.com/owenyu/p/6852664.html" target="_blank" rel="noopener">最大流算法-ISAP</a>，<a href="https://blog.csdn.net/lym940928/article/details/90209172?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">需要反向边的原因的例子说明</a>，下面代码借鉴于 jiangly。注意代码本质上是支持动态更新的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur, h;</span><br><span class="line">	<span class="comment">// h[i] 表示 bfs 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路。</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		h.assign(n, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		h[s] = <span class="number">0</span>;</span><br><span class="line">		Q.push(s);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">					h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] != <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// f 表示从 u 点出发拥有的最大流量，输出的是 u 到 t 的最大流量</span></span><br><span class="line">	<span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, LL f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t || f == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">		LL r = f;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i &lt; g[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = g[u][i];</span><br><span class="line">			<span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">			<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> a = dfs(v, t, <span class="built_in">std</span>::<span class="built_in">min</span>(r, LL(c)));</span><br><span class="line">				e[j].second -= a;</span><br><span class="line">				e[j ^ <span class="number">1</span>].second += a;</span><br><span class="line">				r -= a;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f - r;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dinic(<span class="keyword">int</span> _n) : n(_n), g(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (bfs(s, t)) &#123;</span><br><span class="line">			cur.assign(n, <span class="number">0</span>);</span><br><span class="line">			r += dfs(s, t, INT64_MAX);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用-unordered-map-直接存边的-Dinic-算法（注意结果是否超-int）"><a href="#使用-unordered-map-直接存边的-Dinic-算法（注意结果是否超-int）" class="headerlink" title="使用 unordered_map 直接存边的 Dinic 算法（注意结果是否超 int）"></a>使用 unordered_map 直接存边的 Dinic 算法（注意结果是否超 int）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator&gt; cur;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">	<span class="comment">// h[i] 表示 bfs 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路。</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		h.assign(n, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		h[s] = <span class="number">0</span>;</span><br><span class="line">		Q.push(s);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : g[u]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">					h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] != <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// f 表示从 u 点出发拥有的最大流量，输出的是 u 到 t 的最大流量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t || f == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">		<span class="keyword">int</span> r = f;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it = cur[u]; it != g[u].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = it-&gt;first;</span><br><span class="line">			<span class="keyword">if</span> (it-&gt;second &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> a = dfs(v, t, <span class="built_in">std</span>::<span class="built_in">min</span>(r, it-&gt;second));</span><br><span class="line">				it-&gt;second -= a;</span><br><span class="line">				g[v][u] += a;</span><br><span class="line">				r -= a;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f - r;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dinic(<span class="keyword">int</span> _n) : n(_n), g(n), cur(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 注意这里一定要这样！</span></span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u][v] += c; </span><br><span class="line">		g[v][u] += <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (bfs(s, t)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cur[i] = g[i].<span class="built_in">begin</span>();</span><br><span class="line">			r += dfs(s, t, INT_MAX);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="有向图-S-T-最大流-ISAP-算法-弃用"><a href="#有向图-S-T-最大流-ISAP-算法-弃用" class="headerlink" title="有向图 S-T 最大流 ISAP 算法 (弃用)"></a>有向图 S-T 最大流 ISAP 算法 (弃用)</h3><p>核心就是一句话，Dinic 算法中，每一轮需要进行一次 BFS，可以被优化，并且还有许多细节上的优化。</p>
<blockquote>
<p>折腾了半天发现并没有比 Dinic 快，本质原因是计算 dfs 完之后更新 <code>d</code>，按照上面的做法会极大的增加 <code>aug(s, INT_MAX)</code> 次数。但是确实比 <a href="https://codeforces.com/contest/1473/submission/104862713" target="_blank" rel="noopener">直接更新 d</a> 更快（可能时因为直接更新高度代码会写的很绕，因为可能变换的高度不止自己一个，父节点的高度也可能要更新），而在下面 HLPP 中用这这技巧又会特别慢，可惜~</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结合 https://www.cnblogs.com/owenyu/p/6852664.html 在实现上进行了相应的修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISAP</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, s, t;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="comment">// cur[u] 表示以 u 为起点当前没被增广过的边</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur, d, gap;</span><br><span class="line">	<span class="comment">// d[u] 表示残余网络中 从 u 到 t 的最短距离，注意到可以把 d[u] 理解成连续变化的（否则很难正确的更新 d)。</span></span><br><span class="line">	<span class="comment">// gap[x] 表示 d[u] = x 的节点个数, 用于优化</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span> </span>&#123;</span><br><span class="line">		s = _s;</span><br><span class="line">		t = <span class="keyword">_t</span>;</span><br><span class="line">		d.assign(n, n);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		d[t] = <span class="number">0</span>;</span><br><span class="line">		Q.push(t); </span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">int</span> v = e[i].first, c = e[i ^ <span class="number">1</span>].second;</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; d[v] == n) &#123;</span><br><span class="line">					d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		gap.assign(n + <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : d) ++gap[x];</span><br><span class="line">		cur.assign(n, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从 u 开始到汇点 t 不超过 f 的最大流，如果取到了 f 说明后面还有增广的可能</span></span><br><span class="line">	<span class="function">LL <span class="title">aug</span><span class="params">(<span class="keyword">int</span> u, LL f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t) <span class="keyword">return</span> f;</span><br><span class="line">		LL r = f;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i &lt; <span class="keyword">int</span>(g[u].<span class="built_in">size</span>()); ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = g[u][i];</span><br><span class="line">			<span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">			<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; d[u] == d[v] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> a = aug(v, <span class="built_in">std</span>::<span class="built_in">min</span>(r, LL(c)));</span><br><span class="line">				e[j].second -= a;</span><br><span class="line">				e[j ^ <span class="number">1</span>].second += a;</span><br><span class="line">				r -= a;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cur[u] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (--gap[d[u]] == <span class="number">0</span>) d[s] = n;</span><br><span class="line">		++gap[++d[u]];</span><br><span class="line">		<span class="keyword">return</span> f - r;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ISAP(<span class="keyword">int</span> _n) : n(_n), g(_n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span> </span>&#123;</span><br><span class="line">		init(_s, <span class="keyword">_t</span>);</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (d[s] &lt; n) r += aug(s, INT64_MAX);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="有向图-S-T-最大流的最高标号预流推进算法（HLPP）-O-n-2-sqrt-m-算法"><a href="#有向图-S-T-最大流的最高标号预流推进算法（HLPP）-O-n-2-sqrt-m-算法" class="headerlink" title="有向图 S-T 最大流的最高标号预流推进算法（HLPP） $O(n^2 \sqrt{m})$ 算法"></a>有向图 S-T 最大流的最高标号预流推进算法（HLPP） $O(n^2 \sqrt{m})$ 算法</h3><p>1988 年 <a href="https://www.cs.princeton.edu/courses/archive/fall07/cos521/handouts/p921-goldberg.pdf" target="_blank" rel="noopener">Tarjan, Goldberg</a> 提出次方法，1989 年 <a href="https://www.sciencedirect.com/science/article/pii/S0020019099000198" target="_blank" rel="noopener">Joseph Cheriyan, Kurt Mehlhorn</a> 证明了该方法时间复杂度为 $O(n^2 \sqrt{m})$，直接看 <a href="https://oi-wiki.org/graph/flow/max-flow/" target="_blank" rel="noopener">OI-wiki</a> 最后一张图（下载下来放大）还是很好理解的，Push-Relabel 那段没讲清楚，跳过的看就行，再结合 <a href="(https://www.cnblogs.com/owenyu/p/6858123.html">cnblog</a>) 理解一下优化（不要看代码）就掌握了。然后自己写代码即可。</p>
<p>个人理解其实此算法 ISAP 的优化，Dinic 和 ISAP 都要递归找可行流，但是此算法，先给了再说，多了的再取出来即可，这样不用递归了。</p>
<p>模板例题：<a href="https://vjudge.net/problem/LibreOJ-127" target="_blank" rel="noopener">LibreOJ-127</a>，跑的太慢，有待提升。</p>
<p>注意到每次推流的时候，当前节点时有水的（且高度小于 n 的，高度为 n 说明水是积水）里面高度最高的，因此更新高度的时候就不会出现问题！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HLPP</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; ex;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFlow</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		ex[e[i ^ <span class="number">1</span>].first] -= a;</span><br><span class="line">		ex[e[i].first] += a;</span><br><span class="line">		e[i].second -= a;</span><br><span class="line">		e[i ^ <span class="number">1</span>].second += a;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 首先初始化 u 到 t 的距离得到 d[u]</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		Q.push(t);</span><br><span class="line">		h[t] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">int</span> v = e[i].first;</span><br><span class="line">				<span class="keyword">if</span> (e[i ^ <span class="number">1</span>].second &gt; <span class="number">0</span> &amp;&amp; h[v] == n) &#123;</span><br><span class="line">					h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] == n;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	HLPP(<span class="keyword">int</span> _n) : n(_n), ex(n), h(n, n), g(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (init(s, t)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		std::vector&lt;int&gt; gap(n + 1, 0), vis(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : h) ++gap[x];</span><br><span class="line">		<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">		<span class="comment">// push 之后 ex[u] 还大于 0 就说明当前超载了，需要提升高度</span></span><br><span class="line">		<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ex[u] == <span class="number">0</span> || h[u] == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">				<span class="comment">// 注意 push(s) 的时候不用管高度的问题</span></span><br><span class="line">				<span class="keyword">if</span> (c == <span class="number">0</span> || (h[u] != h[v] + <span class="number">1</span> &amp;&amp; u != s)) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">int</span> a = <span class="built_in">std</span>::<span class="built_in">min</span>(ex[u], LL(c));</span><br><span class="line">				addFlow(i, a);</span><br><span class="line">				<span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">					pq.push(&#123;h[v], v&#125;);</span><br><span class="line">					vis[v] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (ex[u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		ex[s] = INT64_MAX;</span><br><span class="line">		push(s);</span><br><span class="line">		h[s] = n;</span><br><span class="line">		vis[s] = vis[t] = <span class="number">1</span>; <span class="comment">// 起点和终点不会丢进队列中</span></span><br><span class="line">		<span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = pq.top().second;</span><br><span class="line">			pq.pop();</span><br><span class="line">			vis[u] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (push(u)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (--gap[h[u]] == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (h[i] &gt; h[u]) h[i] = n;</span><br><span class="line">				&#125;</span><br><span class="line">				h[u] = n - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">					<span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">					<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[u] &gt; h[v]) h[u] = h[v];</span><br><span class="line">				&#125;</span><br><span class="line">				++gap[++h[u]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ex[t];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="无向图全局最小割-Stoer-Wagner-算法"><a href="#无向图全局最小割-Stoer-Wagner-算法" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法"></a><a href="https://www.cs.dartmouth.edu/~ac/Teach/CS105-Winter05/Handouts/stoerwagner-mincut.pdf" target="_blank" rel="noopener">无向图全局最小割 Stoer-Wagner 算法</a></h3><p>无向图的 S-T 最小割可以通过 S-T 最大流来做（在 addEdge(u, v, c) 中两个边的权值都是 c 即可！）。<br>对任意给定的 S 和 T，全局最小割必然是 S-T 最小割或者 S-T 结合成一个节点后得到新图的最小割。Stoer-Wagner 的论文给了一种简单的方式给出某两个点的 S-T 最小割的办法，那么这个最小割的答案存下来，之后再合并这两个点再继续搞即可。而这个方式叫做 cut-of-the-phase，具体说就是，任取一个点，然后每次往这个点中丢 most tightly connected 点，论文中证明了这种方式得到的图，每一步都是最后两个节点的当前图最小割，所以所有点丢进来之后，最后两个节点的割就是原图的这个两个点的最小割。（直接图原论文很好理解，而且有例子说明）</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P5632" target="_blank" rel="noopener">LOJ5632</a></p>
<h3 id="无向图全局最小割-Stoer-Wagner-算法，邻接矩阵-O-n-3-实现"><a href="#无向图全局最小割-Stoer-Wagner-算法，邻接矩阵-O-n-3-实现" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法，邻接矩阵 $O(n^3)$ 实现"></a>无向图全局最小割 Stoer-Wagner 算法，邻接矩阵 $O(n^3)$ 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 做完 minCut 之后原图就毁了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoerWagner</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; del;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		del[s] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			g[i][t] = (g[t][i] += g[s][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StoerWagner(<span class="keyword">int</span> _n) : n(_n), del(n), g(n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n)) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u][v] += c;</span><br><span class="line">		g[v][u] += c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> cnt, <span class="keyword">int</span> &amp;s, <span class="keyword">int</span> &amp;t) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis(n), d(n);</span><br><span class="line">			<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">				vis[x] = <span class="number">1</span>;</span><br><span class="line">				d[x] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!del[i] &amp;&amp; !vis[i]) d[i] += g[x][i];</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">				push(t);</span><br><span class="line">				s = t;</span><br><span class="line">				t = <span class="built_in">std</span>::max_element(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>()) - d.<span class="built_in">begin</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> d[t];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, r = INT_MAX;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">			r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, f(i, s, t));</span><br><span class="line">			merge(s, t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r == INT_MAX ? <span class="number">0</span> : r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="无向图全局最小割-Stoer-Wagner-算法，邻接-unorded-map-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法）"><a href="#无向图全局最小割-Stoer-Wagner-算法，邻接-unorded-map-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法）" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法，邻接 unorded_map + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法）"></a>无向图全局最小割 Stoer-Wagner 算法，邻接 unorded_map + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 做完 minCut 之后原图就毁了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoerWagner</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d, del;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;s, <span class="keyword">int</span> &amp;t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (g[s].<span class="built_in">size</span>() &gt; g[t].<span class="built_in">size</span>()) <span class="built_in">std</span>::swap(s, t);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [x, c] : g[s]) &#123;</span><br><span class="line">			g[x][t] = (g[t][x] += c);</span><br><span class="line">			g[x].erase(s);</span><br><span class="line">		&#125;</span><br><span class="line">		g.erase(s);</span><br><span class="line">		g[t].erase(t);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StoerWagner(<span class="keyword">int</span> _n) : n(_n), d(n), del(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u][v] += c;</span><br><span class="line">		g[v][u] += c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> &amp;s, <span class="keyword">int</span> &amp;t) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">fill</span>(del.<span class="built_in">begin</span>(), del.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> [i, c] : g[x]) <span class="keyword">if</span> (!del[i]) &#123;</span><br><span class="line">					Q.push(&#123;d[i] += c, i&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">				del[x] = <span class="number">1</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				push(t);</span><br><span class="line">				s = t;</span><br><span class="line">				<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">					t = Q.top().second;</span><br><span class="line">					<span class="keyword">if</span> (!del[t]) <span class="keyword">break</span>;</span><br><span class="line">					Q.pop();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> d[t];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, r = INT_MAX;</span><br><span class="line">		<span class="keyword">while</span>(--n) &#123;</span><br><span class="line">			r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, f(s, t));</span><br><span class="line">			merge(s, t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r == INT_MAX ? <span class="number">0</span> : r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="无向图全局最小割-Stoer-Wagner-算法，邻接表-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法还是-TLE-属实可惜）"><a href="#无向图全局最小割-Stoer-Wagner-算法，邻接表-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法还是-TLE-属实可惜）" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法，邻接表 + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法还是 TLE 属实可惜）"></a>无向图全局最小割 Stoer-Wagner 算法，邻接表 + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法还是 TLE 属实可惜）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Edge = <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function">LL <span class="title">StoerWagner</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; e, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;]() -&gt; <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">		std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; in(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [u, v, w] : e) <span class="keyword">if</span> (u != v) in[v].emplace_back(u, w);</span><br><span class="line">		std::vector&lt;int&gt; del(n), d(n);</span><br><span class="line">		<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [i, c] : in[x]) <span class="keyword">if</span> (!del[i]) &#123;</span><br><span class="line">				Q.push(&#123;d[i] += c, i&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			del[x] = <span class="number">1</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> s, t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			push(t);</span><br><span class="line">			s = t;</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Q.empty()) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!del[i]) Q.push(&#123;d[i], i&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">				t = Q.top().second;</span><br><span class="line">				Q.pop();</span><br><span class="line">				<span class="keyword">if</span> (!del[t]) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &#123;d[t], s, t&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, r = INT_MAX;</span><br><span class="line">	<span class="keyword">while</span>(n &gt; <span class="number">1</span> &amp;&amp; r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [dt, s, t] = f();</span><br><span class="line">		r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, dt);</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">id</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i != s &amp;&amp; i != t) id[i] = ++cnt;</span><br><span class="line">		id[s] = id[t] = ++cnt;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v, w] : e) &#123;</span><br><span class="line">			u = id[u];</span><br><span class="line">			v = id[v];</span><br><span class="line">		&#125;</span><br><span class="line">		--n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r == INT_MAX ? <span class="number">0</span> : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h3><p>在最大流的前提下，追求费用最小。一般通用的做法：每次找一条费用最小的可行流。<br>反向边的费用是原边的相反数，这样就会出现负边，但是因此初始反向边容量为 0，所以初始情况可以理解为图中没有负边。从源点到汇点的费用必然是非负的（因为我们每次走最小费用，所以每次的费用都是非降的，而初始没有负边。）当然这并不代表途中没有经过负边。至于为什么可以用 Dijkstra，很多博客都有介绍。下面代码中 h 为真实的距离，注意到 <code>h[s]</code>始终为 0，对于同一个点，每次的真实距离不减，它将作为下一次求最短路的势。</p>
<p>我们这样再看一次：每次我们找一条最短路径，取流了之后，相当于给这条路径加了反向边，其它的都没有变化，如果我们把当前距离当作势，那么加的这些反向边，其实都可以看作加入了长度为 0 的边。那么我们一直这样搞，就相当于一直没有加入负边！搞定。</p>
<p>由于一般费用最小的路径只有一条，所以我们不妨在求最小费用的时候把前缀边找到，这样就可以直接求路径的最大流了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flow</span> &#123;</span></span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h, path;</span><br><span class="line">	<span class="comment">// h[i] 表示 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路，作为下一次求距离的势。</span></span><br><span class="line">	<span class="comment">// path[v] 表示从 s 到 v 的最短路中，path[v] 的终点指向 v</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">fill</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n, INF)</span></span>;</span><br><span class="line">		d[s] = <span class="number">0</span>;</span><br><span class="line">		Q.push(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> [du, u] = Q.top();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">if</span> (d[u] != -du) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> [v, c, w] = e[i];</span><br><span class="line">				w += h[u] - h[v];</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; d[v] &gt; d[u] + w) &#123;</span><br><span class="line">					d[v] = d[u] + w;</span><br><span class="line">					path[v] = i;</span><br><span class="line">					Q.push(&#123;-d[v], v&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((h[i] += d[i]) &gt; INF) h[i] = INF;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] != INF;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Flow(<span class="keyword">int</span> _n) : n(_n), h(n), path(n), g(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c, w);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>, -w);</span><br><span class="line">	&#125;</span><br><span class="line">	std::pair&lt;LL, LL&gt; maxFlow(int s, int t) &#123;</span><br><span class="line">		LL flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (Dijkstra(s, t)) &#123;</span><br><span class="line">			<span class="keyword">int</span> f = INT_MAX, now = t;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">			<span class="keyword">while</span> (now != s) &#123;</span><br><span class="line">				r.emplace_back(path[now]);</span><br><span class="line">				f = <span class="built_in">std</span>::<span class="built_in">min</span>(f, <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(e[path[now]]));</span><br><span class="line">				now = <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(e[path[now] ^ <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : r) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(e[i]) -= f;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(e[i ^ <span class="number">1</span>]) += f;</span><br><span class="line">			&#125;</span><br><span class="line">			flow += f;</span><br><span class="line">			cost += LL(f) * h[t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &#123;flow, cost&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二维凸包正式版"><a href="#二维凸包正式版" class="headerlink" title="二维凸包正式版"></a>二维凸包正式版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> pdd = <span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLeft</span><span class="params">(<span class="keyword">const</span> pii &amp;op, <span class="keyword">const</span> pii &amp;sp, <span class="keyword">const</span> pii &amp;ep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (sp.first - op.first) * (ep.second - op.second) </span><br><span class="line">	&lt; (sp.second - op.second) * (ep.first - op.first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pdd&gt; <span class="title">convexHull</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pdd&gt; p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">	p.erase(<span class="built_in">std</span>::unique(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()), p.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pdd&gt; <span class="title">q</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; crossLeft(q[top - <span class="number">1</span>], p[i], q[top - <span class="number">2</span>])) --top;</span><br><span class="line">		q[top++] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = top;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top &gt; len &amp;&amp; crossLeft(q[top - <span class="number">1</span>], p[i], q[top - <span class="number">2</span>])) --top;</span><br><span class="line">		q[top++] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	top -= n &gt; <span class="number">1</span>;</span><br><span class="line">	q.resize(top);</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三维凸包模板可以参考 上交模板</p>
</blockquote>
<h3 id="二维凸包（弃用版）"><a href="#二维凸包（弃用版）" class="headerlink" title="二维凸包（弃用版）"></a>二维凸包（弃用版）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">int</span> vc[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y, id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Node &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x != A.x || y != A.y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (y == A.y) <span class="keyword">return</span> x &lt; A.x;</span><br><span class="line">		<span class="keyword">return</span> y &lt; A.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p[N], q[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLeft</span><span class="params">(<span class="keyword">const</span> Node &amp; op,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> Node &amp; sp,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> Node &amp; ep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (sp.x - op.x) * (ep.y - op.y) &gt; (sp.y - op.y) * (ep.x - op.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">graham</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	sort(p, p + n);</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>] = p[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	q[<span class="number">1</span>] = p[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	q[<span class="number">2</span>] = p[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i != n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top &amp;&amp; crossLeft(q[top], p[i], q[top - <span class="number">1</span>])) --top;</span><br><span class="line">		q[++top] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = top;</span><br><span class="line">	q[++top] = p[n - <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">3</span>; i != <span class="number">-1</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top != len &amp;&amp; crossLeft(q[top], p[i], q[top - <span class="number">1</span>])) --top;</span><br><span class="line">		q[++top] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="几类根号算法"><a href="#几类根号算法" class="headerlink" title="几类根号算法"></a>几类根号算法</h2><p>首先注意到 $\max \{x \mid \lfloor \frac{n}{x} \rfloor =  \lfloor \frac{n}{i} \rfloor \} =  \lfloor \frac{ n }{ \lfloor \frac{n}{i} \rfloor } \rfloor$</p>
<p><strong>Proof</strong>：由于 $x \cdot  \lfloor \frac{n}{x} \rfloor \leq n$ 所以 $x \leq \frac{n}{\lfloor \frac{n}{x} \rfloor}$，所以 $x \leq \lfloor \frac{n}{\lfloor \frac{n}{x} \rfloor} \rfloor$，所以取 $x = i$ 和 $x = \lfloor \frac{n}{i} \rfloor$，则 $\lfloor \frac{n}{\lfloor \frac{ n }{ \lfloor \frac{n}{i} \rfloor } \rfloor} \rfloor = \lfloor \frac{n}{i} \rfloor$，另一方面，若 $\lfloor \frac{n}{x} \rfloor =  \lfloor \frac{n}{i} \rfloor$, 则 $x \leq \lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor$，证毕。</p>
<h3 id="s-n-sum-i-1-n-lfloor-frac-n-i-rfloor"><a href="#s-n-sum-i-1-n-lfloor-frac-n-i-rfloor" class="headerlink" title="$ s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $"></a>$ s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	LL sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		sum += LL(j - i + <span class="number">1</span>) * (n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i"><a href="#sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i" class="headerlink" title="$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$"></a>$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// g[i]=f[i]+g[i-1]</span></span><br><span class="line">	LL sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= <span class="built_in">min</span>(n, m); i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = <span class="built_in">min</span>(n / (n / i), m / (m / i);</span><br><span class="line">		sum += LL(n / i) * (m / i) * (g[j] - g[i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题：<a href="https://ac.nowcoder.com/acm/contest/9005/C" target="_blank" rel="noopener">牛客</a>，大致题意是：$n=p \times k + m, 0 \leq m &lt; k$，求 $\sum_{p = 1}^n km$，注意到 $m = n - pk$，所以用上述公式计算即可。</p>
<h3 id="h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor"><a href="#h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor" class="headerlink" title="$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$"></a>$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	<span class="keyword">int</span> r = LL(n) * (n - <span class="number">1</span>) % M * (n - <span class="number">2</span>) % M * inv3 % M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= LL(j - i + <span class="number">1</span>) * getans(n / i) % M;</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>) r += M;</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归算法复杂度分析"><a href="#递归算法复杂度分析" class="headerlink" title="递归算法复杂度分析"></a>递归算法复杂度分析</h2><p>下图取自算法导论</p>
<p><img src= "/img/loading.gif" data-lazy-src="complexAnalysis.png" alt="complexAnalysis"></p>
<h2 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h2><h2 id="日常表白-zly"><a href="#日常表白-zly" class="headerlink" title="日常表白 zly"></a>日常表白 zly</h2></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">dna049</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dna049.com/templateOfCpp/">https://dna049.com/templateOfCpp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dna049.com" target="_blank">dna049</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/rewardAlipay.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/rewardAlipay.png" alt="下次"/></a><div class="post-qr-code-desc">下次</div></li><li class="reward-item"><a href="/img/rewardWechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/rewardWechat.png" alt="一定"/></a><div class="post-qr-code-desc">一定</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/codeStyle/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 代码规范</div></div></a></div><div class="next-post pull-right"><a href="/allTemplate/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">万能通用模板</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/heapWithPy/" title="堆"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-22</div><div class="relatedPosts_title">堆</div></div></a></div><div class="relatedPosts_item"><a href="/codeforces/" title="Codeforces 汇总"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-22</div><div class="relatedPosts_title">Codeforces 汇总</div></div></a></div><div class="relatedPosts_item"><a href="/codeStyle/" title="C++ 代码规范"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-18</div><div class="relatedPosts_title">C++ 代码规范</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"> <div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://hexo.io/" target="_blank" title="由 Hexo 强力驱动" data-pjax-state=""><span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://github.com/chachabai/hexo-theme-butterfly" target="_blank" title="主题" data-pjax-state=""><span class="badge-subject">Theme</span><span class="badge-value bg-blueviolet">Butterfly</span></a></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://github.com/" target="_blank" title="静态网页托管于 GitHub Pages 和 Coding Pages" data-pjax-state=""><span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen">GitHub</span></a></div><div class="footer_custom_text"></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="/" target="_blank" title="运行时间" data-pjax-state=""><span class="badge-subject">Since</span><span class="badge-value bg-orange">2015</span></a></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="/" target="_blank" title="本人博客" data-pjax-state=""><span class="badge-subject">Author</span><span class="badge-value bg-gradient">dna049</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'chachabai/chachabai.github.io')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  if (document.querySelector('.utterances-frame')) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    const iframe = document.querySelector('.utterances-frame');
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !false) {
  if (false) loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN@latest/js/fish.js"></script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script></div></body></html>
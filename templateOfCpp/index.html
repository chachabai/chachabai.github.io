<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>dna049 的 C++ 模板 | dna049</title><meta name="description" content="此处只包含通用代码块，以下为其它内容：  C++ 代码规范 C++ 万能模板 C++ 图论模板（因为图论内容实在太多） C++ 字符串模板（内容相对独立） STL 和 C++17 学习记录   欢迎使用或转载代码块，唯一要求添加一行注释: https:&#x2F;&#x2F;dna049.com  编译器比你想象中的聪明，所以尽量写 编译器好优化 并且 易读 的代码，很多位运算，除法都是可以被优化的！优质的代码本身就"><meta name="keywords" content="C++"><meta name="author" content="dna049"><meta name="copyright" content="dna049"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/dna049.png"><link rel="canonical" href="https://dna049.com/templateOfCpp/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="dna049 的 C++ 模板"><meta property="og:url" content="https://dna049.com/templateOfCpp/"><meta property="og:site_name" content="dna049"><meta property="og:description" content="此处只包含通用代码块，以下为其它内容：  C++ 代码规范 C++ 万能模板 C++ 图论模板（因为图论内容实在太多） C++ 字符串模板（内容相对独立） STL 和 C++17 学习记录   欢迎使用或转载代码块，唯一要求添加一行注释: https:&#x2F;&#x2F;dna049.com  编译器比你想象中的聪明，所以尽量写 编译器好优化 并且 易读 的代码，很多位运算，除法都是可以被优化的！优质的代码本身就"><meta property="og:image" content="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><meta property="article:published_time" content="2020-07-17T17:20:02.000Z"><meta property="article:modified_time" content="2021-04-20T05:53:47.306Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = '2'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?79cbe4231606af28625413fd5210e0b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '4.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"18px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2021-04-20 13:53:47'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="dna049" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/dna049.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">85</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">23</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/templateOfCpp"><i class="fa-fw fas fa-heart"></i><span> C++模板</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-calendar"></i><span> 工具类网站</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#通用代码块"><span class="toc-number">1.</span> <span class="toc-text">通用代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#佛祖保佑，永无-bug"><span class="toc-number">1.1.</span> <span class="toc-text">佛祖保佑，永无 bug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VScode-下-debeg"><span class="toc-number">1.2.</span> <span class="toc-text">VScode 下 debeg</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归程序防止爆栈"><span class="toc-number">1.3.</span> <span class="toc-text">递归程序防止爆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-输入样例（以备不时之需，用-PyPy3-提交）"><span class="toc-number">1.4.</span> <span class="toc-text">Python 输入样例（以备不时之需，用 PyPy3 提交）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#产生-log-的几个原因"><span class="toc-number">1.5.</span> <span class="toc-text">产生 log 的几个原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#产生根号的几个原因"><span class="toc-number">1.6.</span> <span class="toc-text">产生根号的几个原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类中静态成员定义时初始化"><span class="toc-number">1.7.</span> <span class="toc-text">类中静态成员定义时初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitset-高端压位卡常"><span class="toc-number">1.8.</span> <span class="toc-text">bitset 高端压位卡常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-黑魔法：-n-2-过百万，编译器优化-指令集优化"><span class="toc-number">1.9.</span> <span class="toc-text">C++ 黑魔法：$n^2$ 过百万，编译器优化+指令集优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#莫队加速"><span class="toc-number">1.10.</span> <span class="toc-text">莫队加速</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算的关系"><span class="toc-number">1.11.</span> <span class="toc-text">位运算的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最大最小值分配律"><span class="toc-number">1.12.</span> <span class="toc-text">最大最小值分配律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最高位后面位取反-O-1"><span class="toc-number">1.13.</span> <span class="toc-text">最高位后面位取反 $O(1)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最低位-1-置-0-x-x-amp-x-1"><span class="toc-number">1.14.</span> <span class="toc-text">最低位 1 置 0: x &#x3D; x &amp; (x - 1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树状数组中使用的-lowbit-x-x-amp-x-得到-x-的最大-2-的幂次因子。"><span class="toc-number">1.15.</span> <span class="toc-text">树状数组中使用的 lowbit(x) &#x3D; x &amp; (-x) 得到 x 的最大 2 的幂次因子。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mask-位上暴力枚举"><span class="toc-number">1.16.</span> <span class="toc-text">mask 位上暴力枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gosper’s-Hack：n-个集合中选-k-个"><span class="toc-number">1.17.</span> <span class="toc-text">Gosper’s Hack：n 个集合中选 k 个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#"><span class="toc-number">1.18.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#水涨船高技巧"><span class="toc-number">1.19.</span> <span class="toc-text">水涨船高技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Meet-in-Middle-拆半搜索法"><span class="toc-number">1.20.</span> <span class="toc-text">Meet in Middle(拆半搜索法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Small-to-large（把小的合并到大的里面去）"><span class="toc-number">1.21.</span> <span class="toc-text">Small to large（把小的合并到大的里面去）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#倍增思想"><span class="toc-number">1.22.</span> <span class="toc-text">倍增思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int128-的使用"><span class="toc-number">1.23.</span> <span class="toc-text">int128 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#交互式题目模板"><span class="toc-number">1.24.</span> <span class="toc-text">交互式题目模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#负数下标技巧"><span class="toc-number">1.25.</span> <span class="toc-text">负数下标技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优雅的输出技巧"><span class="toc-number">1.26.</span> <span class="toc-text">优雅的输出技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模正数向下取整：-lfloor-frac-a-n-rfloor-和-模正数向下取整：-lceil-frac-a-n-rceil"><span class="toc-number">1.27.</span> <span class="toc-text">模正数向下取整：$\lfloor \frac{a}{n} \rfloor$ 和 模正数向下取整：$\lceil \frac{a}{n} \rceil$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floor-sum-displaystyle-sum-i-0-n-1-lfloor-frac-a-cdot-i-b-m-rfloor"><span class="toc-number">1.28.</span> <span class="toc-text">Floor_sum : $\displaystyle \sum_{i &#x3D; 0}^{n - 1} \lfloor \frac{a \cdot i + b}{m} \rfloor$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带取整的函数取最值的技巧"><span class="toc-number">1.29.</span> <span class="toc-text">带取整的函数取最值的技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释"><span class="toc-number">1.30.</span> <span class="toc-text">Barrent reduction 快速模，弃用，因为并不会变快… ：wiki 镜像解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出全排列"><span class="toc-number">1.31.</span> <span class="toc-text">输出全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出全排列的原理"><span class="toc-number">1.32.</span> <span class="toc-text">输出全排列的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初等数论"><span class="toc-number">2.</span> <span class="toc-text">初等数论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Greatest-Common-divisor"><span class="toc-number">2.1.</span> <span class="toc-text">Greatest Common divisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n"><span class="toc-number">2.2.</span> <span class="toc-text">Sum of least common multiple  $s_n &#x3D;  \sum_{i&#x3D;1} ^n lcm(i,n)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-lcm-i-j"><span class="toc-number">2.3.</span> <span class="toc-text">Double sum of least common multiple $ds_n &#x3D; \sum_{1 \leq i \leq j \leq n} lcm(i,j)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模乘法逆元"><span class="toc-number">2.4.</span> <span class="toc-text">模乘法逆元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速模乘法"><span class="toc-number">2.5.</span> <span class="toc-text">快速模乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阶乘、组合数、Lucas-定理"><span class="toc-number">2.6.</span> <span class="toc-text">阶乘、组合数、Lucas 定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用组合数公式"><span class="toc-number">2.7.</span> <span class="toc-text">常用组合数公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#乞丐版素数判断"><span class="toc-number">2.8.</span> <span class="toc-text">乞丐版素数判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-n-log-n-素数筛"><span class="toc-number">2.9.</span> <span class="toc-text">$O(n \log n)$ 素数筛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧拉线性素数筛（正式使用版）"><span class="toc-number">2.10.</span> <span class="toc-text">欧拉线性素数筛（正式使用版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧拉线性素数筛（弃用）"><span class="toc-number">2.11.</span> <span class="toc-text">欧拉线性素数筛（弃用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-1-（执行）时间复杂度判断一个数是否为素数"><span class="toc-number">2.12.</span> <span class="toc-text">$O(1)$ （执行）时间复杂度判断一个数是否为素数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大素数-Miller-Rabin-概率判别法-和-大整数的最-大-小-因子分解"><span class="toc-number">2.13.</span> <span class="toc-text">大素数 Miller-Rabin 概率判别法 和 大整数的最 大&#x2F;小 因子分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-n-最小素因子预处理"><span class="toc-number">2.14.</span> <span class="toc-text">$O(n)$ 最小素因子预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mobius-function"><span class="toc-number">2.15.</span> <span class="toc-text">Mobius function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mobius-function-前缀和"><span class="toc-number">2.16.</span> <span class="toc-text">Mobius function 前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Euler’s-totient-function"><span class="toc-number">2.17.</span> <span class="toc-text">Euler’s totient function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展-Euler-定理"><span class="toc-number">2.18.</span> <span class="toc-text">拓展 Euler 定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pi-x-函数"><span class="toc-number">2.19.</span> <span class="toc-text">$\pi(x)$ 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pi-x-函数计算的另一种做法"><span class="toc-number">2.20.</span> <span class="toc-text">$\pi(x)$ 函数计算的另一种做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求奇素数的一个原根"><span class="toc-number">2.21.</span> <span class="toc-text">求奇素数的一个原根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数论函数的-Dirichlet-乘积"><span class="toc-number">2.22.</span> <span class="toc-text">数论函数的 Dirichlet 乘积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">2.23.</span> <span class="toc-text">中国剩余定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#离散对数"><span class="toc-number">2.24.</span> <span class="toc-text">离散对数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模素数开根号"><span class="toc-number">2.25.</span> <span class="toc-text">模素数开根号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自然数方幂和-O-k-算法"><span class="toc-number">2.26.</span> <span class="toc-text">自然数方幂和 $O(k)$ 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自然数方幂和精确版"><span class="toc-number">2.27.</span> <span class="toc-text">自然数方幂和精确版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生成函数"><span class="toc-number">3.</span> <span class="toc-text">生成函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多项式取对数和指数"><span class="toc-number">3.1.</span> <span class="toc-text">多项式取对数和指数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NFT-正式可用版-last-updated-2020-7-9"><span class="toc-number">3.2.</span> <span class="toc-text">NFT 正式可用版(last updated: 2020&#x2F;7&#x2F;9)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#siyuan-的-FWT-模板-（弃用）"><span class="toc-number">3.3.</span> <span class="toc-text">siyuan 的 FWT 模板 （弃用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FMT-模板"><span class="toc-number">3.4.</span> <span class="toc-text">FMT 模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MEX"><span class="toc-number">3.5.</span> <span class="toc-text">MEX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#矩阵类"><span class="toc-number">3.6.</span> <span class="toc-text">矩阵类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gauss-消元法浮点版"><span class="toc-number">3.7.</span> <span class="toc-text">Gauss 消元法浮点版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gauss-消元法有限域版"><span class="toc-number">3.8.</span> <span class="toc-text">Gauss 消元法有限域版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#：例题"><span class="toc-number">3.9.</span> <span class="toc-text">线性规划单纯形法：例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#差分约束"><span class="toc-number">3.10.</span> <span class="toc-text">差分约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法"><span class="toc-number">3.11.</span> <span class="toc-text">求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-2"><span class="toc-number">4.</span> <span class="toc-text">博弈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">5.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并查集（Disjoint-Set-Union）"><span class="toc-number">5.1.</span> <span class="toc-text">并查集（Disjoint Set Union）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#离散化"><span class="toc-number">5.2.</span> <span class="toc-text">离散化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逆序数"><span class="toc-number">5.3.</span> <span class="toc-text">逆序数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树状数组（单点更新，从-1-到某个位置的最小值）"><span class="toc-number">5.4.</span> <span class="toc-text">树状数组（单点更新，从 1 到某个位置的最小值）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树状数组（单点更新，区间求和，编号从-1-开始）"><span class="toc-number">5.5.</span> <span class="toc-text">树状数组（单点更新，区间求和，编号从 1 开始）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树状数组（区间更新，区间求和，编号从-1-开始）"><span class="toc-number">5.6.</span> <span class="toc-text">树状数组（区间更新，区间求和，编号从 1 开始）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线段树（正式版）"><span class="toc-number">5.7.</span> <span class="toc-text">线段树（正式版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线段树-（弃用版）"><span class="toc-number">5.8.</span> <span class="toc-text">线段树 （弃用版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMQ-求区间最大值（弃用，RMQ-和-spfa-已经死了）"><span class="toc-number">5.9.</span> <span class="toc-text">RMQ 求区间最大值（弃用，RMQ 和 spfa 已经死了）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三分法简单版"><span class="toc-number">5.10.</span> <span class="toc-text">三分法简单版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准三分法用黄金分割的原因"><span class="toc-number">5.11.</span> <span class="toc-text">标准三分法用黄金分割的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三分法黄金分割版（可用版）"><span class="toc-number">5.12.</span> <span class="toc-text">三分法黄金分割版（可用版）)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#subarray（连续部分）-VS-subsequence（不要求连续部分）"><span class="toc-number">5.13.</span> <span class="toc-text">subarray（连续部分） VS subsequence（不要求连续部分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长（严格）递增子序列"><span class="toc-number">5.14.</span> <span class="toc-text">最长（严格）递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#背包"><span class="toc-number">5.15.</span> <span class="toc-text">背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆与-STL-优先队列"><span class="toc-number">5.16.</span> <span class="toc-text">堆与 STL 优先队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单调队列：解决滑动窗口问题（固定长度内的最值问题）"><span class="toc-number">5.17.</span> <span class="toc-text">单调队列：解决滑动窗口问题（固定长度内的最值问题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单调队列优化-DP"><span class="toc-number">5.18.</span> <span class="toc-text">单调队列优化 DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单调栈：形式更简单应用更广"><span class="toc-number">5.19.</span> <span class="toc-text">单调栈：形式更简单应用更广</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单调栈优化-DP"><span class="toc-number">5.20.</span> <span class="toc-text">单调栈优化 DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑树-red-black-tree"><span class="toc-number">5.21.</span> <span class="toc-text">红黑树 red-black tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几何"><span class="toc-number">6.</span> <span class="toc-text">几何</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二维凸包正式版"><span class="toc-number">6.1.</span> <span class="toc-text">二维凸包正式版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#旋转卡壳求凸包直径（即平面上点的最远欧式距离）"><span class="toc-number">6.2.</span> <span class="toc-text">旋转卡壳求凸包直径（即平面上点的最远欧式距离）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分治法求平面最短距离（任何距离都适用）"><span class="toc-number">6.3.</span> <span class="toc-text">分治法求平面最短距离（任何距离都适用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三维偏序之陈丹琪分治（仅支持离线查询，还是直接暴力好用-）"><span class="toc-number">6.4.</span> <span class="toc-text">三维偏序之陈丹琪分治（仅支持离线查询，还是直接暴力好用~）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k-维偏序（暴力-bitset-优化，分块时间换空间）-O-frac-k-n-2-w"><span class="toc-number">6.5.</span> <span class="toc-text">k 维偏序（暴力 bitset 优化，分块时间换空间） $O(\frac{k n^2}{w})$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几类根号算法（原来这个叫整除分块）"><span class="toc-number">7.</span> <span class="toc-text">几类根号算法（原来这个叫整除分块）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#s-n-sum-i-1-n-lfloor-frac-n-i-rfloor"><span class="toc-number">7.1.</span> <span class="toc-text">$ s(n) &#x3D; \sum_{i&#x3D;1}^{n} \lfloor \frac{n}{i} \rfloor $</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i"><span class="toc-number">7.2.</span> <span class="toc-text">$\sum_{i&#x3D;1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor"><span class="toc-number">7.3.</span> <span class="toc-text">$h(n) &#x3D; \frac{n(n-1)(n-2)}{3} - \sum_{i&#x3D;2}^n h(\lfloor \frac{n}{i} \rfloor)$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归算法复杂度分析"><span class="toc-number">8.</span> <span class="toc-text">递归算法复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#To-Be-Continue"><span class="toc-number">9.</span> <span class="toc-text">To Be Continue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日常表白-zly"><span class="toc-number">10.</span> <span class="toc-text">日常表白 zly</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">dna049</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/templateOfCpp"><i class="fa-fw fas fa-heart"></i><span> C++模板</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-calendar"></i><span> 工具类网站</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">dna049 的 C++ 模板</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-17T17:20:02.000Z" title="发表于 2020-07-18 01:20:02">2020-07-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-20T05:53:47.306Z" title="更新于 2021-04-20 13:53:47">2021-04-20</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>109分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>此处只包含通用代码块，以下为其它内容：</p>
<ul>
<li><a href="/codeStyle/" title="C++ 代码规范">C++ 代码规范</a></li>
<li><a href="/allTemplate/" title="C++ 万能模板">C++ 万能模板</a></li>
<li><a href="/graph/" title="C++ 图论模板">C++ 图论模板</a>（因为图论内容实在太多）</li>
<li><a href="/string/" title="C++ 字符串模板">C++ 字符串模板</a>（内容相对独立）</li>
<li><a href="/stl/" title="STL 和 C++17 学习记录">STL 和 C++17 学习记录</a>
</li>
</ul>
<p><strong>欢迎使用或转载代码块，唯一要求添加一行注释</strong>: <code>https://dna049.com</code></p>
<blockquote>
<p>编译器比你想象中的聪明，所以尽量写 <strong>编译器好优化</strong> 并且 <strong>易读</strong> 的代码，很多位运算，除法都是可以被优化的！<br>优质的代码本身就是一种解释，添加完全不必要的注释只会让人恶心<br>以后尽量使用 <code>vector</code> 而非数组，结合 <code>C++17</code> 特征，可以简化代码且便于编译器优化！<br>以前觉得 <code>main</code> 函数 <code>return 0</code> 只是标准写法，现在(2020/5/22)才知道能返回就能提前优雅的结束，并且可以判断是否正常结束！<br>全局变量数组元素自动默认初始化为 0，局部变量要加 <code>= {}</code> 才会初始化为 0</p>
</blockquote>
<a id="more"></a>
<p><strong>此篇代码不再更新，已经发现不少 bug</strong>。下面是代码存储位置（并不包含全部此篇内容）：</p>
<ul>
<li><a href="https://github.com/izlyforever/cf/blob/master/include/math.hpp" target="_blank" rel="noopener">数学</a></li>
<li><a href="https://github.com/izlyforever/cf/blob/master/include/graph.hpp" target="_blank" rel="noopener">图论</a></li>
<li><a href="https://github.com/izlyforever/cf/blob/master/include/string.hpp" target="_blank" rel="noopener">字符串</a></li>
<li><a href="https://github.com/izlyforever/cf/blob/master/include/dataStruct.hpp" target="_blank" rel="noopener">数据结构</a></li>
</ul>
<h2 id="通用代码块"><a href="#通用代码块" class="headerlink" title="通用代码块"></a>通用代码块</h2><p>竞赛入门书籍推荐：<a href="GuideToCompetitiveProgramming.pdf">GuideToCompetitiveProgramming</a></p>
<h3 id="佛祖保佑，永无-bug"><a href="#佛祖保佑，永无-bug" class="headerlink" title="佛祖保佑，永无 bug"></a>佛祖保佑，永无 bug</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="comment">// #define print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl </span></span><br><span class="line"><span class="comment">// #define println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">auto</span> start = <span class="built_in">std</span>::clock();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time used: "</span> &lt;&lt; (<span class="built_in">std</span>::clock() - start) &lt;&lt; <span class="string">"ms"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">------ Welcome to my blog: http://dna049.com ------</span></span><br><span class="line"><span class="comment">                   _ooOoo_</span></span><br><span class="line"><span class="comment">                  o8888888o</span></span><br><span class="line"><span class="comment">                  88" . "88</span></span><br><span class="line"><span class="comment">                  (| -_- |)</span></span><br><span class="line"><span class="comment">                  O\  =  /O</span></span><br><span class="line"><span class="comment">               ____/`---'\____</span></span><br><span class="line"><span class="comment">             .'  \\|     |//  `.</span></span><br><span class="line"><span class="comment">            /  \\|||  :  |||//  \</span></span><br><span class="line"><span class="comment">           /  _||||| -:- |||||-  \</span></span><br><span class="line"><span class="comment">           |   | \\\  -  /// |   |</span></span><br><span class="line"><span class="comment">           | \_|  ''\---/''  |   |</span></span><br><span class="line"><span class="comment">           \  .-\__  `-`  ___/-. /</span></span><br><span class="line"><span class="comment">         ___`. .'  /--.--\  `. . __</span></span><br><span class="line"><span class="comment">      ."" '&lt;  `.___\_&lt;|&gt;_/___.'  &gt;'"".</span></span><br><span class="line"><span class="comment">     | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span></span><br><span class="line"><span class="comment">     \  \ `-.   \_ __\ /__ _/   .-` /  /</span></span><br><span class="line"><span class="comment">======`-.____`-.___\_____/___.-`____.-'======</span></span><br><span class="line"><span class="comment">                   `=---='</span></span><br><span class="line"><span class="comment">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line"><span class="comment">            佛祖保佑       永无BUG</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐</span></span><br><span class="line"><span class="comment"> * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐</span></span><br><span class="line"><span class="comment"> * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘</span></span><br><span class="line"><span class="comment"> * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐</span></span><br><span class="line"><span class="comment"> * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │</span></span><br><span class="line"><span class="comment"> * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤</span></span><br><span class="line"><span class="comment"> * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │</span></span><br><span class="line"><span class="comment"> * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │</span></span><br><span class="line"><span class="comment"> * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter  │               │ 4 │ 5 │ 6 │   │</span></span><br><span class="line"><span class="comment"> * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤</span></span><br><span class="line"><span class="comment"> * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │</span></span><br><span class="line"><span class="comment"> * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││</span></span><br><span class="line"><span class="comment"> * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│</span></span><br><span class="line"><span class="comment"> * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="VScode-下-debeg"><a href="#VScode-下-debeg" class="headerlink" title="VScode 下 debeg"></a>VScode 下 debeg</h3><p>需要在默认生成的 task.json 中在 <code>&quot;args&quot;:</code> 下添加一行 <code>&quot;-std=c++17&quot;,</code> 不然要报 warning 很烦。另外要使用绝对路径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能使用相对路径 debug，也可能是设置问题</span></span><br><span class="line">freopen(<span class="string">"C:/Users/dna049/cf/in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure>
<h3 id="递归程序防止爆栈"><a href="#递归程序防止爆栈" class="headerlink" title="递归程序防止爆栈"></a>递归程序防止爆栈</h3><p>在 Windows 上，通常的方法是在 <strong>编译选项</strong> 中加入 <code>-Wl,--stack=1000000000</code><br>命令行中可以使用：<code>g++ -static -Wl,--stack=268435456 -O2 -std=c++17 -o main main.cpp</code><br>powerShell 中可以使用：<code>g++ -static (Tab 上的那个键)-Wl,--stack=268435456 -O2 -std=c++17 -o main main.cpp</code><br>在 Linux 上，通常的方法是在运行程序前 <strong>在终端内</strong> 执行 <code>ulimit -s unlimited</code> （WSL 下无法设置可惜）</p>
<h3 id="Python-输入样例（以备不时之需，用-PyPy3-提交）"><a href="#Python-输入样例（以备不时之需，用-PyPy3-提交）" class="headerlink" title="Python 输入样例（以备不时之需，用 PyPy3 提交）"></a>Python 输入样例（以备不时之需，用 PyPy3 提交）</h3><p>用 Python 过的一次大数题：<a href="https://codeforces.com/contest/490/submission/105550245" target="_blank" rel="noopener">490C</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多 case 输入</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(int(input())):</span><br><span class="line"><span class="comment"># 单行输入</span></span><br><span class="line">    n = int(input())</span><br><span class="line"><span class="comment"># 两个元素一行输入</span></span><br><span class="line">	a, b = map(int, input().split())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提前结束	</span></span><br><span class="line">exit()</span><br></pre></td></tr></table></figure>
<h3 id="产生-log-的几个原因"><a href="#产生-log-的几个原因" class="headerlink" title="产生 log 的几个原因"></a>产生 log 的几个原因</h3><ol>
<li>二分，三分</li>
<li>$1 + \frac{1}{2} + \cdots \frac{1}{n} \sim \log n$</li>
<li>树状数组，线段树</li>
<li>重链剖分</li>
<li>倍增</li>
</ol>
<h3 id="产生根号的几个原因"><a href="#产生根号的几个原因" class="headerlink" title="产生根号的几个原因"></a>产生根号的几个原因</h3><ol>
<li>朴素判断素数</li>
<li>$\lfloor \frac{n}{i} \rfloor$ 的值域是 $O(\sqrt{n})$ 的</li>
<li>网络流中 HLPP（没读过这篇复杂度分析的论文，不懂）</li>
<li>分块处理</li>
</ol>
<h3 id="类中静态成员定义时初始化"><a href="#类中静态成员定义时初始化" class="headerlink" title="类中静态成员定义时初始化"></a>类中静态成员定义时初始化</h3><p>在前面加 inline 即可，最后都加，否则在配合 STL 的时候就会链接出错，从而无法编译通过例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Flow</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	Flow(<span class="keyword">int</span> _n) : n(_n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		d.assign(n, INF);</span><br><span class="line">		<span class="keyword">return</span> INF;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Flow <span class="title">g</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g.test() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bitset-高端压位卡常"><a href="#bitset-高端压位卡常" class="headerlink" title="bitset 高端压位卡常"></a><a href="https://www.cnblogs.com/RabbitHu/p/bitset.html" target="_blank" rel="noopener">bitset 高端压位卡常</a></h3><p>典型应用，求传递闭包。</p>
<h3 id="C-黑魔法：-n-2-过百万，编译器优化-指令集优化"><a href="#C-黑魔法：-n-2-过百万，编译器优化-指令集优化" class="headerlink" title="C++ 黑魔法：$n^2$ 过百万，编译器优化+指令集优化"></a>C++ 黑魔法：$n^2$ 过百万，编译器优化+指令集优化</h3><p><a href="https://ouuan.github.io/post/n%E6%96%B9%E8%BF%87%E7%99%BE%E4%B8%87-%E6%9A%B4%E5%8A%9B%E7%A2%BE%E6%A0%87%E7%AE%97%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">博文</a> 和 <a href="extension://oikmahiipjniocckomdccmplodldodja/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fwavwing.site%2F2019%2F01%2F26%2F2019.1.25%2520trainingWeek%2Finstruction_set_elephant.pdf">ppt</a></p>
<p>但是实际上不需要这么麻烦，仅需在头部添加下面代码（codeforces 上支持）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast,no-stack-protector,unroll-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"sse,sse2,sse3,ssse3,sse4.1,sse4.2,abm,mmx,avx,avx2,popcnt,tune=native"</span>)</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<ul>
<li><a href="https://codeforces.com/contest/911/problem/G" target="_blank" rel="noopener">911G</a> 的<a href="https://codeforces.com/contest/911/submission/113144618" target="_blank" rel="noopener">提交</a></li>
<li><a href="https://codeforces.com/contest/1511/problem/G" target="_blank" rel="noopener">1151G</a> 的 <a href="https://codeforces.com/contest/1511/submission/112897863" target="_blank" rel="noopener">提交</a></li>
</ul>
<h3 id="莫队加速"><a href="#莫队加速" class="headerlink" title="莫队加速"></a><a href="https://oi-wiki.org/misc/mo-algo/" target="_blank" rel="noopener">莫队加速</a></h3><p>待补</p>
<h3 id="位运算的关系"><a href="#位运算的关系" class="headerlink" title="位运算的关系"></a>位运算的关系</h3><ul>
<li>异或 <code>1</code> 改变，异或 <code>0</code> 不变</li>
<li>某位异或位 0，表示此位相等，反之不等。</li>
<li>$a \oplus b = (a \mid b) \oplus (a \And b)$</li>
<li>$a \oplus b = (a \mid b) - (a \And b)$</li>
<li>$a + b = (a \mid b) + (a \And b)$</li>
<li>$a + b = (a \oplus b) + 2 (a \And b)$</li>
<li><code>(a &amp; b) | c = (a | b) &amp; (a | c)</code></li>
<li><code>(a | b) &amp; c = (a &amp; b) | (a &amp; c)</code></li>
<li><code>(a | b) ^ 1 = (a ^ 1) &amp; (b ^ 1)</code></li>
<li><code>(a &amp; b) ^ 1 = (a ^ 1) | (b ^ 1)</code></li>
<li><code>(a | b) ^ c</code> 和 <code>(a &amp; b) ^ c</code> 可以逐位转化，因此任何一个数 x 经过任意多次的<code>&amp;, |, ^</code> 运算最终都可以写成 <code>((x ^ a) &amp; b) | c</code>。</li>
</ul>
<h3 id="最大最小值分配律"><a href="#最大最小值分配律" class="headerlink" title="最大最小值分配律"></a>最大最小值分配律</h3><script type="math/tex; mode=display">
\begin{aligned}
\min(\max(x, a), b) = \max(\min(x, b), \min(a, b)) \\
\max(\min(x, a), b) = \min(\max(x, b), \max(a, b))
\end{aligned}</script><p>例题：<a href="https://atcoder.jp/contests/abc196/tasks/abc196_e" target="_blank" rel="noopener">Atcoder abc196E</a></p>
<h3 id="最高位后面位取反-O-1"><a href="#最高位后面位取反-O-1" class="headerlink" title="最高位后面位取反 $O(1)$"></a>最高位后面位取反 $O(1)$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverseBit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n ^ ((<span class="number">1</span> &lt;&lt; <span class="number">32</span> - __builtin_clz(n)) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最低位-1-置-0-x-x-amp-x-1"><a href="#最低位-1-置-0-x-x-amp-x-1" class="headerlink" title="最低位 1 置 0: x = x &amp; (x - 1)"></a>最低位 1 置 0: <code>x = x &amp; (x - 1)</code></h3><h3 id="树状数组中使用的-lowbit-x-x-amp-x-得到-x-的最大-2-的幂次因子。"><a href="#树状数组中使用的-lowbit-x-x-amp-x-得到-x-的最大-2-的幂次因子。" class="headerlink" title="树状数组中使用的 lowbit(x) = x &amp; (-x) 得到 x 的最大 2 的幂次因子。"></a>树状数组中使用的 <code>lowbit(x) = x &amp; (-x)</code> 得到 x 的最大 2 的幂次因子。</h3><h3 id="mask-位上暴力枚举"><a href="#mask-位上暴力枚举" class="headerlink" title="mask 位上暴力枚举"></a><a href="https://cp-algorithms.com/algebra/all-submasks.html" target="_blank" rel="noopener">mask 位上暴力枚举</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i = (i - <span class="number">1</span>) &amp; n) &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Gosper’s-Hack：n-个集合中选-k-个"><a href="#Gosper’s-Hack：n-个集合中选-k-个" class="headerlink" title="Gosper’s Hack：n 个集合中选 k 个"></a>Gosper’s Hack：n 个集合中选 k 个</h3><p>思路：想想怎么把 1011100 变成 110011</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GospersHack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cur = (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> limit = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">	<span class="keyword">while</span> (cur &lt; limit) &#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">		<span class="keyword">int</span> lb = cur &amp; -cur;</span><br><span class="line">		<span class="keyword">int</span> r = cur + lb;</span><br><span class="line">		cur = (((r ^ cur) &gt;&gt; <span class="number">2</span>) / lb) | r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a><a href="/dynamicProgramming/" title="动态规划">动态规划</a></h3><h3 id="水涨船高技巧"><a href="#水涨船高技巧" class="headerlink" title="水涨船高技巧"></a><a href="https://codeforces.com/blog/entry/58316" target="_blank" rel="noopener">水涨船高技巧</a></h3><p>把一个集合中所有元素加一个常数，可以不操作，加在水位线上即可。</p>
<h3 id="Meet-in-Middle-拆半搜索法"><a href="#Meet-in-Middle-拆半搜索法" class="headerlink" title="Meet in Middle(拆半搜索法)"></a>Meet in Middle(拆半搜索法)</h3><blockquote>
<p>类似于动态规划，是一种思想。特别适合处理指数复杂度。</p>
</blockquote>
<p>例题：<a href="https://atcoder.jp/contests/abc184/tasks/abc184_f" target="_blank" rel="noopener">AtCoder abc184F</a>，当然针对此题可以深搜剪枝法。</p>
<h3 id="Small-to-large（把小的合并到大的里面去）"><a href="#Small-to-large（把小的合并到大的里面去）" class="headerlink" title="Small to large（把小的合并到大的里面去）"></a>Small to large（把小的合并到大的里面去）</h3><p>例子：并查集（dus），map 的合并，树上启发式合并（dus on tree)，重链剖分。</p>
<p>例题：<a href="https://codeforces.com/contest/600/problem/E" target="_blank" rel="noopener">600E</a> 的 <a href="https://codeforces.com/blog/entry/21827" target="_blank" rel="noopener">题解</a></p>
<h3 id="倍增思想"><a href="#倍增思想" class="headerlink" title="倍增思想"></a>倍增思想</h3><p>例子：RMQ，LCA。</p>
<h3 id="int128-的使用"><a href="#int128-的使用" class="headerlink" title="int128 的使用"></a>int128 的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int128 <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	__int128 x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printS</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) printS(x / <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">		x = -x;</span><br><span class="line">	&#125;</span><br><span class="line">	printS(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	__int128 a = <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">print</span>(a * a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交互式题目模板"><a href="#交互式题目模板" class="headerlink" title="交互式题目模板"></a><a href="https://codeforces.com/blog/entry/45307" target="_blank" rel="noopener">交互式题目模板</a></h3><p><a href="https://codeforces.com/gym/101021/problem/1" target="_blank" rel="noopener">gym101021: Guess the Number</a><br>需要 <code>fflush(stdout);</code>（对于 <code>scanf/printf</code>） 或 <code>std:::cout &lt;&lt; std::flush</code> （对于 <code>std::cin/std::cout</code>） 来刷新缓冲区，不过 <code>std::endl</code> 会自动刷新一次缓冲区，所以此时可以省略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1e6</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'&lt;'</span>) r = m - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>交互题测试例子：先假设一组答案，按照自己的程序计算出每次 query 的答案，最好用文件输入输出测试。</p>
</blockquote>
<h3 id="负数下标技巧"><a href="#负数下标技巧" class="headerlink" title="负数下标技巧"></a>负数下标技巧</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> aa[N];</span><br><span class="line"><span class="keyword">int</span> *a = (aa + N / <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可用于 $O(1)$ 首尾插入或删除元素，访问第 $i$ 个元素。<br>当然也可以用 <code>std::deque</code> 加一个标号，实现上述操作</p>
</blockquote>
<h3 id="优雅的输出技巧"><a href="#优雅的输出技巧" class="headerlink" title="优雅的输出技巧"></a>优雅的输出技巧</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" \n"</span>[i == n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模正数向下取整：-lfloor-frac-a-n-rfloor-和-模正数向下取整：-lceil-frac-a-n-rceil"><a href="#模正数向下取整：-lfloor-frac-a-n-rfloor-和-模正数向下取整：-lceil-frac-a-n-rceil" class="headerlink" title="模正数向下取整：$\lfloor \frac{a}{n} \rfloor$ 和 模正数向下取整：$\lceil \frac{a}{n} \rceil$"></a>模正数向下取整：$\lfloor \frac{a}{n} \rfloor$ 和 模正数向下取整：$\lceil \frac{a}{n} \rceil$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">floor</span><span class="params">(LL a, LL n)</span> </span>&#123; <span class="comment">// n &gt; 0</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; <span class="number">0</span> ? (a - n + <span class="number">1</span>) / n : a / n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ceil</span><span class="params">(LL a, LL n)</span> </span>&#123; <span class="comment">// n &gt; 0</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; <span class="number">0</span> ? a / n : (a + n - <span class="number">1</span>) / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到 C/C++ 中 ，整数除法 <code>/</code> 是向 <code>0</code> 取整(<code>int(x)</code>也是向 0 取整)，但是 Python（Sagemath） 整数除法 <code>//</code> 是向下取整。在 C++ 中一定不要用 <code>(x - 1) / n + 1</code> 的姿势向上取整！！！</p>
</blockquote>
<h3 id="Floor-sum-displaystyle-sum-i-0-n-1-lfloor-frac-a-cdot-i-b-m-rfloor"><a href="#Floor-sum-displaystyle-sum-i-0-n-1-lfloor-frac-a-cdot-i-b-m-rfloor" class="headerlink" title="Floor_sum : $\displaystyle \sum_{i = 0}^{n - 1} \lfloor \frac{a \cdot i + b}{m} \rfloor$"></a>Floor_sum : $\displaystyle \sum_{i = 0}^{n - 1} \lfloor \frac{a \cdot i + b}{m} \rfloor$</h3><blockquote>
<p>注意到这个求和式表示由直线 $x = 0, x = n, y = 0, y = \frac{a}{m}x + \frac{b}{m}$ 构成的梯形内部（仅包含上边界）的整点个数。</p>
</blockquote>
<p>显然我们可以先预处理，使得 $a &lt; m$ 且 $b &lt; m$，此时我们考虑 $y_{\max} = \lfloor \frac{a \cdot n + b}{m} \rfloor$，定义 $x_{\max} = y_{\max} \cdot m - b$，那么 $[\lceil \frac{x_{\max}}{a} \rceil, n)$ 的纵坐标取整值都相等为 $y_{\max}$，然后我们横纵坐标互换（在一张相对透明的纸上画图，然后在另一面看就是）由直线 $x = 0, x = y_{\max}, y = 0, y = \frac{m}{a}x + \frac{b’}{a}$ 构成的梯形内部（不包含边界）的整点个数。其中 $b’ = \lceil \frac{x_{\max}}{a} \rceil \cdot a - x_{\max}$（表示直线 $y = y_{\max}$ 与 $y = \frac{a}{m}x + \frac{b}{m}$ 以及 $x = \lceil \frac{x_{\max}}{a} \rceil$ 相交的长度）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">floorSum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (a &gt;= m) &#123;</span><br><span class="line">		r += LL(a / m) * (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">		a %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b &gt;= m) &#123;</span><br><span class="line">		r += LL(b / m) * n;</span><br><span class="line">		b %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> yMax = (LL(a) * n + b) / m;</span><br><span class="line">	<span class="keyword">if</span> (yMax == <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	LL xMax = LL(yMax) * m - b;</span><br><span class="line">	r += (n - (xMax + a - <span class="number">1</span>) / a) * yMax;</span><br><span class="line">	r += floorSum(yMax, a, m, (a - (xMax % a)) % a);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们可以考虑用长方形整点数减去上部分的整点数（要往上平移一个单位）<strong>这样搞更快</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">floorSum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (a &gt;= m) &#123;</span><br><span class="line">		r += LL(a / m) * (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">		a %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b &gt;= m) &#123;</span><br><span class="line">		r += LL(b / m) * n;</span><br><span class="line">		b %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> yMax = (LL(a) * n + b) / m;</span><br><span class="line">	<span class="keyword">if</span> (yMax == <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	r += LL(n - <span class="number">1</span>) * yMax;</span><br><span class="line">	r -= floorSum(yMax, a, m, m - b - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://atcoder.jp/contests/practice2/tasks/practice2_c" target="_blank" rel="noopener">模板例题</a> 和 <a href="https://atcoder.jp/contests/arc111/tasks/arc111_e" target="_blank" rel="noopener">应用例题</a></p>
<h3 id="带取整的函数取最值的技巧"><a href="#带取整的函数取最值的技巧" class="headerlink" title="带取整的函数取最值的技巧"></a>带取整的函数取最值的技巧</h3><ul>
<li>先考虑不取整的情况，然后一般这个值是可能的最小值或者最大值</li>
<li>然后通过循环看是否满足取整的情况</li>
</ul>
<h3 id="Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释"><a href="#Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释" class="headerlink" title="Barrent reduction 快速模，弃用，因为并不会变快… ：wiki 镜像解释"></a><a href="https://en.wikipedia.org/wiki/Barrett_reduction" target="_blank" rel="noopener"><del>Barrent reduction 快速模</del>，弃用，因为并不会变快…</a> ：<a href="https://en.jinzhao.wiki/wiki/Barrett_reduction" target="_blank" rel="noopener">wiki 镜像解释</a></h3><blockquote>
<p>对于给定常数 $M$ 求 <code>a % M</code>，并要求 $ 0 \leq a &lt; M^2$，并且 $a &lt; 2^k$。因此下面 $k$ 的取值还是需要注意的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> LL M  = <span class="number">1e9</span> + <span class="number">7</span>; <span class="comment">// too big, M should satisfy M * M &lt; int</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span>  k = <span class="built_in">std</span>::__lg(M) + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> LL m = (<span class="number">1L</span>L &lt;&lt; k) / M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> mod = [&amp;](<span class="keyword">int</span> a) &#123;</span><br><span class="line">	LL r = a - ((a * m) &gt;&gt; k) * M;</span><br><span class="line">	<span class="keyword">return</span> r &gt;= M ? r - M : r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="输出全排列"><a href="#输出全排列" class="headerlink" title="输出全排列"></a>输出全排列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">std</span>::for_each(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(),[](<span class="keyword">int</span> i)&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="built_in">std</span>::next_permutation(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出全排列的原理"><a href="#输出全排列的原理" class="headerlink" title="输出全排列的原理"></a>输出全排列的原理</h3><p>首先初始状态从小到大排列，然后对每一个状态考虑它的后缀，如果后缀是从大到小排列，再考虑向前一位的后缀，直到不是从大到小排列，然后找比第一个位置大的最小值放在开头，其它位置排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(n)</span>:</span></span><br><span class="line">	ans = []</span><br><span class="line">	cnt = math.factorial(n);</span><br><span class="line">	r = list(range(<span class="number">1</span>, n + <span class="number">1</span>))</span><br><span class="line">	ans.append(r.copy())</span><br><span class="line">	cnt -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">		i = n - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> r[i - <span class="number">1</span>] &gt; r[i]: i -= <span class="number">1</span></span><br><span class="line">		r[i:] = r[i:][::<span class="number">-1</span>]</span><br><span class="line">		j = i</span><br><span class="line">		<span class="keyword">while</span> r[j] &lt; r[i - <span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">		r[i - <span class="number">1</span>], r[j] = r[j], r[i - <span class="number">1</span>]</span><br><span class="line">		ans.append(r.copy())</span><br><span class="line">		cnt -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> ans	</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">	print(permutation(i))</span><br></pre></td></tr></table></figure>
<h2 id="初等数论"><a href="#初等数论" class="headerlink" title="初等数论"></a>初等数论</h2><h3 id="Greatest-Common-divisor"><a href="#Greatest-Common-divisor" class="headerlink" title="Greatest Common divisor"></a>Greatest Common divisor</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简洁写法，不推荐，推荐使用内建 __gcd</span></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lambda 表达式写法，开头不能是auto因为递归</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; gcd = [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 快速版本 https://cp-algorithms.com/algebra/euclid-algorithm.html</span></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!a || !b) <span class="keyword">return</span> a | b;</span><br><span class="line">	<span class="keyword">unsigned</span> shift = __builtin_ctzll(a | b);</span><br><span class="line">	a &gt;&gt;= __builtin_ctzll(a);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		b &gt;&gt;= __builtin_ctzll(b);</span><br><span class="line">		<span class="keyword">if</span> (a &gt; b) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">		b -= a;</span><br><span class="line">	&#125; <span class="keyword">while</span> (b);</span><br><span class="line">	<span class="keyword">return</span> a &lt;&lt; shift;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通版拓展GCD</span></span><br><span class="line"><span class="function">LL <span class="title">exGcd</span><span class="params">(LL a, LL b, LL&amp; x, LL&amp; y)</span></span>&#123;  <span class="comment">// ax + by = gcd(a,b)</span></span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">		x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	LL d = exgcd(b, a % b, y, x);</span><br><span class="line">	y -= a / b * x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++17版拓展GCD，优雅了不少!</span></span><br><span class="line">std::tuple&lt;LL, LL, LL&gt; exGcd(LL a, LL b) &#123;  // ax + by = gcd(a,b)</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> &#123;a, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> [d, y, x] = exGcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> &#123;d, x, y - a / b * x&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n"><a href="#Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n" class="headerlink" title="Sum of least common multiple  $s_n =  \sum_{i=1} ^n lcm(i,n)$"></a>Sum of least common multiple  $s_n =  \sum_{i=1} ^n lcm(i,n)$</h3><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1} ^n lcm(i,n) 
&= \sum_{i=1} ^n \frac{i \cdot n}{\gcd(i,n)} \\
&= n \sum_{d|n} \sum_{\gcd(i,\frac{n}{d})= 1} i \\
&= \frac{n}{2} \sum_{d|n} \frac{n}{d} \psi(\frac{n}{d}) \\
&= \frac{n}{2} \sum_{d|n} d \psi(d)
\end{aligned}</script><p>所以，我们可以在 $O(n \log n)$ 处理好 $s_n$ 的前 $n$ 项。</p>
<h3 id="Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-lcm-i-j"><a href="#Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-lcm-i-j" class="headerlink" title="Double sum of least common multiple $ds_n = \sum_{1 \leq i \leq j \leq n} lcm(i,j)$"></a>Double sum of least common multiple $ds_n = \sum_{1 \leq i \leq j \leq n} lcm(i,j)$</h3><p>本来这个也挺麻烦，但是可以借助 $s_n$ 计算：$ds_n =  \sum_{j=1} ^n s_j$，所以复杂度就一致了。当然也可以直接化简成：</p>
<script type="math/tex; mode=display">
\sum_{1 \leq i \leq j \leq n} lcm(i,j) = \sum_{i = 1} ^ n \frac{i}{4} \psi(i) \lfloor \frac{n}{i} \rfloor (\lfloor \frac{n}{i} \rfloor + 1)</script><blockquote>
<p>不借助 $s_n$ 其实也能暴力搞出来的。</p>
</blockquote>
<h3 id="模乘法逆元"><a href="#模乘法逆元" class="headerlink" title="模乘法逆元"></a>模乘法逆元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a, LL p)</span></span>&#123; <span class="comment">// 0 &lt; a &lt; p and gcd(a,p) = 1</span></span><br><span class="line">	<span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (p - p / a) * inv(p % a, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码主要用于线性时间预处理所有$p$以内的逆元，对于较小的常数$a$, 可以直接试除 <code>b p mod a == 1</code><br>用下面快速幂也可以求逆，<code>inv</code> 的步数平均下面显著的比快速幂小，但是由于用到了递归，因此最终它们的平均效率是一致的。<br>可以通过预处理小部分值达到快速的效果。</p>
</blockquote>
<h3 id="快速模乘法"><a href="#快速模乘法" class="headerlink" title="快速模乘法"></a>快速模乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 &lt;= x &lt; p &lt; INT_MAX</span></span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n, LL p)</span></span>&#123;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) r = r * x % p;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; x = x * x % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用 for 循环写的更短一点，但没必要，若 <code>p &lt; INT64_MAX</code> 就需要使用 <code>__int128</code> 了。现代计算机都是 64 位的，因此处理 int 跟 long long 基本没有时间差异，直接用 LL 避免了强制类型转化，因此效率反而更高。但是 <code>__int128</code> 就不同了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 &lt;= x &lt; p &lt; INT64_MAX</span></span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n, LL p)</span></span>&#123;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) r = __int128(r) * x % p;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; x = __int128(x) * x % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阶乘、组合数、Lucas-定理"><a href="#阶乘、组合数、Lucas-定理" class="headerlink" title="阶乘、组合数、Lucas 定理"></a>阶乘、组合数、Lucas 定理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">2</span>;</span><br><span class="line">LL fac[N], ifac[N];</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (M - M / a) * inv(M % a) % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">	ifac[N - <span class="number">1</span>] = inv(fac[N - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; --i) ifac[i - <span class="number">1</span>] = ifac[i] * i % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//if (n &lt; k || n &lt; 0) return 0;</span></span><br><span class="line">	<span class="keyword">return</span> fac[n] * ifac[k] % M * ifac[n - k] % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lucas</span><span class="params">(LL n, LL m, LL p)</span> </span>&#123; <span class="comment">// C(n,m)%p, 仅在p较少时发挥作用</span></span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n &amp;&amp; m) &#123;</span><br><span class="line">		LL np = n % p, mp = m % p;</span><br><span class="line">		<span class="keyword">if</span> (np &lt; mp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		r = binom(np, mp);</span><br><span class="line">		n /= p, m /= p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用组合数公式"><a href="#常用组合数公式" class="headerlink" title="常用组合数公式"></a>常用组合数公式</h3><p>对任意实数，定义：$\binom{\alpha}{k} = \frac{\alpha(\alpha - 1) \cdots (\alpha - k + 1)}{k !}$ 所以我们有：</p>
<script type="math/tex; mode=display">
\binom{-n}{k} = (-1)^{k} \binom{n + k - 1}{k}</script><script type="math/tex; mode=display">
\binom{n + 1}{k + 1} = \binom{n}{k} + \binom{n}{k + 1}</script><blockquote>
<p>最后一个数，先还是不选，这是一个问题。</p>
</blockquote>
<script type="math/tex; mode=display">
{n \choose k}{k \choose i}  = {n \choose i} {n - i \choose k - i}</script><blockquote>
<p>组合意义理解：$n$ 个人中选出 $i$ 个一流人才， $k - i$ 个二流人才。</p>
</blockquote>
<script type="math/tex; mode=display">{n + m \choose k} = \sum_{i + j = k} {n \choose i} {m \choose j}</script><blockquote>
<p>组合意义理解：$n, m$ 两个堆选出 $k$ 个人。</p>
</blockquote>
<h3 id="乞丐版素数判断"><a href="#乞丐版素数判断" class="headerlink" title="乞丐版素数判断"></a>乞丐版素数判断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span> || n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-n-log-n-素数筛"><a href="#O-n-log-n-素数筛" class="headerlink" title="$O(n \log n)$ 素数筛"></a>$O(n \log n)$ 素数筛</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =  <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> isP[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(isP[<span class="number">2</span>]) <span class="keyword">return</span>;</span><br><span class="line">	isP[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isP[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isP[i]) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span> * i; j &lt; N; j += i * <span class="number">2</span>) &#123;</span><br><span class="line">			isP[j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性素数筛（正式使用版）"><a href="#欧拉线性素数筛（正式使用版）" class="headerlink" title="欧拉线性素数筛（正式使用版）"></a>欧拉线性素数筛（正式使用版）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initPrimeP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	p.emplace_back(<span class="number">2</span>);</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> sq = <span class="keyword">int</span>(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(N + <span class="number">0.1</span>))|<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= sq; i += <span class="number">2</span>) <span class="keyword">if</span> (isp[i]) &#123;</span><br><span class="line">		p.emplace_back(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; N; j += i &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">			isp[j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = sq + <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isp[i]) p.emplace_back(i);</span><br><span class="line">	<span class="keyword">return</span> p.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性素数筛（弃用）"><a href="#欧拉线性素数筛（弃用）" class="headerlink" title="欧拉线性素数筛（弃用）"></a>欧拉线性素数筛（弃用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrimeP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	p.emplace_back(<span class="number">2</span>);</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) p.emplace_back(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j != p.<span class="built_in">size</span>() &amp;&amp; p[j] &lt; t; ++j) &#123; <span class="comment">// 用除号是防止溢出</span></span><br><span class="line">			isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="comment">// 不要下面的一步的话，复杂度 O(nloglogn), 但是不用除法，常数小</span></span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-1-（执行）时间复杂度判断一个数是否为素数"><a href="#O-1-（执行）时间复杂度判断一个数是否为素数" class="headerlink" title="$O(1)$ （执行）时间复杂度判断一个数是否为素数"></a>$O(1)$ （执行）时间复杂度判断一个数是否为素数</h3><blockquote>
<p>奇技淫巧来源：<a href="https://codeforces.com/blog/entry/79941#comment-659202" target="_blank" rel="noopener">https://codeforces.com/blog/entry/79941#comment-659202</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sieve</span> &#123;</span></span><br><span class="line">	<span class="keyword">bool</span> isP[N];</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">Sieve</span><span class="params">()</span>: <span class="title">isP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		isP[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isP[i] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isP[i]) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span> * i; j &lt; N; j += i * <span class="number">2</span>) &#123;</span><br><span class="line">					isP[j] = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// MAXN 默认最大值为1&lt;&lt;18=262144, 调节参数 -fconstexpr-loop-limit= 例如：</span></span><br><span class="line"><span class="comment">// g++ main.cpp -std=c++17 -fconstexpr-loop-limit=12345678 -fconstexpr-ops-limit=1234567890</span></span><br><span class="line"><span class="comment">// 使得 MAXN = 1e7+2</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fast_is_prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> Sieve&lt;MAXN&gt; s;</span><br><span class="line">	<span class="keyword">return</span> s.isP[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大素数-Miller-Rabin-概率判别法-和-大整数的最-大-小-因子分解"><a href="#大素数-Miller-Rabin-概率判别法-和-大整数的最-大-小-因子分解" class="headerlink" title="大素数 Miller-Rabin 概率判别法 和 大整数的最 大/小 因子分解"></a>大素数 Miller-Rabin 概率判别法 和 大整数的最 大/小 因子分解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> PollardRho &#123;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::mt19937 <span class="title">rnd</span><span class="params">(<span class="built_in">std</span>::chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n, LL p)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = __int128(r) * x % p;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;   x = __int128(x) * x % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 &lt; a &lt; n，若 n 是素数，那么 a^(n - 1) = 1 mod n</span></span><br><span class="line"><span class="comment">// m - 1 = m * 2 ^ t，返回 false 表示判断失败</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">witness</span><span class="params">(LL a, LL n, LL m, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	LL x = powMod(a, m, n);</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		x = __int128(x) * x %  n;</span><br><span class="line">		<span class="keyword">if</span> (x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TIMES = <span class="number">52</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LL m = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> t = __builtin_ctzll(m);</span><br><span class="line">	m &gt;&gt;= t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>; cnt &lt; TIMES; ++cnt) &#123;</span><br><span class="line">		LL a = rnd() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (witness(a, n, m, t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pollardrho</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	LL x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">1</span>, i = <span class="number">1</span>, k = <span class="number">2</span>, c = rnd() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		x = (__int128(x) * x + c) % n;</span><br><span class="line">		z = __int128(y - x + n) * z % n;</span><br><span class="line">		<span class="comment">// 累计 gcd 一次计算！太猛了啊 茶茶白</span></span><br><span class="line">		<span class="keyword">if</span> (++i == k) &#123;</span><br><span class="line">			LL d = <span class="built_in">std</span>::__gcd(z, n);</span><br><span class="line">			<span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">			y = x;</span><br><span class="line">			<span class="keyword">if</span> (k &gt; n) <span class="keyword">return</span> n;</span><br><span class="line">			k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">spf</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rabin(n) || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">	LL d = n;</span><br><span class="line">	<span class="keyword">while</span> (d == n) d = pollardrho(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">min</span>(spf(d), spf(n / d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">gpf</span><span class="params">(LL n, LL mxf = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rabin(n)) <span class="keyword">return</span> n;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= mxf) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	LL d = n;</span><br><span class="line">	<span class="keyword">while</span> (d == n) d = pollardrho(n);</span><br><span class="line">	LL res = gpf(d, mxf);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">max</span>(res, gpf(n / d, <span class="built_in">std</span>::<span class="built_in">max</span>(res, mxf)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="O-n-最小素因子预处理"><a href="#O-n-最小素因子预处理" class="headerlink" title="$O(n)$ 最小素因子预处理"></a>$O(n)$ 最小素因子预处理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e8</span>; <span class="comment">// 再大内存吃不消了 </span></span><br><span class="line"><span class="keyword">int</span> sp[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt;= sp[i] &amp;&amp; i * p[j] &lt; N; ++j) &#123; <span class="comment">//防止乘法溢出</span></span><br><span class="line">			sp[i * p[j]] = p[j]; <span class="comment">// 注意到sp只被赋值一次</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mobius-function"><a href="#Mobius-function" class="headerlink" title="Mobius function"></a>Mobius function</h3><blockquote>
<p>另类递推公式： $ \mu(i) = - \sum_{d \mid i, d &lt; i} \mu(d) $。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 乞丐版</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line">		n /= <span class="number">2</span>;</span><br><span class="line">		r = -r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">			n /= i;</span><br><span class="line">			<span class="keyword">if</span>(n % i  == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			r = -r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n &gt; <span class="number">1</span> ? -r : r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(n log n) 预处理版本</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e6</span> +<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt; N; j += i) &#123;</span><br><span class="line">			mu[j] -= mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n) 预处理版</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e6</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="keyword">int</span> p[N], mu[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(mu[<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) mu[i] = <span class="number">-1</span>, p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j) &#123;</span><br><span class="line">			isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			mu[i * p[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">4</span>) mu[i] = -mu[i &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mobius-function-前缀和"><a href="#Mobius-function-前缀和" class="headerlink" title="Mobius function 前缀和"></a>Mobius function 前缀和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sumMu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSumMu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mu[<span class="number">1</span>] != <span class="number">1</span>) initmu();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) sumMu[i] = sumMu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSumMu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// M(n) = M(n-1) + mu(n)</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> sumMu[n];</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= (j - i + <span class="number">1</span>) * sumMu(n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Mobius function 绝对值前缀和</span></span><br><span class="line"><span class="function">LL <span class="title">getSumAbsMu</span><span class="params">(LL n)</span> </span>&#123; <span class="comment">// Q(n) = Q(n-1) + |mu(n)|</span></span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>, t; (t = i * i) &lt; n; ++i) &#123;</span><br><span class="line">		r += mu[i] * (n / t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Euler’s-totient-function"><a href="#Euler’s-totient-function" class="headerlink" title="Euler’s totient function"></a>Euler’s totient function</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> phi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPhi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (phi[<span class="number">2</span>] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) phi[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) phi[i] = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (phi[i] != i) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j += i) phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPhi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = (n % <span class="number">2</span> == <span class="number">0</span> ? n/<span class="number">2</span> : n);</span><br><span class="line">	<span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>) n/=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i  == <span class="number">0</span>) &#123;</span><br><span class="line">			r = r / i *(i<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">while</span> (n % i == <span class="number">0</span>) n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>) r = r / n * (n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">LL sumPhi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSumphi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (phi[<span class="number">2</span>] != <span class="number">1</span>) initPhi();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) sumPhi[i] = sumPhi[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, LL&gt; mp;</span><br><span class="line"><span class="function">LL <span class="title">getSumphi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> (LL) sumPhi[n];</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	LL r = LL(n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= (j - i + <span class="number">1</span>) * getSumphi(n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展-Euler-定理"><a href="#拓展-Euler-定理" class="headerlink" title="拓展 Euler 定理"></a>拓展 Euler 定理</h3><p>数论中欧拉定义说：若 $\gcd(a, m) = 1$ 则 $a^{\phi(m)} \equiv 1 \mod m$。</p>
<p>类似于拓展的 Fermat 小定理：$a^p \equiv a \mod p$，我们有拓展 Euler 定理：</p>
<script type="math/tex; mode=display">
a^n \equiv a^{n \mod \phi(m) + phi(m)} \mod m</script><p>证明对 m 素因子分解，再利用 Euler 函数是可乘函数，显然。</p>
<h3 id="pi-x-函数"><a href="#pi-x-函数" class="headerlink" title="$\pi(x)$ 函数"></a>$\pi(x)$ 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span> * <span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">11</span> * <span class="number">13</span> * <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM + <span class="number">1</span>][M + <span class="number">1</span>], sz[M + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	initprime();</span><br><span class="line">	pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		pi[i] = pi[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) ++pi[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sz[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= PM; ++i) phi[i][<span class="number">0</span>] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">		sz[i] = p[i] * sz[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= PM; ++j) &#123;</span><br><span class="line">			phi[j][i] = phi[j][i - <span class="number">1</span>] - phi[j / p[i]][i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s &lt;= M) <span class="keyword">return</span> phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];</span><br><span class="line">	<span class="keyword">if</span> (x / p[s] &lt;= p[s]) <span class="keyword">return</span> primepi(x) - s + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x / p[s] / p[s] &lt;= p[s] &amp;&amp; x &lt; N) &#123;</span><br><span class="line">		<span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>))];</span><br><span class="line">		LL ans = pi[x] - (s2x + s - <span class="number">2</span>) * (s2x - s + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt;= s2x; ++i) &#123;</span><br><span class="line">			ans += pi[x / p[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> primephi(x, s - <span class="number">1</span>) - primephi(x / p[s], s - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; N) <span class="keyword">return</span> pi[x];</span><br><span class="line">	<span class="keyword">int</span> ps2x = primepi(<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>)));</span><br><span class="line">	<span class="keyword">int</span> ps3x = primepi(<span class="keyword">int</span>(cbrt(x + <span class="number">0.2</span>)));</span><br><span class="line">	LL ans = primephi(x, ps3x) + LL(ps2x + ps3x - <span class="number">2</span>) * (ps2x - ps3x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = ps3x + <span class="number">1</span>, ed = ps2x; i &lt;= ed; ++i) &#123;</span><br><span class="line">		ans -= primepi(x / p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pi-x-函数计算的另一种做法"><a href="#pi-x-函数计算的另一种做法" class="headerlink" title="$\pi(x)$ 函数计算的另一种做法"></a>$\pi(x)$ 函数计算的另一种做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">2</span>;</span><br><span class="line">LL L[N], R[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	LL rn = (LL) <span class="built_in">sqrt</span>(n + <span class="number">0.2</span>);</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= rn; ++i) R[i] = n / i - <span class="number">1</span>;</span><br><span class="line">	LL ln = n / (rn + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= ln; ++i) L[i] = i - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL p = <span class="number">2</span>; p &lt;= rn; ++p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L[p] == L[p - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (LL i = <span class="number">1</span>, tn = <span class="built_in">std</span>::<span class="built_in">min</span>(n / (p * p), rn); i &lt;= tn; ++i) &#123;</span><br><span class="line">			R[i] -= (i * p &lt;= rn ? R[i * p] : L[n / (i * p)]) - L[p - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (LL i = ln; i &gt;= p * p; --i) &#123;</span><br><span class="line">			L[i] -= L[i / p] - L[p - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求奇素数的一个原根"><a href="#求奇素数的一个原根" class="headerlink" title="求奇素数的一个原根"></a>求奇素数的一个原根</h3><blockquote>
<p>代码懒得贴，实际上暴力就可以了</p>
</blockquote>
<p>首先，模 $m$ 有原根的充要条件是：$m=2,4,p^a,2p^a$，其中 $p$ 为奇素数。</p>
<p>对于求模 $p$ 的原根方法：对 $p-1$ 素因子分解：$p-1 = p_1^{a_1} \cdots p_s^{a_s}$ 若恒有 </p>
<script type="math/tex; mode=display">
g^{\frac{p-1}{p_i}} \neq 1(\mod \; p)</script><p>则 $g$ 是 模 $p$ 的原根。对于 $p^a$ 可以用 $p$ 的原根简单构造，而 $2p^a$ 的原根为 $p^a$ 的原根与 $p^a$ 的原根和 $p^a$的和中奇数者。(证明见 P150《数论基础》潘承洞)</p>
<blockquote>
<p>求所有原根见 </p>
</blockquote>
<h3 id="数论函数的-Dirichlet-乘积"><a href="#数论函数的-Dirichlet-乘积" class="headerlink" title="数论函数的 Dirichlet 乘积"></a>数论函数的 Dirichlet 乘积</h3><p>以前的代码不想贴了，不优雅，下次有题做的时候补上。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/chineseRemainTheorem/" title="中国剩余定理">中国剩余定理</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;LL,LL&gt; crt2(LL a1,LL m1,LL a2,LL m2)&#123; // x = ai mod mi, m_i &gt;0</span><br><span class="line">	LL t1,t2,ans = a2-a1;</span><br><span class="line">	LL d = exgcd(m1,m2,t1,t2);</span><br><span class="line">	assert(ans%d == <span class="number">0</span>);</span><br><span class="line">	LL m = m1/d*m2;</span><br><span class="line">	ans = (a1+ans/d*t1%m2*m1)%m; <span class="comment">// %m2 是避免溢出</span></span><br><span class="line">	<span class="keyword">return</span> make_pair(ans&gt;<span class="number">0</span>?ans:ans+m,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span>;</span><br><span class="line">LL a[N],m[N];</span><br><span class="line">pair&lt;LL,LL&gt; crt(int n)&#123; // x = a[i] mod m[i], m[i] &gt;0</span><br><span class="line">	pair&lt;LL,LL&gt; ans = make_pair(a[<span class="number">0</span>]%m[<span class="number">0</span>],m[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">		ans = crt2(ans.first,ans.second,a[i],m[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a><a href="http: //blog.miskcoo.com/2015/05/discrete-logarithm-problem">离散对数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">baby_step_giant_step</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123; <span class="comment">// a^x = b mod p</span></span><br><span class="line">	a %= p, b %= p;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b % p ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LL cnt = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL g = <span class="built_in">std</span>::__gcd(a, p); g != <span class="number">1</span>; g = <span class="built_in">std</span>::__gcd(a, p)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		p /= g, b /= g, t = t * (a / g) % p;</span><br><span class="line">		++cnt;</span><br><span class="line">		<span class="keyword">if</span> (b == t) <span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;LL, LL&gt; mp;</span><br><span class="line">	LL m = LL(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(p + <span class="number">0.1</span>) + <span class="number">1</span>);</span><br><span class="line">	LL base = b;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">0</span>; i != m; ++i) &#123;</span><br><span class="line">		mp[base] = i;</span><br><span class="line">		base = base * a % p;</span><br><span class="line">	&#125;</span><br><span class="line">	base = powMod(a, m, p);</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		t = t * base % p;</span><br><span class="line">		<span class="keyword">if</span> (mp.count(t)) <span class="keyword">return</span> i * m - mp[t] + cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模素数开根号"><a href="#模素数开根号" class="headerlink" title="模素数开根号"></a>模素数开根号</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">modsqrt</span><span class="params">(LL a, LL p)</span> </span>&#123; <span class="comment">// find x s.t x*x=a mod p;</span></span><br><span class="line">	a = (p + a % p) % p;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">2</span>) <span class="keyword">return</span> (a &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	LL q = (p - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (powMod(a, q, p) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (q &amp; <span class="number">1</span>) <span class="keyword">return</span> powMod(a, (q + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line">	LL b, cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (powMod(b = rand() % p, q, p) == <span class="number">1</span>); <span class="comment">//find a non quadratic residue</span></span><br><span class="line">	<span class="keyword">while</span> (!(q &amp; <span class="number">1</span>)) ++cnt, q &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	b = powMod(b, q, p);</span><br><span class="line">	LL x = powMod(a, (q + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line">	<span class="keyword">for</span> (LL s = <span class="number">1</span>, t = powMod(a, q, p); t != <span class="number">1</span>; s = <span class="number">1</span>) &#123; <span class="comment">//keep x*x=t*a;t^&#123;2^&#123;cnt-1&#125;&#125;=1</span></span><br><span class="line">		<span class="keyword">for</span> (LL tt = t * t % p; s &lt; cnt &amp;&amp; tt != <span class="number">1</span>; ++s) tt = tt * tt % p;</span><br><span class="line">		LL d = powMod(b, <span class="number">1</span> &lt;&lt; (cnt - s - <span class="number">1</span>), p);</span><br><span class="line">		x = (x * d) % p;</span><br><span class="line">		b = d * d % p;</span><br><span class="line">		t = t * b % p;</span><br><span class="line">		cnt = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mod_sqrt</span><span class="params">(LL a, LL p, <span class="keyword">int</span> k = <span class="number">1</span>)</span> </span>&#123; <span class="comment">//find smallest x&gt;=0 s.t x*x=a mod p^k</span></span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ka = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (a % p == <span class="number">0</span>) a /= p, ++ka, --k;</span><br><span class="line">	<span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ka &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">auto</span> <span class="built_in">pow</span> = [](LL x, <span class="keyword">int</span> n) &#123;</span><br><span class="line">		LL r=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, x *= x)  <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r *= x;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	LL n = <span class="built_in">pow</span>(p, k), x;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">1</span> || k == <span class="number">2</span>) x = a == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a % <span class="number">8</span> != <span class="number">1</span>) x = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			x = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((x * x) % (<span class="number">1</span> &lt;&lt; i) == a % (<span class="number">1</span> &lt;&lt; i)) <span class="keyword">continue</span>;</span><br><span class="line">				x += <span class="number">1</span> &lt;&lt; (i - <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> x = mod_sqrt_p(a, n, p, k);</span><br><span class="line">	<span class="keyword">return</span> x == <span class="number">-1</span> ? <span class="number">-1</span> : <span class="built_in">pow</span>(p, ka &gt;&gt; <span class="number">1</span>) * (x &lt; n - x ? x : n - x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于模一般的 $n$，先素因子分解分别求出答案，然后用中国剩余定理求最终解。</p>
</blockquote>
<h3 id="自然数方幂和-O-k-算法"><a href="#自然数方幂和-O-k-算法" class="headerlink" title="自然数方幂和 $O(k)$ 算法"></a>自然数方幂和 $O(k)$ 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> sp[N], p[N];</span><br><span class="line">LL inv[N], AP[N], AS[N], f[N];</span><br><span class="line"><span class="function">LL <span class="title">getPowSum</span><span class="params">(LL n, <span class="keyword">int</span> k, LL mod)</span> </span>&#123; <span class="comment">// mod &gt; k</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> n % mod;</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">2</span>) spf();</span><br><span class="line">	<span class="keyword">int</span> nk = k + <span class="number">1</span>;</span><br><span class="line">	LL tmp = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk; ++i) tmp = tmp * i % mod;</span><br><span class="line">	inv[nk] = powMod(tmp, mod - <span class="number">2</span>, mod);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) f[i] = powMod(i, k, mod);</span><br><span class="line">		<span class="keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]] % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (f[i] &gt;= mod) f[i] -= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= nk) <span class="keyword">return</span> f[n];</span><br><span class="line">	AP[<span class="number">0</span>] = AS[nk] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) AP[i] = AP[i - <span class="number">1</span>] * (n + <span class="number">1</span> - i) % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) AS[i] = AS[i + <span class="number">1</span>] * (n - i - <span class="number">1</span>) % mod;</span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) &#123; <span class="comment">// because f(i)=0</span></span><br><span class="line">		LL x = f[i] * AP[i] % mod * AS[i] % mod * inv[i] % mod * inv[nk - i] % mod;</span><br><span class="line">		<span class="keyword">if</span> ((nk - i) &amp; <span class="number">1</span>) res -= x; <span class="comment">// be careful</span></span><br><span class="line">		<span class="keyword">else</span> res += x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res % mod + mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自然数方幂和精确版"><a href="#自然数方幂和精确版" class="headerlink" title="自然数方幂和精确版"></a>自然数方幂和精确版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> BINT = boost::multiprecision::cpp_int;</span><br><span class="line"></span><br><span class="line">BINT f[N];</span><br><span class="line"><span class="function">BINT <span class="title">getPowSum</span><span class="params">(LL n, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// k&lt;1000</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> BINT(n);</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="number">2</span>) spf();</span><br><span class="line">	<span class="keyword">int</span> nk = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> bPow = [](BINT x, <span class="keyword">int</span> n) -&gt; BINT &#123;</span><br><span class="line">		BINT r(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (; n; x *= x, n &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r *= x;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) f[i] = bPow(BINT(i), k);</span><br><span class="line">		<span class="keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= nk) <span class="keyword">return</span> f[n];</span><br><span class="line">	BINT res = <span class="number">0</span>, tl = <span class="number">1</span>, tr = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) tr = tr * (n - i - <span class="number">1</span>) / (nk - i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((nk - i) &amp; <span class="number">1</span>) res -= f[i] * tl * tr;</span><br><span class="line">		<span class="keyword">else</span> res += f[i] * tl * tr;</span><br><span class="line">		tl = tl * (n - i) / (i + <span class="number">1</span>);</span><br><span class="line">		tr = tr * (nk - i) / (n - i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要下载<a href="https://www.boost.org/" target="_blank" rel="noopener">boost 包</a> 类似的包还有 NTL，GMP</p>
</blockquote>
<h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><p>有位伟人说过：生成函数就像袋子，把一个个零碎的小部件放在一个袋子里，就可以优雅高效的只关注袋子了。</p>
<p>在 codeforces 上 <code>zscoder</code> 大佬给了一个 <a href="https://codeforces.com/blog/entry/77468" target="_blank" rel="noopener">入门教程</a> 和 <a href="https://codeforces.com/blog/entry/77551" target="_blank" rel="noopener">进阶教程</a> 还有 <code>MiFaFaOvO</code> 的 <a href="https://codeforces.com/blog/entry/76447" target="_blank" rel="noopener">终极教程</a></p>
<p>生成函数分两种：Original generating function，Expentional generating function，选择哪一种是看问题中是否牵扯组合数。无论哪一种都能保存原数列的全部信息，并且由于级数可以使用微积分和常微分方程的技术，所以会变得更好处理。然后大概率可以优化算法复杂度 $O(n^2) \to O(n \log n)$ </p>
<p>关于生成函数多项式的处理：<a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">https://cp-algorithms.com/algebra/polynomial.html</a></p>
<p>多项式高效运算模板：<a href="https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp" target="_blank" rel="noopener">https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp</a></p>
<p><strong>生成函数一般的处理思路</strong>：计算生成函数，分解成有分母不超过二次的分式之和，然后每一个二次的分母部分找一个递推数列来搞定。</p>
<p><a href="https://oi-wiki.org/math/poly/intro/" target="_blank" rel="noopener">OI-wiki 多项式运算</a></p>
<blockquote>
<p><a href="https://www.luogu.com.cn/blog/command-block/sheng-cheng-han-shuo-za-tan#" target="_blank" rel="noopener">多项式计数杂谈</a> 很值得学习一下。</p>
</blockquote>
<h3 id="多项式取对数和指数"><a href="#多项式取对数和指数" class="headerlink" title="多项式取对数和指数"></a>多项式取对数和指数</h3><p>$B(z) = e^{A(z)}$，即 $A(z) = \ln B(z)$ (不妨假设 $A(0) = 0$ 或等价地 $B(0) = 1$)</p>
<p>那么 $B’(z) = A’(z) \cdot B(z)$, 所以 $[z^{n - 1}] B’(z) = \sum_{k = 0}^{n - 1} [z^k] A’(z) \cdot B(z) [z^{n - 1 - k}] = \sum_{k = 1}^{n} [z^{k - 1}] A’(z) \cdot B(z) [z^{n-k}]$，从而</p>
<script type="math/tex; mode=display">
n [z^n] B(z) = \sum_{k = 1}^n k [z^k] A(z) \cdot B(z) [z^{n - k}]</script><p>上式等价于</p>
<script type="math/tex; mode=display">
n [z^n] A(z) = n [z^n] B(z) - \sum_{k = 1}^{n - 1} k [z^k] A(z) \cdot B(z) [z^{n - k}]</script><blockquote>
<p>参考：<a href="https://www.cnblogs.com/Soulist/p/13758388.html" target="_blank" rel="noopener">Soulist</a></p>
</blockquote>
<h3 id="NFT-正式可用版-last-updated-2020-7-9"><a href="#NFT-正式可用版-last-updated-2020-7-9" class="headerlink" title="NFT 正式可用版(last updated: 2020/7/9)"></a>NFT 正式可用版(last updated: 2020/7/9)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>, ROOT = <span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; j) <span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = a.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			(j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a, <span class="keyword">bool</span> isInverse = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">	LL g = powMod(ROOT, (M - <span class="number">1</span>) / a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span> (isInverse) &#123;</span><br><span class="line">		g = powMod(g, M - <span class="number">2</span>);</span><br><span class="line">		LL invLen = powMod(LL(a.<span class="built_in">size</span>()), M - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) x = x * invLen % M;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(a);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != w.<span class="built_in">size</span>(); ++i) w[i] = w[i - <span class="number">1</span>] * g % M;</span><br><span class="line">	<span class="keyword">auto</span> addMod = [](LL x, LL y) &#123;</span><br><span class="line">		<span class="keyword">return</span> (x += y) &gt;= M ? x -= M : x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">2</span>, half = <span class="number">1</span>; half != a.<span class="built_in">size</span>(); <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>, half &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, wstep = a.<span class="built_in">size</span>() / <span class="built_in">step</span>; i != a.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j != i + half; ++j) &#123;</span><br><span class="line">				LL t = (a[j + half] * w[wstep * (j - i)]) % M;</span><br><span class="line">				a[j + half] = addMod(a[j], M - t);</span><br><span class="line">				a[j] = addMod(a[j], t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&amp; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (sz &lt; tot) sz *= <span class="number">2</span>;</span><br><span class="line">	a.resize(sz);</span><br><span class="line">	b.resize(sz);</span><br><span class="line">	nft(a);</span><br><span class="line">	nft(b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != sz; ++i) a[i] = a[i] * b[i] % M;</span><br><span class="line">	nft(a, <span class="number">1</span>);</span><br><span class="line">	a.resize(tot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="siyuan-的-FWT-模板-（弃用）"><a href="#siyuan-的-FWT-模板-（弃用）" class="headerlink" title="siyuan 的 FWT 模板 （弃用）"></a><a href="https://blog.orzsiyuan.com/archives/Fast-Walsh-Hadamard-Transform/" target="_blank" rel="noopener">siyuan 的 FWT 模板</a> （弃用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x += y) &gt;= P &amp;&amp; (x -= P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FWT</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; N &lt; n; N &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j + m], a[i + j]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j + m], a[i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j], a[i + j + m]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j], a[i + j + m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTxor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), inv2 = (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = a[i + j + m];</span><br><span class="line">                <span class="keyword">if</span> (!rev) &#123;</span><br><span class="line">                    a[i + j] = (x + y) % P;</span><br><span class="line">                    a[i + j + m] = (x - y + P) % P;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[i + j] = <span class="number">1L</span>L * (x + y) * inv2 % P;</span><br><span class="line">                    a[i + j + m] = <span class="number">1L</span>L * (x - y + P) * inv2 % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Or</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">And</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTand(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTand(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTand(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Xor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTxor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTxor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTxor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; fwt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    std::vector&lt;int&gt; a1(n), a2(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a2[i]);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    A = fwt.Or(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A = fwt.And(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A = fwt.Xor(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FWT 和 FMT 本质上是一致的，只是写法姿势不同。FWT 是用递归的思想写的，FMT 是用逐位计算写的。别人的总归用起来不舒服，还是用下面自己写的 FMT 模板吧！</p>
</blockquote>
<h3 id="FMT-模板"><a href="#FMT-模板" class="headerlink" title="FMT 模板"></a>FMT 模板</h3><blockquote>
<p>考虑数论函数的 <a href="/dirichletProduct/" title="Dirichlet 积">Dirichlet 积</a> 中的 Mobius 变换（本质就是带条件的求和）这里的变换也就是的各个位上的带条件求和。<br>例题：<a href="https://www.luogu.com.cn/problem/P6097" target="_blank" rel="noopener">洛谷 P6097</a>， 参考：<a href="https://www.cnblogs.com/yijan/p/12387352.html" target="_blank" rel="noopener">yijan</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FMT &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2 = (M + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">	(x += y) &gt;= M &amp;&amp; (x -= M);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> sub = [](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">	(x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += M);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> extend = [](<span class="keyword">int</span> n) &#123;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="built_in">std</span>::<span class="built_in">log</span>(n);</span><br><span class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; r) &lt; n) ++r;</span><br><span class="line">	<span class="keyword">return</span> r; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> FMTor = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> isRev) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(a.<span class="built_in">size</span>());</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRev) sub(a[j], a[j ^ (<span class="number">1</span> &lt;&lt; i)]);</span><br><span class="line">			<span class="keyword">else</span> add(a[j], a[j ^ (<span class="number">1</span> &lt;&lt; i)]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> FMTand = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> isRev) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(a.<span class="built_in">size</span>());</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRev) sub(a[j ^ (<span class="number">1</span> &lt;&lt; i)], a[j]);</span><br><span class="line">			<span class="keyword">else</span> add(a[j ^ (<span class="number">1</span> &lt;&lt; i)], a[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> FMTxor = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> isRev) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(a.<span class="built_in">size</span>());</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = a[j], v = a[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">			a[j] = (v - u + M) % M;</span><br><span class="line">			a[j ^ (<span class="number">1</span> &lt;&lt; i)] = (u + v) % M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isRev) <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) x = LL(inv2) * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> fun = [](<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;, <span class="keyword">bool</span>)&gt; f, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(<span class="built_in">std</span>::<span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()));</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n); b.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	f(a, <span class="number">0</span>); f(b, <span class="number">0</span>);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) c[i] = LL(a[i]) * b[i] % M;</span><br><span class="line">	f(c, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> Or = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">return</span> fun(FMTor, a, b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> And = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">return</span> fun(FMTand, a, b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> Xor = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">return</span> fun(FMTxor, a, b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// i = j | k and j &amp; k = 0</span></span><br><span class="line"><span class="keyword">auto</span> OrAnd = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(<span class="built_in">std</span>::<span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()));</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n); b.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">sa</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; n))</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> sb = sa, sc = sa;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) sa[__builtin_popcount(i)][i] = a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) sb[__builtin_popcount(i)][i] = b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		FMTor(sa[i], <span class="number">0</span>);FMTor(sb[i], <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; n); ++k) &#123;</span><br><span class="line">				add(sc[i][k], LL(sa[j][k]) * sb[i - j][k] % M);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		FMTor(sc[i], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) c[i] = sc[__builtin_popcount(i)][i];</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>namespace 真香！</p>
</blockquote>
<h3 id="MEX"><a href="#MEX" class="headerlink" title="MEX"></a>MEX</h3><p>给定集合 S，求集合 MEX(S) 为 S 中最小未出现的自然数。更进一步的，我们可以求 MEX(S, x) 即 S 中所有数与 x 异或后的 MEX 值。</p>
<p>模板例题：<a href="https://codeforces.com/contest/842/problem/D" target="_blank" rel="noopener">842D</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MEX</span> &#123;</span></span><br><span class="line">	<span class="comment">// 具体数值要对应修改。</span></span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, B&gt; mp;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (S.count(x)) <span class="keyword">return</span>;</span><br><span class="line">		S.insert(x);</span><br><span class="line">		<span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = B - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			mask |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">			++mp[i][x &amp; mask];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!S.count(x)) <span class="keyword">return</span>;</span><br><span class="line">		S.erase(x);</span><br><span class="line">		<span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = B - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			mask |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">			--mp[i][x &amp; mask];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find mex(a_i ^ x)</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> mask = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = B - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			mask |= x &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">			<span class="keyword">if</span> (mp[i][mask] == (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">				mask ^= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">				r |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码解释：<code>mp[i][j]</code>，首先 j 的值域为 $2^i[0, 2^{B-i}]$，即只在乎从 i 到 B 这些位上的值。如果 $mp[i][j] = (1 &lt;&lt; i)$ 就说明 j 这一位下面的值都被填满了。在理解 solve 的原理的时候，我们可以先让 x = 0，此时可以看出一丝端倪。即如果 j 这一位被填满了，那么，我们异或 x，也会被填满。</p>
<h3 id="矩阵类"><a href="#矩阵类" class="headerlink" title="矩阵类"></a>矩阵类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">LL mod;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line">	LL a[N][N];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	Matrix() &#123;&#125;</span><br><span class="line">	Matrix(<span class="keyword">int</span> _n, <span class="keyword">int</span> x = <span class="number">0</span>): n(_n) &#123; <span class="comment">// xIn</span></span><br><span class="line">		all(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			a[i][i] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">all</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				a[i][j] = x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> Matrix &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">Matrix <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				R.a[i][j] = a[i][j] + A.a[i][j];</span><br><span class="line">				<span class="keyword">if</span> (R.a[i][j] &gt;= mod) R.a[i][j] -= mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">Matrix <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">					R.a[i][j] = (R.a[i][j] + a[i][k] * A.a[k][j]) % mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function">Matrix <span class="title">R</span><span class="params">(A.n, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) R = R * A;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; A = A * A;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到，矩阵乘法一定要写成上面的循环形式，这样利用高速缓存执行时间是原有的 $\frac{1}{4}$</p>
<p>另外有序数组的累和要比无序的快很多，也是因为高速缓存（这个不太懂原理）</p>
</blockquote>
<h3 id="Gauss-消元法浮点版"><a href="#Gauss-消元法浮点版" class="headerlink" title="Gauss 消元法浮点版"></a>Gauss 消元法浮点版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">Gauss</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; A, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-12</span>;</span><br><span class="line">	<span class="keyword">auto</span> findNonZero = [&amp;](<span class="keyword">int</span> i) &#123; <span class="comment">// 实际上找最大的比较好</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i; row &lt; n; ++row) <span class="keyword">if</span> (<span class="built_in">fabs</span>(A[row][i]) &gt; eps) <span class="keyword">return</span> row;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> triangleGauss = [&amp;](<span class="keyword">int</span> sz) &#123; <span class="comment">// A[i][i] = 1</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x(sz);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">			x[i] = b[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; i; ++row) b[row] -= A[row][i] * x[i];</span><br><span class="line">		&#125;</span><br><span class="line">		x.resize(A[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> sz = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, row; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">			row = findNonZero(i);</span><br><span class="line">			<span class="keyword">if</span> (row != n) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) A[j][i] = A[j][m - <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">std</span>::swap(p[i], p[--m]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = m; row &lt; n; ++row) <span class="keyword">if</span> (<span class="built_in">fabs</span>(b[row])) &#123;</span><br><span class="line">				<span class="comment">// std::cout &lt;&lt; "\nNo answer\n";</span></span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			sz = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (row != i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(A[row], A[i]);</span><br><span class="line">			<span class="built_in">std</span>::swap(b[row], b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		b[i] /= A[i][i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) A[i][j] /= A[i][i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i + <span class="number">1</span>; row &lt; n; ++row) &#123;</span><br><span class="line">			b[row] -= A[row][i] * b[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">				A[row][j] -= A[row][i] * A[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if (sz != A[0].size()) std::cout &lt;&lt; "\nInfinite answer\n";</span></span><br><span class="line">	<span class="keyword">auto</span> xt = triangleGauss(sz);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); ++t) x[p[t]] = xt[t];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Gauss-消元法有限域版"><a href="#Gauss-消元法有限域版" class="headerlink" title="Gauss 消元法有限域版"></a>Gauss 消元法有限域版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make sure 0 &lt;= A[i][j], b[i] &lt; M</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">Gauss</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&gt; A, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;LL(LL)&gt; inv = [&amp;](LL a) -&gt; LL &#123;</span><br><span class="line">		<span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (M - M / a) * inv(M % a) % M; </span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> sub = [](LL &amp;x, LL y) &#123;</span><br><span class="line">		(x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += M);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> triangleGauss = [&amp;](<span class="keyword">int</span> sz) &#123; <span class="comment">// A[i][i] = 1</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; x(sz);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">			x[i] = (b[i] + M) % M;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; i; ++row) sub(b[row], A[row][i] * x[i] % M);</span><br><span class="line">		&#125;</span><br><span class="line">		x.resize(A[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> findNonZero = [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i; row &lt; n; ++row) <span class="keyword">if</span> (A[row][i]) <span class="keyword">return</span> row;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> sz = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, row; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">			row = findNonZero(i);</span><br><span class="line">			<span class="keyword">if</span> (row != n) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) A[j][i] = A[j][m - <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">std</span>::swap(p[i], p[--m]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = m; row &lt; n; ++row) <span class="keyword">if</span> (b[row]) &#123;</span><br><span class="line">				<span class="comment">// std::cout &lt;&lt; "\nNo answer\n";</span></span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			sz = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (row != i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(A[i], A[row]);</span><br><span class="line">			<span class="built_in">std</span>::swap(b[i], b[row]);</span><br><span class="line">		&#125;</span><br><span class="line">		LL inva = inv(A[i][i]);</span><br><span class="line">		(b[i] *= inva) %= M;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) (A[i][j] *= inva) %= M;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i + <span class="number">1</span>; row &lt; n; ++row) &#123;</span><br><span class="line">			sub(b[row], A[row][i] * b[i] % M);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">				sub(A[row][j], A[row][i] * A[i][j] % M);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if (sz != A[0].size()) std::cout &lt;&lt; "\nInfinite answer\n";</span></span><br><span class="line">	<span class="keyword">auto</span> xt = triangleGauss(sz);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); ++t) x[p[t]] = xt[t];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="：例题"><a href="#：例题" class="headerlink" title="：例题"></a><a href="/simplex/" title="线性规划单纯形法">线性规划单纯形法</a>：<a href="https://vjudge.net/problem/Kattis-cheeseifyouplease" target="_blank" rel="noopener">例题</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> VD = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1e10</span>;</span><br><span class="line"><span class="comment">// make sure that A = (I, A') and b &gt;= 0, compute max cx</span></span><br><span class="line"><span class="function">VD <span class="title">simplexCore</span><span class="params">(VD c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; A, VD b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i].emplace_back(b[i]);</span><br><span class="line">	c.emplace_back(<span class="number">0</span>);</span><br><span class="line">	A.emplace_back(c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			A[n][j] -= A[n][i] * A[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> check = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt; m; ++j) <span class="keyword">if</span> (A[n][j] &gt; eps) &#123;</span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (A[i][j] &gt; eps) &#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> ch = <span class="built_in">std</span>::max_element(A[n].<span class="built_in">begin</span>() + n, A[n].<span class="built_in">begin</span>() + m) - A[n].<span class="built_in">begin</span>(), hc;</span><br><span class="line">		<span class="keyword">if</span> (A[n][ch] &lt; eps) <span class="keyword">break</span>;	</span><br><span class="line">		assert(check()); <span class="comment">// otherwise unbounded, no max solution</span></span><br><span class="line">		<span class="keyword">double</span> theta = DBL_MAX;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (A[i][ch] &gt; eps &amp;&amp; A[i].back() / A[i][ch] &lt; theta) &#123;</span><br><span class="line">			theta = A[i].back() / A[i][ch];</span><br><span class="line">			hc = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::swap(p[ch], p[hc]);</span><br><span class="line">		<span class="keyword">double</span> tmp = <span class="number">1</span> / A[hc][ch];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) A[hc][j] *= tmp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="keyword">if</span> (i != hc) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) <span class="keyword">if</span> (j != ch) &#123;</span><br><span class="line">				A[i][j] -= A[i][ch] * A[hc][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) A[i][ch] *= -tmp;</span><br><span class="line">		A[hc][ch] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">VD <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) x[p[i]] = A[i].back();</span><br><span class="line">	<span class="comment">// watch(-A.back().back()); // max_val</span></span><br><span class="line">	<span class="keyword">return</span> x; <span class="comment">// point Corresponds to max_val</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// compute max cx, with Aqx = bq and Alq x &lt;= blq, end of 0 can be ommit in A and Aq</span></span><br><span class="line"><span class="function">VD <span class="title">simplex</span><span class="params">(VD c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; Aq, VD bq, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; Alq, VD blq)</span> </span>&#123;</span><br><span class="line">	assert(Aq.<span class="built_in">size</span>() == bq.<span class="built_in">size</span>());</span><br><span class="line">	assert(Alq.<span class="built_in">size</span>() == blq.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">int</span> n = Aq.<span class="built_in">size</span>() + Alq.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> m = c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bq.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (bq[i] &lt; -eps) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : Aq[i]) x = -x;</span><br><span class="line">		bq[i] = -bq[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blq.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (blq[i] &lt; -eps) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : Alq[i]) x = -x;</span><br><span class="line">		++m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; <span class="title">A</span><span class="params">(n, VD(n + m))</span></span>;</span><br><span class="line">	VD f(n + m), b(n);</span><br><span class="line">	<span class="keyword">int</span> now = n + c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Aq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Aq[i].<span class="built_in">size</span>(); ++j) A[i][n + j] = Aq[i][j];</span><br><span class="line">		b[i] = bq[i];</span><br><span class="line">		f[i] = -inf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Alq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Alq[i].<span class="built_in">size</span>(); ++j) A[i + Aq.<span class="built_in">size</span>()][n + j] = Alq[i][j];</span><br><span class="line">		<span class="keyword">if</span> (blq[i] &lt; -eps) &#123;</span><br><span class="line">			A[i + Aq.<span class="built_in">size</span>()][now++] = <span class="number">-1</span>;</span><br><span class="line">			f[i + Aq.<span class="built_in">size</span>()] = -inf;</span><br><span class="line">		&#125;</span><br><span class="line">		b[i + Aq.<span class="built_in">size</span>()] = <span class="built_in">fabs</span>(blq[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); ++i) f[n + i] = c[i];</span><br><span class="line">	<span class="keyword">auto</span> x = simplexCore(f, A, b);</span><br><span class="line">	<span class="keyword">return</span> VD(x.<span class="built_in">begin</span>() + n, x.<span class="built_in">begin</span>() + n + c.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><p>$n$ 个变量，$m$ 个约束条件，每个约束条件都形如 $x_i - x_j \leq c_k$，此时我们从节点 j 向 i 连一条长度为 $c_k$ 的有向边，（如果有等于号，我们就连两条），设 <code>dist[0] = 0</code>，然后 0 节点向所有节点连一条长度为 0 的有向边。跑单源最短路，如果环中有负环，那么无解，否则 $x_i = dist[i]$ 为一组解。</p>
<p>可用图论中 Bellman-Ford 算法，或 spfa（随笔图跑的快），例题：<a href="https://www.luogu.com.cn/problem/P1993" target="_blank" rel="noopener">LOJ P1993</a>，<a href="https://www.luogu.com.cn/record/46227278" target="_blank" rel="noopener">spfa 做法</a>，<a href="https://www.luogu.com.cn/record/46228308" target="_blank" rel="noopener">Bellman-Ford 做法</a></p>
<blockquote>
<p>变式：$\frac{x_i}{x_j} \leq c_k$（取 log 即可）</p>
</blockquote>
<h3 id="求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法"><a href="#求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法" class="headerlink" title="求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法"></a>求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1003</span>;</span><br><span class="line">LL c[M], ans[<span class="number">2</span> * M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecSeq</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LL a[<span class="number">2</span> * M];</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	RecSeq(<span class="keyword">int</span> _m, LL x = <span class="number">0</span>): m(_m) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> (a));</span><br><span class="line">		a[<span class="number">0</span>] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	RecSeq <span class="keyword">operator</span> * (<span class="keyword">const</span> RecSeq &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">RecSeq <span class="title">R</span><span class="params">(m)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">				R.a[i + j] = (R.a[i + j] + a[i] * A.a[j]) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * m - <span class="number">2</span>; i &gt;= m; --i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">				R.a[i - m + j] += (R.a[i] * c[j]) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">			R.a[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			R.a[i] %= mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">	<span class="function">T <span class="title">tPow</span><span class="params">(T &amp; A, LL n)</span> </span>&#123;</span><br><span class="line">		<span class="function">T <span class="title">R</span><span class="params">(A.m, <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n &amp; <span class="number">1</span>) R = R * A;</span><br><span class="line">			n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			A = A * A;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initC</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> (c));</span><br><span class="line">	c[<span class="number">0</span>] = c[m - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		ans[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[m] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt; <span class="number">2</span> * m; ++i) &#123;</span><br><span class="line">		ans[i] = ans[i - <span class="number">1</span>] + ans[i - m];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(LL n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	initC(m);</span><br><span class="line">	<span class="function">RecSeq <span class="title">A</span><span class="params">(m)</span></span>;</span><br><span class="line">	A.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	RecSeq R = tPow(A, n - m);</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		r += (R.a[i] * ans[i + m]) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用<a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">多项式带模除法：Division with remainder</a>的 $O(m \log m)$ 算法，可优化到 $O(m \log m \log n)$，</p>
<p>但是如果递推关系中仅有常数个不为 0，比如通常是两个，也可以不用多项式带模除法来搞，只需 NFT 就可以优化到 $O(m \log m \log n + m^2)$ （暂时不知道如何去掉 $m^2$）</p>
</blockquote>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="/nimSgFunction/" title="博弈">博弈</a></h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="并查集（Disjoint-Set-Union）"><a href="#并查集（Disjoint-Set-Union）" class="headerlink" title="并查集（Disjoint Set Union）"></a>并查集（Disjoint Set Union）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始情形: p[i] = i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// p[find(j)] = p[find(i)];</span></span><br><span class="line">	<span class="comment">// In general we should write below, and merge small to big</span></span><br><span class="line">	<span class="comment">// int fi = find(i), fj = find(j);</span></span><br><span class="line">	<span class="comment">// if (fi != fj) p[fi] = fj;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回的是离散化之后的数组值对应的原始值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">discrete</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> b = a;</span><br><span class="line">	<span class="built_in">std</span>::sort(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">	b.erase(<span class="built_in">std</span>::unique(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">r</span><span class="params">(b.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : a) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="built_in">std</span>::lower_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), x) - b.<span class="built_in">begin</span>();</span><br><span class="line">		r[id] = x;</span><br><span class="line">		x = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h3><ol>
<li>直接求 $O(n^2)$ 没啥好写的。</li>
<li>把原数组每个位置进行编号，排序，然后每次把最大的数的编号丢进树状数组中，丢进去先看这个编号前面有多少个数，累加一下就可以了，$O(n^2)$，结合下面树状数组的知识还是很简单的。</li>
<li>带离散化的树状数组（就是如果元素的数值特别大，树状数组内存就不够了，所以需要离散化一下）</li>
<li>归并的求（不会也不想搞 0.0）</li>
<li>逐位处理（代码如下）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// all number in a are nonegetive</span></span><br><span class="line"><span class="function">LL <span class="title">inverseNumber</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> dn = <span class="built_in">std</span>::<span class="built_in">log</span>(*<span class="built_in">std</span>::max_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>())) + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= dn; ++d) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(),[&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">			<span class="keyword">return</span> (a[i] &gt;&gt; d) &lt; (a[j] &gt;&gt; d) || ((a[i] &gt;&gt; d) == (a[j] &gt;&gt; d) &amp;&amp; i &lt; j);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i = j) &#123;</span><br><span class="line">			<span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; n &amp;&amp; (a[p[i]] &gt;&gt; d) == (a[p[j]] &gt;&gt; d)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[p[j]] &gt;&gt; (d - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">					++x1;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					r += x1;</span><br><span class="line">				&#125;</span><br><span class="line">				++j;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组（单点更新，从-1-到某个位置的最小值）"><a href="#树状数组（单点更新，从-1-到某个位置的最小值）" class="headerlink" title="树状数组（单点更新，从 1 到某个位置的最小值）"></a>树状数组（单点更新，从 1 到某个位置的最小值）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArrayMin</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	TreeArrayMin() &#123;&#125;</span><br><span class="line">	TreeArrayMin(<span class="keyword">int</span> n) : s(n + <span class="number">1</span>, INT_MAX) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			s[id] = <span class="built_in">std</span>::<span class="built_in">min</span>(s[id], p);</span><br><span class="line">			id += lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算区间 [1, id] 的最小值</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> r = INT_MAX;</span><br><span class="line">		<span class="keyword">while</span> (id) &#123;</span><br><span class="line">			r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, s[id]);</span><br><span class="line">			id -= lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组（单点更新，区间求和，编号从-1-开始）"><a href="#树状数组（单点更新，区间求和，编号从-1-开始）" class="headerlink" title="树状数组（单点更新，区间求和，编号从 1 开始）"></a>树状数组（单点更新，区间求和，编号从 1 开始）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; s;</span><br><span class="line">	TreeArray() &#123;&#125;</span><br><span class="line">	TreeArray(<span class="keyword">int</span> n) : s(n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			s[id] += p;</span><br><span class="line">			id += lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (id) &#123;</span><br><span class="line">			r += s[id];</span><br><span class="line">			id -= lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find minimal index s.t. sum(id) &gt;= x, sum must be increased</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(LL val)</span> </span>&#123;</span><br><span class="line">		LL sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">std</span>::__lg(s.<span class="built_in">size</span>()); ~i; --i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (id + (<span class="number">1</span> &lt;&lt; i) &lt; s.<span class="built_in">size</span>() &amp;&amp; sum + s[id + (<span class="number">1</span> &lt;&lt; i)] &lt; val) &#123;</span><br><span class="line">				id += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">				sum += s[id];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ++id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理解了树状数组存储方式就能掌握上述 $O(n)$ 的搜索技巧，并且由此我们可以用树状数组 O(n \log n) 求动态第 k 大的值，并且如果元素很大，那么我们可以离线后离散化再建树状数组。</p>
</blockquote>
<h3 id="树状数组（区间更新，区间求和，编号从-1-开始）"><a href="#树状数组（区间更新，区间求和，编号从-1-开始）" class="headerlink" title="树状数组（区间更新，区间求和，编号从 1 开始）"></a>树状数组（区间更新，区间求和，编号从 1 开始）</h3><p>有了单点更新的树状数组，只需简单利用差分就可以变成区间的更新了。<br>设原始数组为 <code>a[1 ~ n]</code>， 定义 <code>c[i] = a[i] - a[i - 1], (a[0] = 0)</code> 显然</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^m a_i = \sum_{i = 1}^m (m - i + 1) c_i = m \sum_{i = 1}^m c_i - \sum_{i = 1}^m (i - 1) c_i</script><p>比如对区间 <code>[l, r]</code> 做更新，那么就只需更新两点：<code>r + 1, l</code> ，套用之前的类就行了。</p>
<blockquote>
<p>注意在树状数组中搜索本来应该是 $O(\log ^2 n)$，但是因为在 $2^i$ 的位置搜索时，一步到位。所以复杂度会降到 $O(\log n)$：<a href="https://codeforces.com/blog/entry/61364" target="_blank" rel="noopener">理论依据</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeArrayPlus</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// c[i] = a[i] - a[i - 1], b_i = (i - 1) * c_i</span></span><br><span class="line">	TreeArray B, C;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		C.add(id, p);</span><br><span class="line">		B.add(id, (id - <span class="number">1</span>) * p);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	TreeArrayPlus() &#123;&#125;</span><br><span class="line">	TreeArrayPlus(<span class="keyword">int</span> _n) : n(_n), B(n), C(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		add(l, p);</span><br><span class="line">		add(r + <span class="number">1</span>, -p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id * C.sum(id) - B.sum(id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sum(r) - sum(l - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find minimal index s.t. sum(id) &gt;= x, sum must be increased</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(LL val)</span> </span>&#123;</span><br><span class="line">		LL sumB = <span class="number">0</span>, sumC = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">std</span>::__lg(n); ~i; --i) <span class="keyword">if</span> (<span class="keyword">int</span> idi = id + (<span class="number">1</span> &lt;&lt; i); idi &lt;= n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (idi * (sumC +  C.s[idi]) - B.s[idi] - sumB &lt; val) &#123;</span><br><span class="line">				id = idi;</span><br><span class="line">				sumB += B.s[id];</span><br><span class="line">				sumC += C.s[id];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ++id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="线段树（正式版）"><a href="#线段树（正式版）" class="headerlink" title="线段树（正式版）"></a>线段树（正式版）</h3><p>首先显然总节点 $m$ 上界为 $4n$，并且可以证明 $\frac{m}{n}$ 的上确界为 $4$，下确界为 $2$ 注意到如果 $n = 2^k + 2^{j + 1}$ 时，则 $m = 2 ^{k + 1} + 2^k + \cdots 2^{k - j} + 1$，所以 $\frac{m}{n} = \frac{4 - 2^{-j} + 2^{-k}}{1 + 2^{j + 1 - k}}$，对任意 $\epsilon &gt; 0$ 存在 $j$ 使得 $4 - 2 ^{-j} &gt; 4 - \epsilon$， 然后让 $k$ 趋于无穷，那么显然 $\frac{m}{n}$ 上极限为 $4$.（$n = 40$ 时， $\frac{m}{n} &gt; 3$，$n = 2^20 + 2^10 = 1049600$ 时，$\frac{m}{n} &gt; 3.99$）</p>
<blockquote>
<p>和与最大值的线段树模板（如果单纯求和，可以用树状数组），现在使用左闭右开线段树，且使用吉老师 pushTag 版本</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mn, tag;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; sm;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lson l, m, 2 * p</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, 2 * p + 1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mn.resize(<span class="number">4</span> * n);</span><br><span class="line">		tag.resize(<span class="number">4</span> * n);</span><br><span class="line">		sm.resize(<span class="number">4</span> * n);</span><br><span class="line">	&#125;</span><br><span class="line">	SegmentTree(<span class="keyword">int</span> _n) : n(_n) &#123;</span><br><span class="line">		resize();</span><br><span class="line">	&#125;</span><br><span class="line">	SegmentTree(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a) &#123;</span><br><span class="line">		n = a.<span class="built_in">size</span>();</span><br><span class="line">		resize();</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; build = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p) &#123;</span><br><span class="line">			<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">				mn[p] = sm[p] = a[l - <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">			build(lson);</span><br><span class="line">			build(rson);</span><br><span class="line">			pull(p);</span><br><span class="line">		&#125;;</span><br><span class="line">		build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		mn[p] = <span class="built_in">std</span>::<span class="built_in">min</span>(mn[<span class="number">2</span> * p], mn[<span class="number">2</span> * p + <span class="number">1</span>]);</span><br><span class="line">		sm[p] = sm[<span class="number">2</span> * p] + sm[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (tag[p]) &#123;</span><br><span class="line">			<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">			<span class="built_in">set</span>(lson, tag[p]);</span><br><span class="line">			<span class="built_in">set</span>(rson, tag[p]);</span><br><span class="line">			tag[p] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		tag[p] = mn[p] = v;</span><br><span class="line">		sm[p] = LL(r - l + <span class="number">1</span>) * v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rangeSet</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;</span><br><span class="line">			<span class="built_in">set</span>(l, r, p, v);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		push(l, r, p);</span><br><span class="line">		<span class="keyword">if</span> (L &lt;= m) rangeSet(L, R, v, lson);</span><br><span class="line">		<span class="keyword">if</span> (R &gt; m) rangeSet(L, R, v, rson);</span><br><span class="line">		pull(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以下内容根据需要修改</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>&amp; y, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mn[p] &gt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= l &amp;&amp; sm[p] &lt;= y) &#123;</span><br><span class="line">			y -= sm[p];</span><br><span class="line">			<span class="keyword">return</span> r - l + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		push(l, r, p);</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= m) ans += query(x, y, lson); </span><br><span class="line">		ans += query(x, y, rson);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">bounded</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mn[p] &gt;= v) <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (mn[<span class="number">2</span> * p] &gt;= v) <span class="keyword">return</span> bounded(v, rson);</span><br><span class="line">		<span class="keyword">return</span> bounded(v, lson);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = bounded(y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (l &lt;= x) rangeSet(l, x, y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> query(x, y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码参考了 Jiangly 的模板，他的是左闭右开的。</p>
</blockquote>
<h3 id="线段树-（弃用版）"><a href="#线段树-（弃用版）" class="headerlink" title="线段树 （弃用版）"></a>线段树 （弃用版）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, lrt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rrt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">LL sum[N * <span class="number">3</span>], col[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	sum[rt] = sum[lrt] + sum[rrt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (col[rt]) &#123;</span><br><span class="line">		col[lrt] += col[rt];</span><br><span class="line">		col[rrt] += col[rt];</span><br><span class="line">		sum[lrt] += (m - (m &gt;&gt; <span class="number">1</span>)) * col[rt];</span><br><span class="line">		sum[rrt] += (m &gt;&gt; <span class="number">1</span>) * col[rt];</span><br><span class="line">		col[rt] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp; sum[rt]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	col[rt] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(lson);</span><br><span class="line">	build(rson);</span><br><span class="line">	pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;</span><br><span class="line">		sum[rt] += p * (r - l + <span class="number">1</span>);</span><br><span class="line">		col[rt] += p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= m) update(L, R, p, lson);</span><br><span class="line">	<span class="keyword">if</span> (R &gt; m) update(L, R, p, rson);</span><br><span class="line">	pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> sum[rt];</span><br><span class="line">	pushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= m) ans += query(L, R, lson);</span><br><span class="line">	<span class="keyword">if</span> (R &gt; m) ans += query(L, R, rson);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>吊打线段树的 <a href="https://blog.csdn.net/CC_dsm/article/details/98166835" target="_blank" rel="noopener">珂朵莉树（Chtholly Tree）</a></p>
</blockquote>
<h3 id="RMQ-求区间最大值（弃用，RMQ-和-spfa-已经死了）"><a href="#RMQ-求区间最大值（弃用，RMQ-和-spfa-已经死了）" class="headerlink" title="RMQ 求区间最大值（弃用，RMQ 和 spfa 已经死了）"></a>RMQ 求区间最大值（弃用，RMQ 和 spfa 已经死了）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMQ</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> a[N][<span class="number">20</span>]; <span class="comment">//a[i][j]=max(s[i]---s[i+2^j-1])</span></span><br><span class="line">	RMQ(<span class="keyword">int</span> * s, <span class="keyword">int</span> _n): n(_n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) a[i][<span class="number">0</span>] = s[i];</span><br><span class="line">		<span class="keyword">int</span> len = (<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(n)) / <span class="built_in">log</span>(<span class="number">2.0</span>)) + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != len; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - (<span class="number">1</span> &lt;&lt; i); ++j) &#123;</span><br><span class="line">				a[j][i] = <span class="built_in">max</span>(a[j][i - <span class="number">1</span>], a[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 0 &lt;= l &lt;= r &lt; n</span></span><br><span class="line">		<span class="keyword">int</span> len = (<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(r - l + <span class="number">1</span>)) / <span class="built_in">log</span>(<span class="number">2.0</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(a[l][len], a[r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们经常用二分答案的思想， 但是其实二分答案是仅仅知道其单调的情况下的策略，实际上，对于具体的问题， 我们完全可以对 $m$ 的值进行不同的处理， 而非单纯的 $m = (l + r) &gt;&gt; 1 $。</p>
</blockquote>
<h3 id="三分法简单版"><a href="#三分法简单版" class="headerlink" title="三分法简单版"></a><a href="https://codeforces.com/contest/439/problem/D" target="_blank" rel="noopener">三分法简单版</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for a given covex function f: (f(a) + f(b)) / 2 &gt;= f((a + b) / 2)</span></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span> (r &gt; l) &#123;</span><br><span class="line">	<span class="keyword">int</span> m = (r - l) / <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> lm = l + m, rm = r - m;</span><br><span class="line">	<span class="keyword">if</span> (f(lm) &lt; f(rm)) r = rm - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> l = lm + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<h3 id="标准三分法用黄金分割的原因"><a href="#标准三分法用黄金分割的原因" class="headerlink" title="标准三分法用黄金分割的原因"></a>标准三分法用黄金分割的原因</h3><p>我们不妨设原始区间为 <code>[0, 1]</code>，我们在其中选两个点 <code>0 &lt; a &lt; b &lt; 1</code>，然后比较 <code>f(a)</code> 和 <code>f(b)</code>，然后再相应改变区间。然后重复上述过程。如果我们能充分利用计算过的值，也就是说假设更新后的区间为 <code>[0, b]</code> 那么我们自然想让 <code>a</code> 的计算值充分被利用，所以我们想再选的两个点的其中一个是 <code>a</code>，如果更新后区间为 <code>[a, 1]</code> 同理。也就是说我们有策略</p>
<script type="math/tex; mode=display">
\frac{a}{b} = b, \frac{b - a}{1 - a} = a</script><p>化简可得 $b(1 + b) = 1$，即 $b = \frac{\sqrt{5} - 1}{2}, a = b ^ 2 = \frac{3 - \sqrt{5}}{2} = 1 - b$。</p>
<blockquote>
<p>注意到上述 $b$ 的值正好是黄金分割 0.618…</p>
</blockquote>
<h3 id="三分法黄金分割版（可用版）"><a href="#三分法黄金分割版（可用版）" class="headerlink" title="三分法黄金分割版（可用版）)"></a><a href="(https://codeforces.com/contest/439/problem/D">三分法黄金分割版（可用版）</a>)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for a given covex function f: (f(a) + f(b)) / 2 &gt;= f((a + b) / 2)</span></span><br><span class="line"><span class="keyword">auto</span> tupleCut = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> phiL = (<span class="number">3</span> - <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">5</span>)) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> phiR = (<span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">5</span>) - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">auto</span> getLeft = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l + (r - l) * phiL;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> getRight = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l + (r - l) * phiR;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> lm = getLeft(l, r), rm = getRight(l, r);</span><br><span class="line">	LL fl = f(lm), fr = f(rm);</span><br><span class="line">	<span class="keyword">while</span> (r - l &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fl &lt; fr) &#123;</span><br><span class="line">			r = rm;</span><br><span class="line">			rm = lm;</span><br><span class="line">			fr = fl;</span><br><span class="line">			fl = f(lm = getRight(l, rm));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			l = lm;</span><br><span class="line">			lm = rm;</span><br><span class="line">			fl = fr;</span><br><span class="line">			fr = f(rm = getLeft(lm, r));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fl = f(l), fr = f(r);</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fl &lt; fr) fr = f(--r);</span><br><span class="line">		<span class="keyword">else</span> fl = f(++l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意返回的是最值而不是最值点</p>
<p>注意到一定要用上述写法，由于取整带来的误差，所以必须充分利用“左分点”是“右分点”的“右分点”，“右分点”是“左分点”的“左分点”（用来保证 $l \leq lm \leq rm \leq r$），然后如果单次求 $f$ 的复杂度特别高，两段各自最后一步也是可以优化一下，少算一次 $f$，但是会很不优雅，所以还是算了。</p>
</blockquote>
<h3 id="subarray（连续部分）-VS-subsequence（不要求连续部分）"><a href="#subarray（连续部分）-VS-subsequence（不要求连续部分）" class="headerlink" title="subarray（连续部分） VS subsequence（不要求连续部分）"></a>subarray（连续部分） VS subsequence（不要求连续部分）</h3><h3 id="最长（严格）递增子序列"><a href="#最长（严格）递增子序列" class="headerlink" title="最长（严格）递增子序列"></a>最长（严格）递增子序列</h3><blockquote>
<p>下面数组 <code>b</code> 的意义：<code>b[i]</code> 表示当前长为 <code>i</code> 的子列的末位的最小值。<br>这个子序列还能给附加限制（比如都要大于某个值）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123; <span class="comment">// length of longest increasing subsquence</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::lower_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), x); it == b.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			b.emplace_back(x);</span><br><span class="line">		&#125; <span class="keyword">else</span> *it = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LNDS</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123; <span class="comment">// length of longest increasing subsquence</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::upper_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), x); it == b.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			b.emplace_back(x);</span><br><span class="line">		&#125; <span class="keyword">else</span> *it = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LISP</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123; <span class="comment">// longest increasing subsquence</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b, pb, pa(a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">std</span>::iota(pa.<span class="built_in">begin</span>(), pa.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::upper_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), a[i]); it == b.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!pb.empty()) pa[i] = pb.back();</span><br><span class="line">			b.emplace_back(a[i]);</span><br><span class="line">			pb.emplace_back(i);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			*it = a[i];</span><br><span class="line">			<span class="keyword">int</span> t = it - b.<span class="built_in">begin</span>();</span><br><span class="line">			pb[t] = i;</span><br><span class="line">			<span class="keyword">if</span> (t &gt; <span class="number">0</span>) pa[i] = pb[t - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">	<span class="keyword">int</span> now = pb.back();</span><br><span class="line">	c.push(a[now]);</span><br><span class="line">	<span class="keyword">while</span> (now != pa[now]) &#123;</span><br><span class="line">		now = pa[now];</span><br><span class="line">		c.push(a[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lower_bound(first,end,val) 表示在单增 [frist,end) 中首次大于等于 val 的位置</span></span><br><span class="line"><span class="comment">// upper_bound(first,end,val) 表示在单增 [frist,end) 中首次大于 val 的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> r[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pack</span><span class="params">(<span class="keyword">int</span> cash, <span class="keyword">int</span> num, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">0</span> || w == <span class="number">0</span> || v == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">1</span>) &#123; <span class="comment">//  0-1背包</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = cash; i &gt;= v; --i)</span><br><span class="line">			r[i] = <span class="built_in">max</span>(r[i], r[i - v] + w);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num * v &gt;= cash - v + <span class="number">1</span>) &#123; <span class="comment">//完全背包</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = v; i &lt;= cash; ++i)</span><br><span class="line">			r[i] = <span class="built_in">max</span>(r[i], r[i - v] + w);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> q[MAX], s[MAX], head, tail;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123; <span class="comment">//多重背包</span></span><br><span class="line">		q[<span class="number">0</span>] = r[j];</span><br><span class="line">		s[<span class="number">0</span>] = head = tail = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = j + v; k &lt;= cash; ++i, k += v) &#123;</span><br><span class="line">			q[i] = r[k] - i * w;</span><br><span class="line">			<span class="keyword">while</span> (s[head] &lt; i - num) ++head;</span><br><span class="line">			<span class="keyword">while</span> (head &lt;= tail &amp;&amp; q[tail] &lt; q[i]) --tail;</span><br><span class="line">			s[++tail] = i;</span><br><span class="line">			q[tail] = q[i];</span><br><span class="line">			r[k] = q[head] + i * w;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆与-STL-优先队列"><a href="#堆与-STL-优先队列" class="headerlink" title="堆与 STL 优先队列"></a>堆与 STL 优先队列</h3><p>可以使用 <a href="http: //www.cplusplus.com/reference/">C++STL</a> 的 priority_queue，查找可用 lower_bound 和 upper_bound。C++ STL 中优先队列是用堆来实现的。用途十分广泛，例如加速最小生成树，拓扑排序，等等。<br>堆的实现一般是用数组。 我们可以用 1 作为树的根， 对每一个节点 $x$， 它的两个节点分别就是 $2x$ 和 $2x + 1$ 平时都用 <code>x &lt;&lt; 1, x &lt;&lt; 1 | 1</code> 表示。 堆只支持三个操作:</p>
<ol>
<li>插入一个节点(我们实现时是插入最尾部， 这样保证了是一个完全二叉树) $O(\log n)$ </li>
<li>删除最大键值节点（ 删除根元素的值） $O(\log n)$ </li>
<li>输出最大键值节点（ 查看根元素的值） $O(1)$</li>
</ol>
<blockquote>
<p>我掌握的也很喜欢的几个数据结构：<code>单调队列，单调栈，树状数组，堆，线段树，红黑树</code></p>
</blockquote>
<h3 id="单调队列：解决滑动窗口问题（固定长度内的最值问题）"><a href="#单调队列：解决滑动窗口问题（固定长度内的最值问题）" class="headerlink" title="单调队列：解决滑动窗口问题（固定长度内的最值问题）"></a>单调队列：解决滑动窗口问题（固定长度内的最值问题）</h3><p><a href="https://zhuanlan.zhihu.com/p/346354943" target="_blank" rel="noopener">知乎 Pecco</a> 讲的很好（建议直接去看它的讲解）：</p>
<blockquote>
<p>如果一个选手比你小还比你强，你就可以退役了。——单调队列的原理</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求每个长度为 m 的区间最大值的编号</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">monicDequeMax</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!Q.empty() &amp;&amp; i - Q.front() &gt;= m) Q.pop_front();</span><br><span class="line">		<span class="comment">// 如果求最小值，大于号改成小于号即可</span></span><br><span class="line">		<span class="keyword">while</span> (!Q.empty() &amp;&amp; a[i] &gt; a[Q.back()]) Q.pop_back();</span><br><span class="line">		Q.push_back(i);</span><br><span class="line">		<span class="comment">// 如果需要返回值，就在下面加入 a[Q.front()]</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt;= m - <span class="number">1</span>) r.emplace_back(Q.front());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题：<a href="https://www.luogu.com.cn/problem/P2216" target="_blank" rel="noopener">LOJ P2216</a>：这个是二维的，我们可以一维一维的处理</p>
<h3 id="单调队列优化-DP"><a href="#单调队列优化-DP" class="headerlink" title="单调队列优化 DP"></a>单调队列优化 DP</h3><p>例题：<a href="https://www.luogu.com.cn/problem/P2034" target="_blank" rel="noopener">LOJ P2034</a>：取数字使得和最大，但是不能取连续 k 个数</p>
<p>肯定是 dp 问题，如果把 dp[i] 定义成取第 i 个，前 i 个结果的最值，会发现很搞。<br>因此我们反过来考虑。考虑删除若干个数，且删除的间隔不超过 k，求删除的最小和。最终答案就是总和减去最小和。设 <code>dp[i]</code> 表示删除 i，且满足性质的前 i 个数的答案。那么显然     $dp[i] = a[i] i \leq k$，$dp[i] = a[i] + \min_{i - k \leq j \leq i - 1} dp[j]$。注意最终答案不是总和减去 dp 的 最小值，而是 $dp[n - k - 2, \cdots, n - 1]$ 的最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	std::vector&lt;int&gt; a(n), dp(n);</span><br><span class="line">	LL s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		s += x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		dp[i] = a[i];</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k + <span class="number">1</span>) dp[i] += dp[Q.front()];</span><br><span class="line">		<span class="keyword">if</span> (!Q.empty() &amp;&amp; i - Q.front() &gt;= k + <span class="number">1</span>) Q.pop_front();</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty() &amp;&amp; dp[i] &lt;= dp[Q.back()]) Q.pop_back();</span><br><span class="line">		Q.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s - *<span class="built_in">std</span>::min_element(dp.<span class="built_in">end</span>() - k - <span class="number">1</span>, dp.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调栈：形式更简单应用更广"><a href="#单调栈：形式更简单应用更广" class="headerlink" title="单调栈：形式更简单应用更广"></a>单调栈：形式更简单应用更广</h3><p><a href="https://zhuanlan.zhihu.com/p/346536592" target="_blank" rel="noopener">知乎 Pecco</a> 的精彩讲解：维护一个栈，当我们碰上一个新元素，我们知道，越靠近栈顶的元素离新元素位置越近。所以不断比较新元素与栈顶，如果新元素比栈顶大，则可断定新元素就是栈顶的下一个更大元素，于是弹出栈顶并继续比较。直到新元素不比栈顶大，再将新元素压入栈。显然，这样形成的栈是单调递减的。</p>
<p>应用一：求下一个比自身大的元素位置（下可以改成上，大可以改成小）</p>
<p>洛谷模板题：<a href="https://www.luogu.com.cn/problem/P5788" target="_blank" rel="noopener">LOJ P5788</a></p>
<p>应用二：两个元素间所有元素均（不）大/小于这二者。</p>
<p>洛谷进阶题：<a href="https://www.luogu.com.cn/problem/P1823" target="_blank" rel="noopener">LOJ P1823</a>，问有多少对元素，它们之间没有比它们都大的元素。<br>代码放在 <a href="/codeforces/" title="这里了">这里了</a></p>
<h3 id="单调栈优化-DP"><a href="#单调栈优化-DP" class="headerlink" title="单调栈优化 DP"></a>单调栈优化 DP</h3><p>应用一优化 DP 例题：<a href="https://codeforces.com/contest/1313/problem/C2" target="_blank" rel="noopener">1313C2</a>，首先最优答案肯定时先递增后递减的。相当于有一个制高点，枚举制高点，自然有 $O(n^2)$ 的算法。但是可以优化到 $O(n)$<br>代码放在 <a href="/codeforces/" title="这里了">这里了</a></p>
<p>应用二优化 DP 例题：<a href="https://codeforces.com/contest/1407/problem/D" target="_blank" rel="noopener">1407D</a>，每次跳跃，它们之间的元素都严格大于它们或者严格小于它们。首先设 <code>dp[i]</code> 为到达 i 最小跳跃数，那么显然 $\displaystyle dp[i] = \min_{j \to i} dp[j] + 1$。我们可以用两个单调栈来看那些 j 能跳到 i。 <a href="/codeforces/" title="这里了">这里了</a></p>
<h3 id="红黑树-red-black-tree"><a href="#红黑树-red-black-tree" class="headerlink" title="红黑树 red-black tree"></a>红黑树 red-black tree</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBT</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span> elemType;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> RED = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> BLACK = <span class="number">1</span>;</span><br><span class="line">		Node * ch[<span class="number">2</span>], * fa; <span class="comment">// x-&gt;fa-&gt;ch[x-&gt;rs] = x</span></span><br><span class="line">		<span class="keyword">int</span> sz;</span><br><span class="line">		elemType key;</span><br><span class="line">		<span class="keyword">bool</span> color, rs; <span class="comment">// is rightson</span></span><br><span class="line">	&#125;;</span><br><span class="line">	Node * root; <span class="comment">// root has no father</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">faSon</span><span class="params">(Node * x, Node * y, <span class="keyword">bool</span> rs)</span> </span>&#123;</span><br><span class="line">		y-&gt;fa = x;</span><br><span class="line">		y-&gt;rs = rs;</span><br><span class="line">		x-&gt;ch[rs] = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">newNode</span><span class="params">(Node * x, elemType val, <span class="keyword">bool</span> rs)</span> </span>&#123; <span class="comment">// x-&gt;ch[rs]=null</span></span><br><span class="line">		Node * p = <span class="keyword">new</span> Node;</span><br><span class="line">		p-&gt;ch[<span class="number">0</span>] = p-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">		p-&gt;sz = <span class="number">1</span>;</span><br><span class="line">		p-&gt;key = val;</span><br><span class="line">		p-&gt;color = Node::RED;</span><br><span class="line">		faSon(x, p, rs);</span><br><span class="line">		++x-&gt;sz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node * x, <span class="keyword">bool</span> rs)</span> </span>&#123; <span class="comment">// x must not null</span></span><br><span class="line">		Node * y = x-&gt;ch[!rs];</span><br><span class="line">		<span class="keyword">if</span> (y == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x == root) root = y;</span><br><span class="line">		<span class="keyword">else</span> faSon(x-&gt;fa, y, x-&gt;rs);</span><br><span class="line">		faSon(x, y-&gt;ch[rs], !rs);</span><br><span class="line">		faSon(y, x, rs);</span><br><span class="line">		y-&gt;sz = x-&gt;sz;</span><br><span class="line">		x-&gt;sz = x-&gt;ch[<span class="number">0</span>]-&gt;sz + x-&gt;ch[<span class="number">1</span>]-&gt;sz + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insMaintain</span><span class="params">(Node * x)</span> </span>&#123; <span class="comment">// x-&gt;color is RED</span></span><br><span class="line">		<span class="keyword">if</span> (x == root || x-&gt;fa-&gt;color == Node::BLACK) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;fa-&gt;fa-&gt;ch[!x-&gt;fa-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;rs ^ x-&gt;fa-&gt;rs) rotate(x-&gt;fa, x-&gt;fa-&gt;rs);</span><br><span class="line">			<span class="keyword">else</span> x = x-&gt;fa;</span><br><span class="line">			x-&gt;color = Node::BLACK;</span><br><span class="line">			x-&gt;fa-&gt;color = Node::RED;</span><br><span class="line">			rotate(x-&gt;fa, !x-&gt;rs);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			x = x-&gt;fa-&gt;fa;</span><br><span class="line">			x-&gt;color = Node::RED;</span><br><span class="line">			x-&gt;ch[<span class="number">0</span>]-&gt;color = x-&gt;ch[<span class="number">1</span>]-&gt;color = Node::BLACK;</span><br><span class="line">			insMaintain(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase1</span><span class="params">(Node * x, Node * y)</span> </span>&#123;</span><br><span class="line">		y-&gt;color = Node::BLACK;</span><br><span class="line">		y-&gt;fa-&gt;color = Node::RED;</span><br><span class="line">		y = y-&gt;ch[!y-&gt;rs];</span><br><span class="line">		rotate(x-&gt;fa, x-&gt;rs);</span><br><span class="line">		delCase2(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase2</span><span class="params">(Node * x, Node * y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;ch[y-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (y-&gt;ch[!y-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">				y-&gt;color = Node::RED;</span><br><span class="line">				delMaintain(y-&gt;fa);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				y-&gt;color = Node::RED;</span><br><span class="line">				y-&gt;ch[!y-&gt;rs]-&gt;color = Node::BLACK;</span><br><span class="line">				rotate(y, y-&gt;rs);</span><br><span class="line">				delCase3(y-&gt;fa);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> delCase3(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase3</span><span class="params">(Node * y)</span> </span>&#123;</span><br><span class="line">		y-&gt;color = y-&gt;fa-&gt;color;</span><br><span class="line">		y-&gt;ch[y-&gt;rs]-&gt;color = y-&gt;fa-&gt;color = Node::BLACK;</span><br><span class="line">		rotate(y-&gt;fa, !y-&gt;rs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delMaintain</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == root || x == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;color == Node::RED) &#123;</span><br><span class="line">			x-&gt;color = Node::BLACK;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node * y = x-&gt;fa-&gt;ch[!x-&gt;rs];</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;color == Node::RED) delCase1(x, y);</span><br><span class="line">		<span class="keyword">else</span> delCase2(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">pred</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// max elem &lt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &gt; val) <span class="keyword">return</span> pred(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] == null) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">return</span> pred(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">succ</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// min elem &gt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &lt; val) <span class="keyword">return</span> succ(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] == null) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">return</span> succ(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// count elem &lt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &gt; val) <span class="keyword">return</span> rank(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">		<span class="keyword">return</span> x-&gt;ch[<span class="number">0</span>]-&gt;sz + <span class="number">1</span> + rank(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">select</span><span class="params">(Node * x, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// k-th smallest elem</span></span><br><span class="line">		<span class="keyword">if</span> (x == null || x-&gt;sz &lt; k) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">int</span> sz = x-&gt;ch[<span class="number">0</span>]-&gt;sz + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (sz == k) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">if</span> (sz &lt; k) <span class="keyword">return</span> select(x-&gt;ch[<span class="number">1</span>], k - sz);</span><br><span class="line">		<span class="keyword">return</span> select(x-&gt;ch[<span class="number">0</span>], k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) <span class="built_in">clear</span>(x-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) <span class="built_in">clear</span>(x-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x != null) <span class="keyword">delete</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"key = %d, sz = %d "</span>, x-&gt;key, x-&gt;sz);</span><br><span class="line">		<span class="built_in">puts</span>(x-&gt;color == Node::RED ? <span class="string">"RED"</span> : <span class="string">"BLACK"</span>);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) <span class="built_in">print</span>(x-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) <span class="built_in">print</span>(x-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	Node * null;</span><br><span class="line">	RBT() &#123;</span><br><span class="line">		null = <span class="keyword">new</span> Node; <span class="comment">// no key, rs, father</span></span><br><span class="line">		null-&gt;ch[<span class="number">0</span>] = null-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">		null-&gt;sz = <span class="number">0</span>;</span><br><span class="line">		null-&gt;color = Node::BLACK;</span><br><span class="line">		root = null;</span><br><span class="line">		null-&gt;key = INF; <span class="comment">// for convenient</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">search</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		Node * x = root;</span><br><span class="line">		<span class="keyword">while</span> (x != null) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val == x-&gt;key) <span class="keyword">return</span> x;</span><br><span class="line">			x = x-&gt;ch[val &gt;= x-&gt;key];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> null;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">			root = <span class="keyword">new</span> Node; <span class="comment">// no father, rs</span></span><br><span class="line">			root-&gt;ch[<span class="number">0</span>] = root-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">			root-&gt;sz = <span class="number">1</span>;</span><br><span class="line">			root-&gt;color = Node::BLACK;</span><br><span class="line">			root-&gt;key = val;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node * x = root;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;ch[val &gt;= x-&gt;key] != null) &#123;</span><br><span class="line">			++x-&gt;sz;</span><br><span class="line">			x = x-&gt;ch[val &gt;= x-&gt;key];</span><br><span class="line">		&#125;</span><br><span class="line">		newNode(x, val, val &gt;= x-&gt;key);</span><br><span class="line">		insMaintain(x-&gt;ch[val &gt;= x-&gt;key]);</span><br><span class="line">		root-&gt;color = Node::BLACK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		Node * x = search(val), * y;</span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;ch[<span class="number">0</span>] != null || x-&gt;ch[<span class="number">1</span>] != null) &#123;</span><br><span class="line">			<span class="keyword">bool</span> rs = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;ch[rs] == null) rs = !rs;</span><br><span class="line">			y = x-&gt;ch[rs];</span><br><span class="line">			<span class="keyword">while</span> (y-&gt;ch[!rs] != null) y = y-&gt;ch[!rs];</span><br><span class="line">			<span class="built_in">std</span>::swap(x-&gt;key, y-&gt;key);</span><br><span class="line">			x = y;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;color == Node::RED) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		delMaintain(x);</span><br><span class="line">		root-&gt;color = Node::BLACK;</span><br><span class="line">		y = x;</span><br><span class="line">		<span class="keyword">while</span> (y != root) &#123;</span><br><span class="line">			y = y-&gt;fa;</span><br><span class="line">			--y-&gt;sz;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x == root) root = null;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) faSon(x-&gt;fa, x-&gt;ch[<span class="number">0</span>], x-&gt;rs);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) faSon(x-&gt;fa, x-&gt;ch[<span class="number">1</span>], x-&gt;rs);</span><br><span class="line">		<span class="keyword">else</span> x-&gt;fa-&gt;ch[x-&gt;rs] = null;</span><br><span class="line">		<span class="keyword">delete</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">pred</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pred(root, val)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">succ</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> succ(root, val)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rank(root, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> select(root, k)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">clear</span>(root);</span><br><span class="line">		root = null;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> root-&gt;sz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root != null) <span class="built_in">print</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// for particular use</span></span><br><span class="line">		<span class="keyword">return</span> select(root, rank(root, a) + k)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><h3 id="二维凸包正式版"><a href="#二维凸包正式版" class="headerlink" title="二维凸包正式版"></a>二维凸包正式版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Point = <span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLeft</span><span class="params">(<span class="keyword">const</span> Point &amp;op, <span class="keyword">const</span> Point &amp;sp, <span class="keyword">const</span> Point &amp;ep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (sp.first - op.first) * (ep.second - op.second) </span><br><span class="line">	&lt;= (sp.second - op.second) * (ep.first - op.first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; <span class="title">convexHull</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">	p.erase(<span class="built_in">std</span>::unique(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()), p.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; <span class="title">q</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; crossLeft(q[top - <span class="number">1</span>], p[i], q[top - <span class="number">2</span>])) --top;</span><br><span class="line">		q[top++] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = top;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top &gt; len &amp;&amp; crossLeft(q[top - <span class="number">1</span>], p[i], q[top - <span class="number">2</span>])) --top;</span><br><span class="line">		q[top++] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	top -= n &gt; <span class="number">1</span>;</span><br><span class="line">	q.resize(top);</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三维凸包模板可以参考 上交模板</p>
</blockquote>
<h3 id="旋转卡壳求凸包直径（即平面上点的最远欧式距离）"><a href="#旋转卡壳求凸包直径（即平面上点的最远欧式距离）" class="headerlink" title="旋转卡壳求凸包直径（即平面上点的最远欧式距离）"></a>旋转卡壳求凸包直径（即平面上点的最远欧式距离）</h3><ul>
<li>整数版模板例题：<a href="https://www.luogu.com.cn/problem/P1452" target="_blank" rel="noopener">LOJ P1452</a></li>
<li>实数版模板例题：<a href="https://www.luogu.com.cn/problem/P6247" target="_blank" rel="noopener">LOJ P6247</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Point = <span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point &amp;op, <span class="keyword">const</span> Point &amp;sp, <span class="keyword">const</span> Point &amp;ep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (sp.first - op.first) * (ep.second - op.second) </span><br><span class="line">	- (sp.second - op.second) * (ep.first - op.first);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist2</span><span class="params">(<span class="keyword">const</span> Point &amp;p, <span class="keyword">const</span> Point &amp;q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x = q.first - p.first, y = q.second - p.second;</span><br><span class="line">	<span class="keyword">return</span> x * x + y * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">diameter</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> q = convexHull(p);</span><br><span class="line">	<span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (q.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> dist2(q[<span class="number">0</span>], q[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">	q.emplace_back(q[<span class="number">0</span>]);</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (cross(q[i], q[i + <span class="number">1</span>], q[j]) &lt; cross(q[i], q[i + <span class="number">1</span>], q[j + <span class="number">1</span>])) j = (j + <span class="number">1</span>) % n;</span><br><span class="line">		ans = <span class="built_in">std</span>::<span class="built_in">max</span>(&#123;ans, dist2(q[i], q[j]), dist2(q[i + <span class="number">1</span>], q[j])&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Manhattan 距离的话仅需考虑 $x_i + y_i$ 的最大最小值之差 与 $x_i - y_i$ 的最大最小值之差的最大值即可。</p>
</blockquote>
<h3 id="分治法求平面最短距离（任何距离都适用）"><a href="#分治法求平面最短距离（任何距离都适用）" class="headerlink" title="分治法求平面最短距离（任何距离都适用）"></a>分治法求平面最短距离（任何距离都适用）</h3><p>首先根据横坐标排序，然后取中位数假设处理好了左右两边的值，然后合并中间的值，首先距离中心点的横坐标不能超过已知的最小值，然后把筛出来的点按照纵坐标排序，然后 $O(n)$ 更新答案。总题复杂度 $O(n \log^2 n)$，如果使用归并排序理论复杂度为 $O(n \log n)$，但是实际效果并不如直接排序。</p>
<p>例题：[<a href="https://www.luogu.com.cn/problem/P1429" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1429</a>] 和 <a href="https://www.luogu.com.cn/problem/P6247" target="_blank" rel="noopener">LOJ P6247</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Point = <span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="comment">// 这里不要用 dist2，否则很多比较的地方都要平方，反而不优雅了。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span> <span class="params">(<span class="keyword">const</span> Point&amp; p, <span class="keyword">const</span> Point &amp;q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x = q.first - p.first, y = q.second - p.second;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">minDist</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> d = DBL_MAX;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">	<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; merge = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (r - l == <span class="number">2</span>) &#123;</span><br><span class="line">			d = <span class="built_in">std</span>::<span class="built_in">min</span>(d, dist(a[l], a[l + <span class="number">1</span>]));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		merge(l, m);</span><br><span class="line">		merge(m + <span class="number">1</span>, r);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; p;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= l &amp;&amp; a[m].first - a[i].first &lt; d; --i) &#123;</span><br><span class="line">			p.emplace_back(a[i].second, a[i].first);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; r &amp;&amp; a[i].first - a[m].first &lt; d; ++i) &#123;</span><br><span class="line">			p.emplace_back(a[i].second, a[i].first);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; p.<span class="built_in">size</span>() &amp;&amp; p[j].first - p[i].first &lt; d; ++j) &#123;</span><br><span class="line">				d = <span class="built_in">std</span>::<span class="built_in">min</span>(d, dist(p[i], p[j]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	merge(<span class="number">0</span>, n);</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分治法还能求两个点作为对交的矩阵的最大面积（详见 <a href="/dynamicProgramming/" title="动态规划之分治算法">动态规划之分治算法</a>）</p>
</blockquote>
<h3 id="三维偏序之陈丹琪分治（仅支持离线查询，还是直接暴力好用-）"><a href="#三维偏序之陈丹琪分治（仅支持离线查询，还是直接暴力好用-）" class="headerlink" title="三维偏序之陈丹琪分治（仅支持离线查询，还是直接暴力好用~）"></a>三维偏序之陈丹琪分治（仅支持离线查询，还是直接暴力好用~）</h3><blockquote>
<p>如果带更新怎么处理呢？先预处理求出，之后更新一个计算一个更新？（那也不太行呀）</p>
</blockquote>
<p>一般地，我们考虑可以考虑 $k$ 维偏序，设有 $n$ 个 $k$ 维向量，$a_j \leq a_i$ 当且仅当所有的下标都满足小于等于关系，想知道对任意 $i$ 有多少个 $j \neq i$ 使得 $a_j \leq a_i$。</p>
<p>有复杂度 $O(n \log^k n)$ 的算法，因此在 $k &gt; 3$ 时，我们会选择直接 $O(n^2)$ 暴力解决问题（见下小节）。</p>
<ul>
<li>$k = 1$ 时，我们直接排序，假设没有相同元素，那么它们排完序之后的位置就是答案，有相同的数字的话可以先合并，也可以用 <code>upper_bound</code> 查找出结果。复杂度 $O(n \log n)$</li>
<li>$k = 2$ 时，我们先对第一个坐标偏序，再来一个树状数组，一个个的加入元素，加入之前可以查询结果。这也是求逆序数的操作(如果数据值域范围很大，可以离散化处理一下，仅需对要加入树状数组的那一维离散化，排序可以使用下标排序，就可以避免使用 tuple）。</li>
</ul>
<p>因此三维偏序是一个空缺的问题，就有大名鼎鼎的 cdq 分治。</p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/P3810" target="_blank" rel="noopener">LOJ P3810</a>，这个题的<a href="https://www.luogu.com.cn/problem/solution/P3810" target="_blank" rel="noopener">题解</a>中，有人讲的很好，echo6342：</p>
<blockquote>
<p>cdq 分治每次计算前一半对后一半的影响。具体地，假设三维分别是 $x, y, z$，先按 $x$ 排序。分治时每次将前半边、后半边分别按 $y$ 排序。虽然现在 $x$ 的顺序被打乱了，但是前半边还是都小于后半边的，所以要是只计算前半边对后半边的偏序关系，是不会受到 $x$ 的影响的。维护后一半的指针 i，前一半的指针 j，每次将 i 后移一位时，若 $y[j] \leq y[i]$ 则不断后移 j，并不断将 z[j] 加入树状数组。然后再查询树状数组中有多少数小于等于 z[i]。 最后要清空树状数组（注意清空的时候不能直接清空，而是根据更新的命令，反向一次命令来清空，否则一直开树状数组耗时的），还有就是要去重贼麻烦，还是弃用吧。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y, z, id, w;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (x == A.x) <span class="keyword">return</span> y == A.y ? z &lt; A.z : y &lt; A.y;</span><br><span class="line">		<span class="keyword">return</span> x &lt; A.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ans[i] 表示 小于或等于 a[i] 的元素个数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cdq</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; &amp;a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先按照 y 排序，免得后面代码写的太麻烦</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(a.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// 去重操作</span></span><br><span class="line">	<span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i].x != a[i - <span class="number">1</span>].x || a[i].y != a[i - <span class="number">1</span>].y || a[i].z != a[i - <span class="number">1</span>].z) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = i - last - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = last; j &lt; i; ++j) &#123;</span><br><span class="line">				ans[a[j].id] = t;</span><br><span class="line">				a[j].w = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			a[i - <span class="number">1</span>].w = i - last;</span><br><span class="line">			last = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> t = a.<span class="built_in">size</span>() - last - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		ans[a[i].id] = t;</span><br><span class="line">		a[i].w = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a.back().w = a.<span class="built_in">size</span>() - last;</span><br><span class="line">	<span class="function">TreeArray <span class="title">A</span><span class="params">(k)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> cmpy = [](<span class="keyword">const</span> Node &amp;lhs, <span class="keyword">const</span> Node &amp;rhs) &#123;</span><br><span class="line">		<span class="keyword">return</span> lhs.y &lt; rhs.y;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; divide = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		divide(l, m);</span><br><span class="line">		divide(m, r);</span><br><span class="line">		<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>() + l, a.<span class="built_in">begin</span>() + m, cmpy);</span><br><span class="line">		<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>() + m, a.<span class="built_in">begin</span>() + r, cmpy);</span><br><span class="line">		<span class="keyword">int</span> t = l;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; r; ++i) &#123;</span><br><span class="line">			<span class="keyword">while</span> (t &lt; m &amp;&amp; a[t].y &lt;= a[i].y) &#123;</span><br><span class="line">				A.add(a[t].z, a[t].w);</span><br><span class="line">				++t;</span><br><span class="line">			&#125;</span><br><span class="line">			ans[a[i].id] += A.sum(a[i].z);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; t; ++i) A.add(a[i].z, -a[i].w);</span><br><span class="line">	&#125;;</span><br><span class="line">	divide(<span class="number">0</span>, a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="k-维偏序（暴力-bitset-优化，分块时间换空间）-O-frac-k-n-2-w"><a href="#k-维偏序（暴力-bitset-优化，分块时间换空间）-O-frac-k-n-2-w" class="headerlink" title="k 维偏序（暴力 bitset 优化，分块时间换空间） $O(\frac{k n^2}{w})$"></a>k 维偏序（暴力 bitset 优化，分块时间换空间） $O(\frac{k n^2}{w})$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e4</span> + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// a 是 k * n 矩阵表示 n 个 k 维向量，输出每个小于自身的向量个数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partialOrder</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;a)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 直接暴力不太行，所以需要时间换空间，具体说就是分块。</span></span><br><span class="line">	<span class="keyword">int</span> k = a.<span class="built_in">size</span>(), n = a[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">using</span> Node = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; <span class="title">f</span><span class="params">(k, Node(n))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) f[i][j] = &#123;a[i][j], j&#125;;</span><br><span class="line">		<span class="built_in">std</span>::sort(f[i].<span class="built_in">begin</span>(), f[i].<span class="built_in">end</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> sn = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">using</span> Data = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt;&gt;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Data&gt; <span class="title">bs</span><span class="params">(k, Data(n / sn + <span class="number">1</span>))</span></span>;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt; now;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j % sn == <span class="number">0</span>) bs[i][j / sn] = now;</span><br><span class="line">			now.<span class="built_in">set</span>(f[i][j].second);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n % sn == <span class="number">0</span>) bs[i][n / sn] = now;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> getbst = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> val) -&gt; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt; &#123;</span><br><span class="line">		<span class="comment">// 如果求小于或等于的个数，这里要改成 upper_bound 并且要用 INT_MAX，还有最终答案减 1（去掉自身）</span></span><br><span class="line">		<span class="keyword">int</span> j = <span class="built_in">std</span>::lower_bound(f[i].<span class="built_in">begin</span>(), f[i].<span class="built_in">end</span>(), <span class="built_in">std</span>::make_pair(val, INT_MIN)) - f[i].<span class="built_in">begin</span>();</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt; r = bs[i][j / sn];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t = j / sn * sn; t &lt; j; ++t) r.<span class="built_in">set</span>(f[i][t].second);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt; now; now.<span class="built_in">set</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">			now &amp;= getbst(i, a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		r[j] = now.count();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/U66865" target="_blank" rel="noopener">LOJ U66865</a>，可参考 <a href="https://www.cnblogs.com/cjyyb/p/8196312.html" target="_blank" rel="noopener">小蒟蒻 yyb 的博客</a> 中的 ppt 实现。其它例题：<a href="http://cogs.pro:8081/cogs/problem/problem.php?pid=vSJzQVejP" target="_blank" rel="noopener">偏序++</a></p>
<blockquote>
<p>虽然三维偏序问题用 cdq 分治更好，但是用 bitset 暴力过题还是没啥问题的，例如 <a href="https://www.luogu.com.cn/problem/P3810" target="_blank" rel="noopener">LOJ P3810</a></p>
</blockquote>
<h2 id="几类根号算法（原来这个叫整除分块）"><a href="#几类根号算法（原来这个叫整除分块）" class="headerlink" title="几类根号算法（原来这个叫整除分块）"></a>几类根号算法（原来这个叫整除分块）</h2><p>首先注意到 $\max \{x \mid \lfloor \frac{n}{x} \rfloor =  \lfloor \frac{n}{i} \rfloor \} =  \lfloor \frac{ n }{ \lfloor \frac{n}{i} \rfloor } \rfloor$</p>
<p><strong>Proof</strong>：由于 $x \cdot  \lfloor \frac{n}{x} \rfloor \leq n$ 所以 $x \leq \frac{n}{\lfloor \frac{n}{x} \rfloor}$，所以 $x \leq \lfloor \frac{n}{\lfloor \frac{n}{x} \rfloor} \rfloor$，所以取 $x = i$ 和 $x = \lfloor \frac{n}{i} \rfloor$，则 $\lfloor \frac{n}{\lfloor \frac{ n }{ \lfloor \frac{n}{i} \rfloor } \rfloor} \rfloor = \lfloor \frac{n}{i} \rfloor$，另一方面，若 $\lfloor \frac{n}{x} \rfloor =  \lfloor \frac{n}{i} \rfloor$, 则 $x \leq \lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor$，证毕。</p>
<h3 id="s-n-sum-i-1-n-lfloor-frac-n-i-rfloor"><a href="#s-n-sum-i-1-n-lfloor-frac-n-i-rfloor" class="headerlink" title="$ s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $"></a>$ s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	LL sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		sum += LL(j - i + <span class="number">1</span>) * (n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i"><a href="#sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i" class="headerlink" title="$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$"></a>$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// g[i]=f[i]+g[i-1]</span></span><br><span class="line">	LL sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= <span class="built_in">min</span>(n, m); i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = <span class="built_in">min</span>(n / (n / i), m / (m / i);</span><br><span class="line">		sum += LL(n / i) * (m / i) * (g[j] - g[i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题：<a href="https://ac.nowcoder.com/acm/contest/9005/C" target="_blank" rel="noopener">牛客</a>，大致题意是：$n=p \times k + m, 0 \leq m &lt; k$，求 $\sum_{p = 1}^n km$，注意到 $m = n - pk$，所以用上述公式计算即可。</p>
<h3 id="h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor"><a href="#h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor" class="headerlink" title="$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$"></a>$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	<span class="keyword">int</span> r = LL(n) * (n - <span class="number">1</span>) % M * (n - <span class="number">2</span>) % M * inv3 % M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= LL(j - i + <span class="number">1</span>) * getans(n / i) % M;</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>) r += M;</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归算法复杂度分析"><a href="#递归算法复杂度分析" class="headerlink" title="递归算法复杂度分析"></a>递归算法复杂度分析</h2><p>下图取自算法导论</p>
<p><img src= "/img/loading.gif" data-lazy-src="complexAnalysis.png" alt="complexAnalysis"></p>
<h2 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h2><h2 id="日常表白-zly"><a href="#日常表白-zly" class="headerlink" title="日常表白 zly"></a>日常表白 zly</h2></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">dna049</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dna049.com/templateOfCpp/">https://dna049.com/templateOfCpp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dna049.com" target="_blank">dna049</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/rewardAlipay.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/rewardAlipay.png" alt="下次"/></a><div class="post-qr-code-desc">下次</div></li><li class="reward-item"><a href="/img/rewardWechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/rewardWechat.png" alt="一定"/></a><div class="post-qr-code-desc">一定</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/codeStyle/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 代码规范</div></div></a></div><div class="next-post pull-right"><a href="/allTemplate/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">万能通用模板</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/convertChar/" title="转义字符"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-30</div><div class="relatedPosts_title">转义字符</div></div></a></div><div class="relatedPosts_item"><a href="/codeforces/" title="Codeforces 汇总"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-22</div><div class="relatedPosts_title">Codeforces 汇总</div></div></a></div><div class="relatedPosts_item"><a href="/graph/" title="C++ 图论模板"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-26</div><div class="relatedPosts_title">C++ 图论模板</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"> <div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://hexo.io/" target="_blank" title="由 Hexo 强力驱动" data-pjax-state=""><span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://github.com/chachabai/hexo-theme-butterfly" target="_blank" title="主题" data-pjax-state=""><span class="badge-subject">Theme</span><span class="badge-value bg-blueviolet">Butterfly</span></a></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://github.com/" target="_blank" title="静态网页托管于 GitHub Pages 和 Coding Pages" data-pjax-state=""><span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen">GitHub</span></a></div><div class="footer_custom_text"></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="/" target="_blank" title="运行时间" data-pjax-state=""><span class="badge-subject">Since</span><span class="badge-value bg-orange">2015</span></a></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="/" target="_blank" title="本人博客" data-pjax-state=""><span class="badge-subject">Author</span><span class="badge-value bg-gradient">dna049</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'chachabai/chachabai.github.io')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  if (document.querySelector('.utterances-frame')) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    const iframe = document.querySelector('.utterances-frame');
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !false) {
  if (false) loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN@latest/js/fish.js"></script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script></div></body></html>
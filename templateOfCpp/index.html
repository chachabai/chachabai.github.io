<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>dna049 的 C++模板 | dna049</title><meta name="description" content="此处包含 C++ 代码规范，C++ 模板，C++ STL 的使用。 欢迎使用或转载代码块，唯一要求添加一行注释: https:&#x2F;&#x2F;dna049.com  编译器比你想象中的聪明，所以写让 编译器好优化 并且 易读 的代码，很多位运算，除法都是可以被优化的！优质的代码本身就是一种解释，添加完全不必要的注释只会让人恶心以后尽量使用 vector 而非数组，虽然数组长度现在不用一开始给定，但是用 vec"><meta name="keywords" content="C++"><meta name="author" content="dna049"><meta name="copyright" content="dna049"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/dna049.png"><link rel="canonical" href="https://dna049.com/templateOfCpp/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="dna049 的 C++模板"><meta property="og:url" content="https://dna049.com/templateOfCpp/"><meta property="og:site_name" content="dna049"><meta property="og:description" content="此处包含 C++ 代码规范，C++ 模板，C++ STL 的使用。 欢迎使用或转载代码块，唯一要求添加一行注释: https:&#x2F;&#x2F;dna049.com  编译器比你想象中的聪明，所以写让 编译器好优化 并且 易读 的代码，很多位运算，除法都是可以被优化的！优质的代码本身就是一种解释，添加完全不必要的注释只会让人恶心以后尽量使用 vector 而非数组，虽然数组长度现在不用一开始给定，但是用 vec"><meta property="og:image" content="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><meta property="article:published_time" content="2020-07-17T17:25:02.000Z"><meta property="article:modified_time" content="2020-09-13T03:59:51.054Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = '2'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?79cbe4231606af28625413fd5210e0b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '4.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"18px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-13 11:59:51'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="dna049" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/dna049.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">79</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">23</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/templateOfCpp"><i class="fa-fw fas fa-heart"></i><span> C++模板</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-calendar"></i><span> 工具类网站</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-代码规范"><span class="toc-number">1.</span> <span class="toc-text">C++ 代码规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总纲"><span class="toc-number">1.1.</span> <span class="toc-text">总纲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空行"><span class="toc-number">1.2.</span> <span class="toc-text">空行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空格"><span class="toc-number">1.3.</span> <span class="toc-text">空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数和变量"><span class="toc-number">1.4.</span> <span class="toc-text">函数和变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名"><span class="toc-number">1.5.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注释"><span class="toc-number">1.6.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码优先级"><span class="toc-number">1.7.</span> <span class="toc-text">代码优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-的使用"><span class="toc-number">1.8.</span> <span class="toc-text">STL 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码规范的说明"><span class="toc-number">1.9.</span> <span class="toc-text">代码规范的说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-模板-by-dna049"><span class="toc-number">2.</span> <span class="toc-text">C++ 模板 by dna049</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通用代码块"><span class="toc-number">2.1.</span> <span class="toc-text">通用代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int128-的使用"><span class="toc-number">2.2.</span> <span class="toc-text">int128 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#交互式题目模板"><span class="toc-number">2.3.</span> <span class="toc-text">交互式题目模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#负数下标技巧"><span class="toc-number">2.4.</span> <span class="toc-text">负数下标技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优雅的输出技巧"><span class="toc-number">2.5.</span> <span class="toc-text">优雅的输出技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向下取整-lfloor-frac-a-n-rfloor-和-向上取整-lceil-frac-a-n-rceil"><span class="toc-number">2.6.</span> <span class="toc-text">向下取整 $\lfloor \frac{a}{n} \rfloor$ 和 向上取整 $\lceil \frac{a}{n} \rceil$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释"><span class="toc-number">2.7.</span> <span class="toc-text">Barrent reduction 快速模，弃用，因为并不会变快… ：wiki 镜像解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出全排列"><span class="toc-number">2.8.</span> <span class="toc-text">输出全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出全排列对应的-Python-原理版本"><span class="toc-number">2.9.</span> <span class="toc-text">输出全排列对应的 Python 原理版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-模板之初等数论"><span class="toc-number">3.</span> <span class="toc-text">C++ 模板之初等数论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Greatest-Common-divisor"><span class="toc-number">3.1.</span> <span class="toc-text">Greatest Common divisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n"><span class="toc-number">3.2.</span> <span class="toc-text">Sum of least common multiple  $s_n &#x3D;  \sum_{i&#x3D;1} ^n lcm(i,n)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-n-lcm-i-j"><span class="toc-number">3.3.</span> <span class="toc-text">Double sum of least common multiple $ds_n &#x3D; \sum_{1 \leq i \leq j \leq n} ^ n lcm(i,j)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模乘法逆元"><span class="toc-number">3.4.</span> <span class="toc-text">模乘法逆元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速模乘法"><span class="toc-number">3.5.</span> <span class="toc-text">快速模乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速模加法"><span class="toc-number">3.6.</span> <span class="toc-text">快速模加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速模加法下的快速模乘法"><span class="toc-number">3.7.</span> <span class="toc-text">快速模加法下的快速模乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阶乘、组合数、Lucas-定理"><span class="toc-number">3.8.</span> <span class="toc-text">阶乘、组合数、Lucas 定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#乞丐版素数判断"><span class="toc-number">3.9.</span> <span class="toc-text">乞丐版素数判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-n-log-n-素数筛"><span class="toc-number">3.10.</span> <span class="toc-text">$O(n \log n)$ 素数筛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧拉线性素数筛（弃用）"><span class="toc-number">3.11.</span> <span class="toc-text">欧拉线性素数筛（弃用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧拉线性素数筛（正式使用版）"><span class="toc-number">3.12.</span> <span class="toc-text">欧拉线性素数筛（正式使用版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大素数-Miller-Rabin-概率判别法"><span class="toc-number">3.13.</span> <span class="toc-text">大素数 Miller-Rabin 概率判别法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-1-（执行）时间复杂度判断一个数是否为素数"><span class="toc-number">3.14.</span> <span class="toc-text">$O(1)$ （执行）时间复杂度判断一个数是否为素数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-n-最小素因子预处理"><span class="toc-number">3.15.</span> <span class="toc-text">$O(n)$ 最小素因子预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大整数的最小素因子"><span class="toc-number">3.16.</span> <span class="toc-text">大整数的最小素因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mobius-function"><span class="toc-number">3.17.</span> <span class="toc-text">Mobius function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mobius-function-前缀和"><span class="toc-number">3.18.</span> <span class="toc-text">Mobius function 前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Euler-‘s-totient-function"><span class="toc-number">3.19.</span> <span class="toc-text">Euler ‘s totient function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pi-x-函数"><span class="toc-number">3.20.</span> <span class="toc-text">$\pi(x)$ 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pi-x-函数计算的另一种做法"><span class="toc-number">3.21.</span> <span class="toc-text">$\pi(x)$ 函数计算的另一种做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求奇素数的一个原根"><span class="toc-number">3.22.</span> <span class="toc-text">求奇素数的一个原根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数论函数的-Dirichlet-乘积"><span class="toc-number">3.23.</span> <span class="toc-text">数论函数的 Dirichlet 乘积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#"><span class="toc-number">3.24.</span> <span class="toc-text">中国剩余定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#离散对数"><span class="toc-number">3.25.</span> <span class="toc-text">离散对数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模素数开根号"><span class="toc-number">3.26.</span> <span class="toc-text">模素数开根号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自然数方幂和-O-k-算法"><span class="toc-number">3.27.</span> <span class="toc-text">自然数方幂和 $O(k)$ 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自然数方幂和精确版"><span class="toc-number">3.28.</span> <span class="toc-text">自然数方幂和精确版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NFT-正式可用版-last-updated-2020-7-9"><span class="toc-number">3.29.</span> <span class="toc-text">NFT 正式可用版(last updated: 2020&#x2F;7&#x2F;9)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#siyuan-的-FWT-模板"><span class="toc-number">3.30.</span> <span class="toc-text">siyuan 的 FWT 模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#矩阵类"><span class="toc-number">3.31.</span> <span class="toc-text">矩阵类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法"><span class="toc-number">3.32.</span> <span class="toc-text">求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-模板之数据结构"><span class="toc-number">4.</span> <span class="toc-text">C++ 模板之数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并查集"><span class="toc-number">4.1.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树状数组（单点更新，区间求和，编号从-1-开始）"><span class="toc-number">4.2.</span> <span class="toc-text">树状数组（单点更新，区间求和，编号从 1 开始）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树状数组（区间更新，区间求和，编号从-1-开始）"><span class="toc-number">4.3.</span> <span class="toc-text">树状数组（区间更新，区间求和，编号从 1 开始）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线段树"><span class="toc-number">4.4.</span> <span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMQ-求区间最大值"><span class="toc-number">4.5.</span> <span class="toc-text">RMQ 求区间最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">4.6.</span> <span class="toc-text">最长（ 严格） 递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#背包"><span class="toc-number">4.7.</span> <span class="toc-text">背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆与-STL-优先队列"><span class="toc-number">4.8.</span> <span class="toc-text">堆与 STL 优先队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序反字典序输出"><span class="toc-number">4.9.</span> <span class="toc-text">拓扑排序反字典序输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑树-red-black-tree"><span class="toc-number">4.10.</span> <span class="toc-text">红黑树 red-black tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-模板之图论"><span class="toc-number">5.</span> <span class="toc-text">C++ 模板之图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#链式前向星"><span class="toc-number">5.1.</span> <span class="toc-text">链式前向星</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#知乎上看到-YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）"><span class="toc-number">5.2.</span> <span class="toc-text">知乎上看到 YYYYLLL 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs-序"><span class="toc-number">5.3.</span> <span class="toc-text">dfs 序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的直径：先从任意点开始寻找最远距离点（bfs-遍历一下），然后再找一次就是了（易证）"><span class="toc-number">5.4.</span> <span class="toc-text">树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#笛卡尔树-：我去，竟然是-O-n-复杂度的建树"><span class="toc-number">5.5.</span> <span class="toc-text">笛卡尔树 ：我去，竟然是 $O(n)$ 复杂度的建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最大流"><span class="toc-number">5.6.</span> <span class="toc-text">最大流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stoer-Wagner-最小割"><span class="toc-number">5.7.</span> <span class="toc-text">Stoer - Wagner 最小割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短路-SPFA"><span class="toc-number">5.8.</span> <span class="toc-text">最短路 SPFA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维凸包"><span class="toc-number">5.9.</span> <span class="toc-text">二维凸包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几类根号算法"><span class="toc-number">6.</span> <span class="toc-text">几类根号算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#s-n-sum-i-1-n-lfloor-frac-n-i-rfloor"><span class="toc-number">6.1.</span> <span class="toc-text">$ s(n) &#x3D; \sum_{i&#x3D;1}^{n} \lfloor \frac{n}{i} \rfloor $</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i"><span class="toc-number">6.2.</span> <span class="toc-text">$\sum_{i&#x3D;1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor"><span class="toc-number">6.3.</span> <span class="toc-text">$h(n) &#x3D; \frac{n(n-1)(n-2)}{3} - \sum_{i&#x3D;2}^n h(\lfloor \frac{n}{i} \rfloor)$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归算法复杂度分析"><span class="toc-number">7.</span> <span class="toc-text">递归算法复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-学习记录"><span class="toc-number">8.</span> <span class="toc-text">STL 学习记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最大最小值"><span class="toc-number">8.1.</span> <span class="toc-text">最大最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#累积运算-accumulate-（长没关系，有代码补全）"><span class="toc-number">8.2.</span> <span class="toc-text">累积运算  accumulate （长没关系，有代码补全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-number">8.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合交并运算"><span class="toc-number">8.4.</span> <span class="toc-text">集合交并运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda-表达式递归写法"><span class="toc-number">8.5.</span> <span class="toc-text">lambda 表达式递归写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-STL-内建的一些好用的函数"><span class="toc-number">8.6.</span> <span class="toc-text">C++ STL 内建的一些好用的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#To-Be-Continue"><span class="toc-number">9.</span> <span class="toc-text">To Be Continue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日常表白-zly"><span class="toc-number">10.</span> <span class="toc-text">日常表白 zly</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">dna049</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/templateOfCpp"><i class="fa-fw fas fa-heart"></i><span> C++模板</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-calendar"></i><span> 工具类网站</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">dna049 的 C++模板</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-17T17:25:02.000Z" title="发表于 2020-07-18 01:25:02">2020-07-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-13T03:59:51.054Z" title="更新于 2020-09-13 11:59:51">2020-09-13</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>74分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>此处包含 C++ 代码规范，C++ 模板，C++ STL 的使用。</p>
<p><strong>欢迎使用或转载代码块，唯一要求添加一行注释</strong>: <code>https://dna049.com</code></p>
<blockquote>
<p>编译器比你想象中的聪明，所以写让 <strong>编译器好优化</strong> 并且 <strong>易读</strong> 的代码，很多位运算，除法都是可以被优化的！<br>优质的代码本身就是一种解释，添加完全不必要的注释只会让人恶心<br>以后尽量使用 <code>vector</code> 而非数组，虽然数组长度现在不用一开始给定，但是用 <code>vector</code> 结合 <code>C++17</code> 可以简化代码！<br>以前觉得 <code>main</code> 函数 <code>return 0</code> 只是标准写法，现在(2020/5/22)才知道能返回就能提前优雅的结束！<br>全局变量数组元素自动默认初始化为 0，局部变量要加 <code>= {}</code> 才会初始化为 0</p>
</blockquote>
<a id="more"></a>
<h2 id="C-代码规范"><a href="#C-代码规范" class="headerlink" title="C++ 代码规范"></a>C++ 代码规范</h2><p>此规范参考：Codeforces 上 <a href="http://codeforces.com/profile/jiangly" target="_blank" rel="noopener">Jiangly</a> 的码风，<a href="https://oi.men.ci/code-style-oi/" target="_blank" rel="noopener">Menci</a> 代码规范，知乎 <a href="https://www.zhihu.com/question/398008181/answer/1259561408" target="_blank" rel="noopener">pansz</a> 的回答<br>VSCode 的 C_Cpp: Clang_format_style 设置为：<code>{ BasedOnStyle: google, IndentWidth: 4,TabWidth: 4, UseTab: Always, BreakBeforeBraces: Custom, AllowShortIfStatementsOnASingleLine: true, IndentCaseLabels: false }</code></p>
<blockquote>
<p>设置可参考：<a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html" target="_blank" rel="noopener">官方代码风格配置</a></p>
</blockquote>
<h3 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h3><ul>
<li>不再使用 <code>using namespace std</code></li>
<li>不建议使用 <code>#include &lt;bits/stdc++.h&gt;</code></li>
<li>Tab 用于缩进，空格用于对齐（可不对齐）</li>
<li>左大括号不换行（左大括号前有且仅有一个空格）</li>
<li>头文件必须全部写在开头，C 的头文件必须以 c 开头而非<code>.h</code> 结尾</li>
<li><code>main</code> 函数必须在整个程序末尾</li>
<li>常用函数尽量写成类和模板形式</li>
<li>尽量使用 STL 减少代码量</li>
<li>尽量不要用 <code>C-type</code> 代码</li>
</ul>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><ul>
<li>不能有两个连续空行</li>
<li>独立的代码块之间要有空行</li>
<li>头文件块、函数、成员函数、结构体、类，全局变量块之间必须用空行隔开</li>
</ul>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>空格的作用：识别族群的位置</p>
<ul>
<li>前后必须都有空格：冒号、双目运算符、三目运算符</li>
<li>前加后不加：<code>* &amp;</code></li>
<li>后加前不加：关键字，逗号</li>
<li>前后都不加：<code>. -&gt; ::</code></li>
</ul>
<h3 id="函数和变量"><a href="#函数和变量" class="headerlink" title="函数和变量"></a>函数和变量</h3><ul>
<li>传参时按照实际需要传 引用、const 引用、值</li>
<li>尽量不使用全局变量</li>
<li>局部变量在用时定义</li>
<li>在合适的时间使用 <code>static</code> 变量</li>
</ul>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul>
<li>统一使用驼峰命名法</li>
<li>常量，<code>typedef</code> 定义的类型 全部大写</li>
<li>类私有变量以 <code>_</code> 开头</li>
<li>函数和变量统一使用小驼峰</li>
<li>结构和类统一使用大驼峰</li>
<li>以 Core 结尾的核心代码是在约束条件下的高效代码</li>
<li>以 S 结尾的是简单且效率较低的代码</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>代码尽量自注释</li>
<li>在函数最开始注释，解释输入输出变量</li>
</ul>
<h3 id="代码优先级"><a href="#代码优先级" class="headerlink" title="代码优先级"></a>代码优先级</h3><ul>
<li>普通代码：正确，可行，可读，通用</li>
<li>Core 代码：正确，高效，通用，可读</li>
</ul>
<h3 id="STL-的使用"><a href="#STL-的使用" class="headerlink" title="STL 的使用"></a>STL 的使用</h3><ul>
<li><code>vector&lt;bool&gt;</code> 不是 <code>vector</code> 类型，谨慎使用</li>
<li>尽量用 <code>vector</code> 取代用户输入的数组，而非开足够大的数组</li>
<li>尽量使用 <code>emplace_back</code> 取代 <code>push_back</code>，有些取代不了，就不取代了</li>
<li>多使用 <code>pair, tuple, sort, stable_sort, iota, accumulate, for_each, lambda函数</code> 使得代码更加优雅</li>
</ul>
<h3 id="代码规范的说明"><a href="#代码规范的说明" class="headerlink" title="代码规范的说明"></a>代码规范的说明</h3><p>空格的作用是区分，空格缩进理论上是不合理的，<strong>强烈抵制四个空格代替 Tab</strong> </p>
<p>双目运算符两边加空格是为了 区分运算符 和 变量，虽然 <code>a+b</code>（这种代码不必加空格，但是为了养成好习惯，还是加上较好），关键字后面加空格是为了避免像 函数调用</p>
<p>工程中不推荐使用 <code>using namespace std</code> ，而且不用的时候你就会知道一些陌生的函数原来是 <code>std</code> 中的，并且以后修改起来很麻烦</p>
<p>不建议使用万能头文件，但是本人用了是因为，打 CF 等比赛的时候你一个个的敲头文件或者写一大堆头文件，还不如就写这一个，并且以后修改成不用万能头文件也很容易</p>
<p>左空格不换行完全是个人喜好，换不换都可以，固定就好</p>
<p>其它总纲的代码规范完全是为了代码通用美感，大道至简</p>
<p>尽量避免全局变量是因为防止程序不可控，降低代码耦合性，局部变量用的时候定义是为了增加代码可读性，<code>static</code> 变量也是为了避免全局变量</p>
<p>驼峰命名的好处在于 “顾名思义，望文生义”（贬义褒用）<br>遵守代码规范，养成编程好习惯~</p>
<h2 id="C-模板-by-dna049"><a href="#C-模板-by-dna049" class="headerlink" title="C++ 模板 by dna049"></a>C++ 模板 by dna049</h2><h3 id="通用代码块"><a href="#通用代码块" class="headerlink" title="通用代码块"></a>通用代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="comment">//using LL = long long;</span></span><br><span class="line"><span class="keyword">using</span> BI = __int128; <span class="comment">// for g++(64 bit)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> <span class="built_in">end</span> = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time used: "</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;(<span class="built_in">end</span> - start).count() &lt;&lt; <span class="string">" (ms)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/*------ Welcome to my blog: http://dna049.com ------*/</span></span><br><span class="line">                   _ooOoo_</span><br><span class="line">                  o8888888o</span><br><span class="line">                  <span class="number">88</span><span class="string">" . "</span><span class="number">88</span></span><br><span class="line">                  (| -_- |)</span><br><span class="line">                  O\  =  /O</span><br><span class="line">               ____/`---'\____</span><br><span class="line">             <span class="number">.'</span>  \\|     |<span class="comment">//  `.</span></span><br><span class="line">            /  \\|||  :  |||<span class="comment">//  \</span></span><br><span class="line">           /  _||||| -:- |||||-  \</span><br><span class="line">           |   | \\\  -  <span class="comment">/// |   |</span></span><br><span class="line">           | \_|  ''\---/''  |   |</span><br><span class="line">           \  .-\__  `-`  ___/-. /</span><br><span class="line">         ___`. <span class="number">.'</span>  /--.--\  `. . __</span><br><span class="line">      ."" '&lt;  `.___\_&lt;|&gt;_/___.'  &gt;'"".</span><br><span class="line">     | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">     \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">======`-.____`-.___\_____/___.-`____.-'======</span><br><span class="line">                   `=---='</span><br><span class="line">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">            佛祖保佑       永无BUG</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐</span></span><br><span class="line"><span class="comment"> * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐</span></span><br><span class="line"><span class="comment"> * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘</span></span><br><span class="line"><span class="comment"> * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐</span></span><br><span class="line"><span class="comment"> * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │</span></span><br><span class="line"><span class="comment"> * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤</span></span><br><span class="line"><span class="comment"> * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │</span></span><br><span class="line"><span class="comment"> * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │</span></span><br><span class="line"><span class="comment"> * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter  │               │ 4 │ 5 │ 6 │   │</span></span><br><span class="line"><span class="comment"> * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤</span></span><br><span class="line"><span class="comment"> * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │</span></span><br><span class="line"><span class="comment"> * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││</span></span><br><span class="line"><span class="comment"> * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│</span></span><br><span class="line"><span class="comment"> * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="int128-的使用"><a href="#int128-的使用" class="headerlink" title="int128 的使用"></a>int128 的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int128 <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	__int128 x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printS</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) printS(x / <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">		x = -x;</span><br><span class="line">	&#125;</span><br><span class="line">	printS(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	__int128 a = <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">print</span>(a * a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交互式题目模板"><a href="#交互式题目模板" class="headerlink" title="交互式题目模板"></a><a href="https://codeforces.com/blog/entry/45307" target="_blank" rel="noopener">交互式题目模板</a></h3><p><a href="https://codeforces.com/gym/101021/problem/1" target="_blank" rel="noopener">gym101021: Guess the Number</a><br>需要 <code>fflush(stdout);</code> 来刷新缓冲区，不过 <code>std::endl</code> 会自动刷新一次缓冲区，所以此时可以省略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1e6</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'&lt;'</span>) r = m - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="负数下标技巧"><a href="#负数下标技巧" class="headerlink" title="负数下标技巧"></a>负数下标技巧</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> aa[N];</span><br><span class="line"><span class="keyword">int</span> *a = (aa + N / <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="优雅的输出技巧"><a href="#优雅的输出技巧" class="headerlink" title="优雅的输出技巧"></a>优雅的输出技巧</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" \n"</span>[i == n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向下取整-lfloor-frac-a-n-rfloor-和-向上取整-lceil-frac-a-n-rceil"><a href="#向下取整-lfloor-frac-a-n-rfloor-和-向上取整-lceil-frac-a-n-rceil" class="headerlink" title="向下取整 $\lfloor \frac{a}{n} \rfloor$ 和 向上取整 $\lceil \frac{a}{n} \rceil$"></a>向下取整 $\lfloor \frac{a}{n} \rfloor$ 和 向上取整 $\lceil \frac{a}{n} \rceil$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">floor</span><span class="params">(LL a, LL n)</span> </span>&#123; <span class="comment">// n &gt; 0</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; <span class="number">0</span> ? (a - n + <span class="number">1</span>) / n : a / n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ceil</span><span class="params">(LL a, LL n)</span> </span>&#123; <span class="comment">// n &gt; 0</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; <span class="number">0</span> ? a / n : (a + n - <span class="number">1</span>) / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到 C/C++ 中 ，整数除法 <code>/</code> 是向 <code>0</code> 取整(<code>int(x)</code>也是向 0 取整)，但是 Python（Sagemath） 整数除法 <code>//</code> 是向下取整。</p>
</blockquote>
<h3 id="Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释"><a href="#Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释" class="headerlink" title="Barrent reduction 快速模，弃用，因为并不会变快… ：wiki 镜像解释"></a><a href="https://en.wikipedia.org/wiki/Barrett_reduction" target="_blank" rel="noopener">Barrent reduction 快速模，弃用，因为并不会变快…</a> ：<a href="https://en.jinzhao.wiki/wiki/Barrett_reduction" target="_blank" rel="noopener">wiki 镜像解释</a></h3><blockquote>
<p>对于给定常数 $M$ 求 <code>a % M</code>，并要求 $ 0 \leq a &lt; M^2$，并且 $a &lt; 2^k$。因此下面 $k$ 的取值还是需要注意的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> LL M  = <span class="number">1e9</span> + <span class="number">7</span>; <span class="comment">// too big, M should satisfy M * M &lt; int</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span>  k = <span class="built_in">std</span>::__lg(M) + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> LL m = (<span class="number">1L</span>L &lt;&lt; k) / M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> mod = [&amp;](<span class="keyword">int</span> a) &#123;</span><br><span class="line">	LL r = a - ((a * m) &gt;&gt; k) * M;</span><br><span class="line">	<span class="keyword">return</span> r &gt;= M ? r - M : r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="输出全排列"><a href="#输出全排列" class="headerlink" title="输出全排列"></a>输出全排列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x[n];</span><br><span class="line">	<span class="built_in">std</span>::iota(x, x + n, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">std</span>::for_each(x, x + n,[](<span class="keyword">int</span> &amp;i)&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="built_in">std</span>::next_permutation(x, x + n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出全排列对应的-Python-原理版本"><a href="#输出全排列对应的-Python-原理版本" class="headerlink" title="输出全排列对应的 Python 原理版本"></a>输出全排列对应的 Python 原理版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutaion</span><span class="params">(n)</span>:</span></span><br><span class="line">	ans = [list(range(<span class="number">1</span>,n+<span class="number">1</span>))]</span><br><span class="line">	r = list(range(<span class="number">1</span>,n+<span class="number">1</span>))</span><br><span class="line">	<span class="keyword">while</span> list(range(n,<span class="number">0</span>,<span class="number">-1</span>)) != r:</span><br><span class="line">		i = n<span class="number">-1</span></span><br><span class="line">		<span class="keyword">while</span> r[i<span class="number">-1</span>]&gt;r[i]: i-=<span class="number">1</span></span><br><span class="line">		r[i<span class="number">-1</span>],r[i] = r[i],r[i<span class="number">-1</span>]</span><br><span class="line">		b = r.copy()</span><br><span class="line">		ans.append(b)</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">	print(permutaion(i))</span><br></pre></td></tr></table></figure>
<h2 id="C-模板之初等数论"><a href="#C-模板之初等数论" class="headerlink" title="C++ 模板之初等数论"></a>C++ 模板之初等数论</h2><h3 id="Greatest-Common-divisor"><a href="#Greatest-Common-divisor" class="headerlink" title="Greatest Common divisor"></a>Greatest Common divisor</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简洁写法，不推荐，推荐使用内建 __gcd</span></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lambda 表达式写法，开头不能是auto因为递归</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; gcd = [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 快速版本 https://cp-algorithms.com/algebra/euclid-algorithm.html 也没啥用，仅仅记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!a || !b) <span class="keyword">return</span> a | b;</span><br><span class="line">	<span class="keyword">unsigned</span> shift = __builtin_ctz(a | b);</span><br><span class="line">	a &gt;&gt;= __builtin_ctz(a);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		b &gt;&gt;= __builtin_ctz(b);</span><br><span class="line">		<span class="keyword">if</span> (a &gt; b) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">		b -= a;</span><br><span class="line">	&#125; <span class="keyword">while</span> (b);</span><br><span class="line">	<span class="keyword">return</span> a &lt;&lt; shift;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通版拓展GCD</span></span><br><span class="line"><span class="function">LL <span class="title">exGcd</span><span class="params">(LL a, LL b, LL&amp; x, LL&amp; y)</span></span>&#123;  <span class="comment">// ax + by = gcd(a,b)</span></span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">		x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	LL d = exgcd(b, a % b, y, x);</span><br><span class="line">	y -= a / b * x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++17版拓展GCD，优雅了不少!</span></span><br><span class="line">std::tuple&lt;LL, LL, LL&gt; exGcd(LL a, LL b) &#123;  // ax + by = gcd(a,b)</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> &#123;a, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> [d, y, x] = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> &#123;d, x, y - a / b * x&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n"><a href="#Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n" class="headerlink" title="Sum of least common multiple  $s_n =  \sum_{i=1} ^n lcm(i,n)$"></a>Sum of least common multiple  $s_n =  \sum_{i=1} ^n lcm(i,n)$</h3><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1} ^n lcm(i,n) 
&= \sum_{i=1} ^n \frac{i \cdot n}{\gcd(i,n)} \\
&= n \sum_{d|n} \sum_{\gcd(i,\frac{n}{d})= 1} i \\
&= \frac{n}{2} \sum_{d|n} \frac{n}{d} \psi(\frac{n}{d}) \\
&= \frac{n}{2} \sum_{d|n} d \psi(d)
\end{aligned}</script><p>所以，我们可以在 $O(n \log n)$ 处理好 $s_n$ 的前 $n$ 项。</p>
<h3 id="Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-n-lcm-i-j"><a href="#Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-n-lcm-i-j" class="headerlink" title="Double sum of least common multiple $ds_n = \sum_{1 \leq i \leq j \leq n} ^ n lcm(i,j)$"></a>Double sum of least common multiple $ds_n = \sum_{1 \leq i \leq j \leq n} ^ n lcm(i,j)$</h3><p>本来这个也挺麻烦，但是可以借助 $s_n$ 计算：$ds_n =  \sum_{j=1} ^n s_j$，所以复杂度就一致了。当然也可以直接化简成：</p>
<script type="math/tex; mode=display">
\sum_{1 \leq i \leq j \leq n} ^ n lcm(i,j) = \sum_{i = 1} ^ n \frac{i}{4} \psi(i) \lfloor \frac{n}{i} \rfloor (\lfloor \frac{n}{i} \rfloor + 1)</script><blockquote>
<p>不借助 $s_n$ 其实也能暴力搞出来的。</p>
</blockquote>
<h3 id="模乘法逆元"><a href="#模乘法逆元" class="headerlink" title="模乘法逆元"></a>模乘法逆元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a, LL p)</span></span>&#123; <span class="comment">// 0 &lt; a &lt; p and gcd(a,p) = 1</span></span><br><span class="line">	<span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (p - p / a) * inv(p % a, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码主要用于线性时间预处理所有$p$以内的逆元，对于较小的常数$a$, 可以直接试除 <code>b p mod a == 1</code></p>
</blockquote>
<h3 id="快速模乘法"><a href="#快速模乘法" class="headerlink" title="快速模乘法"></a>快速模乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">powMod</span><span class="params">(T x,U n,T p)</span></span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) r = r * x % p;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; x = x * x % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以用for循环写的更短一点，但没必要</span></span><br></pre></td></tr></table></figure>
<h3 id="快速模加法"><a href="#快速模加法" class="headerlink" title="快速模加法"></a>快速模加法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mulMod</span><span class="params">(LL x, LL n, LL p)</span> </span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	x %= p;</span><br><span class="line">	<span class="keyword">auto</span> inc = [&amp;](LL x, LL y) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((x += y) &gt;= p) x-=p;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) inc(r,x);</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; inc(x,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速模加法下的快速模乘法"><a href="#快速模加法下的快速模乘法" class="headerlink" title="快速模加法下的快速模乘法"></a>快速模加法下的快速模乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n, LL p)</span></span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) r = mulmod(r, x, p);</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; x = mulmod(x, x, p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阶乘、组合数、Lucas-定理"><a href="#阶乘、组合数、Lucas-定理" class="headerlink" title="阶乘、组合数、Lucas 定理"></a>阶乘、组合数、Lucas 定理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">2</span>;</span><br><span class="line">LL fac[N], ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">	ifac[N - <span class="number">1</span>] = powMod(fac[N - <span class="number">1</span>], M - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; --i) ifac[i - <span class="number">1</span>] = ifac[i] * i % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//if (n &lt; k) return 0;</span></span><br><span class="line">	<span class="keyword">return</span> fac[n] * ifac[k] % M * ifac[n - k] % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lucas</span><span class="params">(LL n, LL m, LL p)</span> </span>&#123; <span class="comment">// C(n,m)%p, 仅在p较少时发挥作用</span></span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n &amp;&amp; m) &#123;</span><br><span class="line">		LL np = n % p, mp = m % p;</span><br><span class="line">		<span class="keyword">if</span> (np &lt; mp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		r = binom(np, mp);</span><br><span class="line">		n /= p, m /= p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="乞丐版素数判断"><a href="#乞丐版素数判断" class="headerlink" title="乞丐版素数判断"></a>乞丐版素数判断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-n-log-n-素数筛"><a href="#O-n-log-n-素数筛" class="headerlink" title="$O(n \log n)$ 素数筛"></a>$O(n \log n)$ 素数筛</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =  <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> isP[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(isP[<span class="number">2</span>]) <span class="keyword">return</span>;</span><br><span class="line">	isP[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isP[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isP[i]) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span> * i; j &lt; N; j += i * <span class="number">2</span>) &#123;</span><br><span class="line">			isP[j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性素数筛（弃用）"><a href="#欧拉线性素数筛（弃用）" class="headerlink" title="欧拉线性素数筛（弃用）"></a>欧拉线性素数筛（弃用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrimeP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	p.emplace_back(<span class="number">2</span>);</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) p.emplace_back(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j != p.<span class="built_in">size</span>() &amp;&amp; p[j] &lt; t; ++j) &#123; <span class="comment">// 用除号是防止溢出</span></span><br><span class="line">			isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="comment">// 不要下面的一步的话，复杂度 O(nloglogn), 但是不用除法，常数小</span></span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性素数筛（正式使用版）"><a href="#欧拉线性素数筛（正式使用版）" class="headerlink" title="欧拉线性素数筛（正式使用版）"></a>欧拉线性素数筛（正式使用版）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initPrimeP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	p.emplace_back(<span class="number">2</span>);</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> sq = <span class="keyword">int</span>(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(N - <span class="number">1</span>))|<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= sq; i += <span class="number">2</span>) <span class="keyword">if</span> (isp[i]) &#123;</span><br><span class="line">		p.emplace_back(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; N; j += i &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">			isp[j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = sq + <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isp[i]) p.emplace_back(i);</span><br><span class="line">	<span class="keyword">return</span> p.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大素数-Miller-Rabin-概率判别法"><a href="#大素数-Miller-Rabin-概率判别法" class="headerlink" title="大素数 Miller-Rabin 概率判别法"></a><a href="http://blog.miskcoo.com/2014/07/miller-rabin-primality-test" target="_blank" rel="noopener">大素数 Miller-Rabin 概率判别法</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">witness</span><span class="params">(LL a, LL n, LL m, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	LL x = powMod(a, m, n);</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		x = mulMod(x, x, n);</span><br><span class="line">		<span class="keyword">if</span> (x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(n &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LL m = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>, cnt = <span class="number">33</span>;</span><br><span class="line">	<span class="keyword">while</span> (!(m &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">		++t;</span><br><span class="line">		m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">		LL a = <span class="built_in">std</span>::rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (Witness(a, n, m, t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-1-（执行）时间复杂度判断一个数是否为素数"><a href="#O-1-（执行）时间复杂度判断一个数是否为素数" class="headerlink" title="$O(1)$ （执行）时间复杂度判断一个数是否为素数"></a>$O(1)$ （执行）时间复杂度判断一个数是否为素数</h3><blockquote>
<p>奇技淫巧来源：<a href="https://codeforces.com/blog/entry/79941#comment-659202" target="_blank" rel="noopener">https://codeforces.com/blog/entry/79941#comment-659202</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sieve</span> &#123;</span></span><br><span class="line">	<span class="keyword">bool</span> isP[N];</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">Sieve</span><span class="params">()</span>: <span class="title">isP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		isP[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isP[i] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isP[i]) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span> * i; j &lt; N; j += i * <span class="number">2</span>) &#123;</span><br><span class="line">					isP[j] = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// MAXN 默认最大值为1&lt;&lt;18=262144, 调节参数 -fconstexpr-loop-limit= 例如：</span></span><br><span class="line"><span class="comment">// g++ main.cpp -std=c++17 -fconstexpr-loop-limit=12345678 -fconstexpr-ops-limit=1234567890</span></span><br><span class="line"><span class="comment">// 使得 MAXN = 1e7+2</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fast_is_prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> Sieve&lt;MAXN&gt; s;</span><br><span class="line">	<span class="keyword">return</span> s.isP[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-n-最小素因子预处理"><a href="#O-n-最小素因子预处理" class="headerlink" title="$O(n)$ 最小素因子预处理"></a>$O(n)$ 最小素因子预处理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e8</span>; <span class="comment">// 再大内存吃不消了 </span></span><br><span class="line"><span class="keyword">int</span> sp[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt;= sp[i] &amp;&amp; i * p[j] &lt; N; ++j) &#123; <span class="comment">//防止乘法溢出</span></span><br><span class="line">			sp[i * p[j]] = p[j]; <span class="comment">// 注意到sp只被赋值一次</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大整数的最小素因子"><a href="#大整数的最小素因子" class="headerlink" title="大整数的最小素因子"></a>大整数的最小素因子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">pollardrho</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	LL x = <span class="built_in">std</span>::rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	LL y = x, i = <span class="number">1</span>, k = <span class="number">2</span>, c = <span class="built_in">std</span>::rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		x = (mulMod(x, x, n) + c) % n;</span><br><span class="line">		LL d = <span class="built_in">std</span>::__gcd(y - x + n, n);</span><br><span class="line">		<span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">		<span class="keyword">if</span> (++i == k) &#123;</span><br><span class="line">			y = x;</span><br><span class="line">			<span class="keyword">if</span> (k &gt; n) <span class="keyword">return</span> n;</span><br><span class="line">			k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findp</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rabin(n)) &#123;</span><br><span class="line">		ans = <span class="built_in">std</span>::<span class="built_in">min</span>(ans, n);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL p = n;</span><br><span class="line">	<span class="keyword">while</span> (p == n) p = pollardrho(n);</span><br><span class="line">	findp(p);</span><br><span class="line">	findp(n / p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mobius-function"><a href="#Mobius-function" class="headerlink" title="Mobius function"></a>Mobius function</h3><blockquote>
<p>另类递推公式： $ \mu(i) = - \sum_{d \mid i, d &lt; i} \mu(d) $。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 乞丐版</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line">		n /= <span class="number">2</span>;</span><br><span class="line">		r = -r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">			n /= i;</span><br><span class="line">			<span class="keyword">if</span>(n % i  == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			r = -r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n &gt; <span class="number">1</span> ? -r : r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(n log n) 预处理版本</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e6</span> +<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt; N; j += i) &#123;</span><br><span class="line">			mu[j] -= mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n) 预处理版</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e6</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="keyword">int</span> p[N], mu[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(mu[<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) mu[i] = <span class="number">-1</span>, p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j) &#123;</span><br><span class="line">			isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			mu[i * p[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">4</span>) mu[i] = -mu[i &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mobius-function-前缀和"><a href="#Mobius-function-前缀和" class="headerlink" title="Mobius function 前缀和"></a>Mobius function 前缀和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sumMu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSumMu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mu[<span class="number">1</span>] != <span class="number">1</span>) initmu();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) sumMu[i] = sumMu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSumMu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// M(n) = M(n-1) + mu(n)</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> sumMu[n];</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= (j - i + <span class="number">1</span>) * sumMu(n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Mobius function 绝对值前缀和</span></span><br><span class="line"><span class="function">LL <span class="title">getSumAbsMu</span><span class="params">(LL n)</span> </span>&#123; <span class="comment">// Q(n) = Q(n-1) + |mu(n)|</span></span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>, t; (t = i * i) &lt; n; ++i) &#123;</span><br><span class="line">		r += mu[i] * (n / t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Euler-‘s-totient-function"><a href="#Euler-‘s-totient-function" class="headerlink" title="Euler ‘s totient function"></a>Euler ‘s totient function</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> phi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPhi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (phi[<span class="number">2</span>] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) phi[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) phi[i] = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (phi[i] != i) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j += i) phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPhi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = (n % <span class="number">2</span> == <span class="number">0</span> ? n/<span class="number">2</span> : n);</span><br><span class="line">	<span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>) n/=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i  == <span class="number">0</span>) &#123;</span><br><span class="line">			r = r / i *(i<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">while</span> (n % i == <span class="number">0</span>) n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>) r = r / n * (n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">LL sumPhi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSumphi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (phi[<span class="number">2</span>] != <span class="number">1</span>) initPhi();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) sumPhi[i] = sumPhi[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, LL&gt; mp;</span><br><span class="line"><span class="function">LL <span class="title">getSumphi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> (LL) sumPhi[n];</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	LL r = LL(n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= (j - i + <span class="number">1</span>) * getSumphi(n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pi-x-函数"><a href="#pi-x-函数" class="headerlink" title="$\pi(x)$ 函数"></a>$\pi(x)$ 函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span> * <span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">11</span> * <span class="number">13</span> * <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM + <span class="number">1</span>][M + <span class="number">1</span>], sz[M + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	initprime();</span><br><span class="line">	pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		pi[i] = pi[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) ++pi[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sz[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= PM; ++i) phi[i][<span class="number">0</span>] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">		sz[i] = p[i] * sz[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= PM; ++j) &#123;</span><br><span class="line">			phi[j][i] = phi[j][i - <span class="number">1</span>] - phi[j / p[i]][i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s &lt;= M) <span class="keyword">return</span> phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];</span><br><span class="line">	<span class="keyword">if</span> (x / p[s] &lt;= p[s]) <span class="keyword">return</span> primepi(x) - s + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x / p[s] / p[s] &lt;= p[s] &amp;&amp; x &lt; N) &#123;</span><br><span class="line">		<span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>))];</span><br><span class="line">		LL ans = pi[x] - (s2x + s - <span class="number">2</span>) * (s2x - s + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt;= s2x; ++i) &#123;</span><br><span class="line">			ans += pi[x / p[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> primephi(x, s - <span class="number">1</span>) - primephi(x / p[s], s - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; N) <span class="keyword">return</span> pi[x];</span><br><span class="line">	<span class="keyword">int</span> ps2x = primepi(<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>)));</span><br><span class="line">	<span class="keyword">int</span> ps3x = primepi(<span class="keyword">int</span>(cbrt(x + <span class="number">0.2</span>)));</span><br><span class="line">	LL ans = primephi(x, ps3x) + LL(ps2x + ps3x - <span class="number">2</span>) * (ps2x - ps3x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = ps3x + <span class="number">1</span>, ed = ps2x; i &lt;= ed; ++i) &#123;</span><br><span class="line">		ans -= primepi(x / p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pi-x-函数计算的另一种做法"><a href="#pi-x-函数计算的另一种做法" class="headerlink" title="$\pi(x)$ 函数计算的另一种做法"></a>$\pi(x)$ 函数计算的另一种做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">2</span>;</span><br><span class="line">LL L[N], R[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	LL rn = (LL) <span class="built_in">sqrt</span>(n + <span class="number">0.2</span>);</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= rn; ++i) R[i] = n / i - <span class="number">1</span>;</span><br><span class="line">	LL ln = n / (rn + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= ln; ++i) L[i] = i - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL p = <span class="number">2</span>; p &lt;= rn; ++p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L[p] == L[p - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (LL i = <span class="number">1</span>, tn = <span class="built_in">std</span>::<span class="built_in">min</span>(n / (p * p), rn); i &lt;= tn; ++i) &#123;</span><br><span class="line">			R[i] -= (i * p &lt;= rn ? R[i * p] : L[n / (i * p)]) - L[p - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (LL i = ln; i &gt;= p * p; --i) &#123;</span><br><span class="line">			L[i] -= L[i / p] - L[p - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求奇素数的一个原根"><a href="#求奇素数的一个原根" class="headerlink" title="求奇素数的一个原根"></a>求奇素数的一个原根</h3><blockquote>
<p>代码懒得贴，实际上暴力就可以了</p>
</blockquote>
<p>首先，模 $m$ 有原根的充要条件是：$m=2,4,p^a,2p^a$，其中 $p$ 为奇素数。</p>
<p>对于求模 $p$ 的原根方法：对 $p-1$ 素因子分解：$p-1 = p_1^{a_1} \cdots p_s^{a_s}$ 若恒有 </p>
<script type="math/tex; mode=display">
g^{\frac{p-1}{p_i}} \neq 1(\mod \; p)</script><p>则 $g$ 是 模 $p$ 的原根。对于 $p^a$ 可以用 $p$ 的原根简单构造，而 $2p^a$ 的原根为 $p^a$ 的原根与 $p^a$ 的原根和 $p^a$的和中奇数者。(证明见 P150《数论基础》潘承洞)</p>
<blockquote>
<p>求所有原根见 </p>
</blockquote>
<h3 id="数论函数的-Dirichlet-乘积"><a href="#数论函数的-Dirichlet-乘积" class="headerlink" title="数论函数的 Dirichlet 乘积"></a>数论函数的 Dirichlet 乘积</h3><p>以前的代码不想贴了，不优雅，下次有题做的时候补上。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><a href="/chineseRemainTheorem/" title="中国剩余定理">中国剩余定理</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;LL,LL&gt; crt2(LL a1,LL m1,LL a2,LL m2)&#123; // x = ai mod mi, m_i &gt;0</span><br><span class="line">	LL t1,t2,ans = a2-a1;</span><br><span class="line">	LL d = exgcd(m1,m2,t1,t2);</span><br><span class="line">	assert(ans%d == <span class="number">0</span>);</span><br><span class="line">	LL m = m1/d*m2;</span><br><span class="line">	ans = (a1+ans/d*t1%m2*m1)%m; <span class="comment">// %m2 是避免溢出</span></span><br><span class="line">	<span class="keyword">return</span> make_pair(ans&gt;<span class="number">0</span>?ans:ans+m,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span>;</span><br><span class="line">LL a[N],m[N];</span><br><span class="line">pair&lt;LL,LL&gt; crt(int n)&#123; // x = a[i] mod m[i], m[i] &gt;0</span><br><span class="line">	pair&lt;LL,LL&gt; ans = make_pair(a[<span class="number">0</span>]%m[<span class="number">0</span>],m[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">		ans = crt2(ans.first,ans.second,a[i],m[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a><a href="http: //blog.miskcoo.com/2015/05/discrete-logarithm-problem">离散对数</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">baby_step_giant_step</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123; <span class="comment">// a^x = b mod p</span></span><br><span class="line">	a %= p, b %= p;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b % p ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LL cnt = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL g = <span class="built_in">std</span>::__gcd(a, p); g != <span class="number">1</span>; g = <span class="built_in">std</span>::__gcd(a, p)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		p /= g, b /= g, t = t * (a / g) % p;</span><br><span class="line">		++cnt;</span><br><span class="line">		<span class="keyword">if</span> (b == t) <span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;LL, LL&gt; mp;</span><br><span class="line">	LL m = LL(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(p + <span class="number">0.1</span>) + <span class="number">1</span>);</span><br><span class="line">	LL base = b;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">0</span>; i != m; ++i) &#123;</span><br><span class="line">		mp[base] = i;</span><br><span class="line">		base = base * a % p;</span><br><span class="line">	&#125;</span><br><span class="line">	base = powMod(a, m, p);</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		t = t * base % p;</span><br><span class="line">		<span class="keyword">if</span> (mp.count(t)) <span class="keyword">return</span> i * m - mp[t] + cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模素数开根号"><a href="#模素数开根号" class="headerlink" title="模素数开根号"></a>模素数开根号</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">modsqrt</span><span class="params">(LL a, LL p)</span> </span>&#123; <span class="comment">// find x s.t x*x=a mod p;</span></span><br><span class="line">	a = (p + a % p) % p;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">2</span>) <span class="keyword">return</span> (a &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	LL q = (p - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (powMod(a, q, p) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (q &amp; <span class="number">1</span>) <span class="keyword">return</span> powMod(a, (q + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line">	LL b, cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (powMod(b = rand() % p, q, p) == <span class="number">1</span>); <span class="comment">//find a non quadratic residue</span></span><br><span class="line">	<span class="keyword">while</span> (!(q &amp; <span class="number">1</span>)) ++cnt, q &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	b = powMod(b, q, p);</span><br><span class="line">	LL x = powMod(a, (q + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line">	<span class="keyword">for</span> (LL s = <span class="number">1</span>, t = powMod(a, q, p); t != <span class="number">1</span>; s = <span class="number">1</span>) &#123; <span class="comment">//keep x*x=t*a;t^&#123;2^&#123;cnt-1&#125;&#125;=1</span></span><br><span class="line">		<span class="keyword">for</span> (LL tt = t * t % p; s &lt; cnt &amp;&amp; tt != <span class="number">1</span>; ++s) tt = tt * tt % p;</span><br><span class="line">		LL d = powMod(b, <span class="number">1</span> &lt;&lt; (cnt - s - <span class="number">1</span>), p);</span><br><span class="line">		x = (x * d) % p;</span><br><span class="line">		b = d * d % p;</span><br><span class="line">		t = t * b % p;</span><br><span class="line">		cnt = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mod_sqrt</span><span class="params">(LL a, LL p, <span class="keyword">int</span> k = <span class="number">1</span>)</span> </span>&#123; <span class="comment">//find smallest x&gt;=0 s.t x*x=a mod p^k</span></span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ka = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (a % p == <span class="number">0</span>) a /= p, ++ka, --k;</span><br><span class="line">	<span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ka &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">auto</span> <span class="built_in">pow</span> = [](LL x, <span class="keyword">int</span> n) &#123;</span><br><span class="line">		LL r=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, x *= x)  <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r *= x;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	LL n = <span class="built_in">pow</span>(p, k), x;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">1</span> || k == <span class="number">2</span>) x = a == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a % <span class="number">8</span> != <span class="number">1</span>) x = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			x = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((x * x) % (<span class="number">1</span> &lt;&lt; i) == a % (<span class="number">1</span> &lt;&lt; i)) <span class="keyword">continue</span>;</span><br><span class="line">				x += <span class="number">1</span> &lt;&lt; (i - <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> x = mod_sqrt_p(a, n, p, k);</span><br><span class="line">	<span class="keyword">return</span> x == <span class="number">-1</span> ? <span class="number">-1</span> : <span class="built_in">pow</span>(p, ka &gt;&gt; <span class="number">1</span>) * (x &lt; n - x ? x : n - x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于模一般的 $n$，先素因子分解分别求出答案，然后用中国剩余定理求最终解。</p>
</blockquote>
<h3 id="自然数方幂和-O-k-算法"><a href="#自然数方幂和-O-k-算法" class="headerlink" title="自然数方幂和 $O(k)$ 算法"></a>自然数方幂和 $O(k)$ 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> sp[N], p[N];</span><br><span class="line">LL inv[N], AP[N], AS[N], f[N];</span><br><span class="line"><span class="function">LL <span class="title">getPowSum</span><span class="params">(LL n, <span class="keyword">int</span> k, LL mod)</span> </span>&#123; <span class="comment">// mod &gt; k</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> n % mod;</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">2</span>) spf();</span><br><span class="line">	<span class="keyword">int</span> nk = k + <span class="number">1</span>;</span><br><span class="line">	LL tmp = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk; ++i) tmp = tmp * i % mod;</span><br><span class="line">	inv[nk] = powMod(tmp, mod - <span class="number">2</span>, mod);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) f[i] = powMod(i, k, mod);</span><br><span class="line">		<span class="keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]] % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (f[i] &gt;= mod) f[i] -= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= nk) <span class="keyword">return</span> f[n];</span><br><span class="line">	AP[<span class="number">0</span>] = AS[nk] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) AP[i] = AP[i - <span class="number">1</span>] * (n + <span class="number">1</span> - i) % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) AS[i] = AS[i + <span class="number">1</span>] * (n - i - <span class="number">1</span>) % mod;</span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) &#123; <span class="comment">// because f(i)=0</span></span><br><span class="line">		LL x = f[i] * AP[i] % mod * AS[i] % mod * inv[i] % mod * inv[nk - i] % mod;</span><br><span class="line">		<span class="keyword">if</span> ((nk - i) &amp; <span class="number">1</span>) res -= x; <span class="comment">// be careful</span></span><br><span class="line">		<span class="keyword">else</span> res += x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res % mod + mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自然数方幂和精确版"><a href="#自然数方幂和精确版" class="headerlink" title="自然数方幂和精确版"></a>自然数方幂和精确版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> BINT = boost::multiprecision::cpp_int;</span><br><span class="line"></span><br><span class="line">BINT f[N];</span><br><span class="line"><span class="function">BINT <span class="title">getpowsum</span><span class="params">(LL n, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// k&lt;1000</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> BINT(n);</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">2</span>) spf();</span><br><span class="line">	<span class="keyword">int</span> nk = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> bPow = [](BINT x, <span class="keyword">int</span> n) -&gt; BINT &#123;</span><br><span class="line">		BINT r(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (; n; x *= x, n &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r *= x;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) f[i] = bPow(BINT(i), k);</span><br><span class="line">		<span class="keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= nk) <span class="keyword">return</span> f[n];</span><br><span class="line">	BINT res = <span class="number">0</span>, tl = <span class="number">1</span>, tr = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) tr = tr * (n - i - <span class="number">1</span>) / (nk - i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((nk - i) &amp; <span class="number">1</span>) res -= f[i] * tl * tr;</span><br><span class="line">		<span class="keyword">else</span> res += f[i] * tl * tr;</span><br><span class="line">		tl = tl * (n - i) / (i + <span class="number">1</span>);</span><br><span class="line">		tr = tr * (nk - i) / (n - i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要下载<a href="https://www.boost.org/" target="_blank" rel="noopener">boost 包</a> 类似的包还有 NTL，GMP</p>
</blockquote>
<h3 id="NFT-正式可用版-last-updated-2020-7-9"><a href="#NFT-正式可用版-last-updated-2020-7-9" class="headerlink" title="NFT 正式可用版(last updated: 2020/7/9)"></a>NFT 正式可用版(last updated: 2020/7/9)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>, ROOT = <span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; j) <span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = a.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			(j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a, <span class="keyword">bool</span> isInverse = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">	LL g = powMod(ROOT, (M - <span class="number">1</span>) / a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span> (isInverse) &#123;</span><br><span class="line">		g = powMod(g, M - <span class="number">2</span>);</span><br><span class="line">		LL invLen = powMod(LL(a.<span class="built_in">size</span>()), M - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) x = x * invLen % M;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(a);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != w.<span class="built_in">size</span>(); ++i) w[i] = w[i - <span class="number">1</span>] * g % M;</span><br><span class="line">	<span class="keyword">auto</span> addMod = [](LL x, LL y) &#123;</span><br><span class="line">		<span class="keyword">return</span> (x += y) &gt;= M ? x -= M : x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">2</span>, half = <span class="number">1</span>; half != a.<span class="built_in">size</span>(); <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>, half &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, wstep = a.<span class="built_in">size</span>() / <span class="built_in">step</span>; i != a.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j != i + half; ++j) &#123;</span><br><span class="line">				LL t = (a[j + half] * w[wstep * (j - i)]) % M;</span><br><span class="line">				a[j + half] = addMod(a[j], M - t);</span><br><span class="line">				a[j] = addMod(a[j], t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">mul</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (sz &lt; tot) sz *= <span class="number">2</span>;</span><br><span class="line">	a.resize(sz);</span><br><span class="line">	b.resize(sz);</span><br><span class="line">	nft(a);</span><br><span class="line">	nft(b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != sz; ++i) a[i] = a[i] * b[i] % M;</span><br><span class="line">	nft(a, <span class="number">1</span>);</span><br><span class="line">	a.resize(tot);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="siyuan-的-FWT-模板"><a href="#siyuan-的-FWT-模板" class="headerlink" title="siyuan 的 FWT 模板"></a><a href="https://blog.orzsiyuan.com/archives/Fast-Walsh-Hadamard-Transform/" target="_blank" rel="noopener">siyuan 的 FWT 模板</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x += y) &gt;= P &amp;&amp; (x -= P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FWT</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; N &lt; n; N &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j + m], a[i + j]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j + m], a[i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j], a[i + j + m]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j], a[i + j + m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTxor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), inv2 = (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = a[i + j + m];</span><br><span class="line">                <span class="keyword">if</span> (!rev) &#123;</span><br><span class="line">                    a[i + j] = (x + y) % P;</span><br><span class="line">                    a[i + j + m] = (x - y + P) % P;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[i + j] = <span class="number">1L</span>L * (x + y) * inv2 % P;</span><br><span class="line">                    a[i + j + m] = <span class="number">1L</span>L * (x - y + P) * inv2 % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Or</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">And</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTand(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTand(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTand(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Xor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTxor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTxor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTxor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; fwt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    std::vector&lt;int&gt; a1(n), a2(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a2[i]);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    A = fwt.Or(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A = fwt.And(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A = fwt.Xor(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵类"><a href="#矩阵类" class="headerlink" title="矩阵类"></a>矩阵类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">LL mod;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line">	LL a[N][N];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	Matrix() &#123;&#125;</span><br><span class="line">	Matrix(<span class="keyword">int</span> _n, <span class="keyword">int</span> x = <span class="number">0</span>): n(_n) &#123; <span class="comment">// xIn</span></span><br><span class="line">		all(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			a[i][i] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">all</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				a[i][j] = x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> Matrix &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">Matrix <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				R.a[i][j] = a[i][j] + A.a[i][j];</span><br><span class="line">				<span class="keyword">if</span> (R.a[i][j] &gt;= mod) R.a[i][j] -= mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">Matrix <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">					R.a[i][j] = (R.a[i][j] + a[i][k] * A.a[k][j]) % mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function">Matrix <span class="title">R</span><span class="params">(A.n, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) R = R * A;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; A = A * A;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到，矩阵乘法一定要写成上面的循环形式，这样利用高速缓存执行时间是原有的 $\frac{1}{4}$</p>
<p>另外有序数组的累和要比无序的快很多，也是因为高速缓存（这个不太懂原理）</p>
</blockquote>
<h3 id="求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法"><a href="#求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法" class="headerlink" title="求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法"></a>求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1003</span>;</span><br><span class="line">LL c[M], ans[<span class="number">2</span> * M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecSeq</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LL a[<span class="number">2</span> * M];</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	RecSeq(<span class="keyword">int</span> _m, LL x = <span class="number">0</span>): m(_m) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> (a));</span><br><span class="line">		a[<span class="number">0</span>] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	RecSeq <span class="keyword">operator</span> * (<span class="keyword">const</span> RecSeq &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">RecSeq <span class="title">R</span><span class="params">(m)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">				R.a[i + j] = (R.a[i + j] + a[i] * A.a[j]) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * m - <span class="number">2</span>; i &gt;= m; --i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">				R.a[i - m + j] += (R.a[i] * c[j]) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">			R.a[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			R.a[i] %= mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">	<span class="function">T <span class="title">tPow</span><span class="params">(T &amp; A, LL n)</span> </span>&#123;</span><br><span class="line">		<span class="function">T <span class="title">R</span><span class="params">(A.m, <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n &amp; <span class="number">1</span>) R = R * A;</span><br><span class="line">			n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			A = A * A;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initC</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> (c));</span><br><span class="line">	c[<span class="number">0</span>] = c[m - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		ans[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[m] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt; <span class="number">2</span> * m; ++i) &#123;</span><br><span class="line">		ans[i] = ans[i - <span class="number">1</span>] + ans[i - m];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(LL n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	initC(m);</span><br><span class="line">	<span class="function">RecSeq <span class="title">A</span><span class="params">(m)</span></span>;</span><br><span class="line">	A.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	RecSeq R = tPow(A, n - m);</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		r += (R.a[i] * ans[i + m]) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用<a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">多项式带模除法：Division with remainder</a>的 $O(m \log m)$ 算法，可优化到 $O(m \log m \log n)$，</p>
<p>但是如果递推关系中仅有常数个不为 0，比如通常是两个，也可以不用多项式带模除法来搞，只需 NFT 就可以优化到 $O(m \log m \log n + m^2)$ （暂时不知道如何去掉 $m^2$）</p>
</blockquote>
<h2 id="C-模板之数据结构"><a href="#C-模板之数据结构" class="headerlink" title="C++ 模板之数据结构"></a>C++ 模板之数据结构</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = x;</span><br><span class="line">	<span class="keyword">while</span> (ans != p[ans]) ans = p[ans];</span><br><span class="line">	<span class="keyword">while</span> (x != ans) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = p[x];</span><br><span class="line">		p[x] = ans;</span><br><span class="line">		x = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组（单点更新，区间求和，编号从-1-开始）"><a href="#树状数组（单点更新，区间求和，编号从-1-开始）" class="headerlink" title="树状数组（单点更新，区间求和，编号从 1 开始）"></a>树状数组（单点更新，区间求和，编号从 1 开始）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; s;</span><br><span class="line">	TreeArray() &#123;&#125;</span><br><span class="line">	TreeArray(<span class="keyword">int</span> n) &#123; init(n); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		s.resize(n + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">fill</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			s[id] += p;</span><br><span class="line">			id += lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (id) &#123;</span><br><span class="line">			r += s[id];</span><br><span class="line">			id -= lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find minimal index s.t. sum(id) &gt;= x, sum must be increased</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(LL val)</span> </span>&#123;</span><br><span class="line">		LL sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">std</span>::__lg(s.<span class="built_in">size</span>()); ~i; --i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (id + (<span class="number">1</span> &lt;&lt; i) &lt; s.<span class="built_in">size</span>() &amp;&amp; sum + s[id + (<span class="number">1</span> &lt;&lt; i)] &lt; val) &#123;</span><br><span class="line">				id += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">				sum += s[id];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ++id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组（区间更新，区间求和，编号从-1-开始）"><a href="#树状数组（区间更新，区间求和，编号从-1-开始）" class="headerlink" title="树状数组（区间更新，区间求和，编号从 1 开始）"></a>树状数组（区间更新，区间求和，编号从 1 开始）</h3><p>有了单点更新的树状数组，只需简单利用差分就可以变成区间的更新了。<br>设原始数组为 <code>a[1 ~ n]</code>， 定义 <code>c[i] = a[i] - a[i - 1], (a[0] = 0)</code> 显然</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^m a_i = \sum_{i = 1}^m (m - i + 1) c_i = m \sum_{i = 1}^m c_i - \sum_{i = 1}^m (i - 1) c_i</script><p>比如对区间 <code>[l, r]</code> 做更新，那么就只需更新两点：<code>r + 1, l</code> ，套用之前的类就行了。</p>
<blockquote>
<p>注意在树状数组中搜索本来应该是 $O(\log ^2 n)$，但是因为在 $2^i$ 的位置搜索时，一步到位。所以复杂度会降到 $O(\log n)$：<a href="https://codeforces.com/blog/entry/61364" target="_blank" rel="noopener">理论依据</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray2</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	TreeArray B, C;</span><br><span class="line">	TreeArray2() &#123;&#125;</span><br><span class="line">	TreeArray2(<span class="keyword">int</span> _n) : n(_n)&#123; </span><br><span class="line">		B.init(n);</span><br><span class="line">		C.init(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		C.add(id, p);</span><br><span class="line">		B.add(id, (id - <span class="number">1</span>) * p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		add(l, p);</span><br><span class="line">		<span class="keyword">if</span> (r + <span class="number">1</span> &lt; n) add(r + <span class="number">1</span>, -p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id * C.sum(id) - B.sum(id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find minimal index s.t. sum(id) &gt;= x, sum must be increased</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(LL val)</span> </span>&#123;</span><br><span class="line">		LL sumB = <span class="number">0</span>, sumC = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">std</span>::__lg(n); ~i; --i) <span class="keyword">if</span> (<span class="keyword">int</span> idi = id + (<span class="number">1</span> &lt;&lt; i); idi &lt;= n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (idi * (sumC +  C.s[idi]) - B.s[idi] - sumB &lt; val) &#123;</span><br><span class="line">				id = idi;</span><br><span class="line">				sumB += B.s[id];</span><br><span class="line">				sumC += C.s[id];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ++id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, lrt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rrt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">LL sum[N * <span class="number">3</span>], col[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	sum[rt] = sum[lrt] + sum[rrt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (col[rt]) &#123;</span><br><span class="line">		col[lrt] += col[rt];</span><br><span class="line">		col[rrt] += col[rt];</span><br><span class="line">		sum[lrt] += (m - (m &gt;&gt; <span class="number">1</span>)) * col[rt];</span><br><span class="line">		sum[rrt] += (m &gt;&gt; <span class="number">1</span>) * col[rt];</span><br><span class="line">		col[rt] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp; sum[rt]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	col[rt] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(lson);</span><br><span class="line">	build(rson);</span><br><span class="line">	pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;</span><br><span class="line">		sum[rt] += p * (r - l + <span class="number">1</span>);</span><br><span class="line">		col[rt] += p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= m) update(L, R, p, lson);</span><br><span class="line">	<span class="keyword">if</span> (R &gt; m) update(L, R, p, rson);</span><br><span class="line">	pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> sum[rt];</span><br><span class="line">	pushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= m) ans += query(L, R, lson);</span><br><span class="line">	<span class="keyword">if</span> (R &gt; m) ans += query(L, R, rson);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>吊打线段树的 <a href="https://blog.csdn.net/CC_dsm/article/details/98166835" target="_blank" rel="noopener">珂朵莉树（Chtholly Tree）</a></p>
</blockquote>
<h3 id="RMQ-求区间最大值"><a href="#RMQ-求区间最大值" class="headerlink" title="RMQ 求区间最大值"></a>RMQ 求区间最大值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMQ</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> a[N][<span class="number">20</span>]; <span class="comment">//a[i][j]=max(s[i]---s[i+2^j-1])</span></span><br><span class="line">	RMQ(<span class="keyword">int</span> * s, <span class="keyword">int</span> _n): n(_n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) a[i][<span class="number">0</span>] = s[i];</span><br><span class="line">		<span class="keyword">int</span> len = (<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(n)) / <span class="built_in">log</span>(<span class="number">2.0</span>)) + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != len; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - (<span class="number">1</span> &lt;&lt; i); ++j) &#123;</span><br><span class="line">				a[j][i] = <span class="built_in">max</span>(a[j][i - <span class="number">1</span>], a[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 0 &lt;= l &lt;= r &lt; n</span></span><br><span class="line">		<span class="keyword">int</span> len = (<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(r - l + <span class="number">1</span>)) / <span class="built_in">log</span>(<span class="number">2.0</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(a[l][len], a[r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/nondecraseSubsequence/" title="最长（ 严格） 递增子序列">最长（ 严格） 递增子序列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// longest increasing subsquence</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> * b = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	b[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; b[k]) b[++k] = a[i];</span><br><span class="line">		<span class="keyword">else</span> b[lower_bound(b, b + k, a[i]) - b] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> k + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lower_bound(first,end,val) 表示在单增 [frist,end) 中首次大于等于 val 的位置</span></span><br><span class="line"><span class="comment">// upper_bound(first,end,val) 表示在单增 [frist,end) 中首次大于 val 的位置</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们经常用二分答案的思想， 但是其实二分答案是仅仅知道其单调的情况下的策略，实际上，对于具体的问题， 我们完全可以对 $m$ 的值进行不同的处理， 而非单纯的 $m = (l + r) &gt;&gt; 1 $。</p>
</blockquote>
<h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> r[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pack</span><span class="params">(<span class="keyword">int</span> cash, <span class="keyword">int</span> num, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">0</span> || w == <span class="number">0</span> || v == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">1</span>) &#123; <span class="comment">//  0-1背包</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = cash; i &gt;= v; --i)</span><br><span class="line">			r[i] = <span class="built_in">max</span>(r[i], r[i - v] + w);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num * v &gt;= cash - v + <span class="number">1</span>) &#123; <span class="comment">//完全背包</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = v; i &lt;= cash; ++i)</span><br><span class="line">			r[i] = <span class="built_in">max</span>(r[i], r[i - v] + w);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> q[MAX], s[MAX], head, tail;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123; <span class="comment">//多重背包</span></span><br><span class="line">		q[<span class="number">0</span>] = r[j];</span><br><span class="line">		s[<span class="number">0</span>] = head = tail = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = j + v; k &lt;= cash; ++i, k += v) &#123;</span><br><span class="line">			q[i] = r[k] - i * w;</span><br><span class="line">			<span class="keyword">while</span> (s[head] &lt; i - num) ++head;</span><br><span class="line">			<span class="keyword">while</span> (head &lt;= tail &amp;&amp; q[tail] &lt; q[i]) --tail;</span><br><span class="line">			s[++tail] = i;</span><br><span class="line">			q[tail] = q[i];</span><br><span class="line">			r[k] = q[head] + i * w;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆与-STL-优先队列"><a href="#堆与-STL-优先队列" class="headerlink" title="堆与 STL 优先队列"></a>堆与 STL 优先队列</h3><p>可以使用 <a href="http: //www.cplusplus.com/reference/">C++STL</a> 的 priority_queue，查找可用 lower_bound 和 upper_bound。C++ STL 中优先队列是用堆来实现的。用途十分广泛，例如加速最小生成树，拓扑排序，等等。<br>堆的实现一般是用数组。 我们可以用 1 作为树的根， 对每一个节点 $x$， 它的两个节点分别就是 $2x$ 和 $2x + 1$ 平时都用 <code>x &lt;&lt; 1, x &lt;&lt; 1 | 1</code> 表示。 堆只支持三个操作:</p>
<ol>
<li>插入一个节点(我们实现时是插入最尾部， 这样保证了是一个完全二叉树) $O(\log n)$ </li>
<li>删除最大键值节点（ 删除根元素的值） $O(\log n)$ </li>
<li>输出最大键值节点（ 查看根元素的值） $O(1)$</li>
</ol>
<blockquote>
<p>我掌握的也很喜欢的几个数据结构：<code>单调队列，单调栈，树状数组，堆，线段树，红黑树</code></p>
</blockquote>
<h3 id="拓扑排序反字典序输出"><a href="#拓扑排序反字典序输出" class="headerlink" title="拓扑排序反字典序输出"></a>拓扑排序反字典序输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], sc, d[N], ans[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ed;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">&#125;</span><br><span class="line">e[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	e[sc].ed = y;</span><br><span class="line">	e[sc].next = head[x];</span><br><span class="line">	head[x] = sc++;</span><br><span class="line">	++d[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	sc = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		head[i] = <span class="number">-1</span>;</span><br><span class="line">		d[i] = <span class="number">0</span>;</span><br><span class="line">		v[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// after read data</span></span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span> &gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (d[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span> (v[u]) <span class="keyword">continue</span>;</span><br><span class="line">		v[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (--d[e[i].ed] == <span class="number">0</span>) q.push(e[i].ed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树-red-black-tree"><a href="#红黑树-red-black-tree" class="headerlink" title="红黑树 red-black tree"></a>红黑树 red-black tree</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBT</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span> elemType;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> RED = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> BLACK = <span class="number">1</span>;</span><br><span class="line">		Node * ch[<span class="number">2</span>], * fa; <span class="comment">// x-&gt;fa-&gt;ch[x-&gt;rs] = x</span></span><br><span class="line">		<span class="keyword">int</span> sz;</span><br><span class="line">		elemType key;</span><br><span class="line">		<span class="keyword">bool</span> color, rs; <span class="comment">// is rightson</span></span><br><span class="line">	&#125;;</span><br><span class="line">	Node * root; <span class="comment">// root has no father</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">faSon</span><span class="params">(Node * x, Node * y, <span class="keyword">bool</span> rs)</span> </span>&#123;</span><br><span class="line">		y-&gt;fa = x;</span><br><span class="line">		y-&gt;rs = rs;</span><br><span class="line">		x-&gt;ch[rs] = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">newNode</span><span class="params">(Node * x, elemType val, <span class="keyword">bool</span> rs)</span> </span>&#123; <span class="comment">// x-&gt;ch[rs]=null</span></span><br><span class="line">		Node * p = <span class="keyword">new</span> Node;</span><br><span class="line">		p-&gt;ch[<span class="number">0</span>] = p-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">		p-&gt;sz = <span class="number">1</span>;</span><br><span class="line">		p-&gt;key = val;</span><br><span class="line">		p-&gt;color = Node::RED;</span><br><span class="line">		faSon(x, p, rs);</span><br><span class="line">		++x-&gt;sz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node * x, <span class="keyword">bool</span> rs)</span> </span>&#123; <span class="comment">// x must not null</span></span><br><span class="line">		Node * y = x-&gt;ch[!rs];</span><br><span class="line">		<span class="keyword">if</span> (y == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x == root) root = y;</span><br><span class="line">		<span class="keyword">else</span> faSon(x-&gt;fa, y, x-&gt;rs);</span><br><span class="line">		faSon(x, y-&gt;ch[rs], !rs);</span><br><span class="line">		faSon(y, x, rs);</span><br><span class="line">		y-&gt;sz = x-&gt;sz;</span><br><span class="line">		x-&gt;sz = x-&gt;ch[<span class="number">0</span>]-&gt;sz + x-&gt;ch[<span class="number">1</span>]-&gt;sz + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insMaintain</span><span class="params">(Node * x)</span> </span>&#123; <span class="comment">// x-&gt;color is RED</span></span><br><span class="line">		<span class="keyword">if</span> (x == root || x-&gt;fa-&gt;color == Node::BLACK) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;fa-&gt;fa-&gt;ch[!x-&gt;fa-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;rs ^ x-&gt;fa-&gt;rs) rotate(x-&gt;fa, x-&gt;fa-&gt;rs);</span><br><span class="line">			<span class="keyword">else</span> x = x-&gt;fa;</span><br><span class="line">			x-&gt;color = Node::BLACK;</span><br><span class="line">			x-&gt;fa-&gt;color = Node::RED;</span><br><span class="line">			rotate(x-&gt;fa, !x-&gt;rs);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			x = x-&gt;fa-&gt;fa;</span><br><span class="line">			x-&gt;color = Node::RED;</span><br><span class="line">			x-&gt;ch[<span class="number">0</span>]-&gt;color = x-&gt;ch[<span class="number">1</span>]-&gt;color = Node::BLACK;</span><br><span class="line">			insMaintain(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase1</span><span class="params">(Node * x, Node * y)</span> </span>&#123;</span><br><span class="line">		y-&gt;color = Node::BLACK;</span><br><span class="line">		y-&gt;fa-&gt;color = Node::RED;</span><br><span class="line">		y = y-&gt;ch[!y-&gt;rs];</span><br><span class="line">		rotate(x-&gt;fa, x-&gt;rs);</span><br><span class="line">		delCase2(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase2</span><span class="params">(Node * x, Node * y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;ch[y-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (y-&gt;ch[!y-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">				y-&gt;color = Node::RED;</span><br><span class="line">				delMaintain(y-&gt;fa);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				y-&gt;color = Node::RED;</span><br><span class="line">				y-&gt;ch[!y-&gt;rs]-&gt;color = Node::BLACK;</span><br><span class="line">				rotate(y, y-&gt;rs);</span><br><span class="line">				delCase3(y-&gt;fa);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> delCase3(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase3</span><span class="params">(Node * y)</span> </span>&#123;</span><br><span class="line">		y-&gt;color = y-&gt;fa-&gt;color;</span><br><span class="line">		y-&gt;ch[y-&gt;rs]-&gt;color = y-&gt;fa-&gt;color = Node::BLACK;</span><br><span class="line">		rotate(y-&gt;fa, !y-&gt;rs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delMaintain</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == root || x == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;color == Node::RED) &#123;</span><br><span class="line">			x-&gt;color = Node::BLACK;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node * y = x-&gt;fa-&gt;ch[!x-&gt;rs];</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;color == Node::RED) delCase1(x, y);</span><br><span class="line">		<span class="keyword">else</span> delCase2(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">pred</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// max elem &lt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &gt; val) <span class="keyword">return</span> pred(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] == null) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">return</span> pred(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">succ</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// min elem &gt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &lt; val) <span class="keyword">return</span> succ(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] == null) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">return</span> succ(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// count elem &lt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &gt; val) <span class="keyword">return</span> rank(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">		<span class="keyword">return</span> x-&gt;ch[<span class="number">0</span>]-&gt;sz + <span class="number">1</span> + rank(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">select</span><span class="params">(Node * x, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// k-th smallest elem</span></span><br><span class="line">		<span class="keyword">if</span> (x == null || x-&gt;sz &lt; k) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">int</span> sz = x-&gt;ch[<span class="number">0</span>]-&gt;sz + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (sz == k) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">if</span> (sz &lt; k) <span class="keyword">return</span> select(x-&gt;ch[<span class="number">1</span>], k - sz);</span><br><span class="line">		<span class="keyword">return</span> select(x-&gt;ch[<span class="number">0</span>], k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) <span class="built_in">clear</span>(x-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) <span class="built_in">clear</span>(x-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x != null) <span class="keyword">delete</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"key = %d, sz = %d "</span>, x-&gt;key, x-&gt;sz);</span><br><span class="line">		<span class="built_in">puts</span>(x-&gt;color == Node::RED ? <span class="string">"RED"</span> : <span class="string">"BLACK"</span>);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) <span class="built_in">print</span>(x-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) <span class="built_in">print</span>(x-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	Node * null;</span><br><span class="line">	RBT() &#123;</span><br><span class="line">		null = <span class="keyword">new</span> Node; <span class="comment">// no key, rs, father</span></span><br><span class="line">		null-&gt;ch[<span class="number">0</span>] = null-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">		null-&gt;sz = <span class="number">0</span>;</span><br><span class="line">		null-&gt;color = Node::BLACK;</span><br><span class="line">		root = null;</span><br><span class="line">		null-&gt;key = INF; <span class="comment">// for convenient</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">search</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		Node * x = root;</span><br><span class="line">		<span class="keyword">while</span> (x != null) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val == x-&gt;key) <span class="keyword">return</span> x;</span><br><span class="line">			x = x-&gt;ch[val &gt;= x-&gt;key];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> null;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">			root = <span class="keyword">new</span> Node; <span class="comment">// no father, rs</span></span><br><span class="line">			root-&gt;ch[<span class="number">0</span>] = root-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">			root-&gt;sz = <span class="number">1</span>;</span><br><span class="line">			root-&gt;color = Node::BLACK;</span><br><span class="line">			root-&gt;key = val;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node * x = root;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;ch[val &gt;= x-&gt;key] != null) &#123;</span><br><span class="line">			++x-&gt;sz;</span><br><span class="line">			x = x-&gt;ch[val &gt;= x-&gt;key];</span><br><span class="line">		&#125;</span><br><span class="line">		newNode(x, val, val &gt;= x-&gt;key);</span><br><span class="line">		insMaintain(x-&gt;ch[val &gt;= x-&gt;key]);</span><br><span class="line">		root-&gt;color = Node::BLACK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		Node * x = search(val), * y;</span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;ch[<span class="number">0</span>] != null || x-&gt;ch[<span class="number">1</span>] != null) &#123;</span><br><span class="line">			<span class="keyword">bool</span> rs = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;ch[rs] == null) rs = !rs;</span><br><span class="line">			y = x-&gt;ch[rs];</span><br><span class="line">			<span class="keyword">while</span> (y-&gt;ch[!rs] != null) y = y-&gt;ch[!rs];</span><br><span class="line">			<span class="built_in">std</span>::swap(x-&gt;key, y-&gt;key);</span><br><span class="line">			x = y;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;color == Node::RED) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		delMaintain(x);</span><br><span class="line">		root-&gt;color = Node::BLACK;</span><br><span class="line">		y = x;</span><br><span class="line">		<span class="keyword">while</span> (y != root) &#123;</span><br><span class="line">			y = y-&gt;fa;</span><br><span class="line">			--y-&gt;sz;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x == root) root = null;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) faSon(x-&gt;fa, x-&gt;ch[<span class="number">0</span>], x-&gt;rs);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) faSon(x-&gt;fa, x-&gt;ch[<span class="number">1</span>], x-&gt;rs);</span><br><span class="line">		<span class="keyword">else</span> x-&gt;fa-&gt;ch[x-&gt;rs] = null;</span><br><span class="line">		<span class="keyword">delete</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">pred</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pred(root, val)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">succ</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> succ(root, val)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rank(root, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> select(root, k)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">clear</span>(root);</span><br><span class="line">		root = null;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> root-&gt;sz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root != null) <span class="built_in">print</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// for particular use</span></span><br><span class="line">		<span class="keyword">return</span> select(root, rank(root, a) + k)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="C-模板之图论"><a href="#C-模板之图论" class="headerlink" title="C++ 模板之图论"></a>C++ 模板之图论</h2><blockquote>
<p>图论还是一个特别强的工具。 为什么没有图论的 STL？</p>
</blockquote>
<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head, nxt, to;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; w;</span><br><span class="line">	LinkStar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		nxt.<span class="built_in">clear</span>();</span><br><span class="line">		to.<span class="built_in">clear</span>();</span><br><span class="line">		head = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL val)</span> </span>&#123;</span><br><span class="line">		nxt.emplace_back(head[u]);</span><br><span class="line">		head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">		to.emplace_back(v);</span><br><span class="line">		w.emplace_back(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="知乎上看到-YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）"><a href="#知乎上看到-YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）" class="headerlink" title="知乎上看到 YYYYLLL 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）"></a>知乎上看到 <a href="https://www.zhihu.com/people/yyyylll-37" target="_blank" rel="noopener">YYYYLLL</a> 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">j</span>] 表示只经过 1～k 号节点优化，i 点到 j 点的最短路径长度。</span><br><span class="line">则 DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">j</span>] = min( DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">j</span>], DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">k</span>]+DP[<span class="string">k-1</span>][<span class="symbol">k</span>][<span class="string">j</span>] ) </span><br><span class="line">= min( DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">j</span>], DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">k</span>]+DP[<span class="string">k</span>][<span class="symbol">k</span>][<span class="string">j</span>] ) </span><br><span class="line">DP[<span class="string">0</span>][<span class="symbol"></span>][<span class="string"></span>] 是初始图的邻接矩阵，DP[<span class="string">n</span>][<span class="symbol"></span>][<span class="string"></span>] 就是最终求得的最短路长度矩阵了</span><br></pre></td></tr></table></figure>
<p>本来一开始是没法做空间优化的， 但是第二个等式， 就保证了可以做空间优化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line">LL dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k!=n;++k)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i&lt;<span class="number">0</span>; i!=n;++i)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j!=n;++j)</span><br><span class="line">				dp[i][j] = <span class="built_in">std</span>::<span class="built_in">min</span>(dp[i][j],dp[i][k] + dp[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dfs-序"><a href="#dfs-序" class="headerlink" title="dfs 序"></a>dfs 序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ncnt = <span class="number">0</span>; <span class="comment">// init every case</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">// dfs order</span></span><br><span class="line">	L[x] = ++ncnt;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (e[i].ed != fa) dfs(e[i].ed, x);</span><br><span class="line">	&#125;</span><br><span class="line">	R[x] = ncnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树的直径：先从任意点开始寻找最远距离点（bfs-遍历一下），然后再找一次就是了（易证）"><a href="#树的直径：先从任意点开始寻找最远距离点（bfs-遍历一下），然后再找一次就是了（易证）" class="headerlink" title="树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）"></a>树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）</h3><p>例题：<a href="https://codeforces.com/contest/1405/problem/D" target="_blank" rel="noopener">1405D</a></p>
<h3 id="笛卡尔树-：我去，竟然是-O-n-复杂度的建树"><a href="#笛卡尔树-：我去，竟然是-O-n-复杂度的建树" class="headerlink" title="笛卡尔树 ：我去，竟然是 $O(n)$ 复杂度的建树"></a><a href="https://oi-wiki.org/ds/cartesian-tree/" target="_blank" rel="noopener">笛卡尔树</a> ：我去，竟然是 $O(n)$ 复杂度的建树</h3><blockquote>
<p>从<a href="https://oi-wiki.org/ds/cartesian-tree/" target="_blank" rel="noopener">OI - wiki</a> 中看到的讲解和复杂度分析!，注意到右链是从尾巴往上查找的。<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506" target="_blank" rel="noopener"><strong>hdu 1506</strong></a><br>这就给出了一个 $O(n)$ 复杂度求出包含 <code>i</code>且以 <code>a[i]</code> 为最小值的区间的方法，太强了！<br>求上述对应的最大值区间，需要修改 0 节点的值，以及 build 的大于号改成小于号。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, val, par, ch[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _id, <span class="keyword">int</span> _val, <span class="keyword">int</span> _par)</span> </span>&#123;</span><br><span class="line">        id = _id, val = _val, par = _par, ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cartesian_build</span><span class="params">(Node *tree, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tree[k].val &lt; tree[i].val) k = tree[k].par;</span><br><span class="line">        tree[i].ch[<span class="number">0</span>] = tree[k].ch[<span class="number">1</span>];</span><br><span class="line">        tree[k].ch[<span class="number">1</span>] = i;</span><br><span class="line">        tree[i].par = k;</span><br><span class="line">        tree[tree[i].ch[<span class="number">0</span>]].par = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>].ch[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        Node tree[n + <span class="number">1</span>];</span><br><span class="line">        tree[<span class="number">0</span>].init(<span class="number">0</span>, <span class="number">1e9</span> + <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            tree[i].init(i, x, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = cartesian_build(tree, n);</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::function &lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sz = dfs(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">            sz += dfs(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">            ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, LL(sz + <span class="number">1</span>) * tree[x].val);</span><br><span class="line">            <span class="keyword">return</span> sz + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面是求以 a[i] 为最小值且包含 i 的最大区间</span></span><br><span class="line">        <span class="keyword">int</span> l[n + <span class="number">1</span>], r[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; getinterval = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[tree[x].par].ch[<span class="number">0</span>] == x) &#123;</span><br><span class="line">                r[x] = tree[x].par - <span class="number">1</span>;</span><br><span class="line">                l[x] = l[tree[x].par];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l[x] = tree[x].par + <span class="number">1</span>;</span><br><span class="line">                r[x] = r[tree[x].par];</span><br><span class="line">            &#125;</span><br><span class="line">            getinterval(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">            getinterval(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        l[root] = <span class="number">1</span>;</span><br><span class="line">        r[root] = n;</span><br><span class="line">        getinterval(tree[root].ch[<span class="number">0</span>]);</span><br><span class="line">        getinterval(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">		<span class="comment">// 要考虑有相同值的情形，必须要分两次搞，不然有bug</span></span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; updateinterval = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[tree[x].par].ch[<span class="number">0</span>] == x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tree[x].val == tree[tree[x].par].val) r[x] = r[tree[x].par];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (tree[x].val == tree[tree[x].par].val) l[x] = l[tree[x].par];</span><br><span class="line">            &#125;</span><br><span class="line">            updateinterval(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">            updateinterval(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">		updateinterval(tree[root].ch[<span class="number">0</span>]);</span><br><span class="line">        updateinterval(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; l[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; r[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>洛谷 T126268 「SWTR-05」Subsequence 有一个典型的应用</p>
</blockquote>
<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> t, w, next;</span><br><span class="line">&#125;</span><br><span class="line">a[N * N];</span><br><span class="line"><span class="keyword">int</span> n, ss, head[N], p[N], flow[N], c[N], h[N], numh[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	a[ss].t = y;</span><br><span class="line">	a[ss].w = w;</span><br><span class="line">	a[ss].next = head[x];</span><br><span class="line">	head[x] = ss++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow, ans = <span class="number">0</span>, neck, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span> (h));</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">memset</span>(numh, <span class="number">0</span>, <span class="keyword">sizeof</span> (numh));</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span> (p));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = head[i];</span><br><span class="line">	numh[<span class="number">0</span>] = n;</span><br><span class="line">	<span class="keyword">int</span> u = s;</span><br><span class="line">	<span class="keyword">while</span> (h[s] &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t) &#123;</span><br><span class="line">			flow = <span class="number">1e9</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i != t; i = a[c[i]].t) &#123;</span><br><span class="line">				<span class="keyword">if</span> (flow &gt; a[c[i]].w) &#123;</span><br><span class="line">					neck = i;</span><br><span class="line">					flow = a[c[i]].w;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i != t; i = a[c[i]].t) &#123;</span><br><span class="line">				a[c[i]].w -= flow;</span><br><span class="line">				a[c[i] ^ <span class="number">1</span>].w += flow;</span><br><span class="line">			&#125;</span><br><span class="line">			ans += flow;</span><br><span class="line">			u = neck;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (k = c[u]; k != <span class="number">-1</span>; k = a[k].next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[k].w &amp;&amp; h[u] == h[a[k].t] + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k != <span class="number">-1</span>) &#123;</span><br><span class="line">			c[u] = k;</span><br><span class="line">			p[a[k].t] = u;</span><br><span class="line">			u = a[k].t;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">0</span> == --numh[h[u]]) <span class="keyword">break</span>;</span><br><span class="line">			c[u] = head[u];</span><br><span class="line">			k = n;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = a[i].next) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[i].w) k = <span class="built_in">std</span>::<span class="built_in">min</span>(k, h[a[i].t]);</span><br><span class="line">			&#125;</span><br><span class="line">			h[u] = k + <span class="number">1</span>;</span><br><span class="line">			++numh[h[u]];</span><br><span class="line">			<span class="keyword">if</span> (u != s) u = p[u];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Stoer-Wagner-最小割"><a href="#Stoer-Wagner-最小割" class="headerlink" title="Stoer - Wagner 最小割"></a>Stoer - Wagner 最小割</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], dis[N], mp[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mincut</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0x7fffffff</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) p[i] = i;</span><br><span class="line">	<span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != n; ++i) &#123;</span><br><span class="line">			dis[p[i]] = mp[p[<span class="number">0</span>]][p[i]];</span><br><span class="line">			<span class="keyword">if</span> (dis[p[i]] &gt; dis[p[t]]) t = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> (vis));</span><br><span class="line">		vis[p[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ret &gt; dis[p[t]]) ret = dis[p[t]];</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != n; ++j) &#123;</span><br><span class="line">					mp[p[j]][p[s]] += mp[p[j]][p[t]];</span><br><span class="line">					mp[p[s]][p[j]] = mp[p[j]][p[s]];</span><br><span class="line">				&#125;</span><br><span class="line">				p[t] = p[--n];</span><br><span class="line">			&#125;</span><br><span class="line">			vis[p[t]] = <span class="literal">true</span>;</span><br><span class="line">			s = t;</span><br><span class="line">			t = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j != n; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!vis[p[j]]) &#123;</span><br><span class="line">					dis[p[j]] += mp[p[j]][p[s]];</span><br><span class="line">					<span class="keyword">if</span> (t == <span class="number">-1</span> || dis[p[j]] &gt; dis[p[t]]) t = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路-SPFA"><a href="#最短路-SPFA" class="headerlink" title="最短路 SPFA"></a>最短路 SPFA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1004</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], rehead[N], dist[N], sc, v[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> g;</span><br><span class="line">	A() &#123;&#125;</span><br><span class="line">	A(<span class="keyword">int</span> x, <span class="keyword">int</span> y): id(x), g(y) &#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> g + dist[id] &gt; a.g + dist[a.id];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ed;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">&#125;</span><br><span class="line">e[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">	e[sc].ed = y;</span><br><span class="line">	e[sc].w = z;</span><br><span class="line">	e[sc].next = head[x];</span><br><span class="line">	head[x] = sc++;</span><br><span class="line">	e[sc].ed = x;</span><br><span class="line">	e[sc].w = z;</span><br><span class="line">	e[sc].next = rehead[y];</span><br><span class="line">	rehead[y] = sc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> (v));</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (dist));</span><br><span class="line">	dist[s] = <span class="number">0</span>;</span><br><span class="line">	v[s] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span> &lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = rehead[u]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> ed = e[i].ed;</span><br><span class="line">			<span class="keyword">if</span> (dist[ed] &gt; dist[u] + e[i].w) &#123;</span><br><span class="line">				dist[ed] = dist[u] + e[i].w;</span><br><span class="line">				<span class="keyword">if</span> (!v[ed]) &#123;</span><br><span class="line">					v[ed] = <span class="literal">true</span>;</span><br><span class="line">					q.push(ed);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		v[u] = <span class="literal">false</span>;</span><br><span class="line">		q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维凸包"><a href="#二维凸包" class="headerlink" title="二维凸包"></a>二维凸包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">int</span> vc[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y, id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Node &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x != A.x || y != A.y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (y == A.y) <span class="keyword">return</span> x &lt; A.x;</span><br><span class="line">		<span class="keyword">return</span> y &lt; A.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p[N], q[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLeft</span><span class="params">(<span class="keyword">const</span> Node &amp; op,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> Node &amp; sp,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> Node &amp; ep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (sp.x - op.x) * (ep.y - op.y) &gt; (sp.y - op.y) * (ep.x - op.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">graham</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	sort(p, p + n);</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>] = p[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	q[<span class="number">1</span>] = p[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	q[<span class="number">2</span>] = p[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i != n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top &amp;&amp; crossLeft(q[top], p[i], q[top - <span class="number">1</span>])) --top;</span><br><span class="line">		q[++top] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = top;</span><br><span class="line">	q[++top] = p[n - <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">3</span>; i != <span class="number">-1</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top != len &amp;&amp; crossLeft(q[top], p[i], q[top - <span class="number">1</span>])) --top;</span><br><span class="line">		q[++top] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="几类根号算法"><a href="#几类根号算法" class="headerlink" title="几类根号算法"></a>几类根号算法</h2><h3 id="s-n-sum-i-1-n-lfloor-frac-n-i-rfloor"><a href="#s-n-sum-i-1-n-lfloor-frac-n-i-rfloor" class="headerlink" title="$ s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $"></a>$ s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	LL sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		sum += (j - i + <span class="number">1</span>) * (n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i"><a href="#sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i" class="headerlink" title="$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$"></a>$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// g[i]=f[i]+g[i-1]</span></span><br><span class="line">	LL sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= <span class="built_in">min</span>(n, m); i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = <span class="built_in">min</span>(n / (n / i), m / (m / i) sum += LL(n / i) * (m / i) * (g[j] - g[i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor"><a href="#h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor" class="headerlink" title="$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$"></a>$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	<span class="keyword">int</span> r = LL(n) * (n - <span class="number">1</span>) % M * (n - <span class="number">2</span>) % M * inv3 % M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= LL(j - i + <span class="number">1</span>) * getans(n / i) % M;</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>) r += M;</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归算法复杂度分析"><a href="#递归算法复杂度分析" class="headerlink" title="递归算法复杂度分析"></a>递归算法复杂度分析</h2><p>下图取自算法导论</p>
<p><img src= "/img/loading.gif" data-lazy-src="complexAnalysis.png" alt="complexAnalysis"></p>
<h2 id="STL-学习记录"><a href="#STL-学习记录" class="headerlink" title="STL 学习记录"></a>STL 学习记录</h2><p>为了更加 <strong>优雅</strong> 的写 C++，在学了一点 C++17 皮毛之后，重新探索了一下 C++ STL，总结一些好用的特征。</p>
<p><code>static_cast&lt;T&gt;, optional&lt;T&gt;</code> 是两个好东西。</p>
<p>等到 Codeforces 支持 <code>C++20</code> 后开始学习 <code>C++2x</code></p>
<blockquote>
<p>没有必要关心你自己不用的特征！用的就一定要搞清楚。</p>
</blockquote>
<p>以下示例中，凡是 vector 类型的 <code>a.begin(),a.end()</code> 对应的数组类型都可以改成 <code>a,a+n</code>。</p>
<h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p><code>min,max,minmax</code> 都是参数个数为 2，返回的是值。所以不举例了没注意到 <code>minmax</code> 返回的是 <code>pair</code></p>
<p><code>min_element,max_element,minmax_element</code> 参数都是 <code>vector</code>，且返回的是索引。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *max_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span> lr = minmax_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//不能取*,因为返回的是pair类型</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *lr.first &lt;&lt; <span class="string">" "</span> &lt;&lt; *lr.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span>[l, r] = minmax_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//自动解析也行</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *l &lt; <span class="string">" "</span> &lt;&lt; *r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="累积运算-accumulate-（长没关系，有代码补全）"><a href="#累积运算-accumulate-（长没关系，有代码补全）" class="headerlink" title="累积运算  accumulate （长没关系，有代码补全）"></a>累积运算  accumulate （长没关系，有代码补全）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//默认累和</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//可选加减乘除</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="built_in">std</span>::minus&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>, <span class="built_in">std</span>::multiplies&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>, <span class="built_in">std</span>::divides&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>, [](<span class="keyword">auto</span> &amp; x, <span class="keyword">auto</span> &amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span> * x + y;</span><br><span class="line">&#125;) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>用 <code>stable_sort</code> 是稳定排序，即不改变原有相互不小于的元素的相对位置</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 默认从小到大排序</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 手动从小到大排序（不一定是int，具体问题具体修改）</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.rbegin(), a.<span class="built_in">end</span>()); <span class="comment">// 从大到小排序</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 从大到小排序</span></span><br><span class="line"><span class="comment">//对于 tuple 和 pair 大小关系都是从按照字典序比较的</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> (x ^ <span class="number">4</span>) &lt; (y ^ <span class="number">4</span>); <span class="comment">// 位运算的优先级好低呀</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="集合交并运算"><a href="#集合交并运算" class="headerlink" title="集合交并运算"></a>集合交并运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::et&lt;<span class="keyword">int</span>&gt; x&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; y&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line"><span class="built_in">std</span>::set_intersection(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>(), y.<span class="built_in">end</span>(), <span class="built_in">std</span>::inserter(t, t.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// 若x,y,t是vector等有push_back 的容器，就可以使用</span></span><br><span class="line"><span class="comment">// set_intersection(x.begin(),x.end(),y.begin(),y.end(),back_inserter(t));</span></span><br><span class="line"><span class="comment">// set_union,set_difference,set_symmetric_difference 等同理</span></span><br></pre></td></tr></table></figure>
<h3 id="lambda-表达式递归写法"><a href="#lambda-表达式递归写法" class="headerlink" title="lambda 表达式递归写法"></a>lambda 表达式递归写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; gcd = [ &amp; ](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="comment">// 注意最前面不能用auto</span></span><br><span class="line">	<span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; gcd(<span class="number">102</span>, <span class="number">210</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::__gcd(<span class="number">102</span>, <span class="number">210</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="C-STL-内建的一些好用的函数"><a href="#C-STL-内建的一些好用的函数" class="headerlink" title="C++ STL 内建的一些好用的函数"></a>C++ STL 内建的一些好用的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::__builtin_parity(uint n):   返回n的二进制<span class="number">1</span>的个数奇偶性</span><br><span class="line"><span class="built_in">std</span>::__builtin_clz(uint n)：     返回n的二进制前置<span class="number">0</span>的个数</span><br><span class="line"><span class="built_in">std</span>::__builtin_ctz(uint n):      返回n的二进制后置<span class="number">0</span>的个数</span><br><span class="line"><span class="built_in">std</span>::__builtin_ffs(<span class="keyword">int</span> n)：      返回n的二进制从后往前第一次出现<span class="number">1</span>的位置</span><br><span class="line"><span class="built_in">std</span>::__lg(<span class="keyword">int</span> n):                返回log2(n)的整数部分</span><br><span class="line">= <span class="built_in">std</span>::__builtin_ctz(uint n)+<span class="number">1</span></span><br><span class="line"><span class="built_in">std</span>::__builtin_popcount(uint n): 返回n的二进制<span class="number">1</span>的个数，以上函数仅在GCC中有</span><br><span class="line">lowbit(uint n): n&amp;(-n)      返回使得最大的<span class="number">2</span>^i|n <span class="comment">// 这个不是内建的</span></span><br><span class="line"><span class="comment">//产生大的随机数</span></span><br><span class="line"><span class="built_in">std</span>::mt19937 rnd(<span class="built_in">std</span>::chrono::steady_clock::now().time_since_epoch().count());</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h2><h2 id="日常表白-zly"><a href="#日常表白-zly" class="headerlink" title="日常表白 zly"></a>日常表白 zly</h2></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">dna049</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dna049.com/templateOfCpp/">https://dna049.com/templateOfCpp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dna049.com" target="_blank">dna049</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/rewardAlipay.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/rewardAlipay.png" alt="下次"/></a><div class="post-qr-code-desc">下次</div></li><li class="reward-item"><a href="/img/rewardWechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/rewardWechat.png" alt="一定"/></a><div class="post-qr-code-desc">一定</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/pointSetTopology/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">从数列极限到点集拓扑学(from array limit to point set topology)</div></div></a></div><div class="next-post pull-right"><a href="/nft/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">快速数论变换</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/singleChip/" title="玩具：HC6800-ES 开发版"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-03-19</div><div class="relatedPosts_title">玩具：HC6800-ES 开发版</div></div></a></div><div class="relatedPosts_item"><a href="/codeforces/" title="Codeforces 汇总"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-22</div><div class="relatedPosts_title">Codeforces 汇总</div></div></a></div><div class="relatedPosts_item"><a href="/dynamicProgramming/" title="动态规划"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-21</div><div class="relatedPosts_title">动态规划</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><label><input id="switch-comments-btn" type="checkbox"/><span class="slider"></span></label><span class="second-comment">Utterances</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="utterances-wrap"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2020 By dna049</div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://hexo.io/" target="_blank" title="由 Hexo 强力驱动" data-pjax-state=""><span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://github.com/chachabai/hexo-theme-butterfly" target="_blank" title="主题" data-pjax-state=""><span class="badge-subject">Theme</span><span class="badge-value bg-blueviolet">Butterfly</span></a></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://github.com/" target="_blank" title="静态网页托管于 GitHub Pages 和 Coding Pages" data-pjax-state=""><span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen">GitHub</span></a></div></div><div class="container" id="jsi-flying-fish-container"></div><style>@media only screen and (max-width: 767px){
  #sidebar_search_box input[type=text]{width:calc(100% - 24px)}
}</style></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'TkSRiW6UjDGmsxqmjPiPRjHV-9Nh9j0Va',
      appKey: 'tQiWPCsXLT3YIbUTm3b9bewX',
      placeholder: '有 Github 账号的建议使用 Utterances 评论',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'chachabai/chachabai.github.io')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  if (document.querySelector('.utterances-frame')) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    const iframe = document.querySelector('.utterances-frame');
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Valine' === 'Utterances' || !false) {
  if (false) loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN@latest/js/fish.js"></script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script></div></body></html>
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Codeforces 汇总</title>
    <url>/codeforces/</url>
    <content><![CDATA[<p>最近感觉自己又行了。就很想重新开始打 <a href="https://codeforces.com" target="_blank" rel="noopener">Codeforces</a>，这里罗列一下从 2020/05/16 开始提交的(不是特别水的）AC 代码。想有生之年上一次黄，先定个小目标上个 1900（最高 1854，当前 1829，换号了！新账号于 2020/11/18 达成 1900+ 成就，紫名:)也太好看了吧）菜鸡 dna049 <del>加油</del> 下班了！</p>
<blockquote>
<p>不再打除了 codeforces, atcoder, 洛谷之外的日常比赛。有空整理一下比赛，好的题目或比赛记得 star。<br><strong>优雅的代码极大的避免了低级错误</strong>，边界处理至少占三分之一的工作量！</p>
<p><strong>不要急着写代码，不要急着写代码，不要急着写代码，重要的事情说三遍！！！</strong><br>优先做 Codeforces, Atcoder, 其它平台的题目可以在 vjudge 中提交（洛谷和 UOJ 除外)，POJ 和 HDU 不在搞了。<br>不要为了补题，Rating，浪费太多的时间<br>把一个问题写成简洁清晰的代码，才算是真的理解了问题！代码能力是快速综合规划的能力。<br>至少先上 2100，再去写博客，分低会影响博客的质量！</p>
</blockquote>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>珍惜每一场比赛，不要怕掉分，<strong>提前 6 分钟</strong>，准备以下事情（加号表示有用次数，2021 年开始计算）：</p>
<ol>
<li>如果没注册，赶紧注册。身体状态不好时，用小号打，上分不易。+2</li>
<li>闹钟（每个题不要长期思考，读完题没明显思路直接跳！只要不被卡题，我上 2100 应该不难，所以闹钟很重要） +2</li>
<li>纸和笔（ipad + pencil + 闹钟 亦可）+0（表示：永远有用）</li>
<li>SageMath，用于一些数据测试</li>
<li>打开自己的网站用于模板 +0</li>
<li>打开 VScode，查看 CF 比赛号，开始 <code>cf race CF 比赛号</code> +0</li>
<li>认真读题，特别是样例特别少的时候！</li>
<li>计算式要列的清晰，并且最好是好输入的（think twice, code once)。+2</li>
<li>不要膨胀，老老实实先做简单题，没思路就直接跳过（拒绝拖延，但是一定记得要回来把简单题补了！）</li>
<li>有思路赶紧写（但是思路清晰再写！无论问题难与否，大家都是一样的，打好自己！），不要觉得时间很多</li>
<li>开 room hack！锁题前检查边界，不要最后 RE 了（根据做题时，可能的 hack 点来找 hack，可以现在 EDU 场练习如何 hack。比赛结束看看自己 room 有那些没有过最终测试的。通用 hack 点：答案超了 long long，用 ceil 向上取整。注意有些狗喜欢 <code>#define int long long</code>）</li>
<li>前面题目被卡会特别影响做后面题的心态！</li>
<li>注意到题目中简单的性质结论都应该写下来，拼一下可能就知道怎么做了。注意特殊问题的特殊解法。</li>
<li>WA 之后，很可能方法错了，或者代码有问题，没有本质修改的话，不要乱提交！</li>
<li>有子问题的题目，两个都会做，先交分数小的。</li>
<li><strong>不要写这样的代码</strong>：<code>if(a[j++]), while(a[j++])</code> 这种数列下标自加，特别容易出问题还不好查，特别在判断语句中。</li>
<li>$N=10^{18}$ 一般会有公式， $N = 2 \cdot 10^5$ 一般会用到排序、树状数组，线段树，等一系列 $O(n \log n)$ 算法，$N=1000$ 一般会用到 $dp$。模 <code>998244353</code> 可能会用到 NFT。</li>
</ol>
<p>Codeforces 比赛规则：每题有基础分数，每题的分数根据时间线性递减到一半（所以有些大佬先做 CD，再做 AB），在最后一次提交前每次提交减 50 分，然后按照分数排名，有 hack，但是只有你过了初例并且 <strong>锁定题目</strong> 才能 hack。<br>Eductional 比赛规则：与 ICPC 一致，不过一次非 AC 提交罚时为 10 分钟（ICPC 20 分钟），难度比 Div2 稍难，需要更细心。</p>
<p>Codeforces Gobal Round：<del>目前实力不支持做这个，容易掉分！</del> 正常发挥都是能加分的！</p>
<p><a href="https://codeforces.com/problemset/standings?friendsEnabled=on" target="_blank" rel="noopener">查看 Codeforces 上的过题数</a>，<a href="https://codeforces.com/contests/with/dna049" target="_blank" rel="noopener">查看比赛 rating 折线</a>，开始使用 <a href="https://github.com/xalanq/cf-tool/blob/master/README_zh_CN.md" target="_blank" rel="noopener">cf-tool</a> + WSL 打比赛（真香）。</p>
<h2 id="题集"><a href="#题集" class="headerlink" title="题集"></a>题集</h2><h3 id="1480C：交互题，找一个排列中的极小值点"><a href="#1480C：交互题，找一个排列中的极小值点" class="headerlink" title="1480C：交互题，找一个排列中的极小值点"></a><a href="https://codeforces.com/contest/1480/problem/C" target="_blank" rel="noopener">1480C</a>：交互题，找一个排列中的极小值点</h3><p>首先让左边相邻两个降序，右边相邻两个升序（否则直接结束了），然后二分比较 m 与 m + 1 即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> query = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x]) <span class="keyword">return</span> a[x];</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"? "</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">int</span> r;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; r;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	a[<span class="number">1</span>] = query(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	a[<span class="number">2</span>] = query(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (a[<span class="number">2</span>] &gt; a[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	a[n] = query(n);</span><br><span class="line">	<span class="keyword">if</span> (a[n] == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">	a[n - <span class="number">1</span>] = query(n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (a[n - <span class="number">1</span>] &gt; a[n]) <span class="keyword">return</span> n;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">2</span>, r = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		a[m] = query(m);</span><br><span class="line">		a[m + <span class="number">1</span>] = query(m + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (a[m] &gt; a[m + <span class="number">1</span>]) &#123;</span><br><span class="line">			l = m + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r = m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> r = solve();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1481E：经典-DP"><a href="#1481E：经典-DP" class="headerlink" title="1481E：经典 DP"></a><a href="https://codeforces.com/contest/1481/problem/E" target="_blank" rel="noopener">1481E</a>：经典 DP</h3><p>题意：每次从数列 a 中取出一个数放在尾部，使得相同的数字挨在一起，问最少需要的次数。</p>
<p>做法：首先反过来考虑，看最多能有多少数维持不动（一下子简单了不少，如果直接处理原问题，会要考虑移动顺序就很难考虑了）我们显然是从后往前好考虑一些，我们设 <code>dp[i]</code> 为 $[i, n]$ 中最多维持不动的数。我们考虑状态转移，我们可以删除第 i 个数，此时 <code>dp[i] = dp[i + 1]</code>，否则我们保留 $[i, n]$ 中所有值为 <code>a[i]</code> 的数，如果更进一步 $[1, i - 1]$ 中不再出现 <code>a[i]</code>，那么我们可以把最后一个出现 <code>a[i]</code> 后面的也拿到，反之不能拿到的原因是，前面的 <code>a[i]</code> 要删掉要放在后面，因此，最后一个 <code>a[i]</code> 后面什么都不能放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	std::vector&lt;int&gt; a(n + 1), l(n + 1), r(n + 1), cnt(n + 1), dp(n + 2);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		r[a[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; --i) l[a[i]] = i;</span><br><span class="line">	<span class="comment">// dp[i] 表示 [i, n] 中能保存下来最多的数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		++cnt[a[i]];</span><br><span class="line">		<span class="keyword">if</span> (l[a[i]] == i) &#123;</span><br><span class="line">			dp[i] = <span class="built_in">std</span>::<span class="built_in">max</span>(dp[i + <span class="number">1</span>], cnt[a[i]] + dp[r[a[i]] + <span class="number">1</span>]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dp[i] = <span class="built_in">std</span>::<span class="built_in">max</span>(dp[i + <span class="number">1</span>], cnt[a[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n - dp[<span class="number">1</span>] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="708C：经典换根-DP"><a href="#708C：经典换根-DP" class="headerlink" title="708C：经典换根 DP"></a><a href="https://codeforces.com/problemset/problem/708/C" target="_blank" rel="noopener">708C</a>：经典换根 DP</h3><p>题意：是否能过通过一次调整（删一条边，加一条边）使得删除该点后的最大连通分支节点个数不超过 $\frac{n}{2}$</p>
<p>做法：首先考虑节点 1 为根，如果所有与 1 相连的子树的节点数均不超过 $\frac{n}{2}$，那么不用操作，已经可以作为重心了，否则最多只有一个子树的节点数大于 $\frac{n}{2}$，那么我们需要在这个子树中找一个节点个数不超过 $\frac{n}{2}$ 的子树，把它删了然后剩下的节点个数还要不超过 $\frac{n}{2}$（自然删节点最多的那个）。所以需要预处理出这个值。然后需要考虑换根（状态转移）。现在假设 fa 的结果已经搞定了，我们要看它的儿子节点 u，如果 u 的所有儿子的节点数都小于 $\frac{n}{2}$，那么我们要看 <code>sz[1] - sz[u]</code> 是否也小于 $\frac{n}{2}$，如果是不用操作了，否则，我们就要看抛弃以 v 为节点的子树后，整棵树节点不超过 $\frac{n}{2}$ 的最大子树（为此，我们需要预处理最大子儿子和次大子儿子）。如果 u 有个儿子节点数大于 $\frac{n}{2}$，那么和 1 一样判断即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// subtree[u] 表示以 u 为根的子树中 sz 不超过 n / 2 中最大的子子树的大小。</span></span><br><span class="line">	<span class="comment">// mx[u], mmx[u] 分别表示以表示以 u 为根的子树中 sz 不超过 n / 2 的中最大和次大的真子子树的大小。</span></span><br><span class="line">	std::vector&lt;int&gt; sz(n + 1), mx(n + 1), mmx(n + 1), subtree(n + 1);</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		sz[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			pdfs(v, u);</span><br><span class="line">			sz[u] += sz[v];</span><br><span class="line">			subtree[u] = <span class="built_in">std</span>::<span class="built_in">max</span>(subtree[u], subtree[v]);</span><br><span class="line">			<span class="keyword">if</span> (subtree[v] &gt; mx[u]) &#123;</span><br><span class="line">				mmx[u] = mx[u];</span><br><span class="line">				mx[u] = subtree[v];</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (subtree[v] &gt; mmx[u]) &#123;</span><br><span class="line">				mmx[u] = subtree[v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sz[u] &lt;= n / <span class="number">2</span>) subtree[u] = sz[u];</span><br><span class="line">	&#125;;</span><br><span class="line">	pdfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	std::vector&lt;int&gt; mxsub(n + 1), ans(n + 1);</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		ans[u] = <span class="number">1</span>;</span><br><span class="line">		mxsub[u] = mxsub[fa];</span><br><span class="line">		<span class="keyword">if</span> (subtree[u] == mx[fa]) &#123;</span><br><span class="line">			mxsub[u] = <span class="built_in">std</span>::<span class="built_in">max</span>(mxsub[fa], mmx[fa]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mxsub[u] = <span class="built_in">std</span>::<span class="built_in">max</span>(mxsub[fa], mx[fa]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sz[<span class="number">1</span>] - sz[u] &lt;= n / <span class="number">2</span>) mxsub[u] = <span class="built_in">std</span>::<span class="built_in">max</span>(mxsub[u], sz[<span class="number">1</span>] - sz[u]);</span><br><span class="line">		<span class="keyword">if</span> (sz[u] &lt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sz[<span class="number">1</span>] - sz[u] - mxsub[u] &gt; n / <span class="number">2</span>) ans[u] = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; sz[v] &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (sz[v] - subtree[v] &gt; n / <span class="number">2</span>) ans[u] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) dfs(v, u);</span><br><span class="line">	&#125;;</span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" \n"</span>[i == n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1324F：经典换根-DP"><a href="#1324F：经典换根-DP" class="headerlink" title="1324F：经典换根 DP"></a><a href="https://codeforces.com/problemset/problem/1324/F" target="_blank" rel="noopener">1324F</a>：经典换根 DP</h3><p>题意：以树的某个节点为根的子树的白色节点减去黑色节点的个数的最大值</p>
<p>做法：首先以 1 为根预处理所有子树的答案，然后分情况状态转移。具体看子节点是否对父节点做了贡献。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">if</span> (a[i] == <span class="number">0</span>) a[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		ans[u] = a[u];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			pdfs(v, u);</span><br><span class="line">			<span class="keyword">if</span> (ans[v] &gt; <span class="number">0</span>) ans[u] += ans[v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	pdfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 预处理出 1 为根的结果，然后进行换根 DP</span></span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ans[v] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ans[u] &gt; <span class="number">0</span>) ans[v] += ans[u];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ans[v] = <span class="built_in">std</span>::<span class="built_in">max</span>(ans[v], ans[u]);</span><br><span class="line">			&#125;</span><br><span class="line">			dfs(v, u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" \n"</span>[i == n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1476D：模拟题"><a href="#1476D：模拟题" class="headerlink" title="1476D：模拟题"></a><a href="https://codeforces.com/contest/1476/problem/D" target="_blank" rel="noopener">1476D</a>：模拟题</h3><p>题意：$n + 1$ 个点排成一排，中间有 n 跳有向边，问从 i 点出发最多可以经过多少个点（没走一次，所有边都会反向一次）</p>
<p>做法：首先，如果不反向，显然可以从左到右，从右到左跑两次得到结果。现在反向了，我们可以把奇数边反向，或者把偶数边反向，两个都需要，用数组好标号。注意逻辑要清晰了，怎么存都想清楚了，列好式子再写代码就会很优雅。</p>
<blockquote>
<p><del>下面代码写的相当优雅！</del> 看了 <a href="https://codeforces.com/contest/1476/submission/105866936" target="_blank" rel="noopener">WZYYN 的代码</a> 发现他比我这代码优雅多了。。直接 <code>f[0], g[0]</code> 表示往前往后没改变时的答案，<code>f[1], g[1]</code> 表示改变了的答案。然后递推就好了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line">std::pair&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; f(std::string s) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	std::vector&lt;int&gt; a(n + 1, 0), b(n + 1, 0);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">'L'</span>) a[i + <span class="number">1</span>] = a[i] + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">'R'</span>) b[i] = b[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> ss[<span class="number">2</span>];</span><br><span class="line">		ss[<span class="number">0</span>] = ss[<span class="number">1</span>] = s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) ss[<span class="number">0</span>][i] = (ss[<span class="number">0</span>][i] == <span class="string">'L'</span> ? <span class="string">'R'</span> : <span class="string">'L'</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) ss[<span class="number">1</span>][i] = (ss[<span class="number">1</span>][i] == <span class="string">'L'</span> ? <span class="string">'R'</span> : <span class="string">'L'</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">2</span>], b[<span class="number">2</span>];</span><br><span class="line">		<span class="built_in">std</span>::tie(a[<span class="number">0</span>], b[<span class="number">0</span>]) = f(ss[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">std</span>::tie(a[<span class="number">1</span>], b[<span class="number">1</span>]) = f(ss[<span class="number">1</span>]);</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'L'</span>) &#123;</span><br><span class="line">				c[i + <span class="number">1</span>] += a[i &amp; <span class="number">1</span>][i + <span class="number">1</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				c[i] += b[i &amp; <span class="number">1</span>][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c[i] &lt;&lt; <span class="string">" \n"</span>[i == n];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gym-102823：NFT-生成函数"><a href="#gym-102823：NFT-生成函数" class="headerlink" title="gym 102823：NFT + 生成函数"></a><a href="https://codeforces.com/gym/102823/problem/B" target="_blank" rel="noopener">gym 102823</a>：NFT + 生成函数</h3><p>首先注意到最终结果必然是形式为 $r[i] = c_0 A[i] + \cdots c_{n - 1 - i} A[n - 1]$ 的样子，并且这些 $c_i$ 都只和 <code>m, L</code> 有关，实际上它们的系数不难看出是 $(1 + x + \cdot x^{L- 1})^m$ 的系数，并且我们计算的时候只要模 $x^n$ 即可。注意到上式可以直接生成函数开方直接求解，复杂度为 $O(n \log n \log m)$，当然了注意到 $(1 + x + \cdot x^{L- 1})^m = (1 - x^L)^m (1 - x)^{-m}$，直接二项式展开求一次乘法，所以可以做到整体复杂度为 $O(n \log n)$。我也是这个题的<a href="https://codeforces.com/gym/102823/status?order=BY_CONSUMED_TIME_ASC" target="_blank" rel="noopener">最佳解答</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>, ROOT = <span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; j) <span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = a.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			(j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a, <span class="keyword">bool</span> isInverse = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">	LL g = powMod(ROOT, (M - <span class="number">1</span>) / a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span> (isInverse) &#123;</span><br><span class="line">		g = powMod(g, M - <span class="number">2</span>);</span><br><span class="line">		LL invLen = powMod(LL(a.<span class="built_in">size</span>()), M - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) x = x * invLen % M;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(a);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != w.<span class="built_in">size</span>(); ++i) w[i] = w[i - <span class="number">1</span>] * g % M;</span><br><span class="line">	<span class="keyword">auto</span> addMod = [](LL x, LL y) &#123;</span><br><span class="line">		<span class="keyword">return</span> (x += y) &gt;= M ? x -= M : x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">2</span>, half = <span class="number">1</span>; half != a.<span class="built_in">size</span>(); <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>, half &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, wstep = a.<span class="built_in">size</span>() / <span class="built_in">step</span>; i != a.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j != i + half; ++j) &#123;</span><br><span class="line">				LL t = (a[j + half] * w[wstep * (j - i)]) % M;</span><br><span class="line">				a[j + half] = addMod(a[j], M - t);</span><br><span class="line">				a[j] = addMod(a[j], t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&amp; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (sz &lt; tot) sz *= <span class="number">2</span>;</span><br><span class="line">	a.resize(sz);</span><br><span class="line">	b.resize(sz);</span><br><span class="line">	nft(a);</span><br><span class="line">	nft(b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != sz; ++i) a[i] = a[i] * b[i] % M;</span><br><span class="line">	nft(a, <span class="number">1</span>);</span><br><span class="line">	a.resize(tot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">2</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">inv</span><span class="params">(N)</span></span>;</span><br><span class="line">	inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) inv[i] = (M - M / i) * inv[M % i] % M;</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> T = <span class="number">1</span>; T &lt;= cas; ++T) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; T &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">		<span class="keyword">int</span> n, L, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; L &gt;&gt; m;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="built_in">std</span>::reverse(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">		LL now = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			b[i] = now;</span><br><span class="line">			now = now * (m + i) % M * inv[i + <span class="number">1</span>] % M;</span><br><span class="line">		&#125;</span><br><span class="line">		mul(a, b);</span><br><span class="line">		a.resize(n);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">fill</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">		now = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * L &lt; n; ++i) &#123;</span><br><span class="line">			b[i * L] = (now + M) % M;</span><br><span class="line">			now = -now * (m - i) % M * inv[i + <span class="number">1</span>] % M;</span><br><span class="line">		&#125;</span><br><span class="line">		mul(a, b);</span><br><span class="line">		a.resize(n);</span><br><span class="line">		<span class="comment">// c[i] = a[i] * b[0] + \cdots a[n - 1] * b[n - 1 - i]</span></span><br><span class="line">		<span class="comment">// 令 d[i] = a[n - 1 - i], e[i] = c[n - 1 - i] 则</span></span><br><span class="line">		<span class="comment">// e[i] = d[i] * b[0] + ... + d[0] * b[i]</span></span><br><span class="line">		<span class="built_in">std</span>::reverse(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gym-102823：分块贪心"><a href="#gym-102823：分块贪心" class="headerlink" title="gym 102823：分块贪心"></a><a href="https://codeforces.com/gym/102823/problem/A" target="_blank" rel="noopener">gym 102823</a>：分块贪心</h3><p>题意：把两个数组<code>a, b</code>合并成一个数组<code>c</code> 保持元素原有的顺序，使得 $\sum_{i = 1}^{n + m} c_i$ 最小。</p>
<p>首先观察到两个事实：1. 最终 c 数组中如果有相邻元素分别在不同的原数组，那么在前面的必然更大。2. 由于我们想尽量让大的元素放在前面，但是又要保持元素原有的性质，这样就会导致大的元素推自己前面的元素跑，例如 n 个 a 中元素，和 m 个 b 中元素，一个放前面一个放后面，那么哪一个放前面呢，计算之后会发现，平均值大的放前面即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::pair&lt;int, int&gt;&gt; f(std::vector&lt;LL&gt; &amp;a, std::vector&lt;LL&gt; &amp;s) &#123;</span><br><span class="line">	<span class="comment">// 从小到大一层一层的 push 数字只会越来越大! 大致懂了</span></span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] - s[Q.top()] &lt;= a[i] * (i - Q.top())) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = Q.top();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">while</span> (!Q.empty() &amp;&amp; (s[t] - s[Q.top()]) * (i + <span class="number">1</span> - t) &lt;= (s[i + <span class="number">1</span>] - s[t]) * (t - Q.top())) &#123;</span><br><span class="line">				t = Q.top();</span><br><span class="line">				Q.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			Q.push(t); </span><br><span class="line">		&#125; <span class="keyword">else</span> Q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; r;</span><br><span class="line">	<span class="keyword">int</span> now = n;</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		r.emplace_back(Q.top(), now);</span><br><span class="line">		now = Q.top();</span><br><span class="line">		Q.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	std::vector&lt;LL&gt; a(n), b(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : b) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	std::vector&lt;LL&gt; sa(n + 1), sb(m + 1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) sa[i + <span class="number">1</span>] = sa[i] + a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) sb[i + <span class="number">1</span>] = sb[i] + b[i];</span><br><span class="line">	<span class="keyword">auto</span> fa = f(a, sa), fb = f(b, sb);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; c;</span><br><span class="line">	<span class="keyword">while</span> (!fa.empty() &amp;&amp; !fb.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [la, ra] = fa.back();</span><br><span class="line">		<span class="keyword">auto</span> [lb, rb] = fb.back();</span><br><span class="line">		<span class="keyword">if</span> ((sa[ra] - sa[la]) * (rb - lb) &gt;= (sb[rb] - sb[lb]) * (ra - la)) &#123;</span><br><span class="line">			fa.pop_back();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = la; i &lt; ra; ++i) c.emplace_back(a[i]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fb.pop_back();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = lb; i &lt; rb; ++i) c.emplace_back(b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fa.empty()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = fb.back().first; i &lt; m; ++i) c.emplace_back(b[i]);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = fa.back().first; i &lt; n; ++i) c.emplace_back(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m; ++i) ans += c[i] * (i + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> T = <span class="number">1</span>; T &lt;= cas; ++T) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; T &lt;&lt; <span class="string">": "</span> &lt;&lt; solve() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1478D：GCD-once-more"><a href="#1478D：GCD-once-more" class="headerlink" title="1478D：GCD once more"></a><a href="https://codeforces.com/contest/1478/problem/D" target="_blank" rel="noopener">1478D</a>：GCD once more</h3><p>此题，一眼看出系数之和恒定为 1，但是我一直想根据 k 的奇偶性递推，但是复杂度完全无法预测，一直卡着自己被卡炸了！<br>通过 <code>2x - y</code> 这样一直搞，那么最终只要满足 系数之和为 1，都会出现。所以这就是个 gcd 问题啊</p>
<script type="math/tex; mode=display">
a_1 x_1 + \cdots a_n x_n = k, x_1 + \cdots x_n = 1</script><p>有整数解，当且仅当</p>
<script type="math/tex; mode=display">
(a_1 - a_i) x_1 + \cdots (a_n - a_i) x_n = k - a_i</script><p>有解。当且仅当 $\gcd(a_1 - a_i, \cdots, a_n - a_i) | k - a_i$</p>
<p>我们可以取 $a_i$ 为最小值，这样求 gcd 就不会出现负数了。代码太简单就不写了。</p>
<h3 id="gym-102832H：二分图博弈"><a href="#gym-102832H：二分图博弈" class="headerlink" title="gym 102832H：二分图博弈"></a><a href="https://codeforces.com/gym/102832/problem/H" target="_blank" rel="noopener">gym 102832H</a>：二分图博弈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur, h;</span><br><span class="line">	<span class="comment">// h[i] 表示 bfs 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路。</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		h.assign(n, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		h[s] = <span class="number">0</span>;</span><br><span class="line">		Q.push(s);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">					h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] != <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// f 表示从 u 点出发拥有的最大流量，输出的是 u 到 t 的最大流量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t || f == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">		<span class="keyword">int</span> r = f;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i &lt; g[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = g[u][i];</span><br><span class="line">			<span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">			<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> a = dfs(v, t, <span class="built_in">std</span>::<span class="built_in">min</span>(r, <span class="keyword">int</span>(c)));</span><br><span class="line">				e[j].second -= a;</span><br><span class="line">				e[j ^ <span class="number">1</span>].second += a;</span><br><span class="line">				r -= a;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f - r;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dinic(<span class="keyword">int</span> _n) : n(_n), g(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (bfs(s, t)) &#123;</span><br><span class="line">			cur.assign(n, <span class="number">0</span>);</span><br><span class="line">			r += dfs(s, t, INT_MAX);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nn, m, ss;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; nn &gt;&gt; m &gt;&gt; ss;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nn; ++i) n *= <span class="number">10</span>;</span><br><span class="line">	<span class="function">Dinic <span class="title">g</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> s = n, t = n + <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ban</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		ban[x] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> cal = [](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (x) &#123;</span><br><span class="line">			r += x % <span class="number">10</span>;</span><br><span class="line">			x /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> cs = cal(ss);</span><br><span class="line">	<span class="keyword">auto</span> add = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> t) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t % <span class="number">2</span> != cs % <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j *= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="comment">// 往上移动一位</span></span><br><span class="line">			<span class="keyword">if</span> (i + j &lt; n &amp;&amp; cal(i + j) == t + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!ban[i + j]) g.addEdge(i, i + j, <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(!ban[i - <span class="number">9</span> * j]) g.addEdge(i, i - <span class="number">9</span> * j, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 往下移动一位</span></span><br><span class="line">			<span class="keyword">if</span> (i &gt;= j &amp;&amp; cal(i - j) == t - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!ban[i - j]) g.addEdge(i, i - j, <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (!ban[i + <span class="number">9</span> * j]) g.addEdge(i, i + <span class="number">9</span> * j, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!ban[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cal(i) % <span class="number">2</span> == cs % <span class="number">2</span>) g.addEdge(s, i, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> g.addEdge(i, t, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ban[ss] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!ban[i]) &#123;</span><br><span class="line">		add(i, cal(i));</span><br><span class="line">	&#125;</span><br><span class="line">	g.maxFlow(s, t);</span><br><span class="line">	ban[ss] = <span class="number">0</span>;</span><br><span class="line">	g.addEdge(s, ss, <span class="number">1</span>);</span><br><span class="line">	add(ss, cs);</span><br><span class="line">	<span class="keyword">return</span> g.maxFlow(s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("C:\\Users\\dna049\\cf\\in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (solve() ? <span class="string">"Alice\n"</span> : <span class="string">"Bob\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gym-102832K：gcd-once-more"><a href="#gym-102832K：gcd-once-more" class="headerlink" title="gym 102832K：gcd once more"></a><a href="https://codeforces.com/gym/102832/problem/K" target="_blank" rel="noopener">gym 102832K</a>：gcd once more</h3><p>考虑 $\gcd(x, y) = x ^ y$。我总想把最终形式给搞出来（想太多，吃力不讨好），首先显然 $x \neq y$（不考虑 0），不妨设 $x &gt; y$，那么 $x - y \geq \gcd(x - y, y) = \gcd(x, y) = x^y \geq x - y$。从而知道 $\gcd(x, y) = x^y = x - y$，然后我还一直想继续推，甚至猜想 $x = 2^k(2n + 1), y = 2^{k + 1} \cdot n$，浪费了特别多的时间，其实此时显然可以枚举 gcd 的值在 $O(n \log n)$ 把所有情况找出来嘛。后面就是并查集常规操作了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bad[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt; N; j += i) <span class="keyword">if</span> ((j ^ i) == j - i)&#123;</span><br><span class="line">			bad[j - i].emplace_back(j);</span><br><span class="line">			bad[j].emplace_back(j - i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) <span class="built_in">std</span>::sort(bad[i].<span class="built_in">begin</span>(), bad[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	std::vector&lt;int&gt; p(n + m + 1), a(n + m + 1);</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	std::vector&lt;std::map&lt;int, int&gt;&gt; mp(n + m + 1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		mp[i].insert(&#123;a[i], <span class="number">1</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; <span class="built_in">find</span> = [&amp;](<span class="keyword">int</span> x) -&gt;<span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">		<span class="keyword">return</span> p[x];</span><br><span class="line">	&#125;;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> merge = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">		<span class="keyword">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (fx == fy) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (mp[fx].<span class="built_in">size</span>() &lt; mp[fy].<span class="built_in">size</span>()) <span class="built_in">std</span>::swap(fx, fy);</span><br><span class="line">		p[fy] = fx;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : mp[fy]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> t : bad[v]) <span class="keyword">if</span> (mp[fx].count(t)) &#123;</span><br><span class="line">				ans += LL(mp[fx][t]) * c;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : mp[fy]) &#123;</span><br><span class="line">			mp[fx][v] += c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> change = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">		<span class="keyword">int</span> fx = <span class="built_in">find</span>(x);</span><br><span class="line">		<span class="keyword">auto</span> &amp;it = mp[fx];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> t : bad[a[x]]) <span class="keyword">if</span> (it.count(t)) &#123;</span><br><span class="line">			ans -= it[t];</span><br><span class="line">		&#125;</span><br><span class="line">		--it[a[x]];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> t : bad[y]) <span class="keyword">if</span> (it.count(t)) &#123;</span><br><span class="line">			ans += it[t];</span><br><span class="line">		&#125;</span><br><span class="line">		++it[y];</span><br><span class="line">		a[x] = y;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> op, x, y;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">			a[x] = y;</span><br><span class="line">			mp[x].insert(&#123;y, <span class="number">1</span>&#125;);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">			merge(x, y);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[x] != y) &#123;</span><br><span class="line">			change(x, y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1313C2：经典问题：单调栈优化"><a href="#1313C2：经典问题：单调栈优化" class="headerlink" title="1313C2：经典问题：单调栈优化"></a><a href="https://codeforces.com/contest/1313/problem/C2" target="_blank" rel="noopener">1313C2</a>：经典问题：单调栈优化</h3><p>首先最优答案肯定时先递增后递减的。相当于有一个制高点，枚举制高点，自然有 $O(n^2)$ 的算法。但是利用单调栈可以优化到 $O(n)$。设 <code>l[i], r[i]</code> 分别表示以 i 为最高点的（前，后）缀和最大值。只讨论前缀，那么求 l[i] 自然时往前找比它小的，然后继承比的小的答案了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;]() -&gt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre(n, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!Q.empty() &amp;&amp; a[Q.top()] &gt;= a[i]) Q.pop();</span><br><span class="line">			<span class="keyword">if</span> (!Q.empty()) pre[i] = Q.top();</span><br><span class="line">			Q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pre;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> g = [&amp;]() -&gt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt(n, n);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!Q.empty() &amp;&amp; a[Q.top()] &gt;= a[i]) Q.pop();</span><br><span class="line">			<span class="keyword">if</span> (!Q.empty()) nxt[i] = Q.top();</span><br><span class="line">			Q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nxt;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> pre = f(), suf = g();</span><br><span class="line">	std::vector&lt;LL&gt; b(n), c(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		b[i] = LL(i - pre[i]) * a[i] + (pre[i] == <span class="number">-1</span> ? <span class="number">0</span> : b[pre[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		c[i] = LL(suf[i] - i) * a[i] + (suf[i] == n ? <span class="number">0</span> : c[suf[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b[i] + c[i] - a[i] &gt; r) &#123;</span><br><span class="line">			r = b[i] + c[i] - a[i];</span><br><span class="line">			id = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = id; i != <span class="number">-1</span>; i = pre[i]) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j != pre[i]; --j) a[j] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = id; i != n; i = suf[i]) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j != suf[i]; ++j) a[j] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" \n"</span>[i == n - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LOJ-P1823：经典问题：问有多少对元素，它们之间没有比它们都大的元素"><a href="#LOJ-P1823：经典问题：问有多少对元素，它们之间没有比它们都大的元素" class="headerlink" title="LOJ P1823：经典问题：问有多少对元素，它们之间没有比它们都大的元素"></a><a href="https://www.luogu.com.cn/problem/P1823" target="_blank" rel="noopener">LOJ P1823</a>：经典问题：问有多少对元素，它们之间没有比它们都大的元素</h3><p>用单调栈存可以被当前位置的人看到的人的编号，显然是单调不增的（你回头一看，看到的人升高时单调不减的）。由于有身高相同的情况，所以需要合并相同身高。    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">izlyforever <span class="number">2021</span>/<span class="number">1</span>/<span class="number">26</span> <span class="number">23</span>:<span class="number">24</span>:<span class="number">58</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; S;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!S.empty() &amp;&amp; S.top().first &lt;= x) &#123;</span><br><span class="line">			<span class="keyword">if</span> (S.top().first == x) &#123;</span><br><span class="line">				cnt = S.top().second;</span><br><span class="line">			&#125;</span><br><span class="line">			r += S.top().second;</span><br><span class="line">			S.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!S.empty()) ++r;</span><br><span class="line">		S.push(&#123;x, ++cnt&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1009F：长链剖分-dsu-on-tree"><a href="#1009F：长链剖分-dsu-on-tree" class="headerlink" title="1009F：长链剖分 dsu on tree"></a><a href="https://codeforces.com/contest/1009/problem/F" target="_blank" rel="noopener">1009F</a>：长链剖分 dsu on tree</h3><p>在 <a href="/graph/" title="C++ 图论模板">C++ 图论模板</a> 长链剖分中有讲解。这个题重链剖分也可以写，但是要写成这样的（不需要编译器优化的版本）：<a href="https://codeforces.com/contest/1009/submission/105484073" target="_blank" rel="noopener">submission 105484073</a>，更优雅更快（由于编译器优化）的写法：<a href="https://codeforces.com/contest/1009/submission/105483361" target="_blank" rel="noopener">submission 105483361</a> 会 RE。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始。</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dsuOnTree</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 预处理出重儿子</span></span><br><span class="line">	std::vector&lt;int&gt; sz(n), son(n), dep(n);</span><br><span class="line">	dep[rt] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		sz[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			sz[u] += pdfs(v, u);</span><br><span class="line">			<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sz[u];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">	std::vector&lt;std::map&lt;int, int&gt;&gt; mp(n);</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (son[u] == <span class="number">0</span>) &#123;</span><br><span class="line">			ans[u] = dep[u];</span><br><span class="line">			mp[u].insert(&#123;dep[u], <span class="number">1</span>&#125;);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(son[u], u);</span><br><span class="line">		<span class="built_in">std</span>::swap(mp[son[u]], mp[u]);</span><br><span class="line">		ans[u] = ans[son[u]];</span><br><span class="line">		<span class="keyword">auto</span> &amp;mpu = mp[u];</span><br><span class="line">		<span class="keyword">int</span> mx = mpu[ans[u]];</span><br><span class="line">		<span class="keyword">auto</span> deal = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> c) &#123;</span><br><span class="line">			<span class="keyword">auto</span> &amp;it = mpu[x];</span><br><span class="line">			it += c;</span><br><span class="line">			<span class="keyword">if</span> (it &gt; mx || (it == mx &amp;&amp; ans[u] &gt;= x)) &#123;</span><br><span class="line">				ans[u] = x;</span><br><span class="line">				mx = it;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		deal(dep[u], <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs(v, u);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [t, x] : mp[v]) &#123;</span><br><span class="line">				deal(t, x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	pdfs(rt,<span class="number">0</span>);</span><br><span class="line">	dfs(rt, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) ans[i] -= dep[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> r = dsuOnTree(e);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` C++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始。</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dsuOnTree</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 预处理出重儿子</span></span><br><span class="line">	std::vector&lt;int&gt; sz(n), son(n);</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			pdfs(v, u);</span><br><span class="line">			<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		sz[u] = sz[son[u]] + <span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> (son[u] == <span class="number">0</span>) &#123;</span><br><span class="line">			ans[u] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> a = dfs(son[u], u);</span><br><span class="line">		ans[u] = ans[son[u]];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			<span class="keyword">auto</span> tmp = dfs(v, u);</span><br><span class="line">			<span class="comment">// 这里需要对齐</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> ai = a.<span class="built_in">size</span>() - <span class="number">1</span>, ti = tmp.<span class="built_in">size</span>() - <span class="number">1</span>; ti &gt;= <span class="number">0</span>; --ti, --ai) &#123;</span><br><span class="line">				a[ai] += tmp[ti];</span><br><span class="line">				<span class="keyword">if</span> (a[ai] &gt; a[ans[u]] || (a[ai] == a[ans[u]] &amp;&amp; ai &gt; ans[u])) &#123;</span><br><span class="line">					ans[u] = ai;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		a.emplace_back(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (a[ans[u]] == <span class="number">1</span>) ans[u] = sz[u] - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;;</span><br><span class="line">	pdfs(rt, <span class="number">0</span>);</span><br><span class="line">	dfs(rt, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) ans[i] = sz[i] - <span class="number">1</span> - ans[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> r = dsuOnTree(e);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="gym-102832F：dsu-on-tree"><a href="#gym-102832F：dsu-on-tree" class="headerlink" title="gym 102832F：dsu on tree"></a><a href="https://codeforces.com/gym/102832/problem/F" target="_blank" rel="noopener">gym 102832F</a>：dsu on tree</h3><p>首先，我们可以枚举 lca(i, j)，也就是说每一个节点都可以当其子树的 lca，它的两个子树中元素的 lca 必然是它。因此把这个答案算成是这个节点的答案。然后就是轻重链的问题了。注意到这里答案是异或值求和，那么我们可以诸位考虑即可。这里的写法跟 600E 的写法不一致。其实也可以写成一致的样子，600E 也可以写成我这个样子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">18</span>;</span><br><span class="line">	<span class="keyword">int</span> a[N]&#123;&#125;;</span><br><span class="line">	Node() &#123;&#125;</span><br><span class="line">	Node(<span class="keyword">int</span> x) &#123;</span><br><span class="line">		++a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (x) &#123;</span><br><span class="line">			a[++now] = x &amp; <span class="number">1</span>;</span><br><span class="line">			x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Node <span class="keyword">operator</span>+=(<span class="keyword">const</span> Node &amp;A) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) a[i] += A.a[i];</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">LL <span class="title">deal</span><span class="params">(<span class="keyword">const</span> Node &amp; A, <span class="keyword">const</span> Node &amp; B)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Node::N; ++i) &#123;</span><br><span class="line">		r += (LL(A.a[<span class="number">0</span>] - A.a[i]) * B.a[i] + LL(B.a[<span class="number">0</span>] - B.a[i]) * A.a[i]) &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始</span></span><br><span class="line"><span class="function">LL <span class="title">dsuOnTree</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 预处理出重儿子</span></span><br><span class="line">	std::vector&lt;int&gt; sz(n), son(n);</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		sz[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			sz[u] += pdfs(v, u);</span><br><span class="line">			<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sz[u];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node&gt;(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Node&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> (son[u] == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#123;a[u], Node(u)&#125;&#125;;</span><br><span class="line">		<span class="keyword">auto</span> mp = dfs(son[u], u); <span class="comment">// 这里开 O2 被编译器优化了，不然直接爆炸</span></span><br><span class="line">		mp[a[u]] += Node(u);</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			<span class="keyword">auto</span> tmp = dfs(v, u);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [i, x] : tmp) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(i ^ a[u]); it != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">					r += deal(it-&gt;second, x);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [i, x] : tmp) mp[i] += x;</span><br><span class="line">		&#125;</span><br><span class="line">		ans[u] = r;</span><br><span class="line">		<span class="keyword">return</span> mp;</span><br><span class="line">	&#125;;</span><br><span class="line">	pdfs(rt, rt);</span><br><span class="line">	dfs(rt, rt);</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) r += ans[i];</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("C:\\Users\\dna049\\cf\\in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dsuOnTree(e, a) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="600E：dsu-on-tree"><a href="#600E：dsu-on-tree" class="headerlink" title="600E：dsu on tree"></a><a href="https://codeforces.com/contest/600/problem/E" target="_blank" rel="noopener">600E</a>：dsu on tree</h3><p>不借鉴别人，自己独创的<a href="https://codeforces.com/contest/600/submission/105278738" target="_blank" rel="noopener">优秀写法</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始，参考：https://www.cnblogs.com/zwfymqz/p/9683124.html</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">dsuOnTree</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	std::vector&lt;int&gt; sz(n), son(n), cnt(n);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="comment">// 预处理出重儿子</span></span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		sz[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			sz[u] += pdfs(v, u);</span><br><span class="line">			<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sz[u];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 这个函数具体问题具体分析</span></span><br><span class="line">	<span class="keyword">int</span> mx = <span class="number">0</span>, Son = <span class="number">0</span>;</span><br><span class="line">	LL sm = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; deal = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		++cnt[a[u]];</span><br><span class="line">		<span class="keyword">if</span> (cnt[a[u]] &gt; mx) &#123;</span><br><span class="line">			mx = cnt[a[u]];</span><br><span class="line">			sm = a[u];</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt[a[u]] == mx) &#123;</span><br><span class="line">			sm += a[u];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; v != Son) &#123;</span><br><span class="line">			deal(v, u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; del = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		--cnt[a[u]];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) del(v, u);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">bool</span> save) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs(v, u, <span class="number">0</span>); <span class="comment">// 先计算轻边贡献，但最终要消除影响，防止影响轻边</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>);  <span class="comment">// 统计重儿子的贡献，但不消除影响</span></span><br><span class="line">		Son = son[u];</span><br><span class="line">		deal(u, fa); <span class="comment">// 暴力处理除重儿子外的贡献</span></span><br><span class="line">		Son = <span class="number">0</span>;</span><br><span class="line">		ans[u] = sm;</span><br><span class="line">		<span class="keyword">if</span> (!save) &#123;</span><br><span class="line">			del(u, fa);</span><br><span class="line">			sm = <span class="number">0</span>;</span><br><span class="line">			mx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	pdfs(rt, rt);</span><br><span class="line">	dfs(rt, rt, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> r = dsuOnTree(e, a);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r[i] &lt;&lt; <span class="string">" \n"</span>[i == n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gym-102832D：无意义的序列"><a href="#gym-102832D：无意义的序列" class="headerlink" title="gym 102832D：无意义的序列"></a><a href="https://codeforces.com/gym/102832/problem/D" target="_blank" rel="noopener">gym 102832D</a>：无意义的序列</h3><p>首先 c = 0 时特判，$c \geq 1$ 时，观察到 $a_n = c^{bit}$, bit 为 n 的二进制中 1 的个数。然后我们只需看小于 10…0（k 个 0） 时的答案即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;   x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">2</span>;</span><br><span class="line">LL fac[N], ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">	ifac[N - <span class="number">1</span>] = powMod(fac[N - <span class="number">1</span>], M - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; --i) ifac[i - <span class="number">1</span>] = ifac[i] * i % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//if (n &lt; k || n &lt; 0) return 0;</span></span><br><span class="line">	<span class="keyword">return</span> fac[n] * ifac[k] % M * ifac[n - k] % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		r += binom(n, i) * powMod(c, i + a) % M; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; c;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1\n"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	init();</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">		r += solve(s.<span class="built_in">size</span>() - i - <span class="number">1</span>, a++, c);</span><br><span class="line">	&#125;</span><br><span class="line">	r += powMod(c, a);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r % M &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtCoder-ABC189F"><a href="#AtCoder-ABC189F" class="headerlink" title="AtCoder ABC189F"></a><a href="https://atcoder.jp/contests/abc189/tasks/abc189_f" target="_blank" rel="noopener">AtCoder ABC189F</a></h3><p>从 0 位置出发，走到大于等于 n 的位置结束，每次平均概率在 [1, m] 步中选择步长来走，有 k 个坑，走到坑就回到起点 0。问结束前步数的期望是多少，如果无法结束就输出 -1。</p>
<p>做法：首先如果有连续 m 个坑（很好判断），必然无法结束，否则可以结束，我们设 <code>dp[i]</code> 表示从 i 出发的答案。显然 $dp[i] = 0, i \geq n$，我们从后往前跑，显然有状态转移，如果 i 位置有坑，那么 $dp[i] = dp[0]$, 否则 $dp[i] = (dp[i + 1] + \cdots dp[i + m]) / m  + 1$。这个后缀和，我们可以用个变量记录下来。因此 所有的 dp[i] 都是一个 $a + b dp[0]$ 的形式，然后到最后有 $dp[0] = a + b dp[0]$ 从而就求得了结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("C:\\Users\\dna049\\cf\\in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(k)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt; k; ++i) <span class="keyword">if</span> (a[i] - a[i - m + <span class="number">1</span>] == m - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-1\n"</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::vector&lt;double&gt; b(n + m), c(n + m);</span><br><span class="line">	<span class="keyword">double</span> sb = <span class="number">0</span>, sc = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a.<span class="built_in">size</span>() &amp;&amp; i == a.back()) &#123;</span><br><span class="line">			b[i] = <span class="number">0</span>;</span><br><span class="line">			c[i] = <span class="number">1</span>;</span><br><span class="line">			a.pop_back();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			b[i] = sb / m + <span class="number">1</span>;</span><br><span class="line">			c[i] = sc / m;</span><br><span class="line">		&#125;</span><br><span class="line">		sb += b[i] - b[i + m];</span><br><span class="line">		sc += c[i] - c[i + m];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; b[<span class="number">0</span>] / (<span class="number">1</span> - c[<span class="number">0</span>]) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gym-102940H"><a href="#gym-102940H" class="headerlink" title="gym 102940H"></a><a href="https://codeforces.com/gym/102940/problem/H" target="_blank" rel="noopener">gym 102940H</a></h3><p>长为 k 取值在 [1, n] 且满足 $a_i \mid a_{i + 1}$ 的序列有多少个。</p>
<p>我一开始以为跟 n 的素因子有关，后来发现没法直接推公式，然后发现是一个 dp 问题，令 <code>dp[k][x]</code> 表示长为 k 满足  $a_i \mid a_{i + 1}$ 且每项都是 x 的因子的序列个数。答案必然就是 $\sum_{x = 1}^n dp[k - 1][x]$。复杂度 $O(k n \log n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(k, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> t = j; t &lt;= n; t += j) &#123;</span><br><span class="line">				(dp[i][t] += dp[i - <span class="number">1</span>][j]) %= M;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) (r += dp[k - <span class="number">1</span>][i]) %= M;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1474D：相连同时减一"><a href="#1474D：相连同时减一" class="headerlink" title="1474D：相连同时减一"></a><a href="https://codeforces.com/contest/1474/problem/D" target="_blank" rel="noopener">1474D</a>：相连同时减一</h3><p>题意：每次可以同时使得相连两个数减 1，问是否能使得数组变成全 0。这个问题相当简单，因此换成，能否最多互换相连两个的值，使得原问题成立。</p>
<p>做法：原问题做法就是从左到右依次跑，如果跑出负数就不行，跑到最后不是 0 也不行。然后一开始我想错了，吃了两次 WA 之后，发现互换相邻两个之后原问题成立的前提是，从左到右跑和从右到左跑都不会出现负数。因此就保存左右两边跑的结果，然后只需考虑 4 个数的时候是否对就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">auto</span> check = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a) &#123;</span><br><span class="line">		<span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">			now = x - now;</span><br><span class="line">			<span class="keyword">if</span> (now &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> now == <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">		b[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; b[i] &gt;= <span class="number">0</span>; ++i) &#123;</span><br><span class="line">			b[i + <span class="number">1</span>] = a[i] - b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (b[n] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; now &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (b[i - <span class="number">1</span>] &gt;= <span class="number">0</span> &amp;&amp; check(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;b[i - <span class="number">1</span>], a[i], a[i - <span class="number">1</span>], now&#125;))) &#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			now = a[i] - now;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (flag ? <span class="string">"YES\n"</span> : <span class="string">"NO\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1474C：乱搞题"><a href="#1474C：乱搞题" class="headerlink" title="1474C：乱搞题"></a><a href="https://codeforces.com/contest/1474/problem/C" target="_blank" rel="noopener">1474C</a>：乱搞题</h3><blockquote>
<p>一开始思路不清晰就写代码，写着发现有问题，被卡了挺长时间，导致 D 题差最后 10 分钟没有 debug 出一个小错误。</p>
</blockquote>
<p>做法：从最大的开始找，然后删除对应的节点即可。初始值 x 必然是 a 中最大值和另一个值的和。分析好问题后再选取合适的 STL，我用的是 map，很多人用的是 multiset </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">auto</span> f = [](<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp, <span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; r;</span><br><span class="line">		<span class="keyword">while</span> (!mp.empty()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> it = mp.rbegin();</span><br><span class="line">			<span class="keyword">int</span> u = it-&gt;first;</span><br><span class="line">			<span class="keyword">if</span> (--mp[u] == <span class="number">0</span>) mp.erase(u);</span><br><span class="line">			<span class="keyword">if</span> (mp.<span class="built_in">find</span>(x - u) == mp.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">			r.emplace_back(x - u, u);</span><br><span class="line">			<span class="keyword">if</span> (--mp[x - u] == <span class="number">0</span>) mp.erase(x - u);</span><br><span class="line">			x = u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			++mp[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; r;</span><br><span class="line">		<span class="keyword">int</span> t = mp.rbegin()-&gt;first;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">			x = t + it-&gt;first;</span><br><span class="line">			r = f(mp, x);</span><br><span class="line">			<span class="keyword">if</span> (r.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (r.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : r) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1473F：经典最大流（最小割）问题"><a href="#1473F：经典最大流（最小割）问题" class="headerlink" title="1473F：经典最大流（最小割）问题"></a><a href="https://codeforces.com/contest/1473/problem/F" target="_blank" rel="noopener">1473F</a>：经典最大流（最小割）问题</h3><p>题意：给定长为 n($1 \leq n \leq 3000$) 的数组 a($1 \leq a_i \leq 100$), b($-10^5 \leq b_i \leq 10^5$)，求 $\displaystyle \max_{i \in S} b_i$，其中集合 $S$ 满足若 $i \in S$，则任意 $0 \leq j &lt; i$, 若 $a_i \equiv 0 \mod a_j$，那么 $j$ 也在 $S$ 中。</p>
<p>做法：设 $s = n$ 为源点，$t = n + 1$ 为汇点，如果 $b_i &gt; 0$（则称 i 为正点，否则为负点），那么我们从源点 $s$ 到 $i$ 建一个容量为 $b_i$ 的边，反之我们就从 $i$ 到 $s$ 建一个容量为 $-b_i$ 的边。如果 $j &lt; i$ 满足 $a_i \equiv 0 \mod a_j$，那么从 $j$ 到 $i$ 建一个容量为无穷大的边（一个必要的优化，直接这样建图，边太多了，根据这个性质的传递性，我们不妨找最后一个值为 $a_j$ 的点和 $i$ 相连）。<br>我们不妨先把所有正点全部放在 $S$ 中，然后求最小割即可，注意到满足性质的边容量是无限大的，因此我们必然会将这样的两个节点放在一起！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="comment">// cur[u] 表示以 u 为起点当前没被增广过的边</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur, h;</span><br><span class="line">	<span class="comment">// h[u] 表示 bfs 从 s 到 u 的距离，如果找到了 t，那么就说明找到了增广路。</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		h.assign(n, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		h[s] = <span class="number">0</span>;</span><br><span class="line">		Q.push(s);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">					h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// f 表示从 u 点出发拥有的最大流量，输出的是 u 到 t 的最大流量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t) <span class="keyword">return</span> f;</span><br><span class="line">		<span class="keyword">int</span> r = f;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i &lt; g[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = g[u][i];</span><br><span class="line">			<span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">			<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> a = dfs(v, t, <span class="built_in">std</span>::<span class="built_in">min</span>(r, c));</span><br><span class="line">				e[j].second -= a;</span><br><span class="line">				e[j ^ <span class="number">1</span>].second += a;</span><br><span class="line">				r -= a;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f - r;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dinic(<span class="keyword">int</span> _n) : n(_n), g(_n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (bfs(s, t)) &#123;</span><br><span class="line">			cur.assign(n, <span class="number">0</span>);</span><br><span class="line">			r += dfs(s, t, INT_MAX);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	std::vector&lt;int&gt; a(n), b(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : b) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">last</span><span class="params">(<span class="number">101</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="function">Dinic <span class="title">g</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			r += b[i];</span><br><span class="line">			g.addEdge(n, i, b[i]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			g.addEdge(i, n + <span class="number">1</span>, -b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= a[i]; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] % j == <span class="number">0</span> &amp;&amp; last[j] != <span class="number">-1</span>) &#123;</span><br><span class="line">				g.addEdge(i, last[j], INT_MAX);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		last[a[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	r -= g.maxFlow(n, n + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1473D：经典前缀后缀"><a href="#1473D：经典前缀后缀" class="headerlink" title="1473D：经典前缀后缀"></a><a href="https://codeforces.com/contest/1473/problem/D" target="_blank" rel="noopener">1473D</a>：经典前缀后缀</h3><p>前缀和的历史最大值和历史最小值是特别好求的。后缀和的呢，却不那么显然。考虑后缀的时候，我们实际上要考虑后缀对最后结果的贡献。比如最大值，我们需要看当前后缀是否大于 0，如果小于等于 0 就直接抛弃重新开始，否则就继续保存。最小值同理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">		std::vector&lt;std::pair&lt;int, int&gt;&gt; a(n + 2), b(n + 2);</span><br><span class="line">		<span class="keyword">int</span> now = <span class="number">0</span>, mx = <span class="number">0</span>, mn = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">				mx = <span class="built_in">std</span>::<span class="built_in">max</span>(mx, ++now);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				mn = <span class="built_in">std</span>::<span class="built_in">min</span>(mn, --now);</span><br><span class="line">			&#125;</span><br><span class="line">			a[i] = &#123;mn, mx&#125;;</span><br><span class="line">			c[i] = now;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> np = <span class="number">0</span>, nq = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">				++np;</span><br><span class="line">				nq = <span class="built_in">std</span>::<span class="built_in">min</span>(++nq, <span class="number">0</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				--nq;</span><br><span class="line">				np = <span class="built_in">std</span>::<span class="built_in">max</span>(--np, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			b[i] = &#123;nq, np&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">			<span class="keyword">int</span> l, r;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">max</span>(a[l - <span class="number">1</span>].second, c[l - <span class="number">1</span>] + b[r + <span class="number">1</span>].second) </span><br><span class="line">			- <span class="built_in">std</span>::<span class="built_in">min</span>(a[l - <span class="number">1</span>].first, c[l - <span class="number">1</span>] + b[r + <span class="number">1</span>].first) + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1473E：经典最短路，去掉一个最长路，加上一个最短路"><a href="#1473E：经典最短路，去掉一个最长路，加上一个最短路" class="headerlink" title="1473E：经典最短路，去掉一个最长路，加上一个最短路"></a><a href="https://codeforces.com/contest/1473/problem/E" target="_blank" rel="noopener">1473E</a>：经典最短路，去掉一个最长路，加上一个最短路</h3><p>一条路径的权值定义为 $\sum w_{e_i} - \max e_i + \min e_i$，显然这等价于 $\min \sum (w_{e_i}) - w_{e_j} + w_{e_k}$。因此我们可以建图：比如原始边为 (u, v, w), 一个节点到了 4u 表示是原始的长度， 4u + 1 表示减去了某个边，4u + 2 表示加上了某条边，4u + 3 表示既加了也减了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> edge &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;LL, <span class="keyword">int</span>&gt;&gt; h;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">dist</span><span class="params">(e.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(e.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">	dist[s] = <span class="number">0</span>;</span><br><span class="line">	h.push(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!h.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [d, u] = h.top();</span><br><span class="line">		h.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		dist[u] = -d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : e[u]) h.emplace(d - w, v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function">edge <span class="title">e</span><span class="params">(<span class="number">4</span> * n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, w;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		--u; --v;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">2</span>; ++t) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) e[<span class="number">4</span> * u + j].emplace_back(<span class="number">4</span> * v + j, w);</span><br><span class="line">			e[<span class="number">4</span> * u].emplace_back(<span class="number">4</span> * v + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			e[<span class="number">4</span> * u].emplace_back(<span class="number">4</span> * v + <span class="number">2</span>, <span class="number">2</span> * w);</span><br><span class="line">			e[<span class="number">4</span> * u].emplace_back(<span class="number">4</span> * v + <span class="number">3</span>, w);</span><br><span class="line">			e[<span class="number">4</span> * u + <span class="number">1</span>].emplace_back(<span class="number">4</span> * v + <span class="number">3</span>, <span class="number">2</span> * w);</span><br><span class="line">			e[<span class="number">4</span> * u + <span class="number">2</span>].emplace_back(<span class="number">4</span> * v + <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">std</span>::swap(u, v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> dist = Dijkstra(<span class="number">0</span>, e);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span>; i &lt; <span class="number">4</span> * n; i += <span class="number">4</span>) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dist[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以不建成上述图，按照原始图建图，操作的时候再也可以，本质上一致更节省空间，代码稍微复杂一点。</p>
</blockquote>
<h3 id="AtCoder-arc111B：经典-2-选-1"><a href="#AtCoder-arc111B：经典-2-选-1" class="headerlink" title="AtCoder arc111B：经典 2 选 1"></a><a href="https://atcoder.jp/contests/arc111/tasks/arc111_b" target="_blank" rel="noopener">AtCoder arc111B</a>：经典 2 选 1</h3><p>大致 有 $n$ 个盒子，每个盒子有两个数，从中取去一个数，问最多可以取多少个不同的数。</p>
<p>数字为节点，盒子中的两个数连边（注意可能有重边），那个连通分支是树，那么答案就是连通分支节点数减 1，否则就是连通分支节点数。（树的情况容易证明，非树的情况总可以删边，删成只有树再多一条边的情况，然后也容易证明）</p>
<h3 id="AtCoder-arc111E"><a href="#AtCoder-arc111E" class="headerlink" title="AtCoder arc111E"></a><a href="https://atcoder.jp/contests/arc111/tasks/arc111_e" target="_blank" rel="noopener">AtCoder arc111E</a></h3><p><a href="https://atcoder.jp/contests/arc111/editorial/546" target="_blank" rel="noopener">教程</a></p>
<h3 id="1467C：类似于把-a-b-变成-a-b-问题（代码自解释）"><a href="#1467C：类似于把-a-b-变成-a-b-问题（代码自解释）" class="headerlink" title="1467C：类似于把 a, b 变成 a - b 问题（代码自解释）"></a><a href="https://codeforces.com/contest/1467/problem/C" target="_blank" rel="noopener">1467C</a>：类似于把 a, b 变成 a - b 问题（代码自解释）</h3><p>题目中 3 个袋子可以换成 $m(m \geq 3)$ 个袋子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n[<span class="number">3</span>]&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n[<span class="number">0</span>] &gt;&gt; n[<span class="number">1</span>] &gt;&gt; n[<span class="number">2</span>];</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, x; j &lt; n[i]; ++j) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			a[i].emplace_back(x);</span><br><span class="line">			r += x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">		b.emplace_back(*<span class="built_in">std</span>::min_element(a[i].<span class="built_in">begin</span>(), a[i].<span class="built_in">end</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::sort(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">	LL ans = r - b[<span class="number">0</span>] * <span class="number">2</span> - b[<span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">		LL tmp = r;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n[i]; ++j) tmp -= a[i][j] * <span class="number">2</span>;</span><br><span class="line">		ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1471D：GCD-问题"><a href="#1471D：GCD-问题" class="headerlink" title="1471D：GCD 问题"></a><a href="https://codeforces.com/contest/1471/problem/D" target="_blank" rel="noopener">1471D</a>：GCD 问题</h3><p>题意：我们称 $a, b$ 相邻，如果 $\lcm(a, b)/gcd(a, b)$ 是平方数，这当且仅当 $ab$ 是平方数。我们定义 $f(n)$ 为 $n$ 的素因子的积，那么 $a, b$ 相邻，当且仅当 $f(a) = f(b)$。这样就好了呀。由于数据范围在 $1e6$ 之间，所以可以预处理以下就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10086</span>; </span><br><span class="line"><span class="keyword">int</span> sp[N], p[N], f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spf</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt;= sp[i] &amp;&amp; i * p[j] &lt; N; ++j) &#123; <span class="comment">//防止乘法溢出</span></span><br><span class="line">			sp[i * p[j]] = p[j]; <span class="comment">// 注意到sp只被赋值一次</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> pi = i / sp[i];</span><br><span class="line">		<span class="keyword">if</span> (pi % sp[i] == <span class="number">0</span>) f[i] = f[pi / sp[i]];</span><br><span class="line">		<span class="keyword">else</span> f[i] = f[pi] * sp[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	spf();</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			++mp[f[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> r0 = INT_MIN, now = mp[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [u, v] : mp) &#123;</span><br><span class="line">			r0 = <span class="built_in">std</span>::<span class="built_in">max</span>(r0, v);</span><br><span class="line">			<span class="keyword">if</span> (u != <span class="number">1</span> &amp;&amp; v % <span class="number">2</span> == <span class="number">0</span>) now += v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> r1 = <span class="built_in">std</span>::<span class="built_in">max</span>(r0, now);</span><br><span class="line">		<span class="keyword">int</span> q;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">		<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">			LL w;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (w == <span class="number">0</span> ? r0 : r1) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面做法还是太慢了！注意到 $f(n)$ 表示 $n$ 的最小 “无平方因子” 的因子。因此可以用平方数预处理，可用下面代码加速</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt; N; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> ii = i * i, cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = ii; j &lt; N; j += ii) f[j] = ++cur;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1471F-图论染色问题"><a href="#1471F-图论染色问题" class="headerlink" title="1471F: 图论染色问题"></a><a href="https://codeforces.com/contest/1471/problem/F" target="_blank" rel="noopener">1471F</a>: 图论染色问题</h3><blockquote>
<p>比赛时，读题没读懂要干嘛。</p>
</blockquote>
<p>用 01 对连通图染色，使得每个 0 周围全是 1，每个 1 周围都存在一个 0. 按照题解的说法：随便选择一点置 0，然后把它周围全部染色为 1，然后找和 1 相邻的没被染色的其中任意一个染色为 0，然后把 0 周围全部染色为 1，一直继续下去。</p>
<p>但是上述做法代码可能写的比较别扭，因此我们可以用队列，先随便选择一点置 0，放进队列中。在队列中的被染色为 1 的是真 1，染色为 0 的表示它和某个染色为 1 的节点相连。出队列后染色为 1 的是真的 1。队首的被染色为 0，那就把和它相邻的没被染色的变成 1 放在队列中，队首的被染色为 1，那就把它相邻的全变成 0（不管有没有被染色过），若没被染色就丢进队列中。</p>
<p>注意到：被染色为 0 后，染色不会变化。出队列的 1 周围的染色全为 0，被染色为 0，必然是某个出了队列的 1 帮它染的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; m; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			--u;</span><br><span class="line">			--v;</span><br><span class="line">			e[u].emplace_back(v);</span><br><span class="line">			e[v].emplace_back(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">val</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">		val[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		Q.push(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">if</span> (val[u] == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (val[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">						val[v] = <span class="number">1</span>;</span><br><span class="line">						Q.push(v);</span><br><span class="line">					&#125; <span class="keyword">else</span> val[v] = <span class="number">1</span>;</span><br><span class="line">				&#125; </span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (val[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">					val[v] = <span class="number">0</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (*<span class="built_in">std</span>::min_element(val.<span class="built_in">begin</span>(), val.<span class="built_in">end</span>()) == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (val[i] == <span class="number">0</span>) r.emplace_back(i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r.<span class="built_in">size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : r) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1466A：线段上-n-个点，两两距离差值的所有可能个数"><a href="#1466A：线段上-n-个点，两两距离差值的所有可能个数" class="headerlink" title="1466A：线段上 $n$ 个点，两两距离差值的所有可能个数"></a><a href="https://codeforces.com/contest/1466/problem/A" target="_blank" rel="noopener">1466A</a>：线段上 $n$ 个点，两两距离差值的所有可能个数</h3><p>$n^2$ 的算法是显然的。</p>
<ol>
<li>利用 Bitset，也是 $n^2$ 的 dp，然后用 bitset 存储数据，就可以达到 $n^2/64$ 的复杂度啦。</li>
<li>如果距离的最大值区间为 $N$，那么 $\sum x^{a_i} \sum x^(N - a_i)$ 中非负系数个数就是答案（所以有 $O(N\log N)$ 的做法。</li>
</ol>
<h3 id="1466E：求和"><a href="#1466E：求和" class="headerlink" title="1466E：求和"></a><a href="https://codeforces.com/contest/1466/problem/E" target="_blank" rel="noopener">1466E</a>：求和</h3><script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{j=1}^n \sum_{k=1}^n (x_i \, \& \, x_j) \cdot (x_j \, | \, x_k)</script><p>显然就是固定 $j$，每位每位的求和即可。</p>
<h3 id="1466F：-mathbb-Z-2-上-m-维向量线性无关组"><a href="#1466F：-mathbb-Z-2-上-m-维向量线性无关组" class="headerlink" title="1466F：$\mathbb{Z}_2$ 上 $m$ 维向量线性无关组"></a><a href="https://codeforces.com/contest/1466/problem/F" target="_blank" rel="noopener">1466F</a>：$\mathbb{Z}_2$ 上 $m$ 维向量线性无关组</h3><p>注意到题目中至多两个位置非零，因此就可以用 并查集（一般情况倒是不知道有啥好办法）。注意到官方题解，可以多加一个维度，使得有每次正好有两个位置非零。</p>
<h3 id="1465D：观察结果题"><a href="#1465D：观察结果题" class="headerlink" title="1465D：观察结果题"></a><a href="https://codeforces.com/contest/1465/problem/D" target="_blank" rel="noopener">1465D</a>：观察结果题</h3><p>题意：给定由 <code>0, 1, ?</code> 构成的字符串，将 <code>?</code> 变成 0 或 1，使得 01 字符和 10 字符权值和最小。（其中，01 权值为 x, 10 权值为 y）</p>
<blockquote>
<p>不妨假设 $x \leq y$, 否则将字符串反序（x, y 互换）</p>
</blockquote>
<p>做法：首先不考虑 <code>?</code>，此时我们可以通过当前位置为 0（看前方 1 的个数），当前位置为 1（看前置 0 的个数）得到基础权值 <code>W</code>，然后注意到 01 的权值低于 10 的权值，因此当 m 个 <code>?</code> 替换成 p 个 1 和 m - p 个 0 时候，把 0，放在最前面会让权值最小，因此我们可以考虑前缀问号给 0，后缀问号为 1 给答案的贡献。然后再加上基础权值 W 再加上 <code>m(m-p)x</code>。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> a;</span><br><span class="line">	LL x, y;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(x, y);</span><br><span class="line">		<span class="built_in">std</span>::reverse(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[<span class="number">2</span>], s[<span class="number">2</span>];</span><br><span class="line">	p[<span class="number">0</span>].resize(n + <span class="number">1</span>);</span><br><span class="line">	p[<span class="number">1</span>].resize(n + <span class="number">1</span>);</span><br><span class="line">	s[<span class="number">0</span>].resize(n + <span class="number">1</span>);</span><br><span class="line">	s[<span class="number">1</span>].resize(n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		p[<span class="number">0</span>][i + <span class="number">1</span>] = p[<span class="number">0</span>][i];</span><br><span class="line">		p[<span class="number">1</span>][i + <span class="number">1</span>] = p[<span class="number">1</span>][i];</span><br><span class="line">		<span class="keyword">if</span> (a[i] != <span class="string">'?'</span>) ++p[a[i] - <span class="string">'0'</span>][i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		s[<span class="number">0</span>][i] = s[<span class="number">0</span>][i + <span class="number">1</span>];</span><br><span class="line">		s[<span class="number">1</span>][i] = s[<span class="number">1</span>][i + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (a[i] != <span class="string">'?'</span>) ++s[a[i] - <span class="string">'0'</span>][i];</span><br><span class="line">	&#125;</span><br><span class="line">	LL ord = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] == <span class="string">'0'</span>) ord += p[<span class="number">1</span>][i] * y;</span><br><span class="line">		<span class="keyword">if</span> (a[i] == <span class="string">'1'</span>) ord += p[<span class="number">0</span>][i] * x;</span><br><span class="line">	&#125;</span><br><span class="line">	std::vector&lt;LL&gt; pre(n + 1), suf(n + 1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		pre[i + <span class="number">1</span>] = pre[i];</span><br><span class="line">		<span class="keyword">if</span> (a[i] == <span class="string">'?'</span>) pre[i + <span class="number">1</span>] += s[<span class="number">1</span>][i] * x + p[<span class="number">1</span>][i] * y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		suf[i] = suf[i + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (a[i] == <span class="string">'?'</span>) suf[i] += s[<span class="number">0</span>][i] * y + p[<span class="number">0</span>][i] * x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="built_in">std</span>::count(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="string">'?'</span>), tnc = <span class="number">0</span>;</span><br><span class="line">	LL r = ord + suf[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (a[i] == <span class="string">'?'</span>) &#123;</span><br><span class="line">		++tnc;</span><br><span class="line">		r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, ord + pre[i + <span class="number">1</span>] + suf[i + <span class="number">1</span>] + x * (cnt - tnc) * tnc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1465E：观察题"><a href="#1465E：观察题" class="headerlink" title="1465E：观察题"></a><a href="https://codeforces.com/contest/1465/problem/E" target="_blank" rel="noopener">1465E</a>：观察题</h3><blockquote>
<p><a href="https://codeforces.com/blog/entry/85792" target="_blank" rel="noopener">官方题解</a> 清晰明了</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	LL s;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> a;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &gt;&gt; a;</span><br><span class="line">	s -= <span class="number">1</span> &lt;&lt; (a.back() - <span class="string">'a'</span>);</span><br><span class="line">	a.pop_back();</span><br><span class="line">	s += <span class="number">1</span> &lt;&lt; (a.back() - <span class="string">'a'</span>);</span><br><span class="line">	a.pop_back();</span><br><span class="line">	s = <span class="built_in">abs</span>(s);</span><br><span class="line">	LL cnt[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) ++cnt[x - <span class="string">'a'</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((s &gt;&gt; i) &gt;= cnt[i]) s -= cnt[i] &lt;&lt; i;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> t = cnt[i] - (s &gt;&gt; i);</span><br><span class="line">			s -= (s &gt;&gt; i) &lt;&lt; i;</span><br><span class="line">			<span class="keyword">if</span> (t % <span class="number">2</span>) s = (<span class="number">1</span> &lt;&lt; i) - s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (s == <span class="number">0</span> ? <span class="string">"Yes"</span> : <span class="string">"No"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用桶排序和取正处理，直接起飞，复杂度骤降为 $O(n)$。</p>
</blockquote>
<h3 id="1450H：圆上配对问题"><a href="#1450H：圆上配对问题" class="headerlink" title="1450H：圆上配对问题"></a><a href="https://codeforces.com/contest/1450/problem/H1" target="_blank" rel="noopener">1450H</a>：圆上配对问题</h3><blockquote>
<p><a href="https://codeforces.com/blog/entry/85348" target="_blank" rel="noopener">官方题解</a> 属实精彩。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;   x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;LL&gt; fac(n + 1), ifac(n + 1);</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">	ifac[n] = powMod(fac[n], M - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) ifac[i - <span class="number">1</span>] = ifac[i] * i % M;</span><br><span class="line">	<span class="keyword">auto</span> binom = [&amp;](<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">		<span class="keyword">return</span> fac[n] * ifac[n - k] % M * ifac[k] % M;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> B[<span class="number">2</span>] = &#123;&#125;, res[<span class="number">2</span>] = &#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">'?'</span>) ++res[i % <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'b'</span>) ++B[i % <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> F = res[<span class="number">0</span>] + res[<span class="number">1</span>], x = B[<span class="number">1</span>] + res[<span class="number">1</span>] - B[<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = (x + n) % <span class="number">2</span>; i &lt;= F; i += <span class="number">2</span>) &#123;</span><br><span class="line">		(r += <span class="built_in">abs</span>(x - i) * binom(F, i)) %= M;</span><br><span class="line">	&#125;</span><br><span class="line">	r = r * powMod(<span class="number">2L</span>L, F * (M - <span class="number">2</span>) % (M - <span class="number">1</span>)) % M;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1453D：简单概率题"><a href="#1453D：简单概率题" class="headerlink" title="1453D：简单概率题"></a><a href="https://codeforces.com/contest/1453/problem/D" target="_blank" rel="noopener">1453D</a>：简单概率题</h3><blockquote>
<p>这么简答的概率题，我竟然做了一个小时，被弱智的错误理解题意搞的头皮发麻！</p>
</blockquote>
<p>题意：对一个长度为 $n$ 的 0-1 序列（首位为 1），<code>0</code> 表示不存档 <code>1</code> 表示存档，如果我们在第 <code>i</code> 关打赢了，那么我们进入第 <code>i + 1</code> 关，否则我们回到最近的一次存档处。那么战斗次数的期望就确定的。现在问题是期望值 $k$，能否给一个 $0-1$ 序列。</p>
<p>首先如果 $n = 1$，那么此时期望为 $\displaystyle \sum_{i = 1}^n \frac{i}{2^i} = 2$. 注意到如果 <code>a[i] = 1</code>，一旦到达 <code>i</code> 位置，那么期望与前面的部分就无关了。所以其实我们只需考虑序列 <code>10...0</code>。记期望为 $p_n$。那么</p>
<script type="math/tex; mode=display">
p_n = \sum_{i = 1}^n \frac{i + p_n}{2^i} + \frac{n}{2^n}</script><p>化简可得 $p_n = 2 (2^n - 1)$. 因此只要 k 是 2 的倍数，必然序列存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		LL n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		n /= <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">		<span class="keyword">while</span> (n) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> ((<span class="number">1L</span>L &lt;&lt; x) &lt;= n + <span class="number">1</span>) ++x;</span><br><span class="line">			--x;</span><br><span class="line">			n -= (<span class="number">1L</span>L &lt;&lt; x) - <span class="number">1</span>;</span><br><span class="line">			a.emplace_back(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; x; ++i) a.emplace_back(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1455B：简单被卡题"><a href="#1455B：简单被卡题" class="headerlink" title="1455B：简单被卡题"></a><a href="https://codeforces.com/contest/1455/problem/B" target="_blank" rel="noopener">1455B</a>：简单被卡题</h3><p>题意：第 $k$ 次移动时，可以往前移动 $k$ 个位置，或往后移动一个位置，从 0 到 $n$ 最少多少步完成。</p>
<blockquote>
<p>一开始在想用 bfs 或者 dfs 或者 dp 来做，没有第一时间搞贪心。写完 bfs 之后，跑不动吐了。此题最多向后走一个位置即可。找到最小的 x 满足 $1 + \cdots x \geq n$，如果 $1 + \cdots x = n + 1$，那么答案就是 $x + 1$，否则为 $x$。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (r * (r + <span class="number">1</span>) / <span class="number">2</span> &lt; x) ++ r;</span><br><span class="line">		<span class="keyword">if</span> (r * (r + <span class="number">1</span>) / <span class="number">2</span> == x + <span class="number">1</span>) ++r;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1455E：好玩的问题"><a href="#1455E：好玩的问题" class="headerlink" title="1455E：好玩的问题"></a><a href="https://codeforces.com/contest/1455/problem/E" target="_blank" rel="noopener">1455E</a>：好玩的问题</h3><p>给定四个不同的点，将它们分别移动，使得称为一个正方形，且边分别和轴平行。左上角，右上角，左下角，右下角四个点明确之后，那么坐标分开讨论。利用一个事实，就是线段上，距离端点长度之和为常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y] : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		LL ans = INT64_MAX;</span><br><span class="line">		<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			LL sum = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 0 3</span></span><br><span class="line">			<span class="comment">// 1 2</span></span><br><span class="line">			sum += <span class="built_in">abs</span>(a[<span class="number">0</span>].first - a[<span class="number">1</span>].first);</span><br><span class="line">			sum += <span class="built_in">abs</span>(a[<span class="number">2</span>].first - a[<span class="number">3</span>].first);</span><br><span class="line">			sum += <span class="built_in">abs</span>(a[<span class="number">0</span>].second - a[<span class="number">3</span>].second);</span><br><span class="line">			sum += <span class="built_in">abs</span>(a[<span class="number">1</span>].second - a[<span class="number">2</span>].second);</span><br><span class="line">			LL xr = <span class="built_in">std</span>::<span class="built_in">max</span>(a[<span class="number">3</span>].first, a[<span class="number">2</span>].first) - <span class="built_in">std</span>::<span class="built_in">min</span>(a[<span class="number">1</span>].first, a[<span class="number">0</span>].first);</span><br><span class="line">			LL xl = <span class="built_in">std</span>::<span class="built_in">min</span>(a[<span class="number">3</span>].first, a[<span class="number">2</span>].first) - <span class="built_in">std</span>::<span class="built_in">max</span>(a[<span class="number">1</span>].first, a[<span class="number">0</span>].first);</span><br><span class="line">			LL yr = <span class="built_in">std</span>::<span class="built_in">max</span>(a[<span class="number">0</span>].second, a[<span class="number">3</span>].second) - <span class="built_in">std</span>::<span class="built_in">min</span>(a[<span class="number">1</span>].second, a[<span class="number">2</span>].second);</span><br><span class="line">			LL yl = <span class="built_in">std</span>::<span class="built_in">min</span>(a[<span class="number">0</span>].second, a[<span class="number">3</span>].second) - <span class="built_in">std</span>::<span class="built_in">max</span>(a[<span class="number">1</span>].second, a[<span class="number">2</span>].second);</span><br><span class="line">			ans = <span class="built_in">std</span>::<span class="built_in">min</span>(ans, sum + <span class="number">2</span> * <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0L</span>L, <span class="built_in">std</span>::<span class="built_in">max</span>(xl, yl) - <span class="built_in">std</span>::<span class="built_in">min</span>(xr, yr)));</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="built_in">std</span>::next_permutation(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()));</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本场 1456 Div1, 我只能做 AB 两题，但是我可以做的快，做的优雅的，可是我没有！</p>
<h3 id="1456A：经典-DP"><a href="#1456A：经典-DP" class="headerlink" title="1456A：经典 DP"></a><a href="https://codeforces.com/contest/1456/problem/A" target="_blank" rel="noopener">1456A</a>：经典 DP</h3><p>题意：给定 0-1 字符串，需要让 $p, p + k, \cdots$ 位置都变成 1，每变一个位代价是 x，或者删除最开始的字符，这样做代价是 y。</p>
<p>做法：我们可以把字符串反过来，然后答案就是 <code>a[n - p]</code>，状态转移：不删字符的情况下，<code>a[i]</code> 为 $s[i], s[i - k], \cdots$ 中 0 的个数。$a[i] = \min_{1 \leq t \leq i}(a[i], a[i - t] + t * y)$，所以我们可以将 <code>a[i] - iy</code> 添加到 set 中，然后最小值加上 当前的 <code>iy</code> 就是真实的最小值。</p>
<blockquote>
<p>很早就想到了做法，实现的时候写的太急了，分析不过细致，把自己整吐了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, p, k, x, y;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; k &gt;&gt; s &gt;&gt; x &gt;&gt; y; </span><br><span class="line">		<span class="built_in">std</span>::reverse(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">		std::vector&lt;int&gt; a(n), cnt(k);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">'0'</span>) ++cnt[i % k];</span><br><span class="line">			a[i] = cnt[i % k] * x;</span><br><span class="line">			<span class="keyword">if</span> (!S.empty()) a[i] = <span class="built_in">std</span>::<span class="built_in">min</span>(a[i], *S.<span class="built_in">begin</span>() + i * y);</span><br><span class="line">			S.insert(a[i] - i * y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[n - p] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1456B：XOR-问题"><a href="#1456B：XOR-问题" class="headerlink" title="1456B：XOR 问题"></a><a href="https://codeforces.com/contest/1456/problem/B" target="_blank" rel="noopener">1456B</a>：XOR 问题</h3><p>题意：给定一个非降的序列，可以将相邻的两个变成它们的异或值，能否在最小的步数上，将这个序列不满足非降条件。</p>
<p>做法：注意到，如果有三个相邻的数最高位一致，那么答案必然是 1，因此本质上我们只需考虑 n = 60 的情况，所以，随便写就能过（所以我写的特别随便，然后被人 hack 了，我真的服了自己！）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">2</span> &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((a[i] ^ a[i + <span class="number">1</span>]) &gt; a[i + <span class="number">2</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; (a[i + <span class="number">1</span>] ^ a[i + <span class="number">2</span>])) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b, c;</span><br><span class="line">		<span class="keyword">int</span> nb = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">			nb ^= a[j];</span><br><span class="line">			b.emplace_back(nb);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> nc = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">			nc ^= a[j];</span><br><span class="line">			c.emplace_back(nc);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; c.<span class="built_in">size</span>(); ++k) <span class="keyword">if</span> (b[j] &gt; c[k]) &#123;</span><br><span class="line">				ans = <span class="built_in">std</span>::<span class="built_in">min</span>(ans, j + k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtCoder-abc184F：假-0-1-背包，Meet-in-Middle"><a href="#AtCoder-abc184F：假-0-1-背包，Meet-in-Middle" class="headerlink" title="AtCoder abc184F：假 0-1 背包，Meet in Middle"></a><a href="https://atcoder.jp/contests/abc184/tasks/abc184_f" target="_blank" rel="noopener">AtCoder abc184F</a>：假 0-1 背包，Meet in Middle</h3><p>题意：给定序列，求选择其中部分，使得它们和最大且不超过 t，这不就是 0-1 背包吗？但是数据范围 $0 \leq n \leq 40, 0 \leq a_i, t \leq 10^9$，此题即使是多重背包，也可以用下面各种方法来做</p>
<ol>
<li>Meet in Middle，但是实现的时候可以有以下几种实现细节：<ul>
<li>用是 set 或 unordered set 存和更新，然后用双指针，整体复杂度 $O(n 2 ^{\frac{n}{2}})$</li>
<li>用 Vector 存，之后排序（只需排序一个），然后用 <code>lower_bounded</code> 查找，复杂度同理</li>
<li>用 Vector 存，保持有序，最后用双指针，复杂度 $O(2 ^{\frac{n}{2}})$</li>
</ul>
</li>
<li>先 dfs 找到一个较好的解，然后每次更新解，用来剪枝。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有序 vector + 双指针，复杂度 $O(2 ^&#123;\frac&#123;n&#125;&#123;2&#125;&#125;)$</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, t;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; t;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="built_in">std</span>::sort(a.rbegin(), a.rend());</span><br><span class="line">	<span class="keyword">auto</span> merge = [&amp;](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; a.<span class="built_in">size</span>() &amp;&amp; a[i] &lt; a[j] + x) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j] + x &lt;= t) b.emplace_back(a[j] + x);</span><br><span class="line">				++j;</span><br><span class="line">			&#125;</span><br><span class="line">			b.emplace_back(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		swap(a, b);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> <span class="built_in">get</span> = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">			merge(x, a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> la = <span class="built_in">get</span>(<span class="number">0</span>, n / <span class="number">2</span>), lb = <span class="built_in">get</span>(n / <span class="number">2</span>, n);</span><br><span class="line">	<span class="keyword">int</span> ib = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = la.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (ib &lt; lb.<span class="built_in">size</span>() &amp;&amp; la[i] + lb[ib] &gt; t) ++ib;</span><br><span class="line">		<span class="keyword">if</span> (ib != lb.<span class="built_in">size</span>()) ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, la[i] + lb[ib]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs 剪枝，下述算法会被制造的数据吃掉，例如 t 为奇数，所有其它数为偶数，并且 t 很大，有特别多的解。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, t;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; t;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="built_in">std</span>::sort(a.rbegin(), a.rend());</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; --i) b[i - <span class="number">1</span>] = a[i - <span class="number">1</span>] + b[i];</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> now, <span class="keyword">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; n || ans == t || ans - now &gt;= b[i]) <span class="keyword">return</span>;</span><br><span class="line">		ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, now);</span><br><span class="line">		<span class="keyword">if</span> (now + a[i] &lt;= t) dfs(now + a[i], i + <span class="number">1</span>);</span><br><span class="line">		dfs(now, i + <span class="number">1</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1451E：交互题"><a href="#1451E：交互题" class="headerlink" title="1451E：交互题"></a><a href="https://codeforces.com/contest/1451/problem/E" target="_blank" rel="noopener">1451E</a>：交互题</h3><p>题意：给定 n（为 2 的幂次，且大于 2），猜测一个长为 n ，取值在 <code>[0, n - 1]</code> 的数列。每次可以询问，<code>XOR i j</code>，<code>OR i j</code>，<code>AND i j</code> 中的一种（$i \neq j$）。询问次数不超过 n + 1。</p>
<blockquote>
<p>上面 <code>OR</code> 和 <code>And</code> 用一个即可，我们这里用 <code>And</code>，<code>OR</code> 也类似。 </p>
</blockquote>
<p>做法：所有的数和第一个数异或（自己跟自己异或为 0，省一次查询），如果有相同的结果，那么做一个 AND 就知道第一个数为多少了，否则所有值都出现了，那么我们可以找到一个 i 使得 $r[1] \wedge r[i] = 2^n - 1$，此时 $r[1] \And r[i] = 0$，我们再找一个数 j，求 <code>r[i] &amp; r[j]</code> 以及 <code>r[1] &amp; r[j]</code> 再利用 <code>a + b = a ^ b + 2 (a &amp; b)</code> 就可以求出 <code>r[1]</code> 了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"XOR 1 "</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b[a[i]] == <span class="number">-1</span>) b[a[i]] = i;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"AND "</span> &lt;&lt; b[a[i]] + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">			x = tmp ^ a[i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> t1, t2;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"AND "</span> &lt;&lt; b[<span class="number">1</span>] + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; b[n - <span class="number">1</span>] + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; t1;</span><br><span class="line">		t1 = t1 * <span class="number">2</span> + n - <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"AND "</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; b[<span class="number">1</span>] + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; t2;</span><br><span class="line">		t2 = t2 * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		x = (n - <span class="number">1</span> + t1 + t2) / <span class="number">2</span> - t1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; (x ^ a[i]);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实本题另一种处理技巧，不需要 $n$ 为 2 的幂次，只需考虑异或为 1 和 2 的 <code>i,j</code>。下面做法基于此想法</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"XOR 1 "</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b[a[i]] == <span class="number">-1</span>) b[a[i]] = i;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"AND "</span> &lt;&lt; b[a[i]] + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">int</span> tmp;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">			x = tmp ^ a[i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> t1, t2;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"AND "</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; b[<span class="number">1</span>] + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; t1;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"AND "</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; b[<span class="number">2</span>] + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; t2;</span><br><span class="line">		x = t1 | (t2 &amp; <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; (x ^ a[i]);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1451D：很好博弈问题"><a href="#1451D：很好博弈问题" class="headerlink" title="1451D：很好博弈问题"></a><a href="https://codeforces.com/contest/1451/problem/D" target="_blank" rel="noopener">1451D</a>：很好博弈问题</h3><p>题意：从 (0, 0) 开始，每次可以向上或向右走 k 个单位（但是和起点距离不能超过 d），两人轮流走，谁不能走了谁输。</p>
<p>显然可以简化成走一个单位，距离不超过 $\frac{d}{k}$. 没过一小会，我就想到了，若 $2 x^2 \leq \frac{d^2}{k^2} &lt; 2 (x + 1)^2$，那么，如果 $x^2 + (x + 1)^2 \leq \frac{d^2}{k^2}$，那么先手赢，否则先手输。</p>
<blockquote>
<p>注意到 $x^2 + (x + 2)^2 = 2 (x + 1)^2 + 2 &gt; d$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		LL d, k;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; d &gt;&gt; k;</span><br><span class="line">		d = d * d / k / k;</span><br><span class="line">		LL x = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(d / <span class="number">2</span> + <span class="number">0.1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x * x + (x + <span class="number">1</span>) * (x + <span class="number">1</span>) &lt;= d ? <span class="string">"Ashish\n"</span> : <span class="string">"Utkarsh\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1451C"><a href="#1451C" class="headerlink" title="1451C"></a><a href="https://codeforces.com/contest/1451/problem/C" target="_blank" rel="noopener">1451C</a></h3><p>题意：给定长为 n 的由小写字母组成的字符串 <code>a, b</code>，可以将 <code>a</code> 相邻的位置互换（因此所有位置都可以互换），也可以将长为 $k$ 且每一位都相同的字母全部变成下一个字母。</p>
<p>做法：一开始想排序之和贪心（<a href="https://codeforces.com/contest/1451/submission/99143008" target="_blank" rel="noopener">这份代码</a>），后来发现 <code>n = 3, k = 2</code> 时 <code>aab</code> 变成 <code>zzy</code> 就会出问题。我还以为思路没问题，又交了一遍，属实天真。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> a, b;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">std</span>::sort(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// for (int i = 0; i &lt; n; ++i) if (a[i] &gt; b[i]) return 0;</span></span><br><span class="line">	<span class="keyword">int</span> sa = <span class="number">0</span>, sb = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> deal = [&amp;](<span class="keyword">char</span> c) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) a[sa - i] = c;</span><br><span class="line">		sa -= k;</span><br><span class="line">		--t;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span> (sb &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sa == n) deal(b[sb]);</span><br><span class="line">		<span class="keyword">if</span> (a[sa] == b[sb]) &#123;</span><br><span class="line">			++sa;</span><br><span class="line">			++sb;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[sa] &gt; b[sb]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (t == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			deal(b[sb]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (sa + k - <span class="number">1</span> &lt; n &amp;&amp; a[sa] == a[sa + k - <span class="number">1</span>]) &#123;</span><br><span class="line">				++t;</span><br><span class="line">				sa += k;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (solve() ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此题考虑每个数的个数会更简单！怪不得他们做的这么快…</p>
</blockquote>
<h3 id="1452E：特别难的复杂度降低问题，经典问题，注意转化"><a href="#1452E：特别难的复杂度降低问题，经典问题，注意转化" class="headerlink" title="1452E：特别难的复杂度降低问题，经典问题，注意转化"></a><a href="https://codeforces.com/contest/1452/problem/E" target="_blank" rel="noopener">1452E</a>：特别难的复杂度降低问题，经典问题，注意转化</h3><p>题意，有两个出题人各自连续讲 k 题，每个参赛者选择去听其中一个出题人讲题，参赛者感兴趣的题在一个区间 <code>[l, r]</code> 问每个参赛者能听的自己感兴趣的题目的总和最大值为多少，$n$：总题目数，$m$ 参赛人数。</p>
<p>首先这里有一个自然的 $O(n^2 m)$ 的做法，有些人利用 Codeforces 上支持的 GCC 指令过了题…。<br>官方题解说：对于每个参赛者的感兴趣区间 <code>[l, r]</code>，某一个出题人讲题区间 <code>[i, i + k - 1]</code>，当 <code>i</code> 在递增时，这两个区间的交会怎样变化呢？在脑子里把区间进行平移会发现，它先增，在它们的中间相交之后递减，并且还是对称的。也就是说，<strong>两个出题人它们区间的中点和参赛者近的会被参赛者选择</strong>。因此排序之后，第一个出题人拿前缀，后一个拿后缀。所以就是求前缀和和后缀和之和的最大值。总复杂度 $O(mn + m \log m)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pii&gt; <span class="title">a</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[l, r] : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">	<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="keyword">const</span> pii &amp;A, <span class="keyword">const</span> pii &amp;B) &#123;</span><br><span class="line">		<span class="keyword">return</span> A.first + A.second &lt; B.first + B.second;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sm</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + k &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">			cur += <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">std</span>::<span class="built_in">min</span>(i + k, a[j].second) - <span class="built_in">std</span>::<span class="built_in">max</span>(i, a[j].first - <span class="number">1</span>));</span><br><span class="line">			sm[j] = <span class="built_in">std</span>::<span class="built_in">max</span>(sm[j], cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = sm[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + k &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">			cur += <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">std</span>::<span class="built_in">min</span>(i + k, a[j].second) - <span class="built_in">std</span>::<span class="built_in">max</span>(i, a[j].first - <span class="number">1</span>));</span><br><span class="line">			ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, cur + sm[j + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有人写了不排序的 $O(n m)$ 做法，反正我时没懂。</p>
</blockquote>
<h3 id="1452F：经典观察贪心问题"><a href="#1452F：经典观察贪心问题" class="headerlink" title="1452F：经典观察贪心问题"></a><a href="https://codeforces.com/contest/1452/problem/F" target="_blank" rel="noopener">1452F</a>：经典观察贪心问题</h3><p>题意：有 $a_i$ 个 $2^i$ 的数，每次可以把某个 $2^{i + 1}$ 分成两个 $2^i$，给定 $x,y$，问至少需要多少次操作可以有至少 $y$ 个数小于 $2^x$。</p>
<p>首先，如果一个数 $2 \leq 2^l \leq 2^x$，那么分一次多一个答案，这种称作小的，可以将 $2^l$ 分成 $2^{l - x}$ 个 $2^x$，需要的次数为 $2^{l - x} + 1$。首先注意到 $l &gt; k$ 时，分小的性价比较高，因此我们递增的考虑 $2^l &gt; 2^x$</p>
<ul>
<li>若 $2^{l - x} \leq k$，全部搞一下就可以了</li>
<li>否则，若 $2^{l - x} &gt; k$，这个时候我们可以看那些小的个数是否大于等于 $k$，如果是，那结束了，否则将 $2^l$ 分割成 两个 $2^{l - 1}$，再判断，若 $2^{l - 1 - x} &gt; k$，那么最多只会用到一个 $2^{l - 1}$，否则有一个 $2^{l - 1}$ 必然全部都拿来用了。那好了再次回到了这个判断上来了。经典！</li>
</ul>
<blockquote>
<p>一开始以为时线段树问题，后来一看 $n &lt; 30$，有一堆的观察之后才好下手的！每一步的观察都要准确！才能一步一步的走向正确的答案</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, q;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">auto</span> getans = [&amp;](<span class="keyword">int</span> x, LL y) -&gt; LL &#123;</span><br><span class="line">		LL small = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= x; ++i) &#123;</span><br><span class="line">			y -= a[i];</span><br><span class="line">			small += (a[i] &lt;&lt; i) - a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (y &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">auto</span> add = [&amp;](<span class="keyword">int</span> i, LL t) &#123;</span><br><span class="line">			ans += (t &lt;&lt; i - x) - t;</span><br><span class="line">			y -= t &lt;&lt; i - x;</span><br><span class="line">			small += (t &lt;&lt; i) - (t &lt;&lt; i - x);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> id = x + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; n) &#123;</span><br><span class="line">			LL t = <span class="built_in">std</span>::<span class="built_in">min</span>(y &gt;&gt; id - x, a[id]);</span><br><span class="line">			<span class="keyword">if</span> (t &gt; <span class="number">0</span>) add(id, t);</span><br><span class="line">			<span class="keyword">if</span> (t &lt; a[id]) <span class="keyword">break</span>;</span><br><span class="line">			++id;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (id == n) <span class="keyword">return</span> y &gt; small ? <span class="number">-1</span> : y + ans;</span><br><span class="line">		<span class="keyword">while</span> (y &gt; small &amp;&amp; id &gt; x) &#123;</span><br><span class="line">			--id;</span><br><span class="line">			++ans;</span><br><span class="line">			<span class="keyword">if</span> (y &gt;&gt; id - x) add(id, <span class="number">1L</span>L);</span><br><span class="line">			<span class="keyword">if</span> (id == x &amp;&amp; y &gt; <span class="number">0</span>) add(id, <span class="number">1L</span>L);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> y + ans;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> op, x;</span><br><span class="line">		LL y;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>) a[x] = y;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getans(x, y) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1440C：模拟题"><a href="#1440C：模拟题" class="headerlink" title="1440C：模拟题"></a><a href="https://codeforces.com/contest/1440/problem/C2" target="_blank" rel="noopener">1440C</a>：模拟题</h3><p>题意：给定 $n \times m$ 的 <code>0-1</code> 矩阵，每次操作改变 $2 \times 2$ 小方块中三个位置，要求在 $nm$ 步内使得所有方块为 0。首先显然每一行可以通过 $m$ 次操作置 0，每一列同理，所以最后转化成对 $2 \times 2$ 四次内变成全 0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : s) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; r;</span><br><span class="line">		<span class="keyword">auto</span> f = [](<span class="keyword">char</span> &amp;x) &#123;x = (x == <span class="string">'0'</span> ? <span class="string">'1'</span> : <span class="string">'0'</span>);&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">1</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) <span class="keyword">if</span> (s[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">				r.emplace_back(i, j);</span><br><span class="line">				r.emplace_back(i - <span class="number">1</span>, j);</span><br><span class="line">				f(s[i - <span class="number">1</span>][j]);</span><br><span class="line">				<span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					r.emplace_back(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">					f(s[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					r.emplace_back(i - <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">					f(s[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt; <span class="number">1</span>; --j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">					r.emplace_back(i, j);</span><br><span class="line">					r.emplace_back(i, j - <span class="number">1</span>);</span><br><span class="line">					r.emplace_back(<span class="number">1</span> - i, j - <span class="number">1</span>);</span><br><span class="line">					f(s[i][j - <span class="number">1</span>]);</span><br><span class="line">					f(s[<span class="number">1</span> - i][j - <span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; t[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">				t[s[i][j] - <span class="string">'0'</span>].emplace_back(i, j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> g = [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">			r.emplace_back(t[i].back());</span><br><span class="line">			t[<span class="number">1</span> - i].emplace_front(t[i].back());</span><br><span class="line">			t[i].pop_back();</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">if</span> (t[<span class="number">1</span>].<span class="built_in">size</span>() == <span class="number">4</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) g(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t[<span class="number">1</span>].<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">			g(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) g(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t[<span class="number">1</span>].<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">			g(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) g(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (t[<span class="number">1</span>].<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) g(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r.<span class="built_in">size</span>() / <span class="number">3</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * <span class="number">3</span> &lt; r.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r[i * <span class="number">3</span> + j].first + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; r[i * <span class="number">3</span> + j].second + <span class="number">1</span> &lt;&lt; <span class="string">" \n"</span>[j == <span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1440D：图论乱搞"><a href="#1440D：图论乱搞" class="headerlink" title="1440D：图论乱搞"></a><a href="https://codeforces.com/contest/1440/problem/D" target="_blank" rel="noopener">1440D</a>：图论乱搞</h3><p>题意：问一个图中是否存在 k-阶完全子图，或一个度数全大于 k 的子图。</p>
<blockquote>
<p>显然，我们可以把度数小于 $k - 1$ 的节点全部踢了。即从度数从小到大的遍历，小于 $k - 1$ 踢了，等于 $k - 1$, 看这 $k$ 个点能否成为完全图，能？结束，否则，继续，直到当前度数为 $k$，或者所有点都被剔除。</p>
</blockquote>
<p>没能在比赛的时候做出原因：</p>
<ul>
<li>没有注意到删点后更新度数的次数只和边数有关，所以当时觉得复杂度过不了！</li>
<li>在完全图判断时不够自信（单次复杂度 $k^2$，但是注意到边数小于 $\frac{(k - 1)k}{2}$ 时不可能为完全图）。</li>
<li>总复杂度 $O(m \sqrt{m} \log n)$，下面代码 998ms 飘过（在死亡的边缘疯狂试探）</li>
<li><code>unordered_set</code> 是基于 hash 表的，如果不需要集合按顺序输出，可以作为优先选择。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x, y; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		--x; --y;</span><br><span class="line">		e[x].insert(y);</span><br><span class="line">		e[y].insert(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; d;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) d.insert(&#123;e[i].<span class="built_in">size</span>(), i&#125;);</span><br><span class="line">	<span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(e[u].<span class="built_in">begin</span>(), e[u].<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (e[tmp[i]].count(tmp[j]) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> del = [&amp;](<span class="keyword">int</span> u) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">			d.erase(&#123;e[v].<span class="built_in">size</span>(), v&#125;);</span><br><span class="line">			e[v].erase(u);</span><br><span class="line">			d.insert(&#123;e[v].<span class="built_in">size</span>(), v&#125;);</span><br><span class="line">			--m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span> (!d.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> du = d.<span class="built_in">begin</span>()-&gt;first;</span><br><span class="line">		<span class="keyword">int</span> u = d.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">		<span class="keyword">if</span> (du &gt;= k) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (it-&gt;second + <span class="number">1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (du == k - <span class="number">1</span> &amp;&amp; k - <span class="number">1</span> &lt;= m * <span class="number">2</span> / k &amp;&amp; check(u)) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : e[u]) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		d.erase(d.<span class="built_in">begin</span>());</span><br><span class="line">		del(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1440E-线段树"><a href="#1440E-线段树" class="headerlink" title="1440E: 线段树"></a><a href="https://codeforces.com/contest/1440/problem/E" target="_blank" rel="noopener">1440E</a>: 线段树</h3><p>没能在比赛的时候做出原因：</p>
<ul>
<li>线段树模板不太好用</li>
<li>没有注意到数列必然单调递减，所以处理的时候处理复杂了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mn, tag;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; sm;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lson l, m, 2 * p</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, 2 * p + 1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mn.resize(<span class="number">4</span> * n);</span><br><span class="line">		tag.resize(<span class="number">4</span> * n);</span><br><span class="line">		sm.resize(<span class="number">4</span> * n);</span><br><span class="line">	&#125;</span><br><span class="line">	SegmentTree(<span class="keyword">int</span> _n) : n(_n) &#123;</span><br><span class="line">		resize();</span><br><span class="line">	&#125;</span><br><span class="line">	SegmentTree(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a) &#123;</span><br><span class="line">		n = a.<span class="built_in">size</span>();</span><br><span class="line">		resize();</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; build = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p) &#123;</span><br><span class="line">			<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">				mn[p] = sm[p] = a[l - <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">			build(lson);</span><br><span class="line">			build(rson);</span><br><span class="line">			pull(p);</span><br><span class="line">		&#125;;</span><br><span class="line">		build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		mn[p] = <span class="built_in">std</span>::<span class="built_in">min</span>(mn[<span class="number">2</span> * p], mn[<span class="number">2</span> * p + <span class="number">1</span>]);</span><br><span class="line">		sm[p] = sm[<span class="number">2</span> * p] + sm[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		tag[p] = mn[p] = v;</span><br><span class="line">		sm[p] = LL(r - l + <span class="number">1</span>) * v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (tag[p]) &#123;</span><br><span class="line">			<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">			<span class="built_in">set</span>(lson, tag[p]);</span><br><span class="line">			<span class="built_in">set</span>(rson, tag[p]);</span><br><span class="line">			tag[p] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rangeSet</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;</span><br><span class="line">			<span class="built_in">set</span>(l, r, p, v);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		push(l, r, p);</span><br><span class="line">		<span class="keyword">if</span> (L &lt;= m) rangeSet(L, R, v, lson);</span><br><span class="line">		<span class="keyword">if</span> (R &gt; m) rangeSet(L, R, v, rson);</span><br><span class="line">		pull(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>&amp; y, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mn[p] &gt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= l &amp;&amp; sm[p] &lt;= y) &#123;</span><br><span class="line">			y -= sm[p];</span><br><span class="line">			<span class="keyword">return</span> r - l + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		push(l, r, p);</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= m) ans += query(x, y, lson); </span><br><span class="line">		ans += query(x, y, rson);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> query(x, y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">bounded</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mn[p] &gt;= v) <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (mn[<span class="number">2</span> * p] &gt;= v) <span class="keyword">return</span> bounded(v, rson);</span><br><span class="line">		<span class="keyword">return</span> bounded(v, lson);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = bounded(y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (l &lt;= x) rangeSet(l, x, y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, q;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="function">SegmentTree <span class="title">A</span><span class="params">(a)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> op, x, y;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>) A.modify(x, y);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A.query(x, y) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1447B：简单细节题"><a href="#1447B：简单细节题" class="headerlink" title="1447B：简单细节题"></a><a href="https://codeforces.com/contest/1447/problem/B" target="_blank" rel="noopener">1447B</a>：简单细节题</h3><ul>
<li>很早就知道，任意两个可以换，要考虑非正数的个数是否为奇数。</li>
<li>然后为奇数时，绝对值总和减去 2 倍的最大的非正数（！！！这是错了）。</li>
<li>后来想了半天终于知道时减去绝对值最小的数。</li>
<li>然后再之前的内容上改，写出了下面屎一样的 RE 代码！还 PE 了，最后 RE，吐了！</li>
</ul>
<p><strong>此代码为 RE 代码！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		n *= m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			r += <span class="built_in">abs</span>(x);</span><br><span class="line">			<span class="keyword">if</span> (x &lt;= <span class="number">0</span>) a.emplace_back(-x);</span><br><span class="line">			<span class="keyword">else</span> b.emplace_back(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a.<span class="built_in">size</span>() &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			r -= <span class="built_in">std</span>::<span class="built_in">min</span>(*<span class="built_in">std</span>::min_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()), *<span class="built_in">std</span>::min_element(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>())) * <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1447C：经典问题：假-0-1-背包，真贪心"><a href="#1447C：经典问题：假-0-1-背包，真贪心" class="headerlink" title="1447C：经典问题：假 0-1 背包，真贪心"></a><a href="https://codeforces.com/contest/1447/problem/C" target="_blank" rel="noopener">1447C</a>：经典问题：假 0-1 背包，真贪心</h3><p>题意：给定 $n$ 件物品 $w_i$，给出一个 $k$ 件物品和在 $[\lfloor \frac{W}{2} \rfloor, W]$ 之间的一种方案</p>
<p>做法：对物品从大到小排序，然后贪心即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		LL w;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; w;</span><br><span class="line">		std::vector&lt;std::pair&lt;int, int&gt;&gt; a(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i].first;</span><br><span class="line">			a[i].second = i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">std</span>::greater&lt;&gt;());</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		LL s = <span class="number">0</span>, h = (w + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s + a[i].first &lt;= w) &#123;</span><br><span class="line">				x.emplace_back(a[i].second);</span><br><span class="line">				s += a[i].first;</span><br><span class="line">				<span class="keyword">if</span> (s &gt;= h) &#123;</span><br><span class="line">					flag = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			<span class="built_in">std</span>::sort(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : x) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1447D：DP"><a href="#1447D：DP" class="headerlink" title="1447D：DP"></a><a href="https://codeforces.com/contest/1447/problem/D" target="_blank" rel="noopener">1447D</a>：DP</h3><blockquote>
<p>就是一个简单的 DP，写完我都有点虚…</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> a, b;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			dp[i][j] = <span class="built_in">std</span>::<span class="built_in">max</span>(&#123;<span class="number">0</span>, dp[i - <span class="number">1</span>][j] - <span class="number">1</span>, dp[i][j - <span class="number">1</span>] - <span class="number">1</span>&#125;);</span><br><span class="line">			<span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) dp[i][j] = <span class="built_in">std</span>::<span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">			r = <span class="built_in">std</span>::<span class="built_in">max</span>(r, dp[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="144E：思维题"><a href="#144E：思维题" class="headerlink" title="144E：思维题"></a><a href="https://codeforces.com/contest/1447/problem/E" target="_blank" rel="noopener">144E</a>：思维题</h3><ul>
<li>考虑最高位，如果最高位为 1，最高位为 0 的个数都大于 1，那么它们必然不连通，所以我们要将其中的一个变得不超过 1，注意不能贪心。并且注意到如果元素个数不超过 2，必然连通。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> now) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (now &lt; <span class="number">0</span> || a.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b, c;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((x &gt;&gt; now) &amp; <span class="number">1</span>) b.emplace_back(x);</span><br><span class="line">			<span class="keyword">else</span> c.emplace_back(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">min</span>(dfs(b, now - <span class="number">1</span>) + <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, <span class="keyword">int</span>(c.<span class="built_in">size</span>() - <span class="number">1</span>)), dfs(c, now - <span class="number">1</span>) + <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, <span class="keyword">int</span>(b.<span class="built_in">size</span>() - <span class="number">1</span>)));</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dfs(a, <span class="number">29</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtCoder-ABC-183f：并查集-map"><a href="#AtCoder-ABC-183f：并查集-map" class="headerlink" title="AtCoder ABC 183f：并查集 + map"></a><a href="https://atcoder.jp/contests/abc183/tasks/abc183_f" target="_blank" rel="noopener">AtCoder ABC 183f</a>：并查集 + map</h3><p>题意：N 个节点，每个节点有一个值，然后 Q 次操作：<code>1 a b</code> 是将 a, b 所在的群合并，<code>2 x y</code> 求 $x$ 所在的群中，值为 $y$ 的个数。细节优化</p>
<ul>
<li>尽量小的向大的合并，合并完小的记得清空</li>
<li><code>std::map</code> 优于 <code>std::multiset</code></li>
<li><code>std::vector&lt;std::map&lt;int, int&gt;&gt;</code> 优于 <code>std::map&lt;std::map&lt;int, int&gt;&gt;</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, q;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	std::vector&lt;int&gt; c(n), p(n);</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	std::vector&lt;std::map&lt;int, int&gt;&gt; mp(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : c) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x, --x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ++mp[i][c[i]];</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; <span class="built_in">find</span> = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> ans = x;</span><br><span class="line">		<span class="keyword">while</span> (ans != p[ans]) ans = p[ans];</span><br><span class="line">		<span class="keyword">while</span> (x != ans) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = p[x];</span><br><span class="line">			p[x] = ans;</span><br><span class="line">			x = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> father = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> pi) &#123;</span><br><span class="line">		p[i] = pi;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = mp[i].<span class="built_in">begin</span>(); it != mp[i].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">			mp[pi][it-&gt;first] += it-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line">		mp[i].<span class="built_in">clear</span>();</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> merge = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">		<span class="keyword">int</span> fi = <span class="built_in">find</span>(i), fj = <span class="built_in">find</span>(j);</span><br><span class="line">		<span class="keyword">if</span> (fi != fj) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mp[fi].<span class="built_in">size</span>() &lt; mp[fj].<span class="built_in">size</span>()) father(fi, fj);</span><br><span class="line">			<span class="keyword">else</span> father(fj, fi);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> op, a, b;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		--a; --b;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">			merge(a, b);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> fa = <span class="built_in">find</span>(a);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mp[fa][b] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtCoder-ABC-183e：经典-DP"><a href="#AtCoder-ABC-183e：经典-DP" class="headerlink" title="AtCoder ABC 183e：经典 DP"></a><a href="https://atcoder.jp/contests/abc183/tasks/abc183_e" target="_blank" rel="noopener">AtCoder ABC 183e</a>：经典 DP</h3><p>题意：在 $n \times m$ 的格点中，有些点可以走有些不行，每次能往右，下或右下中的一个方向走任意步（但是中间不能有非法点），问有多少种从左上角到右下角的走法。</p>
<blockquote>
<p>显然 DP，然后用类和优化</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	std::vector&lt;std::vector&lt;int&gt;&gt; a(n, std::vector&lt;int&gt;(m)), al(n, std::vector&lt;int&gt;(m)), au(n, std::vector&lt;int&gt;(m)), ad(n, std::vector&lt;int&gt;(m));</span><br><span class="line">	a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : s) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j &gt; <span class="number">0</span>) (a[i][j] += al[i][j - <span class="number">1</span>]) %= M;</span><br><span class="line">				<span class="keyword">if</span> (i &gt; <span class="number">0</span>) (a[i][j] += au[i - <span class="number">1</span>][j]) %= M;</span><br><span class="line">				<span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) (a[i][j] += ad[i - <span class="number">1</span>][j - <span class="number">1</span>]) %= M;</span><br><span class="line">				al[i][j] = au[i][j] = ad[i][j] = a[i][j];</span><br><span class="line">				<span class="keyword">if</span> (j &gt; <span class="number">0</span>) (al[i][j] += al[i][j - <span class="number">1</span>]) %= M;</span><br><span class="line">				<span class="keyword">if</span> (i &gt; <span class="number">0</span>) (au[i][j] += au[i - <span class="number">1</span>][j]) %= M;</span><br><span class="line">				<span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) (ad[i][j] += ad[i - <span class="number">1</span>][j - <span class="number">1</span>]) %= M;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">				a[i][j] = al[i][j] = au[i][j] = ad[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[n - <span class="number">1</span>][m - <span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1438-数学场"><a href="#1438-数学场" class="headerlink" title="1438 数学场"></a><a href="https://codeforces.com/contest/1438" target="_blank" rel="noopener">1438 数学场</a></h3><p>A 题：$a_i = 1$ 即可<br>B 题：若存在 $i \neq j$ 使得 $a_i = a_j$，则 YES，否则 NO（考虑二进制）<br>C 题：可以根据假设强制让 $a_{i + j}$ 与 $i + j$ 有相同的奇偶性，那么必然满足条件，此问题一般化 <a href="https://codeforces.com/contest/1438/submission/98431377" target="_blank" rel="noopener">解法</a><br>D 题：注意到首先我们可以让数列成对相等并且 $x \otimes x \otimes y = y$，所以如果 $n$ 为奇数，必然就 YES，若 $n$ 为偶数，我们成对这样搞之后，会有两个元素可能不等，又注意到它们相等当且仅当所有值异或为 0，所以搞定</p>
<blockquote>
<p>代码索然无味就不写了</p>
</blockquote>
<h3 id="Atcoder-ABC182F：找钱问题"><a href="#Atcoder-ABC182F：找钱问题" class="headerlink" title="Atcoder ABC182F：找钱问题"></a><a href="https://atcoder.jp/contests/abc182/tasks/abc182_f" target="_blank" rel="noopener">Atcoder ABC182F</a>：找钱问题</h3><p>给定 $n$ 种纸币，$1 = a_1 &lt; a_2 &lt; \cdots a_n$，且 $a_i | a_{i + 1}$，要买商品 $x$，那么可以给 $y \geq x$，找零 $y - x$，要求 $y$ 和 $y - x$ 的最少纸币表达中没有公共纸币。问所有的 $y$ 有没有种。</p>
<blockquote>
<p>注意到 $y$ 和 $(y_1, \cdots, y_n)$，(其中 $y_i * a_i &lt; a_{i + 1}$，且 $y = \sum a_i y_i$ 有一个一一对应。然后我们可以考虑 $x$ 的向量表达，然后再看 $y + x$ 和 $y$ 没公共非零项的做法。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	LL x;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	x %= a.back();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;LL, LL&gt; mp;</span><br><span class="line">	mp.insert(&#123;x, <span class="number">1</span>&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">map</span>&lt;LL, LL&gt; mp2;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">			mp2[it-&gt;first / a[i]] += it -&gt; second;</span><br><span class="line">			<span class="keyword">if</span> (it-&gt;first % a[i]) mp2[it-&gt;first / a[i] + <span class="number">1</span>] += it-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) a[j] /= a[i];</span><br><span class="line">		<span class="built_in">std</span>::swap(mp, mp2); <span class="comment">// 用 swap 更快！</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mp[<span class="number">0</span>] + mp[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="凸优化借助凸包解决"><a href="#凸优化借助凸包解决" class="headerlink" title="凸优化借助凸包解决"></a><a href="https://vjudge.net/problem/Kattis-mobilization" target="_blank" rel="noopener">凸优化借助凸包解决</a></h3><blockquote>
<p>详细解释放在 <a href="https://izlyforever.com/spookywooky/" target="_blank" rel="noopener">izlyforever</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">using</span> pdd = <span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-12</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fabs</span>(x) &lt; eps ? <span class="number">0</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLeft</span><span class="params">(<span class="keyword">const</span> pii &amp;op, <span class="keyword">const</span> pii &amp;sp, <span class="keyword">const</span> pii &amp;ep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (sp.first - op.first) * (ep.second - op.second) </span><br><span class="line">	&lt; (sp.second - op.second) * (ep.first - op.first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pdd&gt; <span class="title">convexHull</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pdd&gt; p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">	p.erase(<span class="built_in">std</span>::unique(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()), p.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pdd&gt; <span class="title">q</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; crossLeft(q[top - <span class="number">1</span>], p[i], q[top - <span class="number">2</span>])) --top;</span><br><span class="line">		q[top++] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = top;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top &gt; len &amp;&amp; crossLeft(q[top - <span class="number">1</span>], p[i], q[top - <span class="number">2</span>])) --top;</span><br><span class="line">		q[top++] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	top -= n &gt; <span class="number">1</span>;</span><br><span class="line">	q.resize(top);</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, d, c;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; d;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pdd&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y] : p) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; c &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		x = x * d / c;</span><br><span class="line">		y = y * d / c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> q = convexHull(p);</span><br><span class="line">	<span class="keyword">auto</span> cal = [](pdd p) &#123;</span><br><span class="line">		<span class="keyword">return</span> p.first * p.second;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> deal = [](pdd a, pdd b) -&gt; <span class="keyword">double</span> &#123;</span><br><span class="line">		a.first -= b.first; a.second -= b.second;</span><br><span class="line">		<span class="keyword">if</span> (a.first * a.second &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">double</span> t = -(b.first / a.first + b.second / a.second) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (t &gt; <span class="number">0</span> &amp;&amp; t &lt; <span class="number">1</span>) <span class="keyword">return</span> (a.first * t + b.first) * (a.second * t + b.second);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">double</span> r = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : q) r = <span class="built_in">std</span>::<span class="built_in">max</span>(r, cal(x));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != q.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		r = <span class="built_in">std</span>::<span class="built_in">max</span>(r, deal(q[i], q[(i + <span class="number">1</span>) % q.<span class="built_in">size</span>()]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">12</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Atcoder-arc107C：并查集"><a href="#Atcoder-arc107C：并查集" class="headerlink" title="Atcoder arc107C：并查集"></a><a href="https://atcoder.jp/contests/arc107/tasks/arc107_c" target="_blank" rel="noopener">Atcoder arc107C</a>：并查集</h3><p>首先，如果某两列和交换，那么给它们连边，那么只要任意两列可达，那么它们的位置最后就可以交换，也就是求每个连通分支的大小，直接广搜标记也可以做，当然了用并查集会更简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">fac</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">a</span><span class="params">(n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : x) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;]() &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(n);</span><br><span class="line">		<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">auto</span> <span class="built_in">find</span> = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">			<span class="keyword">int</span> ans = x;</span><br><span class="line">			<span class="keyword">while</span> (ans != p[ans]) ans = p[ans];</span><br><span class="line">			<span class="keyword">while</span> (x != ans) &#123;</span><br><span class="line">				<span class="keyword">int</span> t = p[x];</span><br><span class="line">				p[x] = ans;</span><br><span class="line">				x = t;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; n; ++t) &#123;</span><br><span class="line">					<span class="keyword">if</span> (a[i][t] + a[j][t] &gt; k) &#123;</span><br><span class="line">						flag = <span class="literal">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (flag) p[<span class="built_in">find</span>(j)] = p[<span class="built_in">find</span>(i)];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">find</span>(i);</span><br><span class="line">		LL r = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="built_in">std</span>::count(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), i);</span><br><span class="line">			r = r * fac[cnt] % M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	LL r = f();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(a[i][j], a[j][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r = r * f() % M;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Atcoder-arc107D：经典计算，DP-优化"><a href="#Atcoder-arc107D：经典计算，DP-优化" class="headerlink" title="Atcoder arc107D：经典计算，DP 优化"></a><a href="https://atcoder.jp/contests/arc107/tasks/arc107_d" target="_blank" rel="noopener">Atcoder arc107D</a>：经典计算，DP 优化</h3><p>将 $K$ 写成 $N$ 个形如 $2^{-i}, i \geq 0$ 之和（不计顺序），问有多少中写法。我们不妨将答案记作 <code>dp[n][k]</code><br>那么显然 <code>dp[n][k] = dp[n][2k] + dp[n - 1][2k - 2] + \cdots dp[n - k][0]</code>（考虑取多少个 <code>1</code>，那么剩下的最少要以 $\frac{1}{2}$ 为最大值，那么就等价于剩下的数乘以 <code>2</code>)，所以令 <code>s[a] = dp[a][0] + dp[a + 1][2] + \cdots dp[n][2(n - a)]</code>，这样我们就能迅速求出 <code>dp[n][k]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> add = [](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">		(x += y) &gt;= M &amp;&amp; (x -= M);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">			dp[i][j] = s[i - j];</span><br><span class="line">			<span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) add(s[i - (j / <span class="number">2</span>)], dp[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dp[n][k] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1442D：经典分治问题"><a href="#1442D：经典分治问题" class="headerlink" title="1442D：经典分治问题"></a><a href="https://codeforces.com/contest/1442/problem/D" target="_blank" rel="noopener">1442D</a>：经典分治问题</h3><blockquote>
<p>首先这是一个很实在的问题。给定 $n$ 个单调递增的序列，从中取 $k$ 个数，但是取数的时候每次只能在序列的最前面取，也就是取最小的。求最大的和。首先注意最多只有一个序列取了一部分，其它的要么没取，要么取完（反证），那么我们可以二分枚举其在左边还是在右边</p>
</blockquote>
<p>如果直接暴力写，也就是枚举那个只取了一部分的，其它的就是一个 <code>0-1</code> 背包，所以总复杂度为 $O(n^2 k)$，这肯定是过不了的。但是可以分治，也就是说分成两半，一半是 <code>0-1</code> 背包（即要么取完要么没取），另一半是原问题的子问题！这不就有了吗，经典！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 	freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : a) &#123;</span><br><span class="line">		<span class="keyword">int</span> cnt;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cnt;</span><br><span class="line">		p.emplace_back(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; cnt; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; k) p.push_back(p.back() + x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">dp</span><span class="params">(k + <span class="number">1</span>, <span class="number">-1e18</span>)</span></span>;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> merge = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt;= a[i].<span class="built_in">size</span>() - <span class="number">1</span>; --j) &#123;</span><br><span class="line">				dp[j] = <span class="built_in">std</span>::<span class="built_in">max</span>(dp[j], dp[j - a[i].<span class="built_in">size</span>() + <span class="number">1</span>] + a[i].back());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; divide = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[l].<span class="built_in">size</span>(); ++i) ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, dp[k - i] + a[l][i]);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">auto</span> tmp = dp;</span><br><span class="line">		merge(l, m);</span><br><span class="line">		divide(m, r);</span><br><span class="line">		</span><br><span class="line">		dp = tmp;</span><br><span class="line">		merge(m, r);</span><br><span class="line">		divide(l, m);</span><br><span class="line">	&#125;;</span><br><span class="line">	divide(<span class="number">0</span>, n);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本来是每一层都是一个 <code>dp</code>，但是 <a href="https://codeforces.com/profile/Itst" target="_blank" rel="noopener">Itst</a> 做了空间优化<br>知道在某一个性质的点上取得最值，那么不一定要把这个点求出来，可以在一定范围内把值都比较一遍即可，因为极值点的判断有可能相对更为复杂，这可能就是计算机的魅力吧。<br>另外 <a href="https://codeforces.com/contest/1442/submission/97479495" target="_blank" rel="noopener">Jiangly</a> 写了一个非递归的 $\sqrt{n}$ 的做法，也很犀利。</p>
</blockquote>
<h3 id="1443D：经典问题"><a href="#1443D：经典问题" class="headerlink" title="1443D：经典问题"></a><a href="https://codeforces.com/contest/1443/problem/D" target="_blank" rel="noopener">1443D</a>：经典问题</h3><p>给定一个非负数列，问是否可以通过前缀减一，后缀减一的方式使得所有的数都变成 0</p>
<blockquote>
<p>一开始以为只需中间的数大于两边的最小值之和就可以，后来发现不对，然后通过自己想了一个例子，然后想到了正确做法，开心<br>这个问题等价与给定 $a$，求非负序列 $p, q$ 满足 $p + q = a$, $p$ 单调减，$q$ 单调递增（在保证条件下，使得$p$ 尽量大）</p>
</blockquote>
<p>做法：看相邻两个数，比如左边比右边大，那么必然右边至少要做后缀减一的操作它们的差值次，也就是说，后面所有的数都要减去这个差值。反之同理，所以搞两个变量，一个是左边累减去（可以用剩余多少来标记），一个是右边累减。没跑一步判断一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">int</span> now = a[<span class="number">0</span>], cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt; cur) &#123;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (a[i] &gt; a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">				cur += a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				now -= a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span> (now &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (flag ? <span class="string">"YES\n"</span> : <span class="string">"NO\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1445D：一个-trival-的脑力问题"><a href="#1445D：一个-trival-的脑力问题" class="headerlink" title="1445D：一个 trival 的脑力问题"></a><a href="https://codeforces.com/contest/1445/problem/D" target="_blank" rel="noopener">1445D</a>：一个 trival 的脑力问题</h3><p>给定长为 $2n$ 的序列 $a$，分成两个长度为 $n$ 的序列 $p, q$ 然后 $p$ 非降，$q$ 非升，定义 $f(p, q) = \sum_{i = 1}^n |p_i - q_i|$，问所有的 $f(p, q)$ 的和为多少。</p>
<blockquote>
<p>不妨设 $a$ 是有序的，平均分两半，如果 $p$ 在左边取了 $k$ 个元素，那么 $q$ 必然在右边取了 $k$ 个元素，所以无论哪种情况，$f(p, q)$ 是常数。所以结论就显然了！所以可以搞个升级版！。</p>
</blockquote>
<p>答案就是 $\binom{2n}{n} \sum_{i = 1}^{n} (a_{i + n} - a_i)$，代码就不贴了。推公式把我推吐了。</p>
<blockquote>
<p>此题已经被我魔改了，哈哈哈</p>
</blockquote>
<h3 id="1437C：经典问题之动态规划"><a href="#1437C：经典问题之动态规划" class="headerlink" title="1437C：经典问题之动态规划"></a><a href="https://codeforces.com/contest/1437/problem/C" target="_blank" rel="noopener">1437C</a>：经典问题之动态规划</h3><p>给定 $1 \leq a_i \leq n$，求两两不同的正整数 $b_i$，使得 $\sum_{i = 1}^n |a_i - b_i|$ 最小。<br>显然只要 $b$ 的值域确定了，答案就确定了，且 $1 \leq b_i &lt; 2n$。所以就可以对 $a_i$ 排序，然后再 <code>1 ~ 2n - 1</code> 中选 $n$ 个数，使得结果最小。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1e9</span>)</span></span>;</span><br><span class="line">		<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">		dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt; <span class="number">0</span>; --j) dp[j] = <span class="built_in">std</span>::<span class="built_in">min</span>(dp[j], dp[j - <span class="number">1</span>] + <span class="built_in">abs</span>(a[j - <span class="number">1</span>] - i));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(dp[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1437E：最长递增子序列"><a href="#1437E：最长递增子序列" class="headerlink" title="1437E：最长递增子序列"></a><a href="https://codeforces.com/contest/1437/problem/E" target="_blank" rel="noopener">1437E</a>：最长递增子序列</h3><p>在固定数组的一些元素的条件下，最小改变多少数，使得数列严格单调递增（减去标号就变成 <strong>不严格</strong> 递增了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">-1e9</span> - <span class="number">2</span>, a[n + <span class="number">1</span>] = <span class="number">1e9</span> + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		a[i] -= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(k + <span class="number">2</span>)</span></span>;</span><br><span class="line">	b[<span class="number">0</span>] = <span class="number">0</span>, b[k + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) <span class="keyword">if</span> (a[b[i]] &lt; a[b[i - <span class="number">1</span>]])&#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> r = n - k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = b[i] + <span class="number">1</span>; j &lt; b[i + <span class="number">1</span>]; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &gt;= a[b[i]] &amp;&amp; a[j] &lt;= a[b[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> it = <span class="built_in">std</span>::upper_bound(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), a[j]);</span><br><span class="line">				<span class="keyword">if</span> (it == c.<span class="built_in">end</span>()) c.push_back(a[j]);</span><br><span class="line">				<span class="keyword">else</span> *it = a[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		r -= c.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1435C：经典选择问题"><a href="#1435C：经典选择问题" class="headerlink" title="1435C：经典选择问题"></a><a href="https://codeforces.com/contest/1435/problem/C" target="_blank" rel="noopener">1435C</a>：经典选择问题</h3><p>题意大致可以转化成：有 $n$ 个人，每个人有 $m$ 个值可以选择，问如何选择才能使得他们的最大值减最小值最小。</p>
<p>做法就是把所有可能的选择进行排序（二维，一维存值，一维存人），然后看所有人至少一次选择的时候最大值和最小值的差是多少。相当于左右两个指针在跑，复杂度为 $O(nm)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : b) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pii&gt; p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			p.push_back(&#123;b[j] - a[i], j&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">1e9</span> + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, x = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (x &lt; n &amp;&amp; j &lt; p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt[p[j].second] == <span class="number">0</span>) ++x;</span><br><span class="line">			++cnt[p[j].second];</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; n) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (--cnt[p[i].second] == <span class="number">0</span>) --x;</span><br><span class="line">		r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, p[j - <span class="number">1</span>].first - p[i].first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一开始想枚举最小值，三分法来做（但是我知道凸性一般是不成立的）</p>
</blockquote>
<h3 id="1435D：经典进出问题"><a href="#1435D：经典进出问题" class="headerlink" title="1435D：经典进出问题"></a><a href="https://codeforces.com/contest/1435/problem/D" target="_blank" rel="noopener">1435D</a>：经典进出问题</h3><p>将 $1 ~ n$ 个元素进行加入和提出操作（每个元素一次，共 $2n$）次，并且每次出的是当前集合中最小的值。<br>给定一个进出序列，和出的时候的元素值，求进的元素值（不合理的输出：NO)。</p>
<blockquote>
<p>注意到每出一个元素，那么集合中剩下的元素都要大于出的元素，但是这个信息可以由顶元素上加限制来承载。当在加入一个新元素后，这个限制又被暂时的隐藏了。所以存在当前顶元素上是特别优质的做法。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;pii&gt; A;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">		<span class="keyword">char</span> op;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">'+'</span>) A.push(&#123;now++, <span class="number">0</span>&#125;);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (A.empty() || A.top().second &gt; x) &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">"NO"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				r[A.top().first] = x;</span><br><span class="line">				A.pop();</span><br><span class="line">				<span class="keyword">if</span> (!A.empty()) A.top().second = <span class="built_in">std</span>::<span class="built_in">max</span>(A.top().second, x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"YES"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : r) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">println</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此题一开始题意理解有点问题，最后竟然还 PA，结果最终评测 WA 了。</p>
</blockquote>
<h3 id="AtCoder-arc106d：经典求和计算"><a href="#AtCoder-arc106d：经典求和计算" class="headerlink" title="AtCoder arc106d：经典求和计算"></a><a href="https://atcoder.jp/contests/arc106/tasks/arc106_d" target="_blank" rel="noopener">AtCoder arc106d</a>：经典求和计算</h3><p>对任意 $1 \leq x \leq K$ 求 $\sum_{1 \leq i &lt; j \leq n} (a_i + a_j)^x$</p>
<p>注意到 </p>
<script type="math/tex; mode=display">
2 \sum_{1 \leq i < j \leq n} (a_i + a_j)^x = \sum_{i = 1}^n \sum_{j = 1}^n (a_i + a_j)^x - \sum_{i = 1}^n (2a_i)^x</script><p>然后二项式展开即可。</p>
<blockquote>
<p>若此题 $n$ 比较小，$k$ 比较大（$n$ 特别小时直接 $n^2 \log k$ 就没啥意思了），注意到二项式展开之后是个卷积形式，所以用 NFT 有 $O(nk + k \log k)$ 的做法。例如 $n &lt; 3 \cdot 10^4, k &lt; 10^5$ （时限 5s)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> LL inv2 = (M + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	std::vector&lt;LL&gt; fac(k + 1), ifac(k + 1);</span><br><span class="line">	fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">	ifac[k] = powMod(fac[k], M - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; --i) ifac[i - <span class="number">1</span>] = ifac[i] * i % M;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">s</span><span class="params">(k + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		LL p = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">			s[j] += p;</span><br><span class="line">			<span class="keyword">if</span> (s[j] &gt;= M) s[j] -= M;</span><br><span class="line">			p = p * a[i] % M;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> C = [&amp;](<span class="keyword">int</span> n, <span class="keyword">int</span> m) &#123;</span><br><span class="line">		<span class="keyword">return</span> fac[n] * ifac[m] % M * ifac[n - m] % M;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// here nft can be used</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">			r = (r + C(i, j) * s[j] % M * s[i - j] % M) % M;</span><br><span class="line">		&#125;</span><br><span class="line">		r = (r - powMod(<span class="number">2</span>, i) * s[i]) % M;</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>) r += M;</span><br><span class="line">		r = r * inv2 % M;</span><br><span class="line">		<span class="built_in">print</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1436E-MEX"><a href="#1436E-MEX" class="headerlink" title="1436E: MEX"></a><a href="https://codeforces.com/contest/1436/problem/E" target="_blank" rel="noopener">1436E</a>: MEX</h3><p>求 $MEX(MEX(L, R)_{1 \leq L \leq R \leq n}$)，其中 $MEX(L, R)$ 为使得 $a_L, a_{L + 1} \cdots, a_{R}$ 中没出现的最小正整数。</p>
<p>做法：先求出所有 MEX(i, n)，这是能在 $O(n)$ 时间复杂度解决的（因为 MEX 会随着 i 递减而增大，并且值域不超过 $n$）。然后我们删除尾部的点，那么在从右往左首次出现 $Mex(i, n) &gt; a[n]$ 的 <code>pre[n] + 1 ~ i</code> 这一段的值都要改成 <code>a[n]</code>,这里 <code>pre[x]</code> 表示 <code>x</code> 位置前一个值为 <code>a[x]</code> 的位置。那么区间线段树就搞定了。</p>
<blockquote>
<p>没在比赛时候写出，不想写了！</p>
</blockquote>
<h3 id="hdu-4747-MEX"><a href="#hdu-4747-MEX" class="headerlink" title="hdu 4747: MEX"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4747" target="_blank" rel="noopener">hdu 4747</a>: MEX</h3><p>求 $\sum_{1 \leq L \leq R \leq n} MEX(L, R)$)，其中 $MEX(L, R)$ 为使得 $a_L, a_{L + 1} \cdots, a_{R}$ 中没出现的最小自然数</p>
<blockquote>
<p>同理与上面做法，代码不写了，懒得写线段树。</p>
<p>有的 MEX 定义包含 0, 有的不包含，无所谓啦。</p>
</blockquote>
<h3 id="1433G-将某条边的权值置零下最短路径"><a href="#1433G-将某条边的权值置零下最短路径" class="headerlink" title="1433G: 将某条边的权值置零下最短路径"></a><a href="https://codeforces.com/contest/1433/problem/G" target="_blank" rel="noopener">1433G</a>: 将某条边的权值置零下最短路径</h3><blockquote>
<p>我一开始以为是缩点… 想太多了，做法就是先求出任意两点的距离，然后边 <code>x -&gt; y</code> 置零可以看成 <code>a -&gt; b</code> 多了两种选择 <code>a -&gt; x - &gt; y - &gt; b</code> 和 <code>a -&gt; y -&gt; x -&gt; b</code> 就好了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">auto</span> cmax = [](<span class="keyword">auto</span> &amp;x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; y) x = y;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> cmin = [](<span class="keyword">auto</span> &amp;x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; y) x = y;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> n, m, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">d</span><span class="params">(n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1e9</span>))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) d[i][i] = <span class="number">0</span>;</span><br><span class="line">	std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; road(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y, w] : road) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">		--x; --y;</span><br><span class="line">		cmin(d[x][y], w);</span><br><span class="line">		d[y][x] = d[x][y];</span><br><span class="line">	&#125;</span><br><span class="line">	std::vector&lt;std::pair&lt;int, int&gt;&gt; travel(k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[a, b] : travel) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		--a; --b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> floyd = [&amp;]()&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != n; ++k)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j != n; ++j)</span><br><span class="line">					cmin(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">	&#125;;</span><br><span class="line">	floyd();</span><br><span class="line">	LL r = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, w] : road) &#123;</span><br><span class="line">		LL now = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [a, b] : travel) &#123;</span><br><span class="line">			now += <span class="built_in">std</span>::<span class="built_in">min</span>(&#123;d[a][b], d[a][x] + d[y][b], d[a][y] + d[x][b]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		cmin(r, now);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用堆优化 Dijkstra 会更快一些，用 priority_quque 比 set 快一些。不过 set 比 priority_quque 方便很多（好遍历删除等操作）。</p>
</blockquote>
<h3 id="439D：三分法模板题"><a href="#439D：三分法模板题" class="headerlink" title="439D：三分法模板题"></a><a href="https://codeforces.com/contest/439/problem/D" target="_blank" rel="noopener">439D</a>：三分法模板题</h3><p>每次操作可以增加某个数或者减少某个数，问最小多少次操作可以让 <code>a</code> 的最小值不小于 <code>b</code> 的最大值</p>
<p>我们可以枚举 <code>a</code> 最终的最小值 <code>t</code>，那么答案就是 $\sum_{a_i &lt; t} (t - a_i) + \sum_{b_i &gt; t} (b_i - t)$<br>求导然后就知道了它是凸函数了。然后就可以三分法求了。</p>
<h3 id="三分法求凸函数最值"><a href="#三分法求凸函数最值" class="headerlink" title="三分法求凸函数最值"></a><a href="https://codeforces.com/contest/439/problem/D" target="_blank" rel="noopener">三分法求凸函数最值</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	std::vector&lt;int&gt; a(n), b(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : b) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> ma) &#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) <span class="keyword">if</span> (x &lt; ma) r += ma - x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : b) <span class="keyword">if</span> (x &gt; ma) r += x - ma;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">while</span> (l + <span class="number">2</span> &lt; r) &#123;</span><br><span class="line">		<span class="keyword">int</span> lm = (<span class="number">2l</span>l * l + r) / <span class="number">3</span>, rm = (l + <span class="number">2l</span>l * r + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span> (f(lm) &lt; f(rm)) r = rm;</span><br><span class="line">		<span class="keyword">else</span> l = lm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f(l) &lt; f(r)) --r;</span><br><span class="line">		<span class="keyword">else</span> ++l;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(f(l));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然了此题有更简单的做法：将 <code>a</code> 升序，<code>b</code> 降序，然后答案就是 <code>a[i] - b[i]</code> 为正的和。</p>
</blockquote>
<h3 id="1421A：异或，和，交的关系"><a href="#1421A：异或，和，交的关系" class="headerlink" title="1421A：异或，和，交的关系"></a><a href="https://codeforces.com/contest/1421/problem/A" target="_blank" rel="noopener">1421A</a>：异或，和，交的关系</h3><blockquote>
<p>$(a \oplus x) + (x \oplus b)$ 的最小值，$a \oplus b$，此时 <code>x = a &amp; b</code></p>
</blockquote>
<h3 id="1421E：观察总结题（加减号问题）"><a href="#1421E：观察总结题（加减号问题）" class="headerlink" title="1421E：观察总结题（加减号问题）"></a><a href="https://codeforces.com/contest/1421/problem/E" target="_blank" rel="noopener">1421E</a>：观察总结题（加减号问题）</h3><ul>
<li>任何情况下的答案都是 每一项前添加正负号得到的。</li>
<li>相邻两个之间添加的正负号必然有一个是相同的，即不会出现 <code>+-+-+</code> 或 <code>-+-+-</code> 的情况</li>
<li>负号个数 $m$，总个数 $n$，满足 $(n + m) \equiv 1 \mod 3$（可以通过归纳得到，并且 $n$ 个正负号的情况可以看作 $n - 1$ 个正负号中某一个改变符号并且出现两个，再塞进去）</li>
<li>所有的情况如上所言（可以数学归纳证明）</li>
</ul>
<p>我们用 <code>DP[n][3][2][2]</code> 保存全部状态。<code>DP[i][j][k][p]</code> 分别表示当前 <code>i</code> 个位置，(i + 负数个数 <code>mod 3</code>) 等于 <code>j</code> 且<code>k</code> 表示是否非法（是否存在连续的正或负），<code>p</code> 表示最后以为是否为正的最大结果。</p>
<blockquote>
<p>例如 <code>DP[i][j][1][1]</code> 表示前 <code>i</code> 位（<code>i</code> 与 前 <code>i</code> 位负号个数的和模 3 位 <code>j</code>) 且有连续的负号或者正号，且第 <code>i</code> 位为负号的最大和。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">2</span>;</span><br><span class="line">LL dp[N][<span class="number">3</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="keyword">auto</span> upmax = [](LL &amp;a, LL b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a &lt; b) a = b;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">print</span>(a[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>][<span class="number">1</span>] = -a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">2</span>; ++p) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; <span class="number">2</span>; ++b) &#123;</span><br><span class="line">						<span class="keyword">int</span> digit = (j + <span class="number">1</span> + b) % <span class="number">3</span>;</span><br><span class="line">						upmax(dp[i][digit][k | (p == b)][b], dp[i - <span class="number">1</span>][j][k][p] + (b == <span class="number">0</span> ? a[i]: -a[i]));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">std</span>::<span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此题多维数组写 Vector 不方便，但是又不能开局部数组（因为太大了），所以只能全局变量啦。</p>
</blockquote>
<h3 id="1428D：模拟题"><a href="#1428D：模拟题" class="headerlink" title="1428D：模拟题"></a><a href="https://codeforces.com/contest/1428/problem/D" target="_blank" rel="noopener">1428D</a>：模拟题</h3><blockquote>
<p>由简单到复杂一步步的来，很不错的题。</p>
</blockquote>
<h3 id="1428E：经典问题，正整数划分最值问题（可看作优先队列模板题）"><a href="#1428E：经典问题，正整数划分最值问题（可看作优先队列模板题）" class="headerlink" title="1428E：经典问题，正整数划分最值问题（可看作优先队列模板题）"></a><a href="https://codeforces.com/contest/1428/problem/E" target="_blank" rel="noopener">1428E</a>：经典问题，正整数划分最值问题（可看作优先队列模板题）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">val</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> xn = x / n, rn = x - xn * n;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1l</span>l * xn * xn * (n - rn) + <span class="number">1l</span>l * (xn + <span class="number">1</span>) * (xn + <span class="number">1</span>) * rn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">cmpVal</span><span class="params">(<span class="keyword">const</span> pii &amp;A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val(A.first, A.second) - val(A.first, A.second + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> pii &amp;lhs, <span class="keyword">const</span> pii &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cmpVal(lhs) &lt; cmpVal(rhs); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;pii, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pii&gt;, cmp&gt; Q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		Q.push(&#123;x, <span class="number">1</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (n &lt; k) &#123;</span><br><span class="line">		++n;</span><br><span class="line">		<span class="keyword">auto</span> [x, cnt] = Q.top();</span><br><span class="line">		Q.pop();</span><br><span class="line">		Q.push(&#123;x, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [x, cnt] = Q.top();</span><br><span class="line">		Q.pop();</span><br><span class="line">		r += val(x, cnt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若此题 $k$ 特别大，可二分 cmpVal 的题来解决。</p>
</blockquote>
<h3 id="1428F-经典-DP"><a href="#1428F-经典-DP" class="headerlink" title="1428F: 经典 DP"></a><a href="https://codeforces.com/contest/1428/problem/F" target="_blank" rel="noopener">1428F</a>: 经典 DP</h3><p>题意：给定 0-1 序列 S，设 $f(l, r)$ 表示 $S_l S_{l + 1} \cdots, S_{r}$ 中最长连续 1 的个数，求 $\sum_{l = 1}^n \sum_{r = l}^n f(l, r)$</p>
<blockquote>
<p><a href="https://codeforces.com/blog/entry/83771" target="_blank" rel="noopener">官方题解</a> 实在是太精彩了！这种直方图的做法真的很 Nice！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">	LL ans = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">'0'</span>) ans += cur;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> l = i, r = i;</span><br><span class="line">			<span class="keyword">while</span> (r &lt; n &amp;&amp; s[r] == <span class="string">'1'</span>) ++r;</span><br><span class="line">			<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">				++len;</span><br><span class="line">				cur += i - left[len];</span><br><span class="line">				ans += cur;</span><br><span class="line">				left[len] = r - len;</span><br><span class="line">			&#125;</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1430F：反向-DP"><a href="#1430F：反向-DP" class="headerlink" title="1430F：反向 DP"></a><a href="https://codeforces.com/contest/1430/problem/F" target="_blank" rel="noopener">1430F</a>：反向 DP</h3><p>我想到反向 DP (<code>DP[i]</code> 表示这次本次要预留的子弹数为多少），但是还是不明确怎么写。我们可以看每一波的时候至少需要多少子弹预留。然后合理性检测，最后再从头到尾走一波就知道用多少子弹。把检测和计算分两次搞。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	std::vector&lt;int&gt; a(n), l(n), r(n), dp(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i] &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">int</span> need = a[i];</span><br><span class="line">		<span class="keyword">if</span> (i &lt; n - <span class="number">1</span> &amp;&amp; r[i] == l[i + <span class="number">1</span>]) need += dp[i + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (LL(r[i] - l[i] + <span class="number">1</span>) * k &lt; need) &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[i] = <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0L</span>L, need - LL(r[i] - l[i]) * k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cur = k;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		ans += a[i];</span><br><span class="line">		<span class="keyword">if</span> (cur &lt; dp[i]) &#123;</span><br><span class="line">			ans += cur;</span><br><span class="line">			cur = k;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = ((cur - a[i]) % k + k) % k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1430E：可以转化成求逆序数"><a href="#1430E：可以转化成求逆序数" class="headerlink" title="1430E：可以转化成求逆序数"></a><a href="https://codeforces.com/contest/1430/problem/E" target="_blank" rel="noopener">1430E</a>：可以转化成求逆序数</h3><p>这种只能交换相邻位置的问题，一般都能转换成逆序数。我们先根据最后的状态来定义序关系，然后对应赋值，再求逆序数就好了！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; s;</span><br><span class="line">	TreeArray() &#123;&#125;</span><br><span class="line">	TreeArray(<span class="keyword">int</span> n) &#123; init(n); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		s.resize(n + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">fill</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			s[id] += p;</span><br><span class="line">			id += lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (id) &#123;</span><br><span class="line">			r += s[id];</span><br><span class="line">			id -= lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find minimal index s.t. sum(id) &gt;= x, sum must be increased</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(LL val)</span> </span>&#123;</span><br><span class="line">		LL sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">std</span>::__lg(s.<span class="built_in">size</span>()); ~i; --i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (id + (<span class="number">1</span> &lt;&lt; i) &lt; s.<span class="built_in">size</span>() &amp;&amp; sum + s[id + (<span class="number">1</span> &lt;&lt; i)] &lt; val) &#123;</span><br><span class="line">				id += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">				sum += s[id];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ++id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) tmp[s[i] - <span class="string">'a'</span>].emplace_back(++now);</span><br><span class="line">	std::vector&lt;int&gt; a(n + 1), p(n + 1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		a[i] = tmp[s[i - <span class="number">1</span>] - <span class="string">'a'</span>].back();</span><br><span class="line">		tmp[s[i - <span class="number">1</span>] - <span class="string">'a'</span>].pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[a[i]] = i;</span><br><span class="line">	<span class="function">TreeArray <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		r += A.sum(p[i]);</span><br><span class="line">		A.add(p[i], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清华集训-2016-组合数问题"><a href="#清华集训-2016-组合数问题" class="headerlink" title="清华集训 2016 组合数问题"></a><a href="https://uoj.ac/problem/275" target="_blank" rel="noopener">清华集训 2016 组合数问题</a></h3><p>给定 $1 \leq n, m \leq 10^{18}$ 和素数 $p$，求所有 $0 \leq i \leq n, 0 \leq j \leq \min(i,m)$ 中有多少对 $(i, j)$ 满足 ${i \choose j}$ 是 $p$ 的倍数。</p>
<blockquote>
<p>${i \choose j}$ 是 $p$ 的倍数当且仅当 $i, j$ 的 $p$ 进制中至少有一位 $x$ 满足 $i_x &lt; j_x$（利用 Lucas 定理显然）。</p>
</blockquote>
<p>所以最终答案就是 </p>
<script type="math/tex; mode=display">
\frac{(n + 1)(n + 2)}{2} - \frac{k(k+1)}{2} - f(n, m)</script><p>其中 $k = \max(0, n - m)$，$f(n, m)$ 表示 $i$ 的 每一位都满足 $i_x \geq j_x$ 的方案数，注意到此时必有 $i &gt; j$，所以这里的 $i, j$ 限制分别是 $0 \leq i \leq n, 0 \leq j \leq m$. 并且可以让 $m = \min(m, n)$，我们可以从最低位开始 DP 就好了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">LL inv2 = (M + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas, p;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas &gt;&gt; p;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		LL n, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		m = <span class="built_in">std</span>::<span class="built_in">min</span>(m, n);</span><br><span class="line">		LL r = (<span class="number">2</span> * n + <span class="number">2</span> - m) % M * ((m + <span class="number">1</span>) % M) % M * inv2 % M;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; an, bm;</span><br><span class="line">		<span class="keyword">auto</span> digit = [&amp;]() &#123;</span><br><span class="line">			<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (n) &#123;</span><br><span class="line">				an.emplace_back(n % p);</span><br><span class="line">				bm.emplace_back(m % p);</span><br><span class="line">				n /= p;</span><br><span class="line">				m /= p;</span><br><span class="line">				++r;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> d = digit();</span><br><span class="line">		<span class="comment">// dp[i][sa][sb]; sa, sb 分别表示 $a, b$ 第 $i$ 为是否有限制</span></span><br><span class="line">		LL dp[d + <span class="number">1</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) dp[<span class="number">0</span>][i / <span class="number">2</span>][i % <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i) &#123;</span><br><span class="line">			dp[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = (p + <span class="number">1</span>) * p / <span class="number">2</span> * dp[i][<span class="number">0</span>][<span class="number">0</span>] % M;</span><br><span class="line">			dp[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] = ((<span class="number">2</span> * p - bm[i] + <span class="number">1</span>) * bm[i] / <span class="number">2</span> * dp[i][<span class="number">0</span>][<span class="number">0</span>] + (p - bm[i]) * dp[i][<span class="number">0</span>][<span class="number">1</span>]) % M;</span><br><span class="line">			dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = ((an[i] + <span class="number">1</span>) * an[i] / <span class="number">2</span> * dp[i][<span class="number">0</span>][<span class="number">0</span>] + (an[i] + <span class="number">1</span>) * dp[i][<span class="number">1</span>][<span class="number">0</span>]) % M;</span><br><span class="line">			dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (an[i] &gt;= bm[i]) dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] += (an[i] - bm[i]) * dp[i][<span class="number">0</span>][<span class="number">1</span>] + dp[i][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] += dp[i][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">			bm[i] = <span class="built_in">std</span>::<span class="built_in">min</span>(bm[i], an[i]);</span><br><span class="line">			(dp[i + <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] += (<span class="number">2</span> * an[i] + <span class="number">1</span> - bm[i]) * bm[i] / <span class="number">2</span> * dp[i][<span class="number">0</span>][<span class="number">0</span>] + bm[i] * dp[i][<span class="number">1</span>][<span class="number">0</span>]) %= M;</span><br><span class="line">		&#125;</span><br><span class="line">		r = (r + M - dp[d][<span class="number">1</span>][<span class="number">1</span>]) % M;</span><br><span class="line">		<span class="built_in">print</span>(r); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清华集训-2016-求和"><a href="#清华集训-2016-求和" class="headerlink" title="清华集训 2016 求和"></a><a href="https://uoj.ac/problem/269" target="_blank" rel="noopener">清华集训 2016 求和</a></h3><p>$f$ 是一个次数不超过 $m$ 的多项式，满足 $f(i) = a_i, i = 0, \cdots, m$，求</p>
<script type="math/tex; mode=display">
\sum_{k = 0}^n f(k) {n \choose k} x^k (1 - x)^{n-k} \mod 998244353</script><p>给定 $n, m, x$ 和 $a_0, \cdots, a_m$，其中 $1 \leq n \leq 10^9, 1 \leq m  \leq 2 \cdot 10^4, 0 \leq a_i, x \leq 998244353$</p>
<blockquote>
<p>做法：利用二项式反演，记 $f(k) = \sum_{i = 0}^k {k \choose i} f_i$，则 $f_k = \sum_{i = 0}^k {k \choose i} (-1)^{k-i} f(i)$ 注意到 $f(x)$ 是次数不超过 $m$ 的多项式，所以 $f_{m + 1} = f_{m + 2} = \cdots = 0$</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{k = 0}^n f(k) {n \choose k} x^k (1 - x)^{n-k} 
&= \sum_{k = 0}^n \sum_{i = 0}^k {n \choose k} {k \choose i} f_i x^k (1 - x)^{n-k} \\
&= \sum_{i = 0}^n \sum_{k = i}^n {n \choose i}  {n - i \choose k - i} f_i x^k (1 - x)^{n-k} \\
&= \sum_{i = 0}^n f_i {n \choose i}  x^i (1 - x)^ {n - i} \sum_{k - i = 0}^{n - i} {n - i \choose k - i} x^{k - i} (1 - x)^{i - k} \\
&= \sum_{i = 0}^n f_i {n \choose i}  x^i (1 - x)^ {n - i} (1 + \frac{x}{1-x})^{n - i} \\
&= \sum_{i = 0}^n f_i {n \choose i}  x^i
\end{aligned}\</script><p>上述式子最后一项，只有 $m + 1$ 项，$f_0, \cdots, f_m$ 可以由 NFT 计算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> LL ROOT = <span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">LL fac[N], ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">	ifac[N - <span class="number">1</span>] = powMod(fac[N - <span class="number">1</span>], M - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; --i) ifac[i - <span class="number">1</span>] = ifac[i] * i % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; j) <span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = a.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			(j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a, <span class="keyword">bool</span> isInverse = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">	LL g = powMod(ROOT, (M - <span class="number">1</span>) / a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span> (isInverse) &#123;</span><br><span class="line">		g = powMod(g, M - <span class="number">2</span>);</span><br><span class="line">		LL invLen = powMod(LL(a.<span class="built_in">size</span>()), M - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) x = x * invLen % M;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(a);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != w.<span class="built_in">size</span>(); ++i) w[i] = w[i - <span class="number">1</span>] * g % M;</span><br><span class="line">	<span class="keyword">auto</span> addMod = [](LL x, LL y) &#123;</span><br><span class="line">		<span class="keyword">return</span> (x += y) &gt;= M ? x -= M : x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">2</span>, half = <span class="number">1</span>; half != a.<span class="built_in">size</span>(); <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>, half &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, wstep = a.<span class="built_in">size</span>() / <span class="built_in">step</span>; i != a.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j != i + half; ++j) &#123;</span><br><span class="line">				LL t = (a[j + half] * w[wstep * (j - i)]) % M;</span><br><span class="line">				a[j + half] = addMod(a[j], M - t);</span><br><span class="line">				a[j] = addMod(a[j], t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&amp; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (sz &lt; tot) sz *= <span class="number">2</span>;</span><br><span class="line">	a.resize(sz);</span><br><span class="line">	b.resize(sz);</span><br><span class="line">	nft(a);</span><br><span class="line">	nft(b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != sz; ++i) a[i] = a[i] * b[i] % M;</span><br><span class="line">	nft(a, <span class="number">1</span>);</span><br><span class="line">	a.resize(tot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">int</span> m, n, x;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">	std::vector&lt;LL&gt; a(m + 1), b(m + 1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		a[i] = ifac[i] * a[i] % M;</span><br><span class="line">		b[i] = (i % <span class="number">2</span> == <span class="number">0</span>) ? ifac[i] : M - ifac[i];</span><br><span class="line">	&#125;</span><br><span class="line">	mul(a, b);</span><br><span class="line">	a.resize(m + <span class="number">1</span>);</span><br><span class="line">	LL r = <span class="number">0</span>, Anx = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		r += Anx * a[i] % M;</span><br><span class="line">		Anx = Anx * (n - i) % M * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(r % M);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZOJ-3820：树的重心-直径"><a href="#ZOJ-3820：树的重心-直径" class="headerlink" title="ZOJ 3820：树的重心 + 直径"></a><a href="https://vjudge.net/problem/ZOJ-3820" target="_blank" rel="noopener">ZOJ 3820</a>：树的重心 + 直径</h3><p>题意：在一棵树上选择两个点，使得任意点到这两点的最小值的最大值最小。</p>
<blockquote>
<p>如果仅仅选择一个点，那么这个问题就是树的重心。</p>
<p>对此情况，将直径按照中点切开，然后分别求两颗子树的中心, <a href="https://blog.csdn.net/ok_again/article/details/40043197" target="_blank" rel="noopener">参考资料</a></p>
</blockquote>
<p>证明：如果 u,v 是满足条件的两个点，那么把他们沿着中间切开必然最优，然后反证它们在树的直径上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			--u; --v;</span><br><span class="line">			e[u].emplace_back(v);</span><br><span class="line">			e[v].emplace_back(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">auto</span> bfs = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">			d[x] = <span class="number">0</span>;</span><br><span class="line">			Q.push(x);</span><br><span class="line">			<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">				<span class="keyword">int</span> u = Q.front();</span><br><span class="line">				Q.pop();</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (d[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">					d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">std</span>::max_element(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>()) - d.<span class="built_in">begin</span>();</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> v) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">			a.emplace_back(v);</span><br><span class="line">			<span class="keyword">while</span> (d[a.back()]) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> v: e[a.back()]) <span class="keyword">if</span> (d[v] + <span class="number">1</span> == d[a.back()]) &#123;</span><br><span class="line">					a.emplace_back(v);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> mid = a.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">std</span>::make_pair(a[mid - <span class="number">1</span>], a[mid]);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> [u, v] = f(bfs(bfs(<span class="number">0</span>)));</span><br><span class="line">		e[u].erase(<span class="built_in">std</span>::<span class="built_in">find</span>(e[u].<span class="built_in">begin</span>(), e[u].<span class="built_in">end</span>(), v));</span><br><span class="line">		e[v].erase(<span class="built_in">std</span>::<span class="built_in">find</span>(e[v].<span class="built_in">begin</span>(), e[v].<span class="built_in">end</span>(), u));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> ru = bfs(bfs(u)), ansu = (d[ru] + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">auto</span> ra = f(ru).second;</span><br><span class="line">		<span class="keyword">int</span> rv = bfs(bfs(v)), ansv = (d[rv] + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">auto</span> rb = f(rv).second;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">max</span>(ansu, ansv) &lt;&lt; <span class="string">" "</span> &lt;&lt; ru + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; rv + <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1422D：堆优化-Dijkstra-复杂度-O-n-log-E"><a href="#1422D：堆优化-Dijkstra-复杂度-O-n-log-E" class="headerlink" title="1422D：堆优化 Dijkstra 复杂度 $O(n \log E)$"></a><a href="https://codeforces.com/contest/1422/problem/D" target="_blank" rel="noopener">1422D</a>：堆优化 Dijkstra 复杂度 $O(n \log E)$</h3><blockquote>
<p>这里的边数 E 针对本问题可以大大优化，代码可参考 <a href="https://codeforces.com/contest/1422/submission/94679999" target="_blank" rel="noopener">Jiangly 的代码</a></p>
</blockquote>
<h3 id="1422C"><a href="#1422C" class="headerlink" title="1422C"></a><a href="https://codeforces.com/contest/1422/problem/C" target="_blank" rel="noopener">1422C</a></h3><blockquote>
<p>一开始读题读错了，少看了一个连续导致浪费了很多时间（30 分钟）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> a;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	LL r = <span class="number">0</span>, n = <span class="number">0</span>, id = <span class="number">1</span>, r2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">		r = (r * <span class="number">10</span> + id * (id - <span class="number">1</span>) / <span class="number">2</span> * (x - <span class="string">'0'</span>) + r2) % M;</span><br><span class="line">		n = (n * <span class="number">10</span> + (x - <span class="string">'0'</span>)) % M;</span><br><span class="line">		r2 += n;</span><br><span class="line">		++id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Atcoder-ARC-104D"><a href="#Atcoder-ARC-104D" class="headerlink" title="Atcoder ARC 104D"></a><a href="https://atcoder.jp/contests/arc104/tasks/arc104_d" target="_blank" rel="noopener">Atcoder ARC 104D</a></h3><blockquote>
<p>E, F 题也是好题，不过不懂。</p>
</blockquote>
<p>问题描述：对每一个 $m \in [1, n]$ 求满足 $\sum_{x \in S} (x - m) = 0$ 的集合 $S$ 的个数，其中 “集合” $S$ 是由 <code>1~n</code> 中元素构成，元素可重，重数不超过 k。这等价于说 $\sum_{x \in S} x = \sum_{x \in T} x$ 的个数乘以 $k + 1$，其中 $S$ 是由 <code>1 ~ m - 1</code> 构成，$T$ 由 <code>1 ~ n - m</code> 构成。</p>
<p>做法：我们设 <code>dp[i][j] 表示仅用 1 ~ i 中的数构成和为 j 的个数</code>，那么显然</p>
<script type="math/tex; mode=display">
dp[i][j] = \sum_{t = 0}^k dp[i - 1][j - t * i]</script><p>于是我们保存一下前缀和，那么就可以优化计算了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	LL M;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; M;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">	dp[<span class="number">0</span>].emplace_back(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> mx = (i + <span class="number">1</span>) * i / <span class="number">2</span> * k;</span><br><span class="line">		dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">		dp[i].resize(mx + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= mx; ++j) dp[i][j] += dp[i][j - i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = mx; j &gt;= (k + <span class="number">1</span>) * i; --j) dp[i][j] -= dp[i][j - (k + <span class="number">1</span>) * i] %= M;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : dp[i]) x %= M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++x) &#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> tx = <span class="built_in">std</span>::<span class="built_in">min</span>(x - <span class="number">1</span>, n - x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = (tx + <span class="number">1</span>) * tx / <span class="number">2</span> * k; j &gt;= <span class="number">0</span>; --j) r += dp[x - <span class="number">1</span>][j] * dp[n - x][j] % M;</span><br><span class="line">		r = (r * (k + <span class="number">1</span>) % M + M - <span class="number">1</span>) % M;</span><br><span class="line">		<span class="built_in">print</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1408D：二维处理问题，经典重要问题"><a href="#1408D：二维处理问题，经典重要问题" class="headerlink" title="1408D：二维处理问题，经典重要问题"></a><a href="https://codeforces.com/contest/1408/problem/D" target="_blank" rel="noopener">1408D</a>：二维处理问题，经典重要问题</h3><blockquote>
<p>一开始没有看数据范围觉得没法过，就没想这个问题，然后狮子大张口想做最后一题…</p>
</blockquote>
<p>此问题可以转换成经典问题：二维平面，第一象限的 $n$ 个点，每次只能同时向左或者向下移动一个单位，问最少需要多少步，让所有的点都不在第一象限。<br>首先先对一个坐标（例如横坐标）进行从小到大排序，然后最终结果就是 第 i 个点的横坐标加上后面所有点的纵坐标的最大值，这 n + 1 个结果中最小的一个！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	std::vector&lt;std::pair&lt;int, int&gt;&gt; a(n), b(m), t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y] : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y] : b) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i].first &lt;= b[j].first &amp;&amp; a[i].second &lt;= b[j].second) &#123;</span><br><span class="line">				t.push_back(&#123;b[j].first - a[i].first + <span class="number">1</span>, b[j].second - a[i].second + <span class="number">1</span>&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::sort(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mx</span><span class="params">(t.<span class="built_in">size</span>() + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = t.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; --i) &#123;</span><br><span class="line">		mx[i] = <span class="built_in">std</span>::<span class="built_in">max</span>(mx[i + <span class="number">1</span>], t[i].second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = mx[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		ans = <span class="built_in">std</span>::<span class="built_in">min</span>(ans, mx[i + <span class="number">1</span>] + t[i].first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1408F：脑筋急转弯问题"><a href="#1408F：脑筋急转弯问题" class="headerlink" title="1408F：脑筋急转弯问题"></a><a href="https://codeforces.com/contest/1408/problem/F" target="_blank" rel="noopener">1408F</a>：脑筋急转弯问题</h3><p>读完题目我就知道对于 $n$ 为 2 的幂次时，可以让所有元素一致，但是后面怎么就没有想到前后各搞一次呢？我在干什么！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; r;</span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> len) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">1</span>; <span class="built_in">step</span> &lt; len; <span class="built_in">step</span> *= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="built_in">step</span> * <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">step</span>; ++j) &#123;</span><br><span class="line">					r.push_back(&#123;i + j + x, i + j + x + <span class="built_in">step</span>&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="built_in">std</span>::__lg(n);</span><br><span class="line">	f(<span class="number">1</span>, <span class="number">1</span> &lt;&lt; k);</span><br><span class="line">	f(n + <span class="number">1</span> - (<span class="number">1</span> &lt;&lt; k), <span class="number">1</span> &lt;&lt; k);</span><br><span class="line">	<span class="built_in">print</span>(r.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : r) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1408I"><a href="#1408I" class="headerlink" title="1408I"></a><a href="https://codeforces.com/contest/1408/problem/I" target="_blank" rel="noopener">1408I</a></h3><blockquote>
<p>本题解基于 Soulist 的题解和 Jiangly 的代码，写这个的原因是这个题我是非常想搞清楚，然后只有转化成自己的语言才能弄清楚，所以想写下来，从而说明是真的理解了。</p>
</blockquote>
<p>题意：给定 $n$ 个数 ($a_1, a_2, \cdots, a_n$)，（序列元素互异，但是这个条件没啥用吧）每次操作为等概率的选择其中一个数，然后将其减一，问经过 $k$ 次操作之后这 $n$ 个数的异或和 为 $x = 0, 1, \cdots, 2^c - 1$ 的概率。</p>
<p>其中， $k, c \leq 16, a_i \in [k, 2^c)$，最后答案是分数，在模 998244353 的意义下就是个整数啦。</p>
<ul>
<li>令 $sa = a_1 \oplus a_2 \cdots \oplus a_n$，然后考虑答案在 $t$ 上的改变量。</li>
<li>令 $d_{i,j} = a_i \oplus (a_i - j)$，$\displaystyle F(x, y) = \prod_{i = 1}^n \left( \sum_{j = 0}^k \frac{x^{d_{i,j}}}{j!} y^j \right)$ 那么我们的答案就是 $F(x,y)[y^k] \cdot k!$，其中 $x$ 上是异或卷积，$y$ 上的是普通卷积。</li>
</ul>
<p>那么我们现在主要问题就变成如何就 $F(x,y)[y^k] \cdot k!$ 了。由于 $x$ 上的系数加法是异或加法，所以我们需要用 <a href="https://oi-wiki.org/math/poly/fwt/" target="_blank" rel="noopener">异或的 fwt</a> 将它转化成普通乘法。</p>
<ul>
<li>$x$ 上的系数可以本质是下标！下标对应的值是关于$y$的多项式，首先注意到做 fwt 仅仅是将 $x$ 上的系数做了改变，并没有改变其它内容。这样做是为了把卷积异或乘法改成普通卷积乘法。这里做 fwt 的时候可以暴力搞。</li>
<li>优化 1：仅有 $O(ck)$ 中 $k$ 元组</li>
<li>每个 $k$ 元组对应的下标对应 fwt 之后的编号只有 $2^k$ 种！</li>
<li>多项式乘法可以用 <code>ln/exp</code> 来运算</li>
</ul>
<p>soulist 写了<a href="https://www.cnblogs.com/Soulist/p/13758388.html" target="_blank" rel="noopener">题解</a><br>以下是 <a href="https://codeforces.com/contest/1408/submission/94346776" target="_blank" rel="noopener">jiangly 大佬的代码</a> 的注释版。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code by jiangly</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b &gt; <span class="number">0</span>; b /= <span class="number">2</span>, a = <span class="number">1l</span>l * a * a % P)</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">1</span>) res = <span class="number">1l</span>l * res * a % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, k, c;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; c;</span><br><span class="line">    std::vector&lt;int&gt; fac(k + 1), invFac(k + 1), inv(k + 1);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) invFac[i] = power(fac[i], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) inv[i] = power(i, P - <span class="number">2</span>);</span><br><span class="line">	<span class="comment">// 预处理出所有元素异或和，以及每一种序列的个数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">int</span> xsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        xsum ^= a;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(k + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) d[j] = a ^ (a - j);</span><br><span class="line">        ++cnt[d];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// cntm 就是暴力做 fwt 后的每种序列的个数</span></span><br><span class="line">	<span class="comment">// f 就是做完 fwt 后得到式子乘积。</span></span><br><span class="line">    std::vector&lt;int&gt; f(1 &lt;&lt; c), cntm(1 &lt;&lt; k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; (<span class="number">1</span> &lt;&lt; c); ++x) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [d, t] : cnt) &#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="keyword">if</span> (__builtin_parity(x &amp; d[i])) mask |= <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (cntm[mask] == <span class="number">0</span>) e.push_back(mask);</span><br><span class="line">            cntm[mask] += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">g</span><span class="params">(k + <span class="number">1</span>)</span></span>;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> mask : e) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(k + <span class="number">1</span>)</span></span>;</span><br><span class="line">            a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask &gt;&gt; (i - <span class="number">1</span>) &amp; <span class="number">1</span>) a[i] = P - invFac[i];</span><br><span class="line">                <span class="keyword">else</span> a[i] = invFac[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pw</span><span class="params">(k + <span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">int</span> t = cntm[mask];</span><br><span class="line">            pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// 取对数, 再做加法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) res = (res + <span class="number">1l</span>l * pw[j] * a[i - j] % P * (i - j)) % P;</span><br><span class="line">                res = <span class="number">1l</span>l * res * t % P;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) res = (res + <span class="number">1l</span>l * (P - a[j]) * pw[i - j] % P * (i - j)) % P;</span><br><span class="line">                pw[i] = <span class="number">1l</span>l * res * inv[i] % P;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 加起来取指数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) res = (res + <span class="number">1l</span>l * pw[j] * g[i - j]) % P;</span><br><span class="line">                g[i] = res;</span><br><span class="line">            &#125;</span><br><span class="line">            cntm[mask] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[x] = <span class="number">1l</span>l * g[k] * fac[k] % P;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ifwt 得到最后的答案，注意到这里没有除以 2，是因为它最后整体除了 2^c。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; c); i *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; c); j += <span class="number">2</span> * i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = f[j + k], v = f[i + j + k];</span><br><span class="line">                f[j + k] = (u + v) % P;</span><br><span class="line">                f[i + j + k] = (u - v + P) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> invn = <span class="number">1l</span>l * power(<span class="number">1</span> &lt;&lt; c, P - <span class="number">2</span>) * power(n, P - <span class="number">1</span> - k) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; c); ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1l</span>l * f[i ^ xsum] * invn % P &lt;&lt; <span class="string">" \n"</span>[i == (<span class="number">1</span> &lt;&lt; c) - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="453B：状态压缩-DP"><a href="#453B：状态压缩-DP" class="headerlink" title="453B：状态压缩 DP"></a><a href="https://codeforces.com/contest/453/problem/B" target="_blank" rel="noopener">453B</a>：状态压缩 DP</h3><p>给定数列 $a$，求满足元素两两互素的数列 $b$ 使得 $\sum |a_i - b_i|$ 最小</p>
<blockquote>
<p>注意到 $b_i &lt; 2 a_i$，因为否则取 $b_i = 1$ 即可。</p>
</blockquote>
<p>由于 $60$ 内的素数个数为 17, 因此可以状态压缩 DP。设 <code>dp[i][j]</code> 表示使得 $\sum_{k = 1} ^ i |a_k - b_k|$ 最小，且$b_1 \cdots b_i$ 中所有出现的素因子的状态为 $j$。因此状态转移就是 <code>dp[i][j | factor[k]] = min(dp[i - 1][j] + |a_i - k|)</code>，其中 <code>factor[k]</code> 与 $j$ 没有交集。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">int</span> ma = *<span class="built_in">std</span>::max_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) * <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; ma; ++i) &#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i; ++j) <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) p.emplace_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">factor</span><span class="params">(ma)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; ma; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.<span class="built_in">size</span>(); ++j) <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">			factor[i] |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; p.<span class="built_in">size</span>(), <span class="number">1e9</span>))</span></span>;</span><br><span class="line">	ans[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * a[i - <span class="number">1</span>]; ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; p.<span class="built_in">size</span>()); ++k) <span class="keyword">if</span> ((k &amp; factor[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">				ans[i][k | factor[j]] = <span class="built_in">std</span>::<span class="built_in">min</span>(ans[i][k | factor[j]], ans[i - <span class="number">1</span>][k] + <span class="built_in">abs</span>(a[i - <span class="number">1</span>] - j));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="built_in">std</span>::min_element(ans[n].<span class="built_in">begin</span>(), ans[n].<span class="built_in">end</span>()) - ans[n].<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * a[i]; ++j) <span class="keyword">if</span> ((now | factor[j]) == now) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ans[i][now ^ factor[j]] + <span class="built_in">abs</span>(a[i] - j) == ans[i + <span class="number">1</span>][now]) &#123;</span><br><span class="line">				r[i] = j;</span><br><span class="line">				now ^= factor[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : r) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">println</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="662C：状态压缩-DP-FWT-模板"><a href="#662C：状态压缩-DP-FWT-模板" class="headerlink" title="662C：状态压缩 DP + FWT 模板"></a><a href="https://codeforces.com/contest/662/problem/C" target="_blank" rel="noopener">662C</a>：状态压缩 DP + FWT 模板</h3><p>给定 $n \times m$ 的 0-1 方阵，可以取反一些行和列使得最后 0 的数列最小。</p>
<blockquote>
<p>首先注意到 $n &lt; 20$，我们可以把每一列看作一个状态 <code>i</code> ，并且结果跟列的顺序无关。我们可以记录下初始情况每种状态数 C[i] 量。<br>并且每一种状态 <code>i</code> 对答案的贡献显然就是它的 0, 1 个数的最小值记作 <code>g[i]</code>。<br>对于每一个行取反 S, 其实就是将一个状态 i 变成 状态 <code>i ^ S</code><br>所以每一种行取反 S，最终的答案 $\displaystyle F(S) = \sum_{i} C[i] \cdot g[i \wedge S] = \sum_{i \wedge j = S} C[i] \cdot g[j]$ </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x += y) &gt;= P &amp;&amp; (x -= P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FWT</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; N &lt; n; N &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j + m], a[i + j]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j + m], a[i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j], a[i + j + m]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j], a[i + j + m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTxor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), inv2 = (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = a[i + j + m];</span><br><span class="line">                <span class="keyword">if</span> (!rev) &#123;</span><br><span class="line">                    a[i + j] = (x + y) % P;</span><br><span class="line">                    a[i + j + m] = (x - y + P) % P;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[i + j] = <span class="number">1L</span>L * (x + y) * inv2 % P;</span><br><span class="line">                    a[i + j + m] = <span class="number">1L</span>L * (x - y + P) * inv2 % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Or</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">And</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTand(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTand(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTand(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Xor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTxor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTxor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTxor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; fwt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	std::vector&lt;int&gt; c(1 &lt;&lt; n), g(1 &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			r |= (a[j][i] - <span class="string">'0'</span>) &lt;&lt; j;</span><br><span class="line">		&#125;</span><br><span class="line">		++c[r];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j &amp; (<span class="number">1</span> &lt;&lt; i)) ++g[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) &#123;</span><br><span class="line">		g[i] = <span class="built_in">std</span>::<span class="built_in">min</span>(g[i], n - g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> f = fwt.Xor(c, g);</span><br><span class="line">	<span class="built_in">print</span>(*<span class="built_in">std</span>::min_element(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>()));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1417E：异或问题和逆序数"><a href="#1417E：异或问题和逆序数" class="headerlink" title="1417E：异或问题和逆序数"></a><a href="https://codeforces.com/contest/1417/problem/E" target="_blank" rel="noopener">1417E</a>：异或问题和逆序数</h3><blockquote>
<p>注意到两个数比较大小只和它最高位数字有关，如果改变第 $i$ 位，那么第 $i$ 位后面的数就可以不考虑。<br>可以参考 <a href="https://codeforces.com/contest/1416/submission/93985644" target="_blank" rel="noopener">jiangly 的代码</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">	LL cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; <span class="number">31</span>; ++d) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(),[&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">			<span class="keyword">return</span> (a[i] &gt;&gt; d) &lt; (a[j] &gt;&gt; d) || ((a[i] &gt;&gt; d) == (a[j] &gt;&gt; d) &amp;&amp; i &lt; j);</span><br><span class="line">		&#125;);</span><br><span class="line">		LL c0 = <span class="number">0</span>, c1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i = j) &#123;</span><br><span class="line">			<span class="keyword">int</span> x0 = <span class="number">0</span>, x1 = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; n &amp;&amp; (a[p[i]] &gt;&gt; d) == (a[p[j]] &gt;&gt; d)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[p[j]] &gt;&gt; (d - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">					++x1;</span><br><span class="line">					c0 += x0;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					++x0;</span><br><span class="line">					c1 += x1;</span><br><span class="line">				&#125;</span><br><span class="line">				++j;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c0 &lt; c1) &#123;</span><br><span class="line">			cnt += c0;</span><br><span class="line">			r |= (<span class="number">1</span> &lt;&lt; d - <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> cnt += c1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">" "</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述过程也提供了一种求逆序数的方法，就是注意到任意两个数，他们总会在某一个最高位是一致的。</p>
</blockquote>
<h3 id="AtCoder-ACL2f-包容排斥原理-NFT"><a href="#AtCoder-ACL2f-包容排斥原理-NFT" class="headerlink" title="AtCoder ACL2f: 包容排斥原理 + NFT"></a><a href="https://atcoder.jp/contests/abl/tasks/abl_f" target="_blank" rel="noopener">AtCoder ACL2f</a>: 包容排斥原理 + NFT</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>, ROOT = <span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; j) <span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = a.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			(j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a, <span class="keyword">bool</span> isInverse = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">	LL g = powMod(ROOT, (M - <span class="number">1</span>) / a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span> (isInverse) &#123;</span><br><span class="line">		g = powMod(g, M - <span class="number">2</span>);</span><br><span class="line">		LL invLen = powMod(LL(a.<span class="built_in">size</span>()), M - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) x = x * invLen % M;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(a);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != w.<span class="built_in">size</span>(); ++i) w[i] = w[i - <span class="number">1</span>] * g % M;</span><br><span class="line">	<span class="keyword">auto</span> addMod = [](LL x, LL y) &#123;</span><br><span class="line">		<span class="keyword">return</span> (x += y) &gt;= M ? x -= M : x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">2</span>, half = <span class="number">1</span>; half != a.<span class="built_in">size</span>(); <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>, half &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, wstep = a.<span class="built_in">size</span>() / <span class="built_in">step</span>; i != a.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j != i + half; ++j) &#123;</span><br><span class="line">				LL t = (a[j + half] * w[wstep * (j - i)]) % M;</span><br><span class="line">				a[j + half] = addMod(a[j], M - t);</span><br><span class="line">				a[j] = addMod(a[j], t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&amp; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (sz &lt; tot) sz *= <span class="number">2</span>;</span><br><span class="line">	a.resize(sz);</span><br><span class="line">	b.resize(sz);</span><br><span class="line">	nft(a);</span><br><span class="line">	nft(b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != sz; ++i) a[i] = a[i] * b[i] % M;</span><br><span class="line">	nft(a, <span class="number">1</span>);</span><br><span class="line">	a.resize(tot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">2</span>;</span><br><span class="line">LL fac[N], ifac[N];</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span></span>&#123; <span class="comment">// 0 &lt; a &lt; p and gcd(a,p) = 1</span></span><br><span class="line">	<span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (M - M / a) * inv(M % a) % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">	ifac[N - <span class="number">1</span>] = inv(fac[N - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; --i) ifac[i - <span class="number">1</span>] = ifac[i] * i % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> fac[n] * ifac[k] % M * ifac[n - k] % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">1e5</span> + <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		++cnt[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	LL inv2 = (M + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">std</span>::sort(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">auto</span> start = <span class="built_in">std</span>::lower_bound(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(), <span class="number">1</span>) - cnt.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">	q.push_back(&#123;cnt[start], <span class="number">1</span>&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; cnt.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt[i] != q.back().first) q.push_back(&#123;cnt[i], <span class="number">1</span>&#125;);</span><br><span class="line">		<span class="keyword">else</span> ++q.back().second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> [x, xn] : q) <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">a</span><span class="params">(x / <span class="number">2</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line">		LL p2j = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= x / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">			a[j] = fac[x] * ifac[x - <span class="number">2</span> * j] % M * ifac[j] % M * p2j % M;</span><br><span class="line">			p2j = p2j * inv2 % M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (xn) &#123;</span><br><span class="line">			<span class="keyword">if</span> (xn &amp; <span class="number">1</span>) mul(r, a);</span><br><span class="line">			xn &gt;&gt;= <span class="number">1</span>; mul(a, a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">G</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) G[i] = G[i - <span class="number">1</span>] * (<span class="number">2</span> * i - <span class="number">1</span>) % M;</span><br><span class="line">	LL ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.<span class="built_in">size</span>() &amp;&amp; i &lt;= n; ++i) &#123;</span><br><span class="line">		ret += (i % <span class="number">2</span> == <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>) * G[n - i] * r[i] % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>((ret % M + M) % M);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtCoder-ACL2e：线段树模板题"><a href="#AtCoder-ACL2e：线段树模板题" class="headerlink" title="AtCoder ACL2e：线段树模板题"></a><a href="https://atcoder.jp/contests/abl/tasks/abl_e" target="_blank" rel="noopener">AtCoder ACL2e</a>：线段树模板题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, lrt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rrt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = N * <span class="number">3.2</span>;</span><br><span class="line">LL sum[NN], s10[N];</span><br><span class="line"><span class="keyword">int</span> col[NN];</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	sum[rt] = sum[lrt] + sum[rrt];</span><br><span class="line">	<span class="keyword">if</span> (sum[rt] &gt;= M) sum[rt] -= M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (col[rt] != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		col[lrt] = col[rrt] = col[rt];</span><br><span class="line">		col[rt] = <span class="number">-1</span>;</span><br><span class="line">		sum[lrt] = (s10[m] - s10[l - <span class="number">1</span>] + M) * col[lrt] % M;</span><br><span class="line">		sum[rrt] = (s10[r] - s10[m] + M) * col[rrt] % M;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		sum[rt] = s10[r] - s10[l - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (sum[rt] &lt; <span class="number">0</span>) sum[rt] += M;</span><br><span class="line">		col[rt] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	col[rt] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(lson);</span><br><span class="line">	build(rson);</span><br><span class="line">	pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;</span><br><span class="line">		sum[rt] = (s10[r] - s10[l - <span class="number">1</span>] + M) * p % M;</span><br><span class="line">		col[rt] = p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pushDown(l, r, rt);</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= m) update(L, R, p, lson);</span><br><span class="line">	<span class="keyword">if</span> (R &gt; m) update(L, R, p, rson);</span><br><span class="line">	pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	s10[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	LL now = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		s10[i] = now;</span><br><span class="line">		now = now * <span class="number">10</span> % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		s10[i] += s10[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (s10[i] &gt;= M) s10[i] -= M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n, q;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r, d;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span><br><span class="line">		update(n - r + <span class="number">1</span>, n - l + <span class="number">1</span>, d, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">print</span>(sum[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtCoder-ABC178e：Manhattan-距离"><a href="#AtCoder-ABC178e：Manhattan-距离" class="headerlink" title="AtCoder ABC178e：Manhattan 距离"></a><a href="https://atcoder.jp/contests/abc178/tasks/abc178_e" target="_blank" rel="noopener">AtCoder ABC178e</a>：Manhattan 距离</h3><p>给定一堆点，求它们的 Manhattan 距离中最大值</p>
<blockquote>
<p>注意到其实任意两点的距离等于，它们到最左上角和到最下角的距离的距离差的最大值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span>  LL M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> x[n], y[n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> xx[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, yy[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="keyword">int</span>(<span class="number">1e9</span>)&#125;;</span><br><span class="line">	<span class="keyword">int</span> t[<span class="number">2</span>][n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> id = <span class="number">0</span> ; id &lt; <span class="number">2</span>; ++id) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			t[id][i] = <span class="built_in">abs</span>(x[i] - xx[id]) + <span class="built_in">abs</span>(y[i] - yy[id]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> r0 = *<span class="built_in">std</span>::max_element(t[<span class="number">0</span>], t[<span class="number">0</span>] + n) - *<span class="built_in">std</span>::min_element(t[<span class="number">0</span>], t[<span class="number">0</span>] + n);</span><br><span class="line">	<span class="keyword">int</span> r1 = *<span class="built_in">std</span>::max_element(t[<span class="number">1</span>], t[<span class="number">1</span>] + n) - *<span class="built_in">std</span>::min_element(t[<span class="number">1</span>], t[<span class="number">1</span>] + n);</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">std</span>::<span class="built_in">max</span>(r0, r1));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1406D：经典数学题"><a href="#1406D：经典数学题" class="headerlink" title="1406D：经典数学题"></a><a href="https://codeforces.com/contest/1406/problem/D" target="_blank" rel="noopener">1406D</a>：经典数学题</h3><p>给定数列 $a$, 求单调递增数列 $b$ 和单调递减数列 $c$，使得 $a_i = b_i + c_i$，并且使得 $b, c$ 中的最大值最小（即 $\max(b_n, c_1)$ 最小。</p>
<p>如果 $a_i &lt; a_{i+1}$ 令 $b_{i +1} = b_i + a_{i + 1} - a_i$，否则 $c_{i + 1} = c_i + a_{i + 1} - a_i$。<br>设 $c_1 = x$，$b_ 1 = a - x$，容易看出 $b_n = \sum_{i = 2}^n \max{0, a_{i} - a_{i-1}}$。并且每次更新只和 $l, r$ 节点有关。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">floor</span><span class="params">(LL a, LL n)</span> </span>&#123; <span class="comment">// n &gt; 0</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; <span class="number">0</span> ? (a - n + <span class="number">1</span>) / n : a / n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	LL a[n], ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i) a[i] -= a[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) ret += <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0L</span>L, a[i]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">floor</span>(a[<span class="number">0</span>] + ret + <span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r, x;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span> (r != n) &#123;</span><br><span class="line">			ret -= <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0L</span>L, a[r]);</span><br><span class="line">			a[r] -= x;</span><br><span class="line">			ret += <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0L</span>L, a[r]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (l != <span class="number">1</span>) ret -= <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0L</span>L, a[l - <span class="number">1</span>]);</span><br><span class="line">		a[l - <span class="number">1</span>] += x;</span><br><span class="line">		<span class="keyword">if</span> (l != <span class="number">1</span>) ret += <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0L</span>L, a[l - <span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">floor</span>(a[<span class="number">0</span>] + ret + <span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1407B：GCD-问题"><a href="#1407B：GCD-问题" class="headerlink" title="1407B：GCD 问题"></a><a href="https://codeforces.com/contest/1407/problem/B" target="_blank" rel="noopener">1407B</a>：GCD 问题</h3><blockquote>
<p>如果数据范围特别大，则需要下面的处理方式，否则其实可以预处理 gcd<br>如果这题 $c_i = \gcd(b_i, b_{i + 1}$ 将会超级难！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">int</span> a[n];</span><br><span class="line">		<span class="keyword">bool</span> v[n] = &#123;&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">int</span> id = <span class="built_in">std</span>::max_element(a, a + n) - a;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">		ans.push_back(a[id]);</span><br><span class="line">		v[id] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> now = a[id];</span><br><span class="line">		<span class="keyword">while</span> (ans.<span class="built_in">size</span>() != n) &#123;</span><br><span class="line">			<span class="keyword">int</span> mx = <span class="number">0</span>, mi = <span class="number">1e9</span> + <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!v[i]) &#123;</span><br><span class="line">				mx = <span class="built_in">std</span>::<span class="built_in">max</span>(mx, <span class="built_in">std</span>::__gcd(now, a[i]));</span><br><span class="line">				mi = <span class="built_in">std</span>::<span class="built_in">max</span>(mi, <span class="built_in">std</span>::__gcd(now, a[i]));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (mx == mi) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!v[i]) &#123;</span><br><span class="line">				<span class="keyword">if</span>(mx == <span class="built_in">std</span>::__gcd(now, a[i])) &#123;</span><br><span class="line">					ans.push_back(a[i]);</span><br><span class="line">					v[i] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			now = mx;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!v[i]) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1407C：第一次过真实的交互问题"><a href="#1407C：第一次过真实的交互问题" class="headerlink" title="1407C：第一次过真实的交互问题"></a><a href="https://codeforces.com/contest/1407/problem/C" target="_blank" rel="noopener">1407C</a>：第一次过真实的交互问题</h3><p>注意到 $(a \mod b )&gt; (b \mod a)$ 当且仅当 $a &lt; b$ （这里 $a, b$ 都是正整数），并且此时 $(a \mod b) = a$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> a[n + <span class="number">1</span>], mi = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, mx1, mx2; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"? "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; mi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; mx1;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"? "</span> &lt;&lt; mi &lt;&lt; <span class="string">" "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; mx2;</span><br><span class="line">		<span class="keyword">if</span> (mx1 &gt; mx2) &#123;</span><br><span class="line">			a[i] = mx1;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			a[mi] = mx2;</span><br><span class="line">			mi = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a[mi] = n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"!"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; a[i];</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1407D：经典问题：单调栈优化-DP"><a href="#1407D：经典问题：单调栈优化-DP" class="headerlink" title="1407D：经典问题：单调栈优化 DP"></a><a href="https://codeforces.com/contest/1407/problem/D" target="_blank" rel="noopener">1407D</a>：经典问题：单调栈优化 DP</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	std::vector&lt;int&gt; h(n), dp(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : h) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; low, high;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		dp[i] = (i == <span class="number">0</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span> (!low.empty() &amp;&amp; h[i] &gt; h[low.top()]) &#123;</span><br><span class="line">			dp[i] = <span class="built_in">std</span>::<span class="built_in">min</span>(dp[i], dp[low.top()] + <span class="number">1</span>);</span><br><span class="line">			low.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!low.empty()) &#123;</span><br><span class="line">			dp[i] = <span class="built_in">std</span>::<span class="built_in">min</span>(dp[i], dp[low.top()] + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (h[i] == h[low.top()]) low.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		low.push(i);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!high.empty() &amp;&amp; h[i] &lt; h[high.top()]) &#123;</span><br><span class="line">			dp[i] = <span class="built_in">std</span>::<span class="built_in">min</span>(dp[i], dp[high.top()] + <span class="number">1</span>);</span><br><span class="line">			high.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!high.empty()) &#123;</span><br><span class="line">			dp[i] = <span class="built_in">std</span>::<span class="built_in">min</span>(dp[i], dp[high.top()] + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (h[i] == h[high.top()]) high.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		high.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dp[n - <span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1405D：树的直径"><a href="#1405D：树的直径" class="headerlink" title="1405D：树的直径"></a><a href="https://codeforces.com/contest/1405/problem/D" target="_blank" rel="noopener">1405D</a>：树的直径</h3><p>$A, B$ 分别在树上某两点，每次移动的距离最大值为 $da, db$，$A$ 先移动。<br>如果 $A$ 有策略在有限步后与 $B$ 在同一点，那么就 $A$ 获胜，否则 $B$ 获胜。</p>
<p>$A$ 胜可以分这三种情况：</p>
<ul>
<li>$A$ 直接能到 $B$</li>
<li>两倍 $da$ 大于或等于 <strong>树的直径</strong></li>
<li>两倍 $da$ 大于或等于 $db$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head, nxt, to;</span><br><span class="line">	LinkStar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		nxt.<span class="built_in">clear</span>();</span><br><span class="line">		to.<span class="built_in">clear</span>();</span><br><span class="line">		head = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		nxt.emplace_back(head[u]);</span><br><span class="line">		head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">		to.emplace_back(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, a, b, da, db;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; da &gt;&gt; db;</span><br><span class="line">		<span class="function">LinkStar <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			A.addedge(u, v);</span><br><span class="line">			A.addedge(v, u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">auto</span> bfs = [&amp;](<span class="keyword">int</span> s) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">			q.push(s);</span><br><span class="line">			d[s] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">				<span class="keyword">int</span> u = q.front();</span><br><span class="line">				q.pop();</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = A.head[u]; ~i; i = A.nxt[i]) &#123;</span><br><span class="line">					<span class="keyword">int</span> v = A.to[i];</span><br><span class="line">					<span class="keyword">if</span> (d[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">						d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">						q.push(v);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">std</span>::max_element(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>()) - d.<span class="built_in">begin</span>();</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> c = bfs(a);</span><br><span class="line">		<span class="keyword">if</span> (db &lt;= <span class="number">2</span> * da || d[b] &lt;= da) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Alice\n"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c = bfs(c);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (d[c] &lt;= <span class="number">2</span> * da ? <span class="string">"Alice"</span> : <span class="string">"Bob"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1405E：高端树状数组"><a href="#1405E：高端树状数组" class="headerlink" title="1405E：高端树状数组"></a><a href="https://codeforces.com/contest/1405/problem/E" target="_blank" rel="noopener">1405E</a>：高端树状数组</h3><blockquote>
<p><a href="https://codeforces.com/blog/entry/82366" target="_blank" rel="noopener">官方题解</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; s;</span><br><span class="line">	TreeArray() &#123;&#125;</span><br><span class="line">	TreeArray(<span class="keyword">int</span> n) &#123; init(n); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		s.resize(n + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">fill</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			s[id] += p;</span><br><span class="line">			id += lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (id) &#123;</span><br><span class="line">			r += s[id];</span><br><span class="line">			id -= lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find maximal index s.t. sum(id) &gt;= x, sum must be decreased</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(LL val, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		LL sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">1</span>] &lt; val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">std</span>::__lg(r); ~i; --i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (id + (<span class="number">1</span> &lt;&lt; i) &lt; r &amp;&amp; sum + s[id + (<span class="number">1</span> &lt;&lt; i)] &gt;= val) &#123;</span><br><span class="line">				id += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">				sum += s[id];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray2</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	TreeArray B, C;</span><br><span class="line">	TreeArray2() &#123;&#125;</span><br><span class="line">	TreeArray2(<span class="keyword">int</span> _n) : n(_n)&#123; </span><br><span class="line">		B.init(n);</span><br><span class="line">		C.init(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		C.add(id, p);</span><br><span class="line">		B.add(id, (id - <span class="number">1</span>) * p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		add(l, p);</span><br><span class="line">		<span class="keyword">if</span> (r + <span class="number">1</span> &lt; n) add(r + <span class="number">1</span>, -p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id * C.sum(id) - B.sum(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, q;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	std::vector&lt;int&gt; a(n + 1), ans(q), left(q);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">right</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		a[i] = i - a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x, y; i &lt; q; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		left[i] = <span class="number">1</span> + x;</span><br><span class="line">		right[n - y].emplace_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">TreeArray2 <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= n; ++r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[r] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> id = A.C.search(a[r], r + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (id &gt; <span class="number">0</span>) A.add(<span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">min</span>(id, r), <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : right[r]) &#123;</span><br><span class="line">			ans[x] = A.sum(left[x]);</span><br><span class="line">			<span class="keyword">if</span> (left[x] &gt; <span class="number">1</span>) ans[x] -= A.sum(left[x] - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1401D：用-dfs-变成有根树，求出每条边的权重，存在第二次到达的节点上，然后给权重高的边赋大值即可"><a href="#1401D：用-dfs-变成有根树，求出每条边的权重，存在第二次到达的节点上，然后给权重高的边赋大值即可" class="headerlink" title="1401D：用 dfs 变成有根树，求出每条边的权重，存在第二次到达的节点上，然后给权重高的边赋大值即可"></a><a href="https://codeforces.com/contest/1401/problem/D" target="_blank" rel="noopener">1401D</a>：用 dfs 变成有根树，求出每条边的权重，存在第二次到达的节点上，然后给权重高的边赋大值即可</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head, nxt, to;</span><br><span class="line">    LinkStar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        nxt.<span class="built_in">clear</span>();</span><br><span class="line">        to.<span class="built_in">clear</span>();</span><br><span class="line">        head = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        nxt.emplace_back(head[u]);</span><br><span class="line">        head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">        to.emplace_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function">LinkStar <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			A.addedge(x, y);</span><br><span class="line">			A.addedge(y, x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> d[n + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">bool</span> vis[n + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			vis[u] = <span class="literal">true</span>;</span><br><span class="line">			d[u] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = A.head[u]; ~i; i = A.nxt[i]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">int</span> v = A.to[i]; !vis[v]) &#123;</span><br><span class="line">					d[u] += dfs(v);</span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> d[u];</span><br><span class="line">		&#125;;</span><br><span class="line">		dfs(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; r;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			r.emplace_back(LL(d[i]) * (n - d[i]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : p) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span> (r.<span class="built_in">size</span>() &gt; p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">tmp</span><span class="params">(r.<span class="built_in">size</span>() - p.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">			p.insert(p.<span class="built_in">end</span>(), tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::sort(r.<span class="built_in">begin</span>(), r.<span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">		LL s = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (r.<span class="built_in">size</span>() &lt; p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			s = s * p.back() % M;</span><br><span class="line">			p.pop_back();	</span><br><span class="line">		&#125;</span><br><span class="line">		p.back() = p.back() * s % M;</span><br><span class="line">		LL ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != r.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			ans += r[i] * p[i] % M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans % M &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1401E"><a href="#1401E" class="headerlink" title="1401E"></a><a href="https://codeforces.com/contest/1401/problem/E" target="_blank" rel="noopener">1401E</a></h3><p>先算左横线段，再算右横线段，左横线段被退出的时候对应位置加 <code>-1</code> 即可，然后根据竖线从左到右依次加入右横线段，剔除左横线段。用树状数组计算一下就可以了。</p>
<blockquote>
<p>注意如果横竖直线有触碰到两端，那么答案对应要 <code>+1</code>。<br>注意到如果数据范围很大（例如 <code>N = 1e9</code>）那么可以压缩一下达到目的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; s;</span><br><span class="line">    TreeArray() &#123;&#125;</span><br><span class="line">    TreeArray(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		s.resize(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            s[id] += p;</span><br><span class="line">            id += lowbit(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        LL r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (id) &#123;</span><br><span class="line">            r += s[id];</span><br><span class="line">            id -= lowbit(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; la, ra;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> lx, rx, y;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; y &gt;&gt; lx &gt;&gt; rx;</span><br><span class="line">		<span class="keyword">if</span> (lx == <span class="number">0</span>) la.push_back(&#123;rx, y&#125;);</span><br><span class="line">		<span class="keyword">else</span> ra.push_back(&#123;lx, y&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(la.<span class="built_in">begin</span>(), la.<span class="built_in">end</span>());</span><br><span class="line">	sort(ra.<span class="built_in">begin</span>(), ra.<span class="built_in">end</span>());</span><br><span class="line">	std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; b(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, ly, ry] : b) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; ly &gt;&gt; ry;</span><br><span class="line">	sort(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="function">TreeArray <span class="title">A</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y] : la) &#123;</span><br><span class="line">		A.add(y + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (x == N) ++r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//std::cout &lt;&lt; A.sum(100) &lt;&lt; std::endl;</span></span><br><span class="line">	<span class="keyword">int</span> lid = <span class="number">0</span>, rid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, ly, ry] : b) &#123;</span><br><span class="line">		<span class="keyword">while</span> (lid &lt; la.<span class="built_in">size</span>() &amp;&amp; la[lid].first &lt; x) &#123;</span><br><span class="line">			A.add(la[lid].second + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">			++lid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (rid &lt; ra.<span class="built_in">size</span>() &amp;&amp; ra[rid].first &lt;= x) &#123;</span><br><span class="line">			A.add(ra[rid].second + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			++rid;</span><br><span class="line">		&#125;</span><br><span class="line">		r += A.sum(ry + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (ly != <span class="number">0</span>) r -= A.sum(ly);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ry == N) ++r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HDU-6838-Battle-for-Wosneth"><a href="#HDU-6838-Battle-for-Wosneth" class="headerlink" title="HDU 6838 Battle for Wosneth"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6838" target="_blank" rel="noopener">HDU 6838 Battle for Wosneth</a></h3><blockquote>
<p>有两个人记作 Alice 和 Bob，Alice 的生命值很高，所以可以认为是无限的，Bob 的生命值为 m。两个人的攻击命中率分别为 <code>p,q</code>。两个人轮流攻击对方。从 Alice 开始攻击，每次攻击的时候，如果 Alice 命中，那么能让对方的生命值减低 1，同时自己的生命值能恢复 1，如果 Bob 命中，那么能让对方的生命值减低 1，注意 Bob 不会自己回血。直到 Bob 的血量变为 0，游戏结束。Alice 想知道，游戏结束的时候，自己期望生命值。</p>
</blockquote>
<p>不妨设，期望为 <code>a[m]</code>, 则显然<br><code>a[m] = p(1-q)(a[m-1]+1) + pq a[m-1] + (1-p)q(a[m]-1) + (1-p)(1-q)a[m]</code><br>化简一下得到 $a_m =  a_{m - 1} + \frac{p - q}{p}$. 另外 $a_1 = p + (1 - p) q (a_1 - 1)  + (1 - p) (1 - q) a_1$，所以 $a_1 = \frac{p - q + pq}{p}$ 即 $a_m = \frac{p - q}{p} m + q$</p>
<h3 id="HDU-6842-Battle-for-Wosneth2"><a href="#HDU-6842-Battle-for-Wosneth2" class="headerlink" title="HDU 6842 Battle for Wosneth2"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6842" target="_blank" rel="noopener">HDU 6842 Battle for Wosneth2</a></h3><blockquote>
<p>有两个人记作 Alice 和 Bob，生命值分别是 n,m，命中率分别为 p%,q%。两个人轮流攻击对方，从 Alice 开始攻击，每次攻击的时候，如果命中，那么能让对方的生命值减低 1，直到一方的生命值不超过 0 为止。问 Alice 胜的概率</p>
</blockquote>
<p>设 <code>a[n][m], b[m][n]</code> 分别表示表示 Alice, Bob 胜的概率。则<br><code>a[n][m] = p(1-b[n][m]) + (1-p)(1-b[n][m])</code>，<br><code>b[n][m] = q(1-a[m-1][n] + (1-q)(1-a[m][n]</code>，<br>所以我们有<code>(p+q-pq) a[n][m] = p(1-q) a[m][n] + (1-p)q a[m-1][n] + pq a[m-1][n-1]</code></p>
<h3 id="1399D-01序列分组，使得各组相邻元素不同（主要考察复杂度，超级容易-TLE）"><a href="#1399D-01序列分组，使得各组相邻元素不同（主要考察复杂度，超级容易-TLE）" class="headerlink" title="1399D: 01序列分组，使得各组相邻元素不同（主要考察复杂度，超级容易 TLE）"></a><a href="https://codeforces.com/contest/1399/problem/D" target="_blank" rel="noopener">1399D</a>: <code>01</code>序列分组，使得各组相邻元素不同（主要考察复杂度，超级容易 TLE）</h3><blockquote>
<p>可以存储当前 <code>1</code> 和 <code>0</code> 的个数，然后一直跑，就是 $O(n)$ 复杂度了</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>, r[n];</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; id[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = (<span class="string">'0'</span> == s[i]);</span><br><span class="line">			<span class="keyword">if</span> (id[t].<span class="built_in">size</span>()) &#123;</span><br><span class="line">				r[i] = id[t].top();</span><br><span class="line">				id[t].pop();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				r[i] = ++k;</span><br><span class="line">			&#125;</span><br><span class="line">			id[<span class="number">1</span> - t].push(r[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(k);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1399E1：dfs-建树，然后就知道每条边的权重，然后有限队列贪心即可，注意是所有叶子节点到根的距离和"><a href="#1399E1：dfs-建树，然后就知道每条边的权重，然后有限队列贪心即可，注意是所有叶子节点到根的距离和" class="headerlink" title="1399E1：dfs 建树，然后就知道每条边的权重，然后有限队列贪心即可，注意是所有叶子节点到根的距离和"></a><a href="https://codeforces.com/contest/1399/problem/E1" target="_blank" rel="noopener">1399E1</a>：dfs 建树，然后就知道每条边的权重，然后有限队列贪心即可，注意是所有叶子节点到根的距离和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head, nxt, to;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; w;</span><br><span class="line">	LinkStar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		nxt.<span class="built_in">clear</span>();</span><br><span class="line">		to.<span class="built_in">clear</span>();</span><br><span class="line">		head = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL val)</span> </span>&#123;</span><br><span class="line">		nxt.emplace_back(head[u]);</span><br><span class="line">		head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">		to.emplace_back(v);</span><br><span class="line">		w.emplace_back(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> d;</span><br><span class="line">	LL v;</span><br><span class="line">	Node(<span class="keyword">int</span> _d, LL _v) : d(_d), v(_v) &#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (v + <span class="number">1</span>) / <span class="number">2</span> * d &lt; (A.v + <span class="number">1</span>) / <span class="number">2</span> * A.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		LL s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">		<span class="function">LinkStar <span class="title">diag</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i) &#123;</span><br><span class="line">			LL w;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">			diag.addedge(u, v, w);</span><br><span class="line">			diag.addedge(v, u, w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::priority_queue&lt;Node&gt; a;</span><br><span class="line">		<span class="keyword">bool</span> vis[n + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, LL)&gt; dfs = [&amp;](<span class="keyword">int</span> u, LL val) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			vis[u] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = diag.head[u]; ~i; i = diag.nxt[i]) &#123;</span><br><span class="line">				<span class="keyword">int</span> v = diag.to[i];</span><br><span class="line">				<span class="keyword">if</span> (!vis[v]) cnt += dfs(v, diag.w[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			cnt = <span class="built_in">std</span>::<span class="built_in">max</span>(cnt, <span class="number">1</span>);</span><br><span class="line">			s -= val * cnt;</span><br><span class="line">			a.push(&#123;cnt, val&#125;);</span><br><span class="line">			<span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;;</span><br><span class="line">		dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">auto</span> [cnt, val] = a.top();</span><br><span class="line">			s += (val + <span class="number">1</span>) / <span class="number">2</span> * cnt;</span><br><span class="line">			<span class="keyword">if</span>(val &gt; <span class="number">1</span>) a.push(&#123;cnt, val / <span class="number">2</span>&#125;);</span><br><span class="line">			a.pop();</span><br><span class="line">			++r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1399E2-同-E1，只是贪心的时候，枚举费用为-2-的边的个数"><a href="#1399E2-同-E1，只是贪心的时候，枚举费用为-2-的边的个数" class="headerlink" title="1399E2:  同 E1，只是贪心的时候，枚举费用为 2 的边的个数"></a><a href="https://codeforces.com/contest/1399/problem/E2" target="_blank" rel="noopener">1399E2</a>:  同 E1，只是贪心的时候，枚举费用为 2 的边的个数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head, nxt, to, c;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; w;</span><br><span class="line">	LinkStar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		nxt.<span class="built_in">clear</span>();</span><br><span class="line">		to.<span class="built_in">clear</span>();</span><br><span class="line">		head = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL val, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">		nxt.emplace_back(head[u]);</span><br><span class="line">		head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">		to.emplace_back(v);</span><br><span class="line">		w.emplace_back(val);</span><br><span class="line">		c.emplace_back(cost);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		LL s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">		<span class="function">LinkStar <span class="title">diag</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, c; i &lt; n; ++i) &#123;</span><br><span class="line">			LL w;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">			diag.addedge(u, v, w, c - <span class="number">1</span>);</span><br><span class="line">			diag.addedge(v, u, w, c - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, LL&gt;&gt; a;</span><br><span class="line">		<span class="keyword">bool</span> vis[n + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, LL, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, LL val, <span class="keyword">int</span> cost) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			vis[u] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = diag.head[u]; ~i; i = diag.nxt[i]) &#123;</span><br><span class="line">				<span class="keyword">int</span> v = diag.to[i];</span><br><span class="line">				<span class="keyword">if</span> (!vis[v]) cnt += dfs(v, diag.w[i], diag.c[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			cnt = <span class="built_in">std</span>::<span class="built_in">max</span>(cnt, <span class="number">1</span>);</span><br><span class="line">			s -= val * cnt;</span><br><span class="line">			a.push_back(&#123;cost, cnt, val&#125;);</span><br><span class="line">			<span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;;</span><br><span class="line">		dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; q[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [cost, cnt, val] : a) &#123;</span><br><span class="line">			<span class="keyword">while</span> (val) &#123;</span><br><span class="line">				q[cost].emplace_back((val + <span class="number">1</span>) / <span class="number">2</span> * cnt);</span><br><span class="line">				val &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::sort(q[<span class="number">0</span>].<span class="built_in">begin</span>(), q[<span class="number">0</span>].<span class="built_in">end</span>(), <span class="built_in">std</span>::greater&lt;&gt;());</span><br><span class="line">		<span class="built_in">std</span>::sort(q[<span class="number">1</span>].<span class="built_in">begin</span>(), q[<span class="number">1</span>].<span class="built_in">end</span>(), <span class="built_in">std</span>::greater&lt;&gt;());</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : q[<span class="number">0</span>]) s += x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = q[<span class="number">0</span>].<span class="built_in">size</span>(); i &lt;= q[<span class="number">1</span>].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s - q[<span class="number">0</span>][j - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				s -= q[<span class="number">0</span>][--j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (s &gt;= <span class="number">0</span>) r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, <span class="number">2</span> * i  + j);</span><br><span class="line">			<span class="keyword">if</span> (i != q[<span class="number">1</span>].<span class="built_in">size</span>()) s += q[<span class="number">1</span>][i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1399F-区间-dp-问题"><a href="#1399F-区间-dp-问题" class="headerlink" title="1399F :  区间 dp 问题"></a><a href="https://codeforces.com/contest/1399/problem/F" target="_blank" rel="noopener">1399F</a> :  区间 dp 问题</h3><blockquote>
<p>用 <code>f[m]</code> 表示从 <code>a[i]</code> 的左边界到，<code>m</code> 的区间个数(是被一个大的覆盖了的区间，size 一般不为 1）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// follow the idea of Jiangly</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		std::vector&lt;std::pair&lt;int, int&gt;&gt; a(n);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[l, r] : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		a.push_back(&#123;<span class="number">1</span>, <span class="number">2e5</span>&#125;);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[l, r] : a) &#123;</span><br><span class="line">			v.emplace_back(l);</span><br><span class="line">			v.emplace_back(r);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">		v.erase(<span class="built_in">std</span>::unique(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[l, r] : a) &#123;</span><br><span class="line">			l = <span class="built_in">std</span>::lower_bound(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), l) - v.<span class="built_in">begin</span>();</span><br><span class="line">			r = <span class="built_in">std</span>::lower_bound(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), r) - v.<span class="built_in">begin</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;lhs, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;rhs) &#123;</span><br><span class="line">			<span class="keyword">if</span> (lhs.first == rhs.first) <span class="keyword">return</span> lhs.second &lt; rhs.second;</span><br><span class="line">			<span class="keyword">return</span> lhs.first &gt; rhs.first;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">int</span> dp[n + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(a[i].second + <span class="number">1</span>)</span></span>;</span><br><span class="line">			<span class="keyword">int</span> mx = <span class="number">0</span>, x = a[i].first - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j].second &gt; a[i].second) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">while</span> (x + <span class="number">1</span> &lt; a[j].first) mx = <span class="built_in">std</span>::<span class="built_in">max</span>(mx, f[++x]);</span><br><span class="line">				f[a[j].second] = <span class="built_in">std</span>::<span class="built_in">max</span>(f[a[j].second], dp[j] + mx);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : f) mx = <span class="built_in">std</span>::<span class="built_in">max</span>(mx, t);</span><br><span class="line">			dp[i] = <span class="number">1</span> + mx;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(dp[n] - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1389F：二分图"><a href="#1389F：二分图" class="headerlink" title="1389F：二分图"></a><a href="https://codeforces.com/contest/1389/problem/F" target="_blank" rel="noopener">1389F</a>：二分图</h3><p><a href="https://codeforces.com/profile/emorgan5289" target="_blank" rel="noopener">emorgan5289 大佬的代码</a>以及<a href="https://codeforces.com/blog/entry/80723#comment-671203" target="_blank" rel="noopener">解释</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt;&gt; a;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios_base::sync_with_stdio(<span class="number">0</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r, t; <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; t;</span><br><span class="line">		a.insert(t<span class="number">-1</span> ? <span class="built_in">array</span>&#123;r, <span class="number">1</span>, -l&#125; : <span class="built_in">array</span>&#123;l, <span class="number">0</span>, -r&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, t, x] : a) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t &amp;&amp; s.upper_bound(x) != s.<span class="built_in">begin</span>())</span><br><span class="line">			s.erase(--s.upper_bound(x)), n--;</span><br><span class="line">		<span class="keyword">if</span> (!t) s.insert(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1384D：两个人轮流取-n-个数，比较它们取的数的异或值，较大的赢"><a href="#1384D：两个人轮流取-n-个数，比较它们取的数的异或值，较大的赢" class="headerlink" title="1384D：两个人轮流取 $n$ 个数，比较它们取的数的异或值，较大的赢"></a><a href="https://codeforces.com/contest/1384/problem/D" target="_blank" rel="noopener">1384D</a>：两个人轮流取 $n$ 个数，比较它们取的数的异或值，较大的赢</h3><p>记 $s$ 为 $n$ 个数的异或值，如果 $s = 0$，那么显然平局，否则看与 $s$ 的最高位 异或不为 0 的数的人数 cnt，显然这个个数是奇数，所以为 $1 \mod 4$ ，那么先手赢，否则，我们看 $n - cnt$ 是否为奇数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) sum ^= x;</span><br><span class="line">		<span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DRAW\n"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> k = <span class="built_in">std</span>::__lg(sum);</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="keyword">if</span>((x &gt;&gt; k) &amp; <span class="number">1</span>) ++cnt;</span><br><span class="line">			<span class="keyword">if</span> (cnt % <span class="number">4</span> == <span class="number">1</span> || (n - cnt) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"WIN\n"</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"LOSE\n"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1384B：很有意思的一道模拟题，我也不知道为什么我要想这么久，太菜了"><a href="#1384B：很有意思的一道模拟题，我也不知道为什么我要想这么久，太菜了" class="headerlink" title="1384B：很有意思的一道模拟题，我也不知道为什么我要想这么久，太菜了"></a><a href="https://codeforces.com/contest/1384/problem/B2" target="_blank" rel="noopener">1384B</a>：很有意思的一道模拟题，我也不知道为什么我要想这么久，太菜了</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, k, len;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; len;</span><br><span class="line">		<span class="keyword">int</span> d[n];</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">			<span class="keyword">if</span> (d[i] &gt; len) flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> d[i] = len - d[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No\n"</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">0</span>, r = k;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">			<span class="keyword">int</span> li = <span class="built_in">std</span>::<span class="built_in">min</span>(k, d[i]);</span><br><span class="line">			<span class="keyword">int</span> ri = <span class="built_in">std</span>::<span class="built_in">max</span>(k, <span class="number">2</span> * k - d[i]);</span><br><span class="line">			<span class="keyword">if</span> (r &lt; <span class="number">2</span> * k) &#123;</span><br><span class="line">				l = <span class="number">0</span>;</span><br><span class="line">				r = <span class="built_in">std</span>::<span class="built_in">max</span>(r + <span class="number">1</span>, ri);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (++l &gt; li) flag = <span class="literal">true</span>;</span><br><span class="line">			l = <span class="built_in">std</span>::<span class="built_in">min</span>(l, k);</span><br><span class="line">			<span class="keyword">if</span> (d[i] &gt;= k) r = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (flag ? <span class="string">"No"</span> : <span class="string">"Yes"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷-U122053-选择题：经典问题：每个人说另一个人是不是好人，-好人只说真话，坏人只说慌话，输出有多少种可能的情况，并输出可能的情况下，最多的好人和最少的好人数"><a href="#洛谷-U122053-选择题：经典问题：每个人说另一个人是不是好人，-好人只说真话，坏人只说慌话，输出有多少种可能的情况，并输出可能的情况下，最多的好人和最少的好人数" class="headerlink" title="洛谷 U122053 选择题：经典问题：每个人说另一个人是不是好人， 好人只说真话，坏人只说慌话，输出有多少种可能的情况，并输出可能的情况下，最多的好人和最少的好人数"></a><a href="https://www.luogu.com.cn/problem/U122053?contestId=31675" target="_blank" rel="noopener">洛谷 U122053 选择题</a>：<strong>经典问题</strong>：每个人说另一个人是不是好人， 好人只说真话，坏人只说慌话，输出有多少种可能的情况，并输出可能的情况下，最多的好人和最少的好人数</h3><p><code>val[i]</code> 表示第 $i$ 个人是否为好人， <code>w[i,j]</code> 表示$i$ 说 $j$ 是好人还是坏人，或 $j$ 说 $i$ 是好人还是坏人，那么必然 <code>val[i] ^ val[j] = !w[i,j]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/U122053?contestId=31675</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], val[N], cnt, nxt[<span class="number">2</span> * N], to[<span class="number">2</span> * N];</span><br><span class="line"><span class="keyword">bool</span> w[<span class="number">2</span> * N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cnt = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> (head));</span><br><span class="line">	<span class="built_in">memset</span>(val, <span class="number">-1</span>, <span class="keyword">sizeof</span> (val));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">	nxt[++cnt] = head[u];</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">	to[cnt] = v;</span><br><span class="line">	w[cnt] = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此题BFS更好，不过DFS也能过</span></span><br><span class="line">std::pair&lt;int, int&gt; dfs(int u, int flag) &#123;</span><br><span class="line">	val[u] = flag;</span><br><span class="line">	<span class="keyword">int</span> r1 = <span class="number">1</span>, r2 = flag;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = nxt[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = to[i];</span><br><span class="line">		<span class="keyword">if</span> (val[v] != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val[v] != (val[u] ^ w[i])) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">auto</span> [vr1, vr2] = dfs(v, val[u] ^ w[i]);</span><br><span class="line">			<span class="keyword">if</span> (vr1 == <span class="number">-1</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">			r1 += vr1;</span><br><span class="line">			r2 += vr2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;r1, r2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::pair&lt;int, int&gt; bfs(int iu, int iflag) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">	q.push(&#123;iu, iflag&#125;);</span><br><span class="line">	<span class="keyword">int</span> r1 = <span class="number">0</span>, r2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [u, flag] = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span> (val[u] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		val[u] = flag;</span><br><span class="line">		++r1;</span><br><span class="line">		r2 += flag;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = nxt[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = to[i];</span><br><span class="line">			<span class="keyword">if</span> (val[v] != <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (val[v] != (val[u] ^ w[i])) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">			&#125; <span class="keyword">else</span> q.push(&#123;v, val[u] ^ w[i]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;r1, r2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">1</span>, x = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">int</span> n;	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">bool</span> flag;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; flag;</span><br><span class="line">		addedge(i, x, !flag);</span><br><span class="line">		addedge(x, i, !flag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>, mx = <span class="number">0</span>, mi = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (val[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="comment">// auto [r1, r2] = dfs(i, 1);</span></span><br><span class="line">		<span class="keyword">auto</span> [r1, r2] = bfs(i, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (r1 == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No answer\n"</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++now;</span><br><span class="line">		mx += <span class="built_in">std</span>::<span class="built_in">max</span>(r2, r1 - r2);</span><br><span class="line">		mi += <span class="built_in">std</span>::<span class="built_in">min</span>(r2, r1 - r2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; powMod(now) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mx &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷-U122055-出生点-：简单包容排斥"><a href="#洛谷-U122055-出生点-：简单包容排斥" class="headerlink" title="洛谷 U122055 出生点 ：简单包容排斥"></a><a href="https://www.luogu.com.cn/problem/U122055?contestId=31675" target="_blank" rel="noopener">洛谷 U122055 出生点</a> ：简单包容排斥</h3><p><strong>仅考虑 $x$-轴</strong></p>
<p>当$k=0$ 时，那么距离之和就是</p>
<script type="math/tex; mode=display">
m^2 \sum_{i=1}^n i(n-i) = m^2 \sum_{1} ^n i(n-1) - i(i-1) = \frac{m^2(n-1)n(n+1)}{6}</script><p>然后我们减去 $k$ 个障碍点和其它所有点之间的距离</p>
<script type="math/tex; mode=display">
m  \sum _{i=1} ^k \sum_{t=1} ^n |a[i] - t| = m  \sum _{i=1} ^k \frac{(a[i])(a[i]-1) + (n-a[i])(n-a[i] + 1)}{2}</script><p>再加上 $k$ 个障碍点之间的距离</p>
<p>不妨按照 $x$-轴排序，然后把前缀和 <code>sa[i]</code> 求一下，再依次计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL inv2 = (M + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> LL inv6 = (M + <span class="number">1</span>)/<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	LL n, m;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	LL a[k], b[k];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::sort(a, a + k);</span><br><span class="line">	<span class="built_in">std</span>::sort(b, b + k);</span><br><span class="line">	LL sa[k] = &#123;a[<span class="number">0</span>]&#125;, sb[k] = &#123;b[<span class="number">0</span>]&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++ i) &#123;</span><br><span class="line">		sa[i] = sa[i - <span class="number">1</span>] + a[i];</span><br><span class="line">		sb[i] = sb[i - <span class="number">1</span>] + b[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> f = [](LL m, LL n) -&gt; LL &#123;</span><br><span class="line">		<span class="keyword">return</span> m * m % M * (n - <span class="number">1</span>) % M * n % M * (n + <span class="number">1</span>) % M;</span><br><span class="line">	&#125;;</span><br><span class="line">	LL r0 = (f(m, n) + f(n, m)) * inv6 % M;</span><br><span class="line">	</span><br><span class="line">	LL r1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) &#123;</span><br><span class="line">		r1 += ((a[i] - <span class="number">1</span>) * a[i] + (n - a[i] + <span class="number">1</span>) * (n - a[i])) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	r1 = r1 % M * m % M * inv2 % M;</span><br><span class="line">	</span><br><span class="line">	LL r2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) &#123;</span><br><span class="line">		r2 += ((b[i] - <span class="number">1</span>) * b[i] + (m - b[i] + <span class="number">1</span>) * (m - b[i])) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	r2 = r2 % M * n % M * inv2 % M;</span><br><span class="line">	</span><br><span class="line">	LL r3 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		r3 += (sa[k - <span class="number">1</span>] - sa[i] - a[i] * (k - <span class="number">1</span> - i)) % M;</span><br><span class="line">		r3 += (sb[k - <span class="number">1</span>] - sb[i] - b[i] * (k - <span class="number">1</span> - i)) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	r3 %= M;</span><br><span class="line"></span><br><span class="line">	LL r = (r0 - r1 - r2 + r3) % M;</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>) r += M;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷-U122054-强迫症-圆上-n-个点构成的无交错边的图的个数-f-n"><a href="#洛谷-U122054-强迫症-圆上-n-个点构成的无交错边的图的个数-f-n" class="headerlink" title="洛谷 U122054 强迫症 : 圆上 $n$ 个点构成的无交错边的图的个数 $f_n$"></a><a href="https://www.luogu.com.cn/problem/U122054?contestId=31675" target="_blank" rel="noopener">洛谷 U122054 强迫症</a> : <a href="http://oeis.org/A054726" target="_blank" rel="noopener">圆上 $n$ 个点构成的无交错边的图的个数 $f_n$</a></h3><p>$f_0 = 1, f_1 = 1, f_2 = 2, f_3 = 8$，考虑 $n+1$ 个点，如果第 $n+1$ 点与其他点没有边相连有 $f_n$ 种，如果相连，设最小的数为 $i$, 那么一边有 $f_i$ 种（注意到 $n+1$ 这个节点可以不管，因为它不跟小于 $i$ 的节点相连），另一边有 $\frac{f_{n+2-i}}{2}$，即</p>
<script type="math/tex; mode=display">
f_{n + 1} = f_n + \frac{1}{2}\sum_{i = 1} ^ n f_i f_{n+2-i}</script><p>化简一下，可知 </p>
<script type="math/tex; mode=display">
f_{n+1} = 2f_n + \sum_{i=2} ^n f_i f_{n+2-i}</script><p>我们令 $g_n = f_{n+1}$，则 $g_n = 2g_{n-1} + \sum_{i=2} ^ n g_{i-1} g_{n+1-i} = 2 g_{n-1} + \sum_{i=1} ^{n-1} g_i g_{n-i}$，所以 $g_n = \frac{2}{3} g_{n-1} + \frac{1}{3} \sum_{i=0} ^n g_i g_{n-i}$。考虑 $g_n$ 的生成函数 $g(z)$：</p>
<script type="math/tex; mode=display">
g(z) = \sum_{i = 0} ^ {\infty} g_n z^n = g_0 + \frac{2}{3}  \sum_{i = 1} ^ {\infty} g_{n-1} z^n + \frac{1}{3} \sum_{i = 1} ^ {\infty} \sum_{i=0} ^ n g_i g_{n-i} z^n = g_0 + \frac{2}{3} z g(z) + \frac{1}{3} (g^2(z)  - g_0 ^ 2)</script><p>因此 $\frac{1}{3} g^2(z) + (\frac{2}{3} z - 1) g(z) + \frac{2}{3} = 0$，从而 $g(z) = \frac{3-2z \pm \sqrt{1 - 12 z + 4z^2}}{2}$, 由 $g_1 = 2$ 知 $g(z) = \frac{3-2z - \sqrt{1 - 12 z + 4z^2}}{2}$，从而 $f(z) = f_0 + z g(z) = 1 + \frac{3}{2} z - z^2 - \frac{z}{2} \sqrt{1 - 12 z + 4 z^2}$。</p>
<script type="math/tex; mode=display">
g'(z) = -1 - \frac{2z - 3}{\sqrt{1 - 12 z + 4 z^2}} = \frac{3-2z - \sqrt{1 - 12 z + 4 z^2}}{\sqrt{1 - 12 z + 4 z^2}}</script><script type="math/tex; mode=display">
(1 - 12z + 4 z^2) g'(z) = (3-2z - \sqrt{1 - 12 z + 4 z^2}) (\sqrt{1 - 12 z + 4 z^2}) = (3 - 2z) (3-2z - 2g(z)) - (1 - 12z + 4 z^2 = (4z - 6) g(z) + 8</script><p>因此 $(n + 1)g_{n+1} - 12 n g_n + 4(n-1)g_{n-1} = 4 g_{n-1} - 6 g_n$，整理得到 $(n+1)g_{n+1}  = (12 n - 6) g_n - (4n-8)g_{n-1}$</p>
<p>从而 $(n+1)f_{n+2} = (12 n - 6) f_{n+1} - (4n - 8) f_n$，即递推公式 $f_{n} = \frac{ (12 n - 30) f_{n-1} - (4 n - 16) f_{n-2} }{n-1}$。</p>
<p>所以原问题的答案就是 </p>
<script type="math/tex; mode=display">
\frac{ \sum_{i = 0} ^{n - 2} \sum_{j = i + 1} ^ {n-1} a_i a_j \frac{f_{j-i+1}}{2} \frac{f_{n+i-j+1}}{2} }{f_n} = \frac{ \sum_{i = 0} ^{n - 2} \sum_{j = i + 1} ^ {n-1} a_i a_j f_{j-i+1} f_{n+i-j+1}}{ 4 f_n}</script><p>仅看分子：</p>
<script type="math/tex; mode=display">
\sum_{i = 0} ^{n - 2} \sum_{j = i + 1} ^ {n-1} a_i a_j f_{j-i+1} f_{n+i-j+1} = \sum_{t = 2} ^ n f_t f_{n-t+2} \sum_{i=0}^{n-t} a_i a_{i+t-1}</script><p>如果我们定义 $b_i = a_{n-1-i}$，$c_t = \sum_{i = 0} ^{t} a_{t-i} b_{i} = \sum_{i = 0} ^{t} a_{i} b_{t-i} = \sum_{i = 0} ^{t} a_{i} a_{n-1-(t-i)}$，则 $c_{n-t} = \sum_{i = 0} ^{n-t} a_{i} a_{n-1-(n-t-i)} = \sum_{i = 0} ^{n-t} a_{i} a_{i+t-1}$ 。即答案为</p>
<script type="math/tex; mode=display">
\frac{ \sum_{t = 2} ^ n f_t f_{n-t+2} \cdot c_{n-t} }{4 f_n}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/U122054?contestId=31675</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>, ROOT = <span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; j) <span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = a.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			(j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a, <span class="keyword">bool</span> isInverse = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">	LL g = powMod(ROOT, (M - <span class="number">1</span>) / a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span> (isInverse) &#123;</span><br><span class="line">		g = powMod(g, M - <span class="number">2</span>);</span><br><span class="line">		LL invLen = powMod(LL(a.<span class="built_in">size</span>()), M - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) x = x * invLen % M;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(a);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != w.<span class="built_in">size</span>(); ++i) w[i] = w[i - <span class="number">1</span>] * g % M;</span><br><span class="line">	<span class="keyword">auto</span> addMod = [](LL x, LL y) &#123;</span><br><span class="line">		<span class="keyword">return</span> (x += y) &gt;= M ? x -= M : x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">2</span>, half = <span class="number">1</span>; half != a.<span class="built_in">size</span>(); <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>, half &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, wstep = a.<span class="built_in">size</span>() / <span class="built_in">step</span>; i != a.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j != i + half; ++j) &#123;</span><br><span class="line">				LL t = (a[j + half] * w[wstep * (j - i)]) % M;</span><br><span class="line">				a[j + half] = addMod(a[j], M - t);</span><br><span class="line">				a[j] = addMod(a[j], t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">mul</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (sz &lt; tot) sz *= <span class="number">2</span>;</span><br><span class="line">	a.resize(sz);</span><br><span class="line">	b.resize(sz);</span><br><span class="line">	nft(a);</span><br><span class="line">	nft(b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != sz; ++i) a[i] = a[i] * b[i] % M;</span><br><span class="line">	nft(a, <span class="number">1</span>);</span><br><span class="line">	a.resize(tot);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">b</span><span class="params">(a.rbegin(),a.rend())</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> c = mul(a, b);</span><br><span class="line"></span><br><span class="line">	LL inv[n] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, f[n + <span class="number">1</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) inv[i] = (M - M / i) * inv[M % i] % M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		f[i] = ((<span class="number">12</span> * i - <span class="number">30</span>)* f[i - <span class="number">1</span>] - (<span class="number">4</span> * i - <span class="number">16</span>) * f[i - <span class="number">2</span>]) % M * inv[i - <span class="number">1</span>] % M;</span><br><span class="line">		<span class="keyword">if</span> (f[i] &lt; <span class="number">0</span>) f[i] += M;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		r += f[i] * f[n - i + <span class="number">2</span>] % M * c[n - i] % M;</span><br><span class="line">	&#125;</span><br><span class="line">	r = r * inv[<span class="number">4</span>] % M * powMod(f[n], M - <span class="number">2</span>) % M;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1382D-：0-1-背包问题"><a href="#1382D-：0-1-背包问题" class="headerlink" title="1382D ：0-1 背包问题"></a><a href="https://codeforces.com/contest/1382/problem/D" target="_blank" rel="noopener">1382D</a> ：0-1 背包问题</h3><blockquote>
<p>注意到一段选择了 <code>a[i]</code> 那么后来连续小于 <code>a[i]</code> 的都要被选择。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, maxn;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">int</span> a[<span class="number">2</span> * n];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">bool</span> dp[n + <span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i = j) &#123;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; <span class="number">2</span> * n &amp;&amp; a[j] &lt;= a[i]) ++j;</span><br><span class="line">			<span class="keyword">int</span> len = j - i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = n; k &gt;= len; --k) &#123;</span><br><span class="line">				dp[k] |= dp[k - len];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (dp[n] ? <span class="string">"YES"</span> : <span class="string">"NO"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1382C-：设-f-0-1string-gt-0-1string将字符串-0-换成-1，1-换成-0，然后倒序。给定长度为-n-的字符串-a-b-。每次可以改变-a-的前缀，给出一种方案（不超过-3n-，或者不超过-2n-）"><a href="#1382C-：设-f-0-1string-gt-0-1string将字符串-0-换成-1，1-换成-0，然后倒序。给定长度为-n-的字符串-a-b-。每次可以改变-a-的前缀，给出一种方案（不超过-3n-，或者不超过-2n-）" class="headerlink" title="1382C ：设 f: 0-1string ---&gt; 0-1string将字符串 0 换成 1，1 换成 0，然后倒序。给定长度为 $n$ 的字符串$a, b$ 。每次可以改变 $a$ 的前缀，给出一种方案（不超过 $3n$，或者不超过 $2n$ ）"></a><a href="https://codeforces.com/contest/1382/problem/C2" target="_blank" rel="noopener">1382C</a> ：设 <code>f: 0-1string ---&gt; 0-1string</code>将字符串 0 换成 1，1 换成 0，然后倒序。给定长度为 $n$ 的字符串$a, b$ 。每次可以改变 $a$ 的前缀，给出一种方案（不超过 $3n$，或者不超过 $2n$ ）</h3><ul>
<li>注意到取 $n$ 再取 $1$，再去 $n$，这样只会改变最后一个，所以就给出了不超过 $3n$ 的方案</li>
<li>可以先将 $a$变成 全$0$，再把 $b$ 变成 全$0$ 的方案反序，然后再复合。变成 $0$ 的做法就是一直让前缀数字相同。</li>
</ul>
<p>方案一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#define watch(x) std::cout &lt;&lt; (#x) &lt;&lt; &quot; is &quot; &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="line">using LL &#x3D; long long;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	&#x2F;&#x2F;freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	std::ios::sync_with_stdio(false);</span><br><span class="line">	std::cin.tie(nullptr);</span><br><span class="line">	int cas;</span><br><span class="line">	std::cin &gt;&gt; cas;</span><br><span class="line">	while (cas--) &#123;</span><br><span class="line">		int n;</span><br><span class="line">		std::string a, b;</span><br><span class="line">		std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		std::vector&lt;int&gt; q;</span><br><span class="line">		while (--n &gt;&#x3D; 0) &#123;</span><br><span class="line">			if(a[n] !&#x3D; b[n]) &#123;</span><br><span class="line">				q.emplace_back(n + 1);</span><br><span class="line">				q.emplace_back(1);</span><br><span class="line">				q.emplace_back(n + 1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; q.size();</span><br><span class="line">		for (auto &amp;x : q) std::cout &lt;&lt; &quot; &quot; &lt;&lt; x;</span><br><span class="line">		std::cout &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方案二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> a, b;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		a += <span class="string">'0'</span>; b += <span class="string">'0'</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; qa, qb;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] != a[i<span class="number">-1</span>]) qa.emplace_back(i);</span><br><span class="line">			<span class="keyword">if</span> (b[i] != b[i<span class="number">-1</span>]) qb.emplace_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		qa.insert(qa.<span class="built_in">end</span>(), qb.rbegin(), qb.rend());</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; qa.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : qa) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="百度之星-2020-初赛-1008：数论函数题"><a href="#百度之星-2020-初赛-1008：数论函数题" class="headerlink" title="百度之星 2020 初赛 1008：数论函数题"></a><a href="http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=889&amp;pid=1008" target="_blank" rel="noopener">百度之星 2020 初赛 1008</a>：数论函数题</h3><p>已知，$f(n) = \displaystyle \sum_{d|n} d \cdot [\gcd(d,\frac{n}{d}) == 1]$，求 $\displaystyle \sum_{n=1} ^N f(n)$</p>
<p>首先 </p>
<script type="math/tex; mode=display">
f(n) = \sum_{d|n} d \cdot [\gcd(d,\frac{n}{d}) == 1] = \sum_{d|n} d \cdot \sum_{l| \gcd(d,\frac{n}{d})} \mu(l) = \sum_{l^2 | n} \mu(l) \cdot l \cdot g(\frac{n}{l^2})</script><p>其中 $g(n) = \displaystyle \sum_{d|n} d$，所以 </p>
<script type="math/tex; mode=display">
\sum_{n=1} ^N f(n) = \sum_{n=1} ^N \sum_{l^2 | n} \mu(l) \cdot l \cdot g(\frac{n}{l^2}) = \sum_{l=1}^{\sqrt{N}} \mu(l) l \sum_{n=1} ^{\lfloor \frac{N}{l^2} \rfloor} g(n) = \sum_{l=1}^{\sqrt{N}} \mu(l) \cdot l \cdot h(\lfloor \frac{N}{l^2} \rfloor)</script><p>其中 $h(n) = \sum_{i = 1} ^n g(i) = \sum_{d=1}^n d \lfloor \frac{n}{d} \rfloor$，求 $h(n)$ 有众所周知的 $O (\sqrt{n})$ 的算法，所以总时间复杂度为 $O(\sum \frac{\sqrt{N}}{l}) = O(\sqrt{N} \log N)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt; N; j += i) &#123;</span><br><span class="line">			mu[j] -= mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	initmu();</span><br><span class="line">	<span class="keyword">auto</span> f = [](LL n) &#123;</span><br><span class="line">		LL ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">			r = n / (n / l);</span><br><span class="line">			ret += ((n / l) % M) * ((l + r) % M) % M * ((r - l + <span class="number">1</span>) % M) % M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret % M * ((M + <span class="number">1</span>) / <span class="number">2</span>) % M;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		LL n, ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (LL i = <span class="number">1</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mu[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			ans += (M + mu[i]) * i % M * f(n / (i * i)) % M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans%M &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种计算思考：考虑每一个 $d$ 对答案的贡献，则 </p>
<script type="math/tex; mode=display">
\begin{array}{lc}
ans_N &= \sum_{d=1} ^N d \sum_{x d \leq N}  [\gcd(x,d) == 1] \\
&=  \sum_{d=1} ^N d \sum_{x d \leq N}  \sum_{l|gcd(x,d)} \mu(l) \\
&= \sum_{l=1} ^{\sqrt{N}} \mu(l) l \sum_{d = 1} ^{\lfloor \frac{N}{l} \rfloor}  d \cdot \lfloor \frac{N}{l^2 d} \rfloor\\
&= \sum_{l=1} ^{\sqrt{N}} \mu(l) l \sum_{d = 1} ^{\lfloor \frac{N}{l^2} \rfloor} d \cdot \lfloor \frac{ \lfloor\frac{N}{l^2} \rfloor}{d} \rfloor \\
\end{array}</script><h3 id="Atcode：经典生成函数题"><a href="#Atcode：经典生成函数题" class="headerlink" title="Atcode：经典生成函数题"></a><a href="https://atcoder.jp/contests/aising2020/tasks/aising2020_f" target="_blank" rel="noopener">Atcode</a>：经典生成函数题</h3><p>题目很容易转化成，满足所有$(a_1+\cdots+a_5)+2(b_1+\cdots+b_5) \leq N$的$a_1 \cdots a_5$之和，其中$a_i,b_i$ 均为非负整数</p>
<p>我一开始把 5 看作变量，从 <code>1,2,3</code> 一直推出 5 的公式，贼麻烦。后来  <a href="https://codeforces.com/profile/querty20002" target="_blank" rel="noopener">querty20002</a> 给出了生成函数做法的 <a href="https://codeforces.com/blog/entry/79978#comment-659438" target="_blank" rel="noopener">题解</a>。答案唯一的依赖于 $N$，即可认为答案是关于 $N$ 的数列，那么它的生成函数即为：</p>
<script type="math/tex; mode=display">
\begin{array}{cl}
\sum a_1a_2a_3a_4a_5(N) x^N &= (x+2x^2+\cdots)^5 (1+x^2+x^4+\cdots)^5 (1+x+x^2) \\
&= (\frac{x}{(1-x)^2})^5 (\frac{1}{1-x^2})^5 \frac{1}{1-x} \\
&=  \frac{x^5(1+x)^{11}}{(1-x^2)^{16}}\\
&= x^5(1+x)^{11} \sum_{n} \binom{n+15}{15} x^{2n}
\end{array}</script><p>所以答案就是 $\sum_{i=N\%2}^{11} \binom{11}{i} \binom{\frac{N-i-5}{2}+15}{15}$，所以我们选择 Python 交题 0.0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">M = <span class="number">1000000007</span></span><br><span class="line">T = int(input())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(T):</span><br><span class="line">	n = int(input())</span><br><span class="line">	r = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range((n<span class="number">-5</span>)%<span class="number">2</span>,<span class="number">12</span>,<span class="number">2</span>):</span><br><span class="line">		r+=math.comb(<span class="number">11</span>,i)%M*math.comb((n-i+<span class="number">25</span>)//<span class="number">2</span>,<span class="number">15</span>)%M;</span><br><span class="line">	print(r%M)</span><br></pre></td></tr></table></figure>
<p>或者 C++ 也行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> LL M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a,LL p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:(p-p/a)*inv(p%a,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">		r = r*(n-i)%M*inv(i+<span class="number">1</span>,M)%M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		LL n ,r = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=(n+<span class="number">1</span>)%<span class="number">2</span>;i&lt;=<span class="number">11</span>;i+=<span class="number">2</span>) &#123;</span><br><span class="line">			r+=C(<span class="number">11</span>,i)*C((n-i+<span class="number">25</span>)/<span class="number">2</span>,<span class="number">15</span>)%M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;r%M&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1215E：给定长度为-n-数据范围-1-20-的数组，求最少交换相邻位置元素使得相同的数字都紧挨着"><a href="#1215E：给定长度为-n-数据范围-1-20-的数组，求最少交换相邻位置元素使得相同的数字都紧挨着" class="headerlink" title="1215E：给定长度为 $n$ 数据范围 $[1,20]$ 的数组，求最少交换相邻位置元素使得相同的数字都紧挨着"></a><a href="https://codeforces.com/contest/1215/problems" target="_blank" rel="noopener">1215E</a>：给定长度为 $n$ 数据范围 $[1,20]$ 的数组，求最少交换相邻位置元素使得相同的数字都紧挨着</h3><blockquote>
<p>参考 <a href="https://skywt.cn/posts/cf1215e" target="_blank" rel="noopener">cf1215e</a>，注意到交换两个数字，其它数字的相对位置不发生改变</p>
</blockquote>
<p><strong>状态 dp</strong>：设 <code>dp[mask]</code> 表示状态为 <code>mask</code> 的最小交换次数，其中 <code>mask&amp;(1&lt;&lt;i)=1</code> 表示值为 <code>1+i</code> 的数已经被考虑到了。所以 $dp[2^{20}-1]$ 就是我们要的结果。状态转移</p>
<script type="math/tex; mode=display">
dp[mask] = \min_{j \in mask} dp[mask\wedge2^{j}] + \sum_{k \in mask\wedge2^{j}} cnt(j,k)</script><p>其中 <code>cnt(j,k)</code> 表示把    所有的 <code>j</code> 移动到 <code>k</code> 前面需要的次数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line">LL cnt[N][N],s[N],dp[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;--x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j) <span class="keyword">if</span>(x!=j)&#123;</span><br><span class="line">			cnt[x][j] += s[j];</span><br><span class="line">		&#125;</span><br><span class="line">		++s[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=(<span class="number">1</span>&lt;&lt;N);++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j) <span class="keyword">if</span>(!(i&amp;(<span class="number">1</span>&lt;&lt;j)))&#123;</span><br><span class="line">			LL s = dp[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;++k) <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;k))&#123;</span><br><span class="line">				s+=cnt[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[i|(<span class="number">1</span>&lt;&lt;j)] = <span class="built_in">min</span>(dp[i|(<span class="number">1</span>&lt;&lt;j)],s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[(<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码基本 copy <a href="https://codeforces.com/profile/WZYYN" target="_blank" rel="noopener">WZYYN</a> 的<a href="https://codeforces.com/contest/1215/submission/60614830" target="_blank" rel="noopener">代码</a></p>
</blockquote>
<h3 id="1228E：（二维）包容排斥原理"><a href="#1228E：（二维）包容排斥原理" class="headerlink" title="1228E：（二维）包容排斥原理"></a><a href="https://codeforces.com/contest/1228/problem/E" target="_blank" rel="noopener">1228E</a>：（二维）包容排斥原理</h3><blockquote>
<p>在 $n \times n$ 的格子中填不超过$k$的正整数，使得每行每列的最小值都为 1 的填法方案数。下图是 <a href="https://codeforces.com/blog/entry/70162" target="_blank" rel="noopener">官方题解</a></p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="1228E.png" alt="1228E"></p>
<p><strong>无论是 dp 还是包容排斥，定义好状态是最重要的。</strong></p>
<h3 id="1148B：在一次转机的旅行中，取消-k-个航班，使得旅客最晚达到终点"><a href="#1148B：在一次转机的旅行中，取消-k-个航班，使得旅客最晚达到终点" class="headerlink" title="1148B：在一次转机的旅行中，取消 $k$ 个航班，使得旅客最晚达到终点"></a><a href="https://codeforces.com/contest/1148/problem/B" target="_blank" rel="noopener">1148B</a>：在一次转机的旅行中，取消 $k$ 个航班，使得旅客最晚达到终点</h3><blockquote>
<p>一开始被卡住了，想一下子吃个胖子 0.0 其实枚举起点取消的航班数，然后取最大值即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m,ta,tb,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;ta&gt;&gt;tb&gt;&gt;k;</span><br><span class="line">	<span class="keyword">int</span> a[n],b[m];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		a[i]+=ta;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=k||m&lt;=k)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;++i)&#123;</span><br><span class="line">			<span class="keyword">int</span> id = lower_bound(b,b+m,a[i])-b;</span><br><span class="line">			<span class="keyword">if</span>(id+k-i&gt;=m)&#123;</span><br><span class="line">				ans = <span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans,tb+b[id+k-i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1251F-组成周长固定的先单调递增后单调递减的序列"><a href="#1251F-组成周长固定的先单调递增后单调递减的序列" class="headerlink" title="1251F:  组成周长固定的先单调递增后单调递减的序列"></a><a href="https://codeforces.com/contest/1251/problem/F" target="_blank" rel="noopener">1251F</a>:  组成周长固定的先单调递增后单调递减的序列</h3><blockquote>
<p>很快就能想到周长为 $2(L+x)$，其中 $L,x$ 分别表示序列最大值和长度。一开始想不明白的地方在于，如果有两个长度相同的怎么计数，后来发现相同的可以标记一个只能放左边，另一个只能放右边。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> LL M = <span class="number">998244353</span>,ROOT=<span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powmod</span><span class="params">(LL x,LL n)</span></span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%M;</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>; x=x*x%M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i!=a.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;j) swap(a[i],a[j]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l=a.<span class="built_in">size</span>()&gt;&gt;<span class="number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; &amp;a,<span class="keyword">bool</span> isInverse=<span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">	LL g = powmod(ROOT,(M<span class="number">-1</span>)/a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">		g = powmod(g,M<span class="number">-2</span>);</span><br><span class="line">		LL invLen = powmod(LL(a.<span class="built_in">size</span>()),M<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) x=x*invLen%M;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(a);</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(),<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=w.<span class="built_in">size</span>();++i) w[i] = w[i<span class="number">-1</span>]*g%M;</span><br><span class="line">	<span class="keyword">auto</span> addMod = [](LL x,LL y)&#123;<span class="keyword">return</span> (x+=y)&gt;=M?x-=M:x;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">2</span>,half = <span class="number">1</span>;half!=a.<span class="built_in">size</span>();<span class="built_in">step</span>&lt;&lt;=<span class="number">1</span>,half&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=a.<span class="built_in">size</span>();i+=<span class="built_in">step</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j!=half;++j)&#123;</span><br><span class="line">				LL t = (a[i+j+half]*w[a.<span class="built_in">size</span>()/<span class="built_in">step</span>*j])%M;</span><br><span class="line">				a[i+j+half]=addMod(a[i+j],M-t);</span><br><span class="line">				a[i+j]=addMod(a[i+j],t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;LL&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; a,<span class="built_in">vector</span>&lt;LL&gt; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz=<span class="number">1</span>,tot = a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(sz&lt;tot) sz*=<span class="number">2</span>;</span><br><span class="line">	a.resize(sz);b.resize(sz);</span><br><span class="line">	nft(a);nft(b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=sz;++i) a[i] = a[i]*b[i]%M;</span><br><span class="line">	nft(a,<span class="number">1</span>);</span><br><span class="line">	a.resize(tot);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">2</span>;</span><br><span class="line">LL fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) fac[i] = fac[i<span class="number">-1</span>]*i%M;</span><br><span class="line">	ifac[N<span class="number">-1</span>] = powmod(fac[N<span class="number">-1</span>],M<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>;i;--i) ifac[i<span class="number">-1</span>] = ifac[i]*i%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fac[n]*ifac[k]%M*ifac[n-k]%M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">int</span> n,k,x,q;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">int</span> cnt[N] = &#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		++cnt[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;LL&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>*N)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		<span class="keyword">int</span> c1=<span class="number">0</span>,c2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;x;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cnt[i]&gt;<span class="number">1</span>) c2+=<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(cnt[i]==<span class="number">1</span>) ++c1;</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;LL&gt; a(c1+1),b(c2+1);</span><br><span class="line">		<span class="keyword">auto</span> inc = [](LL &amp;a,LL b)&#123;<span class="keyword">if</span>((a+=b)&gt;=M) a-=M;&#125;;</span><br><span class="line">		LL p2=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=c1;++i)&#123;</span><br><span class="line">			a[i] = binom(c1,i)*p2%M;</span><br><span class="line">			inc(p2,p2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=c2;++i) b[i] = binom(c2,i);</span><br><span class="line">		a = mul(a,b);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=a.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">			inc(ans[i+x+<span class="number">1</span>],a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans[x/<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1251E-花最少的钱，让所有人都投票给自己（选民跟风且贪财）"><a href="#1251E-花最少的钱，让所有人都投票给自己（选民跟风且贪财）" class="headerlink" title="1251E:  花最少的钱，让所有人都投票给自己（选民跟风且贪财）"></a><a href="https://codeforces.com/contest/1251/problem/E2" target="_blank" rel="noopener">1251E</a>:  花最少的钱，让所有人都投票给自己（选民跟风且贪财）</h3><blockquote>
<p>我们按照 $m$ 分层，然后从大到小记录白嫖的人，然后实在没法白嫖的，就取消费最少的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[n];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,x,y;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			a[x].emplace_back(y);</span><br><span class="line">		&#125;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">         <span class="comment">// q 也可以用 multiset 取代，会稍微快点</span></span><br><span class="line">		priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q; <span class="comment">//白嫖的votes</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a[i]) q.push(x);</span><br><span class="line">			<span class="keyword">while</span>(n-q.<span class="built_in">size</span>()&lt;i)&#123;</span><br><span class="line">				r+=q.top();</span><br><span class="line">				q.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1375D-MEX-once-more，通过修改数组的某一个值成-mex，使得数组最终非降"><a href="#1375D-MEX-once-more，通过修改数组的某一个值成-mex，使得数组最终非降" class="headerlink" title="1375D: MEX once more，通过修改数组的某一个值成 mex，使得数组最终非降"></a><a href="https://codeforces.com/contest/1375/problem/D" target="_blank" rel="noopener">1375D</a>: MEX once more，通过修改数组的某一个值成 mex，使得数组最终非降</h3><blockquote>
<p>不妨最终变成 <code>0~n-1</code>，这是不好想的，特别是紧张的比赛的时候</p>
</blockquote>
<p>如果当前<code>mex = n</code> 即数列正好是一个排列，此时选择任意一个<code>a[i]!=i</code> 的位置，让 <code>a[i]=n</code>，否则 <code>mex &lt; n</code> 此时令<code>a[mex]=n</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin)</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">int</span> a[n],v[n],c[n+<span class="number">1</span>]=&#123;&#125;,<span class="built_in">step</span>=n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">			++c[a[i]];</span><br><span class="line">			v[i] = (a[i]==i);</span><br><span class="line">			<span class="keyword">if</span>(v[i]) --<span class="built_in">step</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">		<span class="keyword">int</span> mex = <span class="number">0</span>,l=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(c[mex]) ++mex;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">step</span>--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mex == n)&#123;</span><br><span class="line">				<span class="keyword">while</span>(v[l]) ++l;</span><br><span class="line">				q.push_back(l+<span class="number">1</span>);</span><br><span class="line">				--c[a[l]];</span><br><span class="line">				++c[mex];</span><br><span class="line">				mex = a[l];</span><br><span class="line">				a[l] = n;</span><br><span class="line">			&#125;</span><br><span class="line">			++c[mex];</span><br><span class="line">			<span class="keyword">int</span> nmex = mex;</span><br><span class="line">			<span class="keyword">if</span>(--c[a[mex]]==<span class="number">0</span>&amp;&amp;a[mex]&lt;mex)&#123;</span><br><span class="line">				nmex = a[mex];</span><br><span class="line">			&#125;</span><br><span class="line">			a[mex] = mex;</span><br><span class="line">			v[mex] = <span class="literal">true</span>;</span><br><span class="line">			q.push_back(mex+<span class="number">1</span>);</span><br><span class="line">			mex = nmex;</span><br><span class="line">			<span class="keyword">while</span>(c[mex]) ++mex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:q) <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面算法过度追求效率而丢失了可读性。其实可以缩短一半代码量</p>
</blockquote>
<h3 id="1119C-选取-4-个角，反位，使得-A-矩阵变成-B-矩阵"><a href="#1119C-选取-4-个角，反位，使得-A-矩阵变成-B-矩阵" class="headerlink" title="1119C: 选取 4 个角，反位，使得 A 矩阵变成 B 矩阵"></a><a href="https://codeforces.com/contest/1119/problem/c" target="_blank" rel="noopener">1119C</a>: 选取 4 个角，反位，使得 A 矩阵变成 B 矩阵</h3><blockquote>
<p>把 A，B 异或到 A，然后就转化成 A 矩阵变成 0 矩阵的方案了。这个时候一行行的处理就搞定了！（一开始就是没思路，后来灵光一闪）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">502</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i][j])&#123;</span><br><span class="line">				++cnt;</span><br><span class="line">				<span class="keyword">if</span>(i!=n)&#123;</span><br><span class="line">					a[i+<span class="number">1</span>][j]^=a[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(i==n) <span class="keyword">return</span> cnt==<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin)</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,x;j&lt;=m;++j)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			a[i][j]^=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;(f(n,m)?<span class="string">"Yes"</span>:<span class="string">"No"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1110：打麻将-0-0"><a href="#1110：打麻将-0-0" class="headerlink" title="1110：打麻将 0.0"></a><a href="https://codeforces.com/contest/1110/problem/D" target="_blank" rel="noopener">1110</a>：打麻将 0.0</h3><blockquote>
<p>就是计算最容易听牌的数量，ABC 和 AAA 的个数和</p>
</blockquote>
<p>考虑 <code>ans[n][i][j]</code> 表示只考虑小于 <code>n</code> 的情况下，有 <code>i</code> 个 <code>(n-1,n)</code>和 <code>j</code> 个 <code>n</code> 剩余的答案。由于三个 <code>(n,n+1,n+2)</code> 可以转化成 <code>(n,n,n),(n+1,n+1,n+1),(n+2,n+2,n+2)</code>，所以 <code>i,j</code> 都小于 3。且 <code>ans[n+1][j][k] = max(ans[n][i][j]+i+(c[n+1]-i-j-k)/3)</code>，最后可以优化一下空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin)</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cnt,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cnt&gt;&gt;m;</span><br><span class="line">	<span class="keyword">int</span> c[m+<span class="number">1</span>]=&#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;cnt;++i)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		++c[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> dp[<span class="number">3</span>][<span class="number">3</span>],new_dp[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;m;++n)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(new_dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(new_dp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;++k)&#123;</span><br><span class="line">					<span class="keyword">if</span>(i+j+k&lt;=c[n+<span class="number">1</span>]&amp;&amp;dp[i][j]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">						new_dp[j][k] = <span class="built_in">max</span>(new_dp[j][k],dp[i][j]+i+(c[n+<span class="number">1</span>]-i-j-k)/<span class="number">3</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(new_dp,dp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1371E：给定长为-n-的数组和素数-p-，记满足-x-i-lt-a-sigma-i-0-leq-i-lt-n-的排列个数为-f-x-，输出所有-x-使得-p-not-n"><a href="#1371E：给定长为-n-的数组和素数-p-，记满足-x-i-lt-a-sigma-i-0-leq-i-lt-n-的排列个数为-f-x-，输出所有-x-使得-p-not-n" class="headerlink" title="1371E：给定长为 $n$ 的数组和素数 $p$，记满足 $x+i &lt; a_{\sigma(i)},0\leq i&lt;n$ 的排列个数为 $f(x)$，输出所有 $x$ 使得 $p \not | n$"></a><a href="https://codeforces.com/contest/1371/problem/E2" target="_blank" rel="noopener">1371E</a>：给定长为 $n$ 的数组和素数 $p$，记满足 $x+i &lt; a_{\sigma(i)},0\leq i&lt;n$ 的排列个数为 $f(x)$，输出所有 $x$ 使得 $p \not | n$</h3><blockquote>
<p>先排序，并且注意到 $x \in (\max a_i-n,\max a_i+n)$ 之间。</p>
</blockquote>
<p>记 $b_i$ 为数组中小于等于 $i$ 的元素个数。则 $f(x) = \prod\limits_{i=x}^{x+n-1} b_i-(i-x) = \prod \limits_{i=x}^{x+n-1} x-(i-b_i)$，所以我们预处理出 $i-b_i$ 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,p;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line">	<span class="keyword">int</span> a[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">int</span> mx = *max_element(a,a+n);</span><br><span class="line">	<span class="keyword">int</span> bb[n*<span class="number">2</span>+<span class="number">2</span>]=&#123;&#125;;</span><br><span class="line">	<span class="keyword">int</span> lx = mx-n;</span><br><span class="line">	<span class="keyword">int</span> *b = bb - lx; <span class="comment">// 黑科技，哈哈</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) ++b[<span class="built_in">max</span>(lx,a[i])];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n*<span class="number">2</span>+<span class="number">2</span>;++i) bb[i]+=bb[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">int</span> mp[n]=&#123;&#125;;</span><br><span class="line">	<span class="keyword">auto</span> modp = [](<span class="keyword">int</span> x,<span class="keyword">int</span> p)&#123;</span><br><span class="line">		x%=p;</span><br><span class="line">		<span class="keyword">return</span> x&lt;<span class="number">0</span>?x+p:x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lx;i&lt;=mx;++i)&#123;</span><br><span class="line">		++mp[modp(i-b[i],p)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=lx;i&lt;=mx;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(mp[modp(i,p)]==<span class="number">0</span>)&#123;</span><br><span class="line">			q.emplace_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		--mp[modp(i-b[i],p)];</span><br><span class="line">		++mp[modp(i+n-b[i+n],p)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=q.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;q[i]&lt;&lt;<span class="string">" \n"</span>[i == q.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1245F：经典-XOR-递归"><a href="#1245F：经典-XOR-递归" class="headerlink" title="1245F：经典 XOR 递归"></a><a href="https://codeforces.com/contest/1245/problem/F" target="_blank" rel="noopener">1245F</a>：经典 XOR 递归</h3><blockquote>
<p>在区间 <code>[l,r)</code> 中找 <code>(a,b)</code> 使得 $a+b = a \wedge b$ 的个数 $f(l,r)$。</p>
</blockquote>
<p>显然，$f(x,x) = 0 \; (x\neq 0),\; f(2l,2r) = 3f(l,r)$，若 $l$ 为奇数，那么 $f(l,r) = f(l+1,r) + 2(g(l,r)-g(l,l))-(l==0)$，若 $r$ 为奇数，那么 $f(l,r) = f(l,r-1) + 2(g(r-1,r)-g(r-1,l))-(r==1)$ 。其中 $g(x,n)$ 表示满足下式的 $y$ 的个数：</p>
<script type="math/tex; mode=display">
0 \leq y < n ,\; x+y = x \wedge y</script><p>通过比较 $x,n$ 的二进制，$g(x,n)$ 的计算是容易计算的的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; g = [&amp;](<span class="keyword">int</span> x ,<span class="keyword">int</span> n)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ret = <span class="number">1</span>,zeros=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(n&amp;i)&#123;</span><br><span class="line">				n^=i;</span><br><span class="line">				<span class="keyword">if</span>(!(x&amp;n)) ret += <span class="number">1</span>&lt;&lt;zeros;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!(x&amp;i)) ++zeros;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;;</span><br><span class="line">	function&lt;LL(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; f = [&amp;](<span class="keyword">int</span> l ,<span class="keyword">int</span> r)-&gt;LL&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		LL ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			ret += (g(l,r)-g(l,l))*<span class="number">2</span>-(l==<span class="number">0</span>);</span><br><span class="line">			++l;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(r&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			ret += (g(r<span class="number">-1</span>,r)-g(r<span class="number">-1</span>,l))*<span class="number">2</span>-(r==<span class="number">1</span>);</span><br><span class="line">			--r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret + <span class="number">3</span>*f(l/<span class="number">2</span>,r/<span class="number">2</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;f(l,r+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1373F：-f-x-表示非负整数-x-的十进制表示的各位数之和。求最小的非负整数-x-使得-sum-i-0-k-f-x-i-n"><a href="#1373F：-f-x-表示非负整数-x-的十进制表示的各位数之和。求最小的非负整数-x-使得-sum-i-0-k-f-x-i-n" class="headerlink" title="1373F：$f(x)$ 表示非负整数 $x$ 的十进制表示的各位数之和。求最小的非负整数 $x$ 使得 $\sum_{i=0} ^k f(x+i) = n$"></a><a href="https://codeforces.com/contest/1373/problem/E" target="_blank" rel="noopener">1373F</a>：$f(x)$ 表示非负整数 $x$ 的十进制表示的各位数之和。求最小的非负整数 $x$ 使得 $\sum_{i=0} ^k f(x+i) = n$</h3><p>由于 $0 \leq k \leq 9$，也就是说 $x,x+1,\cdots,x+k$，的个位数各不相同。我们可以枚举 $x$ 的个位数，那么 $x/10,\cdots, (x+k)/10$，最多仅有两种取值。若只有一种，即没有进位（不能为 9），那么直接就可以把 $x$ 的位数和求出来，否则 $x/10$ 的个数必为 9。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = <span class="number">1e17</span>+<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">auto</span> csum = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">		<span class="keyword">return</span> (a+b)*(b-a+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> f = [](<span class="keyword">int</span> n)&#123;</span><br><span class="line">		LL r = <span class="number">0</span>,d = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(n&gt;<span class="number">9</span>)&#123;</span><br><span class="line">			r+=<span class="number">9</span>*d;</span><br><span class="line">			d*=<span class="number">10</span>;</span><br><span class="line">			n-=<span class="number">9</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r+n*d;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> g = [&amp;](<span class="keyword">int</span> a,<span class="keyword">int</span> k,<span class="keyword">int</span> n) -&gt; LL&#123;</span><br><span class="line">		LL r = <span class="number">0</span>,d = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;a) <span class="keyword">return</span> inf;</span><br><span class="line">		<span class="keyword">while</span>((n-a)%k)&#123;</span><br><span class="line">			n-=<span class="number">9</span>*(k-a);</span><br><span class="line">			r+=d*<span class="number">9</span>;</span><br><span class="line">			d*=<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span>(n&lt;a) <span class="keyword">return</span> inf;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r+d*(f((n-a)/k+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n,k;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;f(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k*(k<span class="number">-1</span>)/<span class="number">2</span> &gt; n)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LL r = inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i+k&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">				<span class="keyword">int</span> t = csum(i,i+k);</span><br><span class="line">				<span class="keyword">if</span>(n&gt;=t&amp;&amp;(n-t)%(k+<span class="number">1</span>)==<span class="number">0</span>) r = <span class="built_in">min</span>(r,<span class="number">10</span>*f((n-t)/(k+<span class="number">1</span>))+i);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">int</span> t = csum(i,<span class="number">9</span>)+csum(<span class="number">0</span>,i+k<span class="number">-10</span>);</span><br><span class="line">				<span class="keyword">if</span>(n&gt;=t) r = <span class="built_in">min</span>(r,<span class="number">10</span>*g(i+k<span class="number">-9</span>,k+<span class="number">1</span>,n-t)+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(r==inf? <span class="number">-1</span>:r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上代码按照时间顺序(2020/6/25——now)倒序，以下代码按照时间顺序(2020/5/22 —— 2020/6/25)排序</strong></p>
<h3 id="1355B-：贪心模仿加法进位"><a href="#1355B-：贪心模仿加法进位" class="headerlink" title="1355B ：贪心模仿加法进位"></a><a href="https://codeforces.com/contest/1355/problem/B" target="_blank" rel="noopener">1355B</a> ：贪心模仿加法进位</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		x+=a[i];</span><br><span class="line">		ans+=x/i;</span><br><span class="line">		x%=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas,n,x;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			++a[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;getans(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1354C-：计算包含单位正-n-边形的最小正方形的边长"><a href="#1354C-：计算包含单位正-n-边形的最小正方形的边长" class="headerlink" title="1354C  ：计算包含单位正 $n$ 边形的最小正方形的边长"></a><a href="https://codeforces.com/problemset/problem/1354/C2" target="_blank" rel="noopener">1354C</a>  ：计算包含单位正 $n$ 边形的最小正方形的边长</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas,n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="built_in">cout</span>.precision(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">double</span> x = <span class="built_in">sqrt</span>(<span class="number">1</span>-<span class="built_in">cos</span>((n/<span class="number">2</span>)*pi/n));</span><br><span class="line">			<span class="keyword">double</span> y = <span class="built_in">sqrt</span>(<span class="number">1</span>-<span class="built_in">cos</span>((n/<span class="number">2</span>+<span class="number">1</span>)*pi/n));</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;(x+y)/<span class="number">2</span>/<span class="built_in">sin</span>(pi/<span class="number">2</span>/n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">1.0</span>/<span class="built_in">tan</span>(pi/<span class="number">2</span>/n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1354D-：模拟操作：-加数字或删除第-k-小的数"><a href="#1354D-：模拟操作：-加数字或删除第-k-小的数" class="headerlink" title="1354D ：模拟操作： 加数字或删除第 $k$ 小的数"></a><a href="https://codeforces.com/problemset/problem/1354/D" target="_blank" rel="noopener">1354D</a> ：模拟操作： 加数字或删除第 $k$ 小的数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> s[N], Size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (id &lt;= Size) &#123;</span><br><span class="line">		s[id] += p;</span><br><span class="line">		id += lowbit(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (id) &#123;</span><br><span class="line">		r += s[id];</span><br><span class="line">		id -= lowbit(id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = Size;</span><br><span class="line">	<span class="keyword">while</span> (r&gt;l) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (sum(m) &gt;= k) r = m;</span><br><span class="line">		<span class="keyword">else</span> l = m+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	add(<span class="built_in">find</span>(k), <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> q, x;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; Size &gt;&gt; q) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Size; ++i) s[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Size; ++i) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			add(x, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (x &gt; <span class="number">0</span>) add(x, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				del(-x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;(sum(ans)&gt;<span class="number">0</span>?ans:<span class="number">0</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1354F-：经典-DP-问题"><a href="#1354F-：经典-DP-问题" class="headerlink" title="1354F ：经典 DP 问题"></a><a href="https://codeforces.com/problemset/problem/1354/F" target="_blank" rel="noopener">1354F</a> ：经典 DP 问题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">bool</span> isin[N][N],chose[N];</span><br><span class="line"><span class="keyword">using</span> node = tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line">node q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+(k<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;i &amp;&amp; j&lt;=k;++j)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = dp[i<span class="number">-1</span>][j]+(k<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i]);</span><br><span class="line">			<span class="keyword">int</span> y = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(j<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i])+<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(q[i]);</span><br><span class="line">			<span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">				dp[i][j] = x;</span><br><span class="line">				isin[i][j] = <span class="literal">false</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[i][j] = y;</span><br><span class="line">				isin[i][j] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=k)&#123;</span><br><span class="line">			dp[i][i] = dp[i<span class="number">-1</span>][i<span class="number">-1</span>]+(i<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i])+<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(q[i]);</span><br><span class="line">			isin[i][i] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n,j=k;i;--i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isin[i][j])&#123;</span><br><span class="line">			chose[i]=<span class="literal">true</span>;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			chose[i]=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas,n,k,a,b;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			q[i] = &#123;i,a,b&#125;;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">		sort(q+<span class="number">1</span>,q+n+<span class="number">1</span>,[](<span class="keyword">const</span> node &amp; x, <span class="keyword">const</span> node &amp; y)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(x)&lt;<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(y);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(<span class="number">2</span>*n-k)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		getans(n,k);</span><br><span class="line">		<span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(chose[i])&#123;</span><br><span class="line">				<span class="keyword">if</span>(++last == k)&#123;</span><br><span class="line">					last = i;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!chose[i])  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>&lt;&lt;-<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[last])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1345F-：经典二分，利用二阶偏导（离散偏导，即增量）是常量"><a href="#1345F-：经典二分，利用二阶偏导（离散偏导，即增量）是常量" class="headerlink" title="1345F ：经典二分，利用二阶偏导（离散偏导，即增量）是常量"></a><a href="https://codeforces.com/problemset/problem/1345/F" target="_blank" rel="noopener">1345F</a> ：经典二分，利用二阶偏导（离散偏导，即增量）是常量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	LL k,x;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;LL&gt; q;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			q.push_back(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> <span class="built_in">get</span> = [](LL x ,LL mx)&#123;</span><br><span class="line">			LL l=<span class="number">0</span>,r=x<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">				LL m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(x-m*(m+<span class="number">1</span>)*<span class="number">3</span> == mx)  <span class="keyword">return</span> make_pair(m,m+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(x-m*(m+<span class="number">1</span>)*<span class="number">3</span> &gt; mx)  l = m+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span>  r = m<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> make_pair(l,l);</span><br><span class="line">		&#125;;</span><br><span class="line">		LL l = <span class="number">-3e18</span><span class="number">-3e8</span>, r = <span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">			LL m = (l+r)&gt;&gt;<span class="number">1</span>,x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:q)&#123;</span><br><span class="line">				<span class="keyword">auto</span> tmp = <span class="built_in">get</span>(i,m);</span><br><span class="line">				x+=tmp.first;</span><br><span class="line">				y+=tmp.second;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(x&gt;k) l = m+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(y&lt;k) r = m<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				y-=k;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:q)&#123;</span><br><span class="line">					<span class="keyword">auto</span> tmp = <span class="built_in">get</span>(i,m);</span><br><span class="line">					<span class="comment">//cout&lt;&lt;endl&lt;&lt;tmp.first&lt;&lt;" "&lt;&lt;tmp.second&lt;&lt;endl;;</span></span><br><span class="line">					<span class="keyword">if</span>(tmp.first&lt;tmp.second &amp;&amp; y--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">						<span class="built_in">cout</span>&lt;&lt;tmp.first&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="built_in">cout</span>&lt;&lt;tmp.second&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1325B：Set-的用法举例"><a href="#1325B：Set-的用法举例" class="headerlink" title="1325B：Set 的用法举例"></a><a href="https://codeforces.com/problemset/problem/1325/B" target="_blank" rel="noopener">1325B</a>：Set 的用法举例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas,n,x;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			q.insert(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1325D：（异或）位运算：判断是否有-n-个数，异或和为-u-和为-v"><a href="#1325D：（异或）位运算：判断是否有-n-个数，异或和为-u-和为-v" class="headerlink" title="1325D：（异或）位运算：判断是否有 $n$ 个数，异或和为 $u$, 和为 $v$"></a><a href="https://codeforces.com/contest/1325/problem/D" target="_blank" rel="noopener">1325D</a>：（异或）位运算：判断是否有 $n$ 个数，异或和为 $u$, 和为 $v$</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	LL u,v;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v)&#123;</span><br><span class="line">		<span class="keyword">if</span>(u&gt;v||((v-u)&amp;<span class="number">1</span>))&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(u == v)&#123;</span><br><span class="line">			<span class="keyword">if</span>(u)  <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;u&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			v = (v-u)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(u&amp;v) <span class="built_in">cout</span>&lt;&lt;<span class="number">3</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;u&lt;&lt;<span class="string">" "</span>&lt;&lt;v&lt;&lt;<span class="string">" "</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;u+v&lt;&lt;<span class="string">" "</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到 $a+b = a \wedge b + 2(a \&amp; b)$，并且 $(a \wedge b) \&amp; (a\&amp;b) = 0$ 当且仅当 $a b = 0$</p>
</blockquote>
<h3 id="1358D：给定区间最值问题，但是可以写的很漂亮"><a href="#1358D：给定区间最值问题，但是可以写的很漂亮" class="headerlink" title="1358D：给定区间最值问题，但是可以写的很漂亮"></a><a href="https://codeforces.com/problemset/problem/1358/D" target="_blank" rel="noopener">1358D</a>：给定区间最值问题，但是可以写的很漂亮</h3><blockquote>
<p>注意到区间最值一定在左或者右端点达到局部最大值（极值）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">102</span>;</span><br><span class="line"><span class="keyword">int</span> n,n2;</span><br><span class="line">LL a[N],b[N],s[N];</span><br><span class="line"><span class="function">LL <span class="title">f</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((x+<span class="number">1</span>)*x)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sumx</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> it = lower_bound(b,b+n2,x) - b;</span><br><span class="line">    <span class="comment">// 这里注意是it, 比赛的时候没减，搞得怀疑人生</span></span><br><span class="line">	<span class="keyword">return</span> s[it<span class="number">-1</span>]+f(x-b[it<span class="number">-1</span>]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	LL d;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;d;</span><br><span class="line">	n2=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		a[i+n] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	b[<span class="number">0</span>] = a[<span class="number">0</span>];s[<span class="number">0</span>] = f(a[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n2;++i)&#123;</span><br><span class="line">		b[i]=b[i<span class="number">-1</span>]+a[i];</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+f(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans,sumx(b[i]+d<span class="number">-1</span>)-s[i]+a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;n2;++i)&#123;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans,s[i]-sumx(b[i]-d));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1358E：很有意思的数据处理题目，官方题解"><a href="#1358E：很有意思的数据处理题目，官方题解" class="headerlink" title="1358E：很有意思的数据处理题目，官方题解"></a><a href="https://codeforces.com/problemset/problem/1358/E" target="_blank" rel="noopener">1358E</a>：很有意思的数据处理题目，<a href="https://codeforces.com/blog/entry/77869" target="_blank" rel="noopener">官方题解</a></h3><blockquote>
<p>注意到如果 $k$ 满足答案，则 $2k$ 也满足，所以不妨设 $k&gt; \lfloor \frac{n}{2} \rfloor$，另一方面题目中要求若 $i&gt;  \lceil \frac{n}{2} \rceil$，则 $a_{i} = x$</p>
</blockquote>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line">LL a[N],s[N],m[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">int</span> n2 = (n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	LL x;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n2+<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		a[i]=x;</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)&#123;</span><br><span class="line">		m[i+<span class="number">1</span>] = <span class="built_in">min</span>(m[i],x*i-s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=n2;k&lt;=n;++k)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[k]+m[n-k+<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1359C-读题被坑…-反正就是倒冷热水接近给定温度）"><a href="#1359C-读题被坑…-反正就是倒冷热水接近给定温度）" class="headerlink" title="1359C:  读题被坑…(反正就是倒冷热水接近给定温度）"></a><a href="https://codeforces.com/contest/1359/problem/C" target="_blank" rel="noopener">1359C</a>:  读题被坑…(反正就是倒冷热水接近给定温度）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="keyword">int</span> h,t,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;h&gt;&gt;c&gt;&gt;t;</span><br><span class="line">		h-=c;t-=c;</span><br><span class="line">		<span class="keyword">if</span>(h&gt;=<span class="number">2</span>*t)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			LL n = (h-t)/(<span class="number">2</span>*t-h);</span><br><span class="line">			<span class="keyword">auto</span> f = [](LL n,<span class="keyword">int</span> h,<span class="keyword">int</span> t)&#123;</span><br><span class="line">				<span class="keyword">return</span> (n+<span class="number">1</span>)*(<span class="number">2</span>*n+<span class="number">3</span>)*h+(<span class="number">2</span>*n+<span class="number">1</span>)*(n+<span class="number">2</span>)*h&gt;(<span class="number">2</span>*n+<span class="number">1</span>)*(<span class="number">2</span>*n+<span class="number">3</span>)*t*<span class="number">2</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">if</span>(f(n,h,t)) ++n;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>*n+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后对于奇数项，单调递减趋于平均问题，然后判断的时候转化成整数的判断</p>
</blockquote>
<h3 id="1359D：线段树，但是由于数据特殊，可以不用线段树"><a href="#1359D：线段树，但是由于数据特殊，可以不用线段树" class="headerlink" title="1359D：线段树，但是由于数据特殊，可以不用线段树"></a><a href="https://codeforces.com/contest/1359/problem/D" target="_blank" rel="noopener">1359D</a>：线段树，但是由于数据特殊，可以不用线段树</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;=<span class="number">30</span>;++m)&#123;</span><br><span class="line">		<span class="keyword">int</span> suml =<span class="number">0</span>,sum=<span class="number">0</span>,maxa = <span class="number">-31</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;m)&#123;</span><br><span class="line">				sum = suml = <span class="number">0</span>;</span><br><span class="line">				maxa = <span class="number">-31</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				sum+=a[i];</span><br><span class="line">				<span class="comment">//这里取全局最大是因为，我们枚举了最大值的可能</span></span><br><span class="line">				maxa = <span class="built_in">max</span>(maxa,a[i]);</span><br><span class="line">				ans = <span class="built_in">max</span>(ans,sum-suml-maxa);</span><br><span class="line">				<span class="comment">//相当于前面是全0的部分删了！并且这样不会避免中间负的情况</span></span><br><span class="line">				suml = <span class="built_in">min</span>(sum,suml);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到 $-30&lt;a_i&lt;30 $</p>
</blockquote>
<h3 id="1359E：找到公式后就是模素数组合数"><a href="#1359E：找到公式后就是模素数组合数" class="headerlink" title="1359E：找到公式后就是模素数组合数"></a><a href="https://codeforces.com/contest/1359/problem/E" target="_blank" rel="noopener">1359E</a>：找到公式后就是模素数组合数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line">LL inv[N],frac[N];</span><br><span class="line"><span class="function">LL <span class="title">powmod</span><span class="params">(LL x, LL n, LL p)</span> </span>&#123;</span><br><span class="line">	LL r=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		x=x*x%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	frac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">		frac[i] = frac[i<span class="number">-1</span>]*i%M;</span><br><span class="line">	&#125;</span><br><span class="line">	inv[N<span class="number">-1</span>] = powmod(frac[N<span class="number">-1</span>],M<span class="number">-2</span>,M);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-2</span>;i;--i)&#123;</span><br><span class="line">		inv[i] = inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%M;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==m||m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> frac[n]*inv[m]%M*inv[n-m]%M;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	init();</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = n/i;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;k) <span class="keyword">break</span>;</span><br><span class="line">		ans += C(x<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans%M&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先考虑$k=2$ 的情况知道 $a_1|a_2$，然后发现对于任意$k$，仅需 $a_1|a_i$ 即可。</p>
</blockquote>
<h3 id="1363E：有根数，互换子树的节点位数到预定值，dfs-和图存储范例"><a href="#1363E：有根数，互换子树的节点位数到预定值，dfs-和图存储范例" class="headerlink" title="1363E：有根数，互换子树的节点位数到预定值，dfs 和图存储范例"></a><a href="https://codeforces.com/contest/1363/problem/E" target="_blank" rel="noopener">1363E</a>：有根数，互换子树的节点位数到预定值，dfs 和图存储范例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="comment">// head[u] 和 cnt 的初始值都为 -1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">bool</span> b[N],c[N];</span><br><span class="line"></span><br><span class="line">tuple&lt;int,int,LL&gt; dfs(int u,int parent,int mn)&#123;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">	LL cost=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(b[u]!=c[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(b[u]) ++l;</span><br><span class="line">		<span class="keyword">else</span> ++r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:g[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v == parent) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">auto</span> [sl,sr,scost] = dfs(v,u,<span class="built_in">min</span>(mn,a[u]));</span><br><span class="line">		l+=sl;r+=sr;cost+=scost;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a[u]&lt;mn)&#123;</span><br><span class="line">		<span class="keyword">int</span> take = <span class="built_in">min</span>(l,r);</span><br><span class="line">		cost += LL(a[u])*(take*<span class="number">2</span>);</span><br><span class="line">		l -= take;</span><br><span class="line">		r -= take;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;l,r,cost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,u,v;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		g[u].push_back(v);</span><br><span class="line">		g[v].push_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> [l,r,cost] = dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2e9</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;(l||r?<span class="number">-1</span>:cost)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码写得呢，就很优雅，哈哈！</p>
</blockquote>
<h3 id="1361E-：下面代码至今没过我也是没懂为什么"><a href="#1361E-：下面代码至今没过我也是没懂为什么" class="headerlink" title="1361E ：下面代码至今没过我也是没懂为什么"></a>1361E ：下面代码至今没过我也是没懂为什么</h3><blockquote>
<p>模仿进制的操作，最后用其他代码过的题。多设几个变量没坏处的其实。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">LL a[N],p;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">powmod</span><span class="params">(T x,U n,T p)</span></span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;  x=x*x%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas,n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;(n&amp;<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">		LL ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans==<span class="number">0</span>)&#123;</span><br><span class="line">				ans = <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[n]==a[n<span class="number">-1</span>]) --ans;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">while</span>(a[n]&gt;a[n<span class="number">-1</span>])&#123;</span><br><span class="line">						ans*=p;</span><br><span class="line">						--a[n];</span><br><span class="line">						<span class="keyword">if</span>(ans&gt;n) <span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(a[n]!=a[n<span class="number">-1</span>]) <span class="keyword">break</span>;</span><br><span class="line">					--ans;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			--n;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = ans%M*powmod(p,a[n],M)%M;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">			ans-=powmod(p,a[i],M);</span><br><span class="line">		&#125;</span><br><span class="line">		ans = (M+ans%M)%M;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1349F-：神奇的对应"><a href="#1349F-：神奇的对应" class="headerlink" title="1349F ：神奇的对应"></a><a href="https://codeforces.com/contest/1349/problem/F1" target="_blank" rel="noopener">1349F</a> ：神奇的对应</h3><p>我们称一个长度为 $n$ 的序列 $p$ 为<strong>好序列</strong>，如果对任意正整数$k&gt;1$，存在 $1 \leq i &lt; j \leq n$ 使得，$p_i = k-1, p_j = k$</p>
<p>存在 <strong>好序列</strong> 和长为 $n$ 的排列一一对应：</p>
<ul>
<li>给定排列 $a_1,a_2,\cdots, a_n$ ， 相邻两个之间添加 <code>&gt;</code> 或 <code>&lt;</code> ,那么 $p_{a_i}$ 就定义为 $a_1,\cdots,a_i$ 中 <code>&lt;</code> 个数加一</li>
<li>给定好序列 $p$，从右到左依次标记出 <code>1,2,...</code> ，直到标记完所有数即得到了排列</li>
</ul>
<p>因此 <strong>好序列</strong> 中最大值对应这排列中单调递减区间的个数！</p>
<blockquote>
<p>答案要求的是：所有好序列中出现 $k$ 的个数之和。</p>
</blockquote>
<p>代码下次再写吧…</p>
<h3 id="1365E：这题其实没啥，但是比赛的时候竟然把-想成了-，很烦"><a href="#1365E：这题其实没啥，但是比赛的时候竟然把-想成了-，很烦" class="headerlink" title="1365E：这题其实没啥，但是比赛的时候竟然把 | 想成了 ^ ，很烦"></a><a href="https://codeforces.com/problemset/problem/1365/E" target="_blank" rel="noopener">1365E</a>：这题其实没啥，但是比赛的时候竟然把 <code>|</code> 想成了 <code>^</code> ，很烦</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		LL a[n];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a,a+n,greater&lt;LL&gt;());</span><br><span class="line">		LL ans = a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">2</span>*a[i]&lt;=a[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">				LL t = a[i]|a[j];</span><br><span class="line">				ans = <span class="built_in">max</span>(ans,t);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;n;++k)&#123;</span><br><span class="line">					ans = <span class="built_in">max</span>(ans,t|a[k]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1312D：计算满足条件的数列个数"><a href="#1312D：计算满足条件的数列个数" class="headerlink" title="1312D：计算满足条件的数列个数"></a><a href="https://codeforces.com/contest/1312/problem/D" target="_blank" rel="noopener">1312D</a>：计算满足条件的数列个数</h3><p>计算满足下列条件的数列个数：</p>
<ul>
<li>数列项数为 $n$，且每一项都是不超过 $m$ 的正整数，$2\cdot 10^5 =N&gt;m \geq n \geq 2$</li>
<li>数列中有且仅有两项是相同的</li>
<li>数列在 $i$ 项前严格单调递增，$i$ 项后严格单调递减</li>
</ul>
<p>我们枚举 $i$ 的位置和 $i$ 的值，以及相同的项，则显然有如下计算式</p>
<script type="math/tex; mode=display">
\sum_{i=2} ^ {n-1} \sum_{j=n-1} ^m {j-1 \choose 1} {j-2 \choose i-2} {j-i \choose n-i-1} = \sum_{i=2} ^{n-1} \frac{1}{(i-2)!(n-i-1)} \sum_{j=n-1}^m \frac{(j-1)!}{(j-n+1)!}</script><p>预处理一下阶乘和阶乘逆，我们就可以在 $O(N)$ 解决问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="function">LL <span class="title">powmod</span><span class="params">(LL a,LL n)</span></span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*a%M;</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;  a=a*a%M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">LL fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=N;++i)&#123;</span><br><span class="line">		fac[i] = fac[i<span class="number">-1</span>]*i%M;</span><br><span class="line">	&#125;</span><br><span class="line">	ifac[N<span class="number">-1</span>] = powmod(fac[N<span class="number">-1</span>],M<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-2</span>;~i;--i)&#123;</span><br><span class="line">		ifac[i] = ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%M; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		LL x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">			x+=fac[i<span class="number">-1</span>]*ifac[i-n+<span class="number">1</span>]%M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i)&#123;</span><br><span class="line">			y+=ifac[i<span class="number">-2</span>]*ifac[n-i<span class="number">-1</span>]%M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(x%M)*(y%M)%M&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是<a href="https://codeforces.com/blog/entry/74640" target="_blank" rel="noopener">官方题解</a>给了一个更简单的方法</p>
</blockquote>
<p>首先把 $n=2$ 时无解，所以考虑 $n&gt;2$ 的情况，首先把所有用到的数字选好：$m \choose n-1$，然后选择好相同的数字：$n-2$，然后剩下的非最大的数，要么放在最大的数左边要么放在最大的数右边：$2^{n-3}$，即最终答案是 ${m \choose n-1}(n-2)2^{n-3}$</p>
<h3 id="1312E：经典-DP，解释放在"><a href="#1312E：经典-DP，解释放在" class="headerlink" title="1312E：经典 DP，解释放在 "></a><a href="https://codeforces.com/contest/1312/problem/E" target="_blank" rel="noopener">1312E</a>：经典 DP，解释放在 <a href="/dynamicProgramming/" title="动态规划">动态规划</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1022</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">502</span>][N],b[<span class="number">502</span>][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,x;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(ans,inf,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		ans[<span class="number">0</span>][x] = <span class="number">1</span>;</span><br><span class="line">		b[<span class="number">0</span>][x]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;N;++j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(ans[i<span class="number">-1</span>][j]!=inf)&#123;</span><br><span class="line">					ans[i][x] = <span class="built_in">min</span>(ans[i][x],ans[i<span class="number">-1</span>][j]+<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				b[i][x]=i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> s = i<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">while</span>(s&gt;=<span class="number">0</span>&amp;&amp;ans[s][x]!=inf)&#123;</span><br><span class="line">				ans[i][x+<span class="number">1</span>] = ans[s][x];</span><br><span class="line">				b[i][x+<span class="number">1</span>] = b[s][x];</span><br><span class="line">				s = b[s][x]<span class="number">-1</span>;</span><br><span class="line">				++x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> r = inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">			r = <span class="built_in">min</span>(r,ans[n<span class="number">-1</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1295E：题解，相当精彩的线段树实例"><a href="#1295E：题解，相当精彩的线段树实例" class="headerlink" title="1295E：题解，相当精彩的线段树实例"></a><a href="https://codeforces.com/contest/1295/problem/E" target="_blank" rel="noopener">1295E</a>：<a href="https://codeforces.com/blog/entry/73467" target="_blank" rel="noopener">题解</a>，相当精彩的线段树实例</h3><blockquote>
<p>下面代码取自：<a href="https://codeforces.com/profile/jiangly" target="_blank" rel="noopener">jiangly</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="built_in">min</span>, tag;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">long</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">min</span>[p] += v;</span><br><span class="line">        tag[p] += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        add(<span class="number">2</span> * p, tag[p]);</span><br><span class="line">        add(<span class="number">2</span> * p + <span class="number">1</span>, tag[p]);</span><br><span class="line">        tag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">min</span>[p] = <span class="built_in">std</span>::<span class="built_in">min</span>(<span class="built_in">min</span>[<span class="number">2</span> * p], <span class="built_in">min</span>[<span class="number">2</span> * p + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rangeAdd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y)</span><br><span class="line">            <span class="keyword">return</span> add(p, v);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        push(p);</span><br><span class="line">        rangeAdd(<span class="number">2</span> * p, l, m, x, y, v);</span><br><span class="line">        rangeAdd(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, v);</span><br><span class="line">        pull(p);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SegmentTree(<span class="keyword">int</span> n) : n(n), <span class="built_in">min</span>(<span class="number">4</span> * n), tag(<span class="number">4</span> * n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rangeAdd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        rangeAdd(<span class="number">1</span>, <span class="number">0</span>, n, l, r, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p, a, pos;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    p.resize(n);</span><br><span class="line">    a.resize(n);</span><br><span class="line">    pos.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">        --p[i];</span><br><span class="line">        pos[p[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="function">SegmentTree <span class="title">t</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        t.rangeAdd(pos[i], n - <span class="number">1</span>, a[pos[i]]);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = t.getMin();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        t.rangeAdd(pos[i], n - <span class="number">1</span>, -a[pos[i]]);</span><br><span class="line">        t.rangeAdd(<span class="number">0</span>, pos[i], a[pos[i]]);</span><br><span class="line">        ans = <span class="built_in">std</span>::<span class="built_in">min</span>(ans, t.getMin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1295F：给定区间的非降序列概率（个数）"><a href="#1295F：给定区间的非降序列概率（个数）" class="headerlink" title="1295F：给定区间的非降序列概率（个数）"></a><a href="https://codeforces.com/contest/1295/problem/F" target="_blank" rel="noopener">1295F</a>：给定区间的非降序列概率（个数）</h3><blockquote>
<p>下面代码取自：<a href="https://codeforces.com/profile/jiangly" target="_blank" rel="noopener">jiangly</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> P = <span class="number">998'244'353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="number">1L</span>L * res * a % P;</span><br><span class="line">        a = <span class="number">1L</span>L * a * a % P;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l, r, v, inv, dp;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    l.resize(n);</span><br><span class="line">    r.resize(n);</span><br><span class="line">    v.reserve(<span class="number">2</span> * n);</span><br><span class="line">    inv.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        inv[i] = power(i, P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">        ++r[i];</span><br><span class="line">        v.push_back(l[i]);</span><br><span class="line">        v.push_back(r[i]);</span><br><span class="line">        total = <span class="number">1L</span>L * total * (r[i] - l[i]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    v.erase(<span class="built_in">std</span>::unique(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        l[i] = <span class="built_in">std</span>::lower_bound(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), l[i]) - v.<span class="built_in">begin</span>();</span><br><span class="line">        r[i] = <span class="built_in">std</span>::lower_bound(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), r[i]) - v.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    c.assign(v.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(v.<span class="built_in">size</span>()) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            c[i][j] = <span class="number">1L</span>L * c[i][j - <span class="number">1</span>] * (j - <span class="number">1</span> + v[i + <span class="number">1</span>] - v[i]) % P * inv[j] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    dp.resize(n + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">int</span>(v.<span class="built_in">size</span>()) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = n - <span class="number">1</span>; a &gt;= <span class="number">0</span>; --a) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a; b &lt; n; ++b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; l[b] || i &gt;= r[b])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                dp[b + <span class="number">1</span>] = (dp[b + <span class="number">1</span>] + <span class="number">1L</span>L * dp[a] * c[i][b - a + <span class="number">1</span>]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1L</span>L * dp[n] * power(total, P - <span class="number">2</span>) % P &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1364C：已知-a-i-MEX-b-1-cdots-b-i-为不出现在-b-1-cdots-b-i-中的最小非负整数，在给定-0-leq-a-i-leq-i-a-i-lt-a-i-1-的情况下，给出一种-b-i-的方案"><a href="#1364C：已知-a-i-MEX-b-1-cdots-b-i-为不出现在-b-1-cdots-b-i-中的最小非负整数，在给定-0-leq-a-i-leq-i-a-i-lt-a-i-1-的情况下，给出一种-b-i-的方案" class="headerlink" title="1364C：已知 $a_i=MEX({b_1,\cdots,b_i})$ 为不出现在 $b_1,\cdots,b_i$ 中的最小非负整数，在给定 $0\leq a_i \leq i,a_i&lt;a_{i+1}$ 的情况下，给出一种 $b_i$ 的方案"></a><a href="https://codeforces.com/contest/1364/problem/C" target="_blank" rel="noopener">1364C</a>：已知 $a_i=MEX({b_1,\cdots,b_i})$ 为不出现在 $b_1,\cdots,b_i$ 中的最小非负整数，在给定 $0\leq a_i \leq i,a_i&lt;a_{i+1}$ 的情况下，给出一种 $b_i$ 的方案</h3><p>方案就是：设当前最大值为 $n$，从尾部开始，先标 <code>a[i]</code> 的值被访问，然后看 <code>a[i]</code> 是否等于 <code>a[i-1]</code>，如果是就在没被访问的点中给一个最大给 <code>b[i]</code>，否则 $b[i]=a[i-1]$。然后边界判断！ <code>i=1</code> 时，当作不等处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ma = n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">		v[a[i]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>||a[i]==a[i<span class="number">-1</span>])&#123;</span><br><span class="line">			<span class="keyword">while</span>(ma&gt;=<span class="number">0</span>&amp;&amp;v[ma]) --ma;</span><br><span class="line">			v[ma] = <span class="literal">true</span>;</span><br><span class="line">			b[i] = ma--;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			b[i]=a[i<span class="number">-1</span>];</span><br><span class="line">			v[b[i]]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;b[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codeforc.com/contest/1353/problem/D" target="_blank" rel="noopener">1353D</a>：有趣的标准优先队列+BFS 题目</p>
<blockquote>
<p>初始值为 0 的长度为 n 的数组，每次在连续 0 中长度最大的那一段的中点编号，直到编完。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (r-l)&lt;(A.r-A.l)||((r-l)==(A.r-A.l)&amp;&amp;l&gt;A.l);</span><br><span class="line">	&#125;</span><br><span class="line">	Node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r)&#123;</span><br><span class="line">		l = _l;</span><br><span class="line">		r = _r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		LL n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">int</span> a[n+<span class="number">1</span>];</span><br><span class="line">		priority_queue&lt;Node&gt; q;</span><br><span class="line">		q.push(&#123;<span class="number">1</span>,n&#125;);</span><br><span class="line">		<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">			<span class="keyword">auto</span> u = q.top();</span><br><span class="line">			<span class="keyword">int</span> l=u.l,r=u.r;</span><br><span class="line">			q.pop();</span><br><span class="line">			a[(l+r)/<span class="number">2</span>] = ++now;</span><br><span class="line">			<span class="keyword">if</span>(l==r) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>((r-l)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">				q.push(Node(l,(l+r)/<span class="number">2</span><span class="number">-1</span>));</span><br><span class="line">				q.push(Node((l+r)/<span class="number">2</span>+<span class="number">1</span>,r));</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				q.push(Node((l+r)/<span class="number">2</span>+<span class="number">1</span>,r));</span><br><span class="line">				<span class="keyword">if</span>(l&lt;(l+r)/<span class="number">2</span>) q.push(Node(l,(l+r)/<span class="number">2</span><span class="number">-1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" \n"</span>[i==n];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codeforc.com/contest/1353/problem/E" target="_blank" rel="noopener">1353E</a>：在 <code>01</code>序列中改变最小的位，使得其中的所有 <code>1</code> 都是连续的。</p>
<blockquote>
<p>设 <code>dp[i]</code> 为使得前 <code>i</code> 位中 1 连续出现，且第 <code>i</code> 位为 1 的最小改变位数，状态转移就显然了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n,k;</span><br><span class="line">		<span class="built_in">string</span> a;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;a;</span><br><span class="line">		<span class="keyword">auto</span> solve = [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">			<span class="keyword">int</span> n = s.length();</span><br><span class="line">			<span class="keyword">int</span> all = count(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="string">'1'</span>);</span><br><span class="line">			<span class="keyword">int</span> s1=(s[<span class="number">0</span>]==<span class="string">'1'</span>);</span><br><span class="line">			<span class="keyword">int</span> ans = all-s1,res = <span class="number">1</span>-s1;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">				<span class="keyword">int</span> cur = (s[i]==<span class="string">'1'</span>);</span><br><span class="line">				s1+=cur;</span><br><span class="line">				res = <span class="number">1</span>-cur+<span class="built_in">min</span>(res,s1-cur);</span><br><span class="line">				ans = <span class="built_in">min</span>(ans,res+all-s1);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> all-ans;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">			<span class="built_in">string</span> s;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j+=k)&#123;</span><br><span class="line">				s+=a[j];</span><br><span class="line">			&#125;</span><br><span class="line">			mx = <span class="built_in">max</span>(mx,solve(s));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;count(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="string">'1'</span>)-mx&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1367E：不难但是很有趣的数学题"><a href="#1367E：不难但是很有趣的数学题" class="headerlink" title="1367E：不难但是很有趣的数学题"></a><a href="https://codeforces.com/contest/1367/problem/E" target="_blank" rel="noopener">1367E</a>：不难但是很有趣的数学题</h3><blockquote>
<p>在给定一些元素中取出最大数量构成一个 k 旋转不变的圈</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n,k;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">		<span class="keyword">int</span> c[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:s) ++c[i-<span class="string">'a'</span>];</span><br><span class="line">		sort(c,c+<span class="number">26</span>,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">		<span class="keyword">auto</span> check=[&amp;](<span class="keyword">int</span> m)&#123;</span><br><span class="line">			<span class="keyword">int</span> d = __gcd(m,k);</span><br><span class="line">			<span class="keyword">int</span> md = m/d;</span><br><span class="line">			<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">				x+=c[i]/md;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> x&gt;=d;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">while</span>(!check(n)) --n;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1367F：给定规则最小步骤使得数列有序"><a href="#1367F：给定规则最小步骤使得数列有序" class="headerlink" title="1367F：给定规则最小步骤使得数列有序"></a><a href="https://codeforces.com/problemset/problem/1367/F1" target="_blank" rel="noopener">1367F</a>：给定规则最小步骤使得数列有序</h3><blockquote>
<p>只允许将数列中某一个数最前或者最后，问最少多少步使得数列有序。</p>
</blockquote>
<p>我们称数列中两个数 $a_i \leq a_j$是<strong>相接</strong>的，如果 $i&lt;j$ 且排好序后 $a_i,a_j$ 相邻。那么我们的答案就是 $n-$ 最长相接子列的长度。</p>
<p><strong>原因</strong>：首先它是一个可行的答案，其次答案的方案去掉数列中被移动的数，剩下的数必然是相接的！</p>
<blockquote>
<p>因为数列中的数的大小并不影响结果，影响结果的是相对关系，因此可以通过预处理，让数列的取值范围是一个区间。</p>
</blockquote>
<p>记 <code>dp[i]</code> 为以 $i$ 结尾的最长相接子列。状态转移是好写的。</p>
<p>如果数列中元素两两互异，会很简单，因为有相同元素的时候要考虑 <code>0 1 0 2</code> 这种数列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="keyword">int</span> a[n],id[n];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		iota(id,id+n,<span class="number">0</span>);</span><br><span class="line">		sort(id,id+n,[&amp;](<span class="keyword">int</span> &amp;i,<span class="keyword">int</span> &amp;j)&#123;</span><br><span class="line">			<span class="keyword">return</span> a[i]==a[j]?i&lt;j:a[i]&lt;a[j];</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			a[id[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> dp[n],ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			dp[i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;<span class="number">0</span> &amp;&amp; id[a[i]<span class="number">-1</span>]&lt;i) dp[i] += dp[id[a[i]<span class="number">-1</span>]];</span><br><span class="line">			ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;n-ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>否则，我们就要考虑 $i$ 之前 <code>a[i]</code> 严格小的相接元的 <code>dp</code> 最小值加上这些元的元素个数。</p>
<p>但是也可以直接求不用 DP 参考 <a href="https://codeforces.com/contest/1367/submission/83985710" target="_blank" rel="noopener">jiangly 的代码</a>，直接找包含第 $i$ 位最长的相接子列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">2e5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; z;</span><br><span class="line">    <span class="keyword">while</span> (z--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">std</span>::iota(p, p + n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">std</span>::sort(p, p + n, [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;<span class="keyword">return</span> a[i] &lt; a[j] || (a[i] == a[j] &amp;&amp; i &lt; j);&#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r; l &lt; n; l = r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (r = l + <span class="number">1</span>; r &lt; n &amp;&amp; p[r] &gt; p[r - <span class="number">1</span>]; ++r)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">int</span> res = r - l;</span><br><span class="line">            <span class="keyword">if</span> (l)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; a[p[i]] == a[p[l - <span class="number">1</span>]]; --i)</span><br><span class="line">                    <span class="keyword">if</span> (p[i] &lt; p[l])</span><br><span class="line">                        ++res;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; n &amp;&amp; a[p[i]] == a[p[r]]; ++i)</span><br><span class="line">                    <span class="keyword">if</span> (p[i] &gt; p[r - <span class="number">1</span>])</span><br><span class="line">                        ++res;</span><br><span class="line">            ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, m, r; l &lt; n; l = m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (m = l; m &lt; n &amp;&amp; a[p[m]] == a[p[l]]; ++m)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">if</span> (m == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (r = m; r &lt; n &amp;&amp; a[p[r]] == a[p[m]]; ++r)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = m; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; r &amp;&amp; p[j] &lt; p[i])</span><br><span class="line">                    ++j;</span><br><span class="line">                ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, i + <span class="number">1</span> - l + r - j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n - ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1368B：简单的问题比赛的时候无语的想复杂了！然后就是参看-tourist-男神的优雅代码"><a href="#1368B：简单的问题比赛的时候无语的想复杂了！然后就是参看-tourist-男神的优雅代码" class="headerlink" title="1368B：简单的问题比赛的时候无语的想复杂了！然后就是参看 tourist 男神的优雅代码"></a><a href="https://codeforces.com/contest/1368/problem/B" target="_blank" rel="noopener">1368B</a>：简单的问题比赛的时候无语的想复杂了！然后就是参看 tourist 男神的优雅代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  tourist</span></span><br><span class="line"><span class="comment"> *    created: 18.06.2020 17:46:48       </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  <span class="built_in">string</span> s = <span class="string">"codeforces"</span>;</span><br><span class="line">  <span class="keyword">int</span> n = (<span class="keyword">int</span>) s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> prod = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> it = <span class="number">0</span>; prod &lt; k; it = (it + <span class="number">1</span>) % n) &#123;</span><br><span class="line">    prod = prod / a[it] * (a[it] + <span class="number">1</span>);</span><br><span class="line">    ++a[it];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i]; j++) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1368D：一眼看出！哎要不是-B-题被卡了，我决定能上大分！好气"><a href="#1368D：一眼看出！哎要不是-B-题被卡了，我决定能上大分！好气" class="headerlink" title="1368D：一眼看出！哎要不是 B 题被卡了，我决定能上大分！好气"></a><a href="https://codeforces.com/contest/1368/problem/D" target="_blank" rel="noopener">1368D</a>：一眼看出！哎要不是 B 题被卡了，我决定能上大分！好气</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">int</span> a[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;,x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(x)&#123;</span><br><span class="line">				<span class="keyword">if</span>(x&amp;<span class="number">1</span>) ++a[j];</span><br><span class="line">				x&gt;&gt;=<span class="number">1</span>; ++j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		LL r=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			LL t = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;i&lt;<span class="number">20</span>;++i,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i])&#123;</span><br><span class="line">					t+=j;</span><br><span class="line">					--a[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			r+=t*t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1285D：比赛的时候想到了，但是怕复杂度过补了，能过复杂度是因为每个元素-a-最多递归-log-a-次"><a href="#1285D：比赛的时候想到了，但是怕复杂度过补了，能过复杂度是因为每个元素-a-最多递归-log-a-次" class="headerlink" title="1285D：比赛的时候想到了，但是怕复杂度过补了，能过复杂度是因为每个元素 $a$ 最多递归 $\log a$ 次"></a><a href="https://codeforces.com/contest/1285/problem/D" target="_blank" rel="noopener">1285D</a>：比赛的时候想到了，但是怕复杂度过补了，能过复杂度是因为每个元素 $a$ 最多递归 $\log a$ 次</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> <span class="built_in">bit</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">bit</span>&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l,r;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)&#123;</span><br><span class="line">		<span class="keyword">if</span>((x&gt;&gt;<span class="built_in">bit</span>)&amp;<span class="number">1</span>) l.push_back(x);</span><br><span class="line">		<span class="keyword">else</span> r.push_back(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> solve(r,<span class="built_in">bit</span><span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(r.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> solve(l,<span class="built_in">bit</span><span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(solve(l,<span class="built_in">bit</span><span class="number">-1</span>),solve(r,<span class="built_in">bit</span><span class="number">-1</span>))+(<span class="number">1</span>&lt;&lt;<span class="built_in">bit</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;solve(a,<span class="number">30</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1285C：找出使得-max-a-b-最小并使得-lcm-a-b-x-的最小-a-b"><a href="#1285C：找出使得-max-a-b-最小并使得-lcm-a-b-x-的最小-a-b" class="headerlink" title="1285C：找出使得$\max(a,b)$最小并使得$lcm(a,b)=x$的最小$a,b$"></a><a href="https://codeforces.com/contest/1285/problem/C" target="_blank" rel="noopener">1285C</a>：找出使得$\max(a,b)$最小并使得$lcm(a,b)=x$的最小$a,b$</h3><blockquote>
<p>将 $x$ 分解素因子可知，$\max(a,b)$ 最小的前提是，$\gcd(a,b)=1$，又因为 $x$ 的因子个数不超过$2\sqrt{x}$，搞定</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	LL n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		LL r = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(LL i=<span class="number">1</span>;i*i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(n%i==<span class="number">0</span>&amp;&amp;__gcd(i,n/i)==<span class="number">1</span>)&#123;</span><br><span class="line">				r=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="string">" "</span>&lt;&lt;n/r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本来不想写这个题，但是由于下题都是 <code>lcm</code> 问题，又是同一场，所以就记录一下</p>
<h3 id="1285F：一道很秀的-lcm-题，计算-displaystyle-max-1-leq-i-lt-j-leq-n-lcm-a-i-a-j"><a href="#1285F：一道很秀的-lcm-题，计算-displaystyle-max-1-leq-i-lt-j-leq-n-lcm-a-i-a-j" class="headerlink" title="1285F：一道很秀的 lcm 题，计算 $\displaystyle \max_{1\leq i&lt; j \leq n} lcm(a_i,a_j)$"></a><a href="https://codeforces.com/contest/1285/problem/F" target="_blank" rel="noopener">1285F</a>：一道很秀的 lcm 题，计算 $\displaystyle \max_{1\leq i&lt; j \leq n} lcm(a_i,a_j)$</h3><blockquote>
<p>参考这里：<a href="https://www.xht37.com/codeforces-round-613-div-2-题解/#Classical" target="_blank" rel="noopener">https://www.xht37.com/codeforces-round-613-div-2-%E9%A2%98%E8%A7%A3/#Classical</a></p>
</blockquote>
<p>通过加入 $a_i$ 的所有因子，我们可以改成计算 $\displaystyle \max_{\gcd(a_i,a_j)=1} a_ia_j$，我们将 $a_i$ 从大到小排序，然后开始遍历，用堆 s 保存之前的内容，注意到，如果堆 s 中有一个元素 t，跟当前需要遍历的元素 $a_i$ 互素，那么小于 s 中小于 $t$ 的元素讲不再能为结果做贡献。因此可以踢出栈中，现在问题是我们如何快速的记录<strong>堆 $s$ 中是否有与$a_i$ 互素的元素</strong>。记 $c_i$ 为堆中是 $i$ 的倍数的元素个数，那么堆中和$x$互素的个数为 $cop = \sum_{d|x} \mu(d) c_d$，这是因为包容排斥原理，首先所有数都是 1 的倍数，然后减去和 $x$ 的最小公约数为素数的，在加上和 $x$ 的最小公约数为两个素数相乘…。若 $cop$ 不为 0，那么就一个个的剔除，剔除的时候可以计算一下乘积（虽然不一定互素，但是不会影响的最终结果）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">bool</span> a[N]=&#123;&#125;;</span><br><span class="line">		<span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			a[x]=<span class="number">1</span>;</span><br><span class="line">			mx = <span class="built_in">max</span>(mx,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[mx+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> mu[mx+<span class="number">1</span>]=&#123;&#125;,c[mx+<span class="number">1</span>]=&#123;&#125;;</span><br><span class="line">		mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)&#123;</span><br><span class="line">			p[i].push_back(i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=mx;j+=i)&#123;</span><br><span class="line">				p[j].push_back(i);</span><br><span class="line">				a[i]|=a[j];</span><br><span class="line">				mu[j]-=mu[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">		LL ans = mx;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=mx;i;--i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i])&#123;</span><br><span class="line">				<span class="keyword">int</span> cop = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:p[i]) cop+=mu[x]*c[x];</span><br><span class="line">				<span class="keyword">while</span>(cop)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:p[s.top()])&#123;</span><br><span class="line">						--c[x];</span><br><span class="line">						<span class="keyword">if</span>(i%x==<span class="number">0</span>) cop-=mu[x];</span><br><span class="line">					&#125;</span><br><span class="line">					ans = <span class="built_in">max</span>(ans,LL(i)*s.top());</span><br><span class="line">					s.pop();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:p[i]) ++c[x];</span><br><span class="line">				s.push(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1370D：在长为-n-的序列中找一个长为-k-的子列，子列中奇数项最大值和偶数项最大值的最小值最小"><a href="#1370D：在长为-n-的序列中找一个长为-k-的子列，子列中奇数项最大值和偶数项最大值的最小值最小" class="headerlink" title="1370D：在长为 n 的序列中找一个长为 k 的子列，子列中奇数项最大值和偶数项最大值的最小值最小"></a><a href="https://codeforces.com/contest/1370/problem/D" target="_blank" rel="noopener">1370D</a>：在长为 n 的序列中找一个长为 k 的子列，子列中奇数项最大值和偶数项最大值的最小值最小</h3><blockquote>
<p>比赛的时候，我很快就知可以二分查找答案，但是顾前不顾尾，下面代码没过，因为当最后一个数正好是满足 <code>a[i]&lt;=m</code> 时答案就不行了！<strong>应该按照原来的逻辑去叠加啊！</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此代码是错误代码！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">int</span> a[n],r=<span class="number">0</span>,l=<span class="number">1e9</span>+<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		r = <span class="built_in">max</span>(r,a[i]);</span><br><span class="line">		l = <span class="built_in">min</span>(l,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> m)&#123;</span><br><span class="line">		<span class="keyword">int</span> now = <span class="number">-2</span>,s=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=k%<span class="number">2</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;=m)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i&gt;now+<span class="number">1</span>)&#123;</span><br><span class="line">					++s;</span><br><span class="line">					now = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s&gt;=k/<span class="number">2</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(f(m)) r=m<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=m+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是修正的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">	<span class="keyword">auto</span> g = [&amp;](<span class="keyword">int</span> m,<span class="keyword">bool</span> cur)&#123;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cur)&#123;</span><br><span class="line">				cur = !cur;</span><br><span class="line">				++s;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i]&lt;=m)&#123;</span><br><span class="line">					++s;</span><br><span class="line">					cur = !cur;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s&gt;=k;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> l = *min_element(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> r = *max_element(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">   	<span class="comment">//auto lr = minmax_element(a.begin(),a.end());</span></span><br><span class="line">	<span class="comment">//int l = *lr.first,r = *lr.second;</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(g(m,<span class="number">0</span>)||g(m,<span class="number">1</span>)) r=m<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=m+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1370E：找出最少的轮换使得字符串-s-变成-t"><a href="#1370E：找出最少的轮换使得字符串-s-变成-t" class="headerlink" title="1370E：找出最少的轮换使得字符串 s 变成 t"></a><a href="https://codeforces.com/contest/1370/problem/E" target="_blank" rel="noopener">1370E</a>：找出最少的轮换使得字符串 s 变成 t</h3><p>我一开始知道是贪心，然后我以为 <strong>是找到其中最长的连续 0 或者 1</strong>，然后发现并不是！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此代码是错误代码！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">string</span> a,b;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="keyword">int</span> ab=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) <span class="keyword">if</span>(x==<span class="string">'1'</span>) ++ab;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:b) <span class="keyword">if</span>(x==<span class="string">'1'</span>) --ab;</span><br><span class="line">	<span class="keyword">if</span>(ab)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]!=b[i]) s.push_back(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	s+=s;</span><br><span class="line">	<span class="comment">//cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,t;i&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>((i == <span class="number">0</span>)||(s[i]!=s[i<span class="number">-1</span>])) t=<span class="number">0</span>;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans,++t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看了<a href="https://codeforces.com/blog/entry/79107" target="_blank" rel="noopener">官方题解</a>！</p>
<p>在有解的前提下，我们可以构造取值在 $\{-1,0,1\}$ 的数组 $a$： if  $s_i = t_i,a_i = 0$，else if $s_i = 1,a_i=1$ else $a_i=-1$。因此答案就是</p>
<script type="math/tex; mode=display">
\max _{1 \leq l \leq r \leq n} |\sum_{i=l} ^r  a_i| = max(\max _{1 \leq l \leq r \leq n} \sum_{i=l} ^r  a_i,\max _{1 \leq l \leq r \leq n} \sum_{i=l} ^r  -a_i)</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">string</span> s,t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==t[i]) <span class="keyword">continue</span>;</span><br><span class="line">		a.emplace_back(s[i]==<span class="string">'1'</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(accumulate(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">0</span>))&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> sign)&#123;</span><br><span class="line">		<span class="keyword">int</span> mx = <span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)&#123;</span><br><span class="line">			cur += sign*x;</span><br><span class="line">			mx = <span class="built_in">max</span>(mx,cur);</span><br><span class="line">			cur = <span class="built_in">max</span>(cur,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mx;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">max</span>(f(<span class="number">1</span>),f(<span class="number">-1</span>))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1263D：Set-lt-int-gt-集合操作范例"><a href="#1263D：Set-lt-int-gt-集合操作范例" class="headerlink" title="1263D：Set&lt;int&gt; 集合操作范例"></a><a href="https://codeforces.com/problemset/problem/1263/D" target="_blank" rel="noopener">1263D</a>：<code>Set&lt;int&gt;</code> 集合操作范例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin)</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s) a[c-<span class="string">'a'</span>].insert(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(a[x].<span class="built_in">size</span>()==<span class="number">0</span>) ++x;</span><br><span class="line">	q.insert(a[x]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i].<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">set</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; p;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:q)&#123;</span><br><span class="line">			<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">			set_intersection(x.<span class="built_in">begin</span>(),x.<span class="built_in">end</span>(),a[i].<span class="built_in">begin</span>(),a[i].<span class="built_in">end</span>(),inserter(t, t.<span class="built_in">begin</span>()));</span><br><span class="line">			<span class="keyword">if</span>(t.<span class="built_in">size</span>())&#123;</span><br><span class="line">				set_union(x.<span class="built_in">begin</span>(),x.<span class="built_in">end</span>(),a[i].<span class="built_in">begin</span>(),a[i].<span class="built_in">end</span>(),inserter(t, t.<span class="built_in">begin</span>()));</span><br><span class="line">				a[i] = t;</span><br><span class="line">				p.insert(x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">set</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; t;</span><br><span class="line">		set_difference(q.<span class="built_in">begin</span>(),q.<span class="built_in">end</span>(),p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),inserter(t, t.<span class="built_in">begin</span>()));</span><br><span class="line">		t.insert(a[i]);</span><br><span class="line">		q = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1369D-组合计数问题"><a href="#1369D-组合计数问题" class="headerlink" title="1369D:  组合计数问题"></a><a href="https://codeforces.com/contest/1369/problem/D" target="_blank" rel="noopener">1369D</a>:  组合计数问题</h3><blockquote>
<p>题解写在官方的 <a href="https://codeforces.com/blog/entry/79235#comment-648996" target="_blank" rel="noopener">教程里面</a>，代码也不想 copy 过来了。</p>
</blockquote>
<p>补充一个更好的生成函数的做法：已知 $a_n$，满足 $a_n = a_{n-1} + 2 a_{n-2} + (n \% 3==0?4:0)$，$a_0 = a_1= a_2 = 0$，计算$a_n$。</p>
<p>设 $f(x) = \sum_{n=0} ^ {\infty} a_n x^n$，则我们有</p>
<script type="math/tex; mode=display">
f(x) = \sum_{n=0} ^ {\infty} (a_{n-1} + 2 a_{n-2} ) x^n + \sum_{n=1} ^ {\infty} 4x^{3n} = xf(x) + x^2f(x) + 4 \sum_{n=1} ^ {\infty} x^{3n}</script><p>所以</p>
<script type="math/tex; mode=display">
f(x) = \frac{4 \sum_{n=1} ^ {\infty} x^{3n}}{(1-2x)(1+x)}</script><p>由于 $\frac{1}{1-x} = \sum_{n=0}^{\infty} x^n$，所以 $\frac{1}{(1-2x)(1+x)} = \frac{2}{3(1-2x)} + \frac{1}{3(1+x)} = \sum_{n=0}^{\infty} \frac{2^{n+1}+(-1)^n}{3}x^n$（推荐），$\frac{1}{(1-2x)(1+x)} = \sum_{n=0}^{\infty} (2x)^n \sum_{n=0}^{\infty}(-x)^n = \sum_{n=0}^{\infty} \frac{2^{n+1}+(-1)^n}{3}x^n$（不推荐），因此</p>
<script type="math/tex; mode=display">
f(x) = \frac{4}{3} \sum_{n=0} ^ \infty (\frac{2^{n \% 3 +1} (8^{n/3}-1)}{8-1} + \frac{(-1)^{n \% 3 +1} ((-1)^{n/3}-1)}{-1-1}) x^n</script><h3 id="1369F：博弈题"><a href="#1369F：博弈题" class="headerlink" title="1369F：博弈题"></a><a href="https://codtforcts.com/conttst/1369/probltm/F" target="_blank" rel="noopener">1369F</a>：博弈题</h3><blockquote>
<p>给定两个正整数 $s \leq t$，$A,B$ 两人依次玩游戏，每次可以从$s$变成 $s+1$ 或 $2s$，谁先严格大于 $t$，谁输了。</p>
<p>现在给你一堆的 $s_i,t_i$，$A,B$ 两人依次玩游戏，每一局输了的人作为下一局开始的人。问 $A$ 能否最后一局必赢，能否最后一局必输</p>
</blockquote>
<p>先考虑单个 $s,t$ 的情况。</p>
<p>用$f(s,t)$ 分别表示$A$ 是否有必胜策略。</p>
<ul>
<li>$t$ 为奇数，若 $s$ 为偶数，那么 $A$ 就让它变成 $s+1$，那么无论 $B$ 如何操作只能变成偶数，所以此时 $f(s,t) = 1$，若 $s$ 为奇数，显然若 $B$ 用 $A$ 刚刚的策略，则 $A$ 输，$f(s,t) = 0$。</li>
<li>$t$ 为偶数，若 $2s&gt;t$，此时只能做加法，$f(s,t) = s \mod 2$，若 $4s&gt;t \geq 2s$，此时 $f(s,t)=1$ ，因为总可以变成 $f(2s,t)=0$。若 $4s \leq t$，若 $f(s,\lfloor \frac{t}{4} \rfloor) = 1$, 则 $A$ 必有策略到达区间 $(\lfloor \frac{t}{4} \rfloor,2\lfloor \frac{t}{4} \rfloor)$ 的某一点，从而 $f(s,t)=1$, 同理若 $f(s,\lfloor \frac{t}{4} \rfloor) = 0$，则 $B$ 有 $A$ 的策略，从而 $f(s,t)=0$ （<strong>比赛的时候能想出来的人是真的虎</strong>) 。</li>
</ul>
<p>用 $g(s,t)$ 分别表示 $A$ 是否有必输的策略：若 $2s&gt;t$，则 $g(s,t)=1$，同理，若 $2s \leq t$，$f(s,\lfloor \frac{t}{2} \rfloor)=1$，则必有策略使得 $B$ 到达 $(\lfloor \frac{t}{2} \rfloor,2\lfloor \frac{t}{2} \rfloor)$ 的某一点，所以 $g(s,t) = f(s,\lfloor \frac{t}{2} \rfloor)$</p>
<p>有了这两个函数后，我们就可以从后往前依次来决定最后能否有必胜或必输的决策。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin)</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	function&lt;<span class="keyword">bool</span>(LL,LL)&gt; f = [&amp;](LL s,LL t)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(t%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> s%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">2</span>*s&gt;t) <span class="keyword">return</span> s%<span class="number">2</span>==<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">4</span>*s&gt;t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> f(s,t/<span class="number">4</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	function&lt;<span class="keyword">bool</span>(LL,LL)&gt; g = [&amp;](LL s,LL t)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">2</span>*s&gt;t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> f(s,t/<span class="number">2</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">bool</span> win=<span class="number">0</span>,lose=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		LL s,t;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">		<span class="keyword">if</span>(win^lose==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(lose)&#123;</span><br><span class="line">			win = f(s,t);</span><br><span class="line">			lose = g(s,t);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			win = !f(s,t);</span><br><span class="line">			lose = !g(s,t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;win&lt;&lt;<span class="string">" "</span>&lt;&lt;lose&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以认为一开始仅有必输策略所以让$A$先选，然后如果$A$原来有必胜且有必败策略，这后面必然一直有，若没有必胜也没有必败策略，则后面也是。所以只用考虑仅有其中之一的情形。</p>
</blockquote>
<h2 id="300iq-Contest-3"><a href="#300iq-Contest-3" class="headerlink" title="300iq Contest 3"></a><a href="https://codeforces.com/gym/102538/" target="_blank" rel="noopener">300iq Contest 3</a></h2><blockquote>
<p>罗列一下自己有兴趣的题目，<a href="300iqContest3.pdf">官方题解</a></p>
</blockquote>
<h3 id="A-Airplane-Cliques"><a href="#A-Airplane-Cliques" class="headerlink" title="A. Airplane Cliques"></a>A. Airplane Cliques</h3><p>题意：给定 $n$ 个节点的树，称两个节点是友好的，如果它们相连的边数不超过 $x$，问对任意 $1 \leq k \leq n$，有多少个元素个数为 $k$ 的集合，它们的点之间两两友好。其中 $1 \leq n \leq 300,000, 0 \leq x &lt; n$，最终答案对 998244353 取模</p>
<blockquote>
<p>看别人代码 200 多行，下次吧。</p>
</blockquote>
<h3 id="C-Cells-Blocking"><a href="#C-Cells-Blocking" class="headerlink" title="C. Cells Blocking"></a>C. Cells Blocking</h3><p>题意：从 <code>(1, 1)</code> 到 <code>(n, m)</code> 只能往右或往下走格子，然后有些格子是不能走的，让你将 2 个能走的格子变得不能走，最后使得格子 <code>(1, 1)</code> 无法到达 <code>(n, m)</code>，问有多少种变的方式。 $1 \leq m, n \leq 3000$</p>
<p>做法，首先从任意点看它是否可以到 <code>(n, m)</code>，再看任意点是否可从 <code>(1, 1)</code> 到。然后就可以选择最下和最上的两个路径，显然路径重叠的点被移除的时候 <code>(1, 1)</code> 就无法到达 <code>(n, m)</code>（如果一开始就无法到达，答案自然就是 $\text{nm} \choose 2$, nm 表示可以走的格子数)，然后最下的路径不重叠的点，必然可以必须需要删去其中的一个，删除之后再让它走最下的路径，看它与最上路径的交点，交点个数就是可选点的个数。（一个小技巧就是一开始重叠的点标记一下，不再考虑，这样就不会重复计数了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> nm = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : s) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		nm += <span class="built_in">std</span>::count(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), <span class="string">'.'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">a</span><span class="params">(n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m))</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> b = a;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;pii&gt; Q;</span><br><span class="line">	<span class="keyword">if</span> (s[n - <span class="number">1</span>][m - <span class="number">1</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">		Q.push(&#123;n - <span class="number">1</span>, m - <span class="number">1</span>&#125;);</span><br><span class="line">		b[n - <span class="number">1</span>][m - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [x, y] = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; s[x - <span class="number">1</span>][y] == <span class="string">'.'</span> &amp;&amp; b[x - <span class="number">1</span>][y] == <span class="number">0</span>) &#123;</span><br><span class="line">			Q.push(&#123;x - <span class="number">1</span>, y&#125;);</span><br><span class="line">			b[x - <span class="number">1</span>][y] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (y &gt; <span class="number">0</span> &amp;&amp; s[x][y - <span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp; b[x][y - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">			Q.push(&#123;x, y - <span class="number">1</span>&#125;);</span><br><span class="line">			b[x][y - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="number">1l</span>l * nm * (nm - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (s[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">		Q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">		a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [x, y] = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">if</span> (x + <span class="number">1</span> &lt; n &amp;&amp; s[x + <span class="number">1</span>][y] == <span class="string">'.'</span> &amp;&amp; a[x + <span class="number">1</span>][y] == <span class="number">0</span>) &#123;</span><br><span class="line">			Q.push(&#123;x + <span class="number">1</span>, y&#125;);</span><br><span class="line">			a[x + <span class="number">1</span>][y] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (y + <span class="number">1</span> &lt; m &amp;&amp; s[x][y + <span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp; a[x][y + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">			Q.push(&#123;x, y + <span class="number">1</span>&#125;);</span><br><span class="line">			a[x][y + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pii&gt; leftRoad, rightRoad;</span><br><span class="line">	leftRoad.push_back(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span> (leftRoad.back() != <span class="built_in">std</span>::make_pair(n - <span class="number">1</span>, m - <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [x, y] = leftRoad.back();</span><br><span class="line">		<span class="keyword">if</span> (x + <span class="number">1</span> &lt; n &amp;&amp; b[x + <span class="number">1</span>][y]) leftRoad.push_back(&#123;x + <span class="number">1</span>, y&#125;);</span><br><span class="line">		<span class="keyword">else</span> leftRoad.push_back(&#123;x, y + <span class="number">1</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	rightRoad.push_back(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span> (rightRoad.back() != <span class="built_in">std</span>::make_pair(n - <span class="number">1</span>, m - <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [x, y] = rightRoad.back();</span><br><span class="line">		<span class="keyword">if</span> (y + <span class="number">1</span> &lt; m &amp;&amp; b[x][y + <span class="number">1</span>]) rightRoad.push_back(&#123;x, y + <span class="number">1</span>&#125;);</span><br><span class="line">		<span class="keyword">else</span> rightRoad.push_back(&#123;x + <span class="number">1</span>, y&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n + m - <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> nm1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != rightRoad.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (leftRoad[i] == rightRoad[i]) ++nm1;</span><br><span class="line">		<span class="keyword">else</span> cnt[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL r = <span class="number">1l</span>l * nm1 * (nm - nm1) + <span class="number">1l</span>l * nm1 * (nm1 - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;](pii p) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [x, y] = p;</span><br><span class="line">		<span class="keyword">int</span> r = cnt[x + y] * (rightRoad[x + y] == p);</span><br><span class="line">		<span class="keyword">while</span> (x + y) &#123;</span><br><span class="line">			<span class="keyword">if</span> (y &gt; <span class="number">0</span> &amp;&amp; a[x][y - <span class="number">1</span>]) &#123;</span><br><span class="line">				r += cnt[x + y - <span class="number">1</span>] * (rightRoad[x + y - <span class="number">1</span>] == <span class="built_in">std</span>::make_pair(x, y - <span class="number">1</span>));</span><br><span class="line">				--y;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				r += cnt[x - <span class="number">1</span> + y] * (rightRoad[x - <span class="number">1</span> + y] == <span class="built_in">std</span>::make_pair(x - <span class="number">1</span>, y));</span><br><span class="line">				--x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		x = p.first; y = p.second;</span><br><span class="line">		<span class="keyword">while</span> (x + y &lt; n + m - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((x + <span class="number">1</span> &lt; n) &amp;&amp; b[x + <span class="number">1</span>][y]) &#123;</span><br><span class="line">				r += cnt[x + <span class="number">1</span> + y] * (rightRoad[x + <span class="number">1</span> + y] == <span class="built_in">std</span>::make_pair(x + <span class="number">1</span>, y));</span><br><span class="line">				++x;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				r += cnt[x + y + <span class="number">1</span>] * (rightRoad[x + y + <span class="number">1</span>] == <span class="built_in">std</span>::make_pair(x, y + <span class="number">1</span>));</span><br><span class="line">				++y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m - <span class="number">1</span>; ++i) <span class="keyword">if</span>(leftRoad[i] != rightRoad[i]) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [x, y] = leftRoad[i];</span><br><span class="line">		--x; ++y;</span><br><span class="line">		<span class="keyword">while</span> (a[x][y] == <span class="number">0</span> || b[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">			--x; ++y;</span><br><span class="line">		&#125;</span><br><span class="line">		r += f(&#123;x, y&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="E-Easy-Win"><a href="#E-Easy-Win" class="headerlink" title="E. Easy Win"></a><a href="https://codeforces.com/gym/102538/problem/E" target="_blank" rel="noopener">E. Easy Win</a></h3><blockquote>
<p>SG 函数-博弈问题</p>
</blockquote>
<p>题意：有 $n$ 堆石子 $(a_1, \cdots, a_n)$（$a_i \leq n$），每次最少选 1 个，最多选 $x$ 个，最后谁没法选谁输，问对于所有的 $1 \leq x \leq n$，先手赢还是先手输。其中 $1 \leq n \leq 500,000$</p>
<p>首先，对每一个具体的 $x$ 答案是 $f(x) = (a_1 \mod x + 1) \oplus \cdots \oplus (a_n \mod x + 1)$ 是否为 0. 原因可参考之前的博文： <a href="/nimSgFunction/" title="SG 函数之取石子博弈">SG 函数之取石子博弈</a></p>
<p>为了优化时间复杂度，我们逐位计算 $f(x)$（即 计算 $f(x) \And 2^{j}$ 的值），首先我们对 $a_i$ 去重，用 $c_i = |\{t | a_t = i \}|$，令 $y = x + 1$。所以此时 $f(x) \And 2^{j} = \sum_{i = 1}^n c[i] (i \mod y) \mod 2 \cdot 2^{j}$<br>我们将 $[0, n]$ 分成 $[0, y), [y, 2y), \cdots, [ky, n]$，注意到若 $ky \leq a_i &lt; (k + 1) y$，那么 $a_i \equiv a_i - ky \mod y$，如果对于每个区间我们在预处理的前提下，能在 $O(1)$ 时间复杂度计算出每个区间的值，那么我们就能在 $O(n \log^2 n)$ 解决此问题。注意到区间 $[ky, (k+1)y)$ 对答案的贡献是：那些满足 $ky \leq t &lt; (k+1)y$，且 $t - ky$ 包含 j 位的那些 $c_t$ 的和。我们定义 $\displaystyle f_{i, j} = \sum_{x \geq i, (x - i) \And (2^j) \neq 0} c_x$，那么由于 $(x - i) \And 2^{j} \neq 0$ 等价于 $(x - i \pm 2^{j+1} \neq 0)$。所以有状态转移：</p>
<script type="math/tex; mode=display">
f_{i, j} = f_{i + 2^{j + 1}} + \sum_{t = i + 2^{j}}^{i + 2 ^{j + 1} - 1} c_t</script><p>然后区间 $[ky, (k+1)y)$ 对答案的贡献就是 $f_{ky, j} - f_{t, j} - \sum_{i = \min((k + 1)y, t - 2^{j})}^{t - 1} c_i$，其中 $t = ky + \lfloor \frac{y}{2^{j + 1}} \rfloor$ 是不小于 $(k + 1) y$ 且与 $ky$ 模 $2^{j + 1}$ 次数最小的值。后面那个求和是因为那部分的和中 $i - ky$ 必然有 $j$ 位。搞定！</p>
<blockquote>
<p>下面代码并不完全和上面解释一致，是因为我们值关心每一个位置是否为 0，用加减不方便，直接异或就行，也就是说其实下面很多 <code>int</code> 都可以换成 <code>bool</code>，不过 <code>std::vector&lt;bool&gt;</code> 不是 bool 型的向量，用起来不方便就没这么做了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	std::vector&lt;int&gt; c(n + 1), s(n + 1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		c[x] ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s[n] = c[n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) s[i] = s[i + <span class="number">1</span>] ^ c[i];</span><br><span class="line">	<span class="keyword">auto</span> sum = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">return</span> x &gt; n ? <span class="number">0</span> : s[x];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">bit</span> = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; <span class="built_in">bit</span>) &lt;= n; ++<span class="built_in">bit</span>) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">auto</span> fum = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">			<span class="keyword">return</span> x &gt; n ? <span class="number">0</span> : f[x];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			f[i] = fum(i + (<span class="number">2</span> &lt;&lt; <span class="built_in">bit</span>)) ^ sum(i + (<span class="number">1</span> &lt;&lt; <span class="built_in">bit</span>)) ^ sum(i + (<span class="number">2</span> &lt;&lt; <span class="built_in">bit</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">2</span>; x &lt; n; ++x, ++y) <span class="keyword">if</span> (r[x] == <span class="number">0</span> &amp;&amp; y &gt; (<span class="number">1</span> &lt;&lt; <span class="built_in">bit</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> sy = <span class="number">0</span>, <span class="built_in">step</span> = (y + (<span class="number">2</span> &lt;&lt; <span class="built_in">bit</span>) - <span class="number">1</span>) &gt;&gt; <span class="built_in">bit</span> + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k * y &lt;= n; ++k) &#123;</span><br><span class="line">				<span class="keyword">int</span> t = k * y + (<span class="built_in">step</span> &lt;&lt; <span class="built_in">bit</span> + <span class="number">1</span>);</span><br><span class="line">				sy ^= f[k * y] ^ fum(t) ^ sum(<span class="built_in">std</span>::<span class="built_in">max</span>((k + <span class="number">1</span>) * y, t - (<span class="number">1</span> &lt;&lt; <span class="built_in">bit</span>))) ^ sum(t);</span><br><span class="line">			&#125;</span><br><span class="line">			r[x] |= sy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : r) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (x ? <span class="string">"Alice "</span> : <span class="string">"Bob "</span>);</span><br><span class="line">	<span class="built_in">println</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="I-Ignore-Submasks"><a href="#I-Ignore-Submasks" class="headerlink" title="I. Ignore Submasks"></a>I. Ignore Submasks</h3><blockquote>
<p>本场最简单的一题</p>
</blockquote>
<p>题意：给定序列 $a_1, \cdots, a_n$ （$0 \leq a_i &lt; 2^k$），记 $f(x)$ 为使得 $a_i \And x \neq a_i$ 的最小的 $i$，如果没有就为 0，求 $\sum_{i = 0}^{2^k - 1} f(i)$，对答案取模 998244353，其中 $1 \leq n \leq 100, 1 \leq k \leq 60$</p>
<p>做法：相当于一开始有 $k$ 个位是自由的，假设当前还有 $r$ 个位是自由的，$a_i$ 占有其中 c 个自由位，然后其它的自由位随便取，所以它对结果的贡献就是 $(2^r - 1) \cdot 2^{k - r} \cdot i$，注意 $k \leq 60$，很多地方记得加 <code>ll</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">v</span><span class="params">(k, <span class="literal">true</span>)</span></span>;</span><br><span class="line">	LL r = <span class="number">0</span>, id = <span class="number">0</span>, rest = k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((x &amp; (<span class="number">1l</span>l &lt;&lt; i)) &amp;&amp; v[i]) &#123;</span><br><span class="line">				v[i] = <span class="literal">false</span>;</span><br><span class="line">				++cnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		r += ((<span class="number">1l</span>l &lt;&lt; cnt) - <span class="number">1</span>) % M * ((<span class="number">1l</span>l &lt;&lt; (rest -= cnt)) % M) % M * (++id) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(r % M);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="耻辱记录"><a href="#耻辱记录" class="headerlink" title="耻辱记录"></a>耻辱记录</h2><ul>
<li>2020/5/24 水题竟然也能被卡，傻子吧我！</li>
<li>被 <code>lower_bound</code> 坑了，也怪自己，<code>lower_bound(a.begin(),a.end(),x)-a</code> ：对于单调递增的序列，返回第一个大于等于<code>x</code>的序号。<code>upper_bound</code> 返回的是第一个大于 <code>x</code> 的序号，所以讲道理，upper_bound 更好用！</li>
<li>2020/6/1 低级错误，把 <code>int</code> 型变量放在 <code>bool</code> 型后面定义了！结果找了半天的错误！！导致少做一题。给了自己几巴掌</li>
<li><a href="https://codeforces.com/contest/1379" target="_blank" rel="noopener">Codeforces Round #657 (Div. 2)</a>：只做了一题？？？被 A 题卡了一个多小时？？？</li>
<li><a href="https://codeforces.com/contest/1397" target="_blank" rel="noopener">Codeforces Round #666 (Div. 2)</a>：犯了一堆低级错误</li>
<li><a href="https://codeforces.com/contest/1407" target="_blank" rel="noopener">Codeforces Round #669 (Div. 2)</a>：由读题引发的一系列低级错误！</li>
<li><a href="https://codeforces.com/contest/1438" target="_blank" rel="noopener">Codeforces Round #682 (Div. 2)</a>：10 分钟后没过题，被 C 卡了！！！不定闹钟的坏处！</li>
<li><a href="https://codeforces.com/contest/1456" target="_blank" rel="noopener">Codeforces Round #687 (Div. 1, based on Technocup 2021 Elimination Round 2)</a>：首场 Div1，惨败（跟 jiangly 分到一个 room），还被人 hack 了！</li>
<li><a href="https://codeforces.com/contest/1461" target="_blank" rel="noopener">Codeforces Round #689 (Div. 2, based on Zed Code Competition)</a>，又被 b 题卡，真的菜！</li>
<li><a href="https://codeforces.com/contest/1466" target="_blank" rel="noopener">Good Bye 2020</a>：被一道简单的 DP C 题，卡了一个小时最后也没搞定，吐了。</li>
<li><a href="https://codeforces.com/contest/1467" target="_blank" rel="noopener">Codeforces Round #695 (Div. 2)</a>：只做了一个 C ？？？</li>
<li><a href="https://codeforces.com/contest/1481" target="_blank" rel="noopener">Codeforces Round #699 (Div. 2)</a>：首次忘了提前注册。</li>
</ul>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ul>
<li><a href="https://codeforces.com/contest/1428" target="_blank" rel="noopener">Codeforces Raif Round 1 (Div. 1 + Div. 2)</a> 是一场非常好，但是我没做好的一场比赛</li>
<li><a href="https://codeforces.com/contest/1366" target="_blank" rel="noopener">Educational Codeforces Round 89 (Rated for Div. 2)</a>：我竟然有做 5 题的实力！，但是因为网络原因我只做了 4 题。最后一个差一点，后面 1A 补上了。可惜。不过也还行加油！</li>
<li><a href="https://codeforces.com/contest/1367" target="_blank" rel="noopener">Codeforces Round #650 (Div. 3)</a>：第一次两小时内做 5 题，全部 1A，虽然是 div3！(竟然最后只加了 131 分)</li>
<li><a href="https://codeforces.com/contest/1370" target="_blank" rel="noopener">Codeforces Round #651 (Div. 2)</a>：唯一一次<del>不加不减</del>（过几小时之后它又减了我一分），但是，收获颇多的一次。</li>
<li><a href="https://codeforces.com/contest/1373" target="_blank" rel="noopener">Educational Codeforces Round 90 (Rated for Div. 2)</a>：做了 4 题，因为第五题没做出来，所以没交题！</li>
<li><a href="https://codeforces.com/contest/1371" target="_blank" rel="noopener">Codeforces Round #654 (Div. 2)</a>：好烦啊，又是结束后 5 分钟做出第五题。</li>
<li>目前，打字（代码）速度是限制我做 5 题的瓶颈！</li>
<li>提高码字速度，多总结，最近不要主动刷新题了。（2020/7/5)</li>
<li><a href="https://codeforces.com/contest/1251" target="_blank" rel="noopener">Educational Codeforces Round 75 (Rated for Div. 2)</a>: 第一次补完题目 （2020/7/9)</li>
<li><a href="https://codeforces.com/contest/1399" target="_blank" rel="noopener">Codeforces Round #661 (Div. 3)</a> 补完题目</li>
<li>图论，树上的问题也没那么可怕，就是麻烦点</li>
<li><a href="https://codeforces.com/contest/1430" target="_blank" rel="noopener">Educational Codeforces Round 96 (Rated for Div2)</a>：第一次 Div2 做 5 题，但是因为提交问题和低级错误，导致用时太久从而没有一个好的排名。</li>
<li><a href="https://codeforces.com/contest/1447" target="_blank" rel="noopener">Code(forces Round #683 (Div. 2, by Meet IT)</a>：首次进前 100</li>
<li><a href="https://codeforces.com/contest/1440" target="_blank" rel="noopener">Codeforces Round #684 (Div. 2)</a>：首次成为 Candidate Master</li>
<li><a href="https://codeforces.com/contest/1462" target="_blank" rel="noopener">Codeforces Round #690 (Div. 3)</a>: 1:39:54 AK</li>
<li><a href="https://codeforces.com/contest/1465" target="_blank" rel="noopener">Codeforces Round #692 (Div. 2, based on Technocup 2021 Elimination Round 3)</a> 第 47 名，首次进前 50。</li>
<li><a href="https://codeforces.com/contest/1472" target="_blank" rel="noopener">Codeforces Round #693 (Div. 3)</a> <a href="https://codeforces.com/contest/1472/submission/103302494" target="_blank" rel="noopener">01:59:57 AC</a> 也太刺激了吧，虽然这场不算分。</li>
<li><a href="https://atcoder.jp/contests/abc185" target="_blank" rel="noopener">ABC 185</a> 01:20:27 AK</li>
<li><a href="https://atcoder.jp/contests/abc189" target="_blank" rel="noopener">ABC 189</a> 01:31:38 AK</li>
<li><a href="https://codeforces.com/contest/1475" target="_blank" rel="noopener">Codeforces Round #697 (Div. 3)</a> 01:49:00 AK</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
        <tag>图论</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 字符串模板</title>
    <url>/string/</url>
    <content><![CDATA[<p>本篇内容为 <a href="https://oi-wiki.org/string" target="_blank" rel="noopener">oi-wiki 字符串篇</a> 的学习笔记。</p>
<h2 id="字典树（Trie）"><a href="#字典树（Trie）" class="headerlink" title="字典树（Trie）"></a>字典树（Trie）</h2><p>假设在一堆仅有大/小写字母的字符串中，需要快速检测某个字符串是否存在，那么 Trie 是个不错的选择。</p>
<h3 id="仅包含小写字母的-Trie（大写字母同理）"><a href="#仅包含小写字母的-Trie（大写字母同理）" class="headerlink" title="仅包含小写字母的 Trie（大写字母同理）"></a>仅包含小写字母的 Trie（大写字母同理）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">	<span class="keyword">using</span> Node = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">26</span>&gt;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; nxt;</span><br><span class="line">	<span class="comment">// 0 表示没有，1 表示有且没被访问过，2 表示有且被访问过</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tag;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> fa, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		nxt[fa][c] = nxt.<span class="built_in">size</span>();</span><br><span class="line">		nxt.emplace_back(Node());</span><br><span class="line">		tag.emplace_back(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Trie() : nxt(<span class="number">1</span>), tag(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line">			<span class="keyword">int</span> c = x - <span class="string">'a'</span>;</span><br><span class="line">			<span class="keyword">if</span> (nxt[p][c] == <span class="number">0</span>) addNode(p, c);</span><br><span class="line">			p = nxt[p][c]; </span><br><span class="line">		&#125;</span><br><span class="line">		tag[p] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line">			<span class="keyword">int</span> c = x - <span class="string">'a'</span>;</span><br><span class="line">			<span class="keyword">if</span> (nxt[p][c] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			p = nxt[p][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tag[p] != <span class="number">1</span>) <span class="keyword">return</span> tag[p];</span><br><span class="line">		tag[p] = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/P2580" target="_blank" rel="noopener">LOJ P2580</a></p>
<h3 id="01-Trie-求异或最大值"><a href="#01-Trie-求异或最大值" class="headerlink" title="01-Trie 求异或最大值"></a>01-Trie 求异或最大值</h3><p>做法：将数的二进制表示看成一个字符串，就可以建出字符集为 <code>{0, 1}</code> 的 Trie 树。把所有数字丢进去建好树之后，<br>对于这 n 个数中每个数，查找和它当前位不一致的位有没有。有就取，没有只能取自己，然后接着跑到底。</p>
<blockquote>
<p>注意这里可以，丢一个进去算一个，也就是说可以支持动态添加。因为要求异或最值，因此我们需要从最高位往最低位建 Trie，因此要统一高度。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">	<span class="keyword">using</span> Node = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; ch;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> fa, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		ch[fa][c] = ch.<span class="built_in">size</span>();</span><br><span class="line">		ch.emplace_back(Node());</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Trie() : ch(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>, p = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">int</span> c = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (ch[p][c] == <span class="number">0</span>) addNode(p, c);</span><br><span class="line">			p = ch[p][c];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>, p = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">int</span> c = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (ch[p][c ^ <span class="number">1</span>]) &#123;</span><br><span class="line">				p = ch[p][c ^ <span class="number">1</span>];</span><br><span class="line">				r |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				p = ch[p][c];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getAns</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">			insert(x);</span><br><span class="line">			r = <span class="built_in">std</span>::<span class="built_in">max</span>(r, getMax(x));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>典型例题：<a href="https://www.luogu.com.cn/problem/P4551" target="_blank" rel="noopener">LOJ P4551</a></p>
<p>此问题是树上问题，即树上两点路径上的异或和最大。任取一点为根可以将此问题转化成数列问题。</p>
<h3 id="01-Trie-Fusion-Tree-求异或和（支持修改，全局加-1，暂不支持合并）"><a href="#01-Trie-Fusion-Tree-求异或和（支持修改，全局加-1，暂不支持合并）" class="headerlink" title="01-Trie (Fusion Tree) 求异或和（支持修改，全局加 1，暂不支持合并）"></a>01-Trie (Fusion Tree) 求异或和（支持修改，全局加 1，暂不支持合并）</h3><blockquote>
<p>这里求异或和，可以从最低位往最高位建树节省空间。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">	<span class="keyword">using</span> Node = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">4</span>&gt;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; ch;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lson ch[p][0]</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rson ch[p][1]</span></span><br><span class="line">	<span class="comment">// ch[p][2] 表示以 p 为根的子树的大小</span></span><br><span class="line">	<span class="comment">// ch[p][3] 表示以 p 为根的子树的异或值</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		ch[p][c] = ch.<span class="built_in">size</span>();</span><br><span class="line">		ch.emplace_back(Node());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		ch[p][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (lson) ch[p][<span class="number">3</span>] ^= (ch[lson][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (rson) ch[p][<span class="number">3</span>] ^= (ch[rson][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | (ch[rson][<span class="number">2</span>] &amp; <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注意这里 ch[lson][2] = ch[p][2] - ch[rson] 是延迟更新的。</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		++ch[p][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (!ch[p][x &amp; <span class="number">1</span>]) addNode(p, x &amp; <span class="number">1</span>);</span><br><span class="line">		insert(ch[p][x &amp; <span class="number">1</span>], x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		pushUp(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		--ch[p][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">		erase(ch[p][x &amp; <span class="number">1</span>], x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		pushUp(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!ch[p][<span class="number">2</span>]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (rson) addAll(rson);</span><br><span class="line">		<span class="comment">// 为了进位，先补 0，补 0 的时候记得更新 ch[lson][2]（它延迟更新了）</span></span><br><span class="line">		<span class="keyword">if</span> (!lson) addNode(p, <span class="number">0</span>);</span><br><span class="line">		ch[lson][<span class="number">2</span>] = ch[p][<span class="number">2</span>] - (rson ? ch[rson][<span class="number">2</span>] : <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">std</span>::swap(lson, rson);</span><br><span class="line">		pushUp(p);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Trie() : ch(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		insert(<span class="number">0</span>, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		erase(<span class="number">0</span>, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		addAll(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ch[<span class="number">0</span>][<span class="number">3</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例题：<a href="https://www.luogu.com.cn/problem/P6018" target="_blank" rel="noopener">LOJ P6018</a></p>
<blockquote>
<p>注意数据必须保证任意时刻每个节点的矿泉水数非负。</p>
</blockquote>
<p><a href="https://www.luogu.com.cn/record/46497724" target="_blank" rel="noopener">灵活变长版</a> 和 <a href="https://www.luogu.com.cn/record/46496796" target="_blank" rel="noopener">定长版</a></p>
<h2 id="前缀函数"><a href="#前缀函数" class="headerlink" title="前缀函数"></a>前缀函数</h2><script type="math/tex; mode=display">
\pi[i] = \max_{k = 0, \cdots, i} \{ k : s[0, \cdots, k - 1] = s[i - (k - 1), \cdots i] \}</script><p>即子串 $s[0, \cdots, i]$ 的最长相等<strong>真</strong>前缀与<strong>真</strong>后缀的长度。</p>
<p>注意到两个事实：由定义知 $\pi[i + 1] \leq \pi[i] + 1$，因此若 $s[i + 1] == s[\pi[i]]$，那 $\pi[i + 1] = \pi[i] + 1$，反之，注意到我们始终有 $s[0, \cdots, \pi[i] - 1] = s[i - \pi[i] + 1, \cdots, i]$，对于的第二大的长度 $j$，我们有：</p>
<script type="math/tex; mode=display">
s[0, \cdots, j - 1] = s[i - j + 1, \cdots, i] = s[\pi[i] - j, \cdots, \pi[i] - 1]</script><p>即 j 等价于字串 $s[\pi[i] - 1]$ 的前缀和函数值，即 $j = \pi[\pi[i] - 1]$，然后依次这样进行下去即可。</p>
<p>复杂度：$O(n)$，注意到 $\pi[i + 1] \leq \pi[i] + 1$，若取等，我们称为上升（每步最多上升一次），反之我们称为下降，显然严格下降的次数不会超过上升的次数，因此整体上升下降次数不会超过 $2n$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefixFunction</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = p[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = p[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (s[i] == s[j]) ++j;</span><br><span class="line">		p[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意上述算法是一个在线算法，即可以一个一个的字符添加。</p>
</blockquote>
<h3 id="KMP-算法（Knuth-Morris-Pratt-算法）"><a href="#KMP-算法（Knuth-Morris-Pratt-算法）" class="headerlink" title="KMP 算法（Knuth-Morris-Pratt 算法）"></a>KMP 算法（Knuth-Morris-Pratt 算法）</h3><p>给定文本 t 和 字符串 s，尝试找到并展示 s 在 t 中的所有出现。</p>
<p>我们可以构建一个字符串 <code>s + # + t</code>，然后求前缀函数即可，<br>并且注意</p>
<ol>
<li>函数值最大为 n</li>
<li>若值为 n 表示匹配成功，且 i - 2n 为出现位置</li>
<li>我们不需要保存 t 的信息。</li>
</ol>
<p>因此我们可以在 $O(n + m)$ 时间 $O(n)$ 空间利用前缀函数解决此问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回所有匹配在 t 的首位置</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">kmp</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="built_in">std</span>::<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">auto</span> p = prefixFunction(s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[j] != t[i]) j = p[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (s[j] == t[i] &amp;&amp; ++j == n) ans.emplace_back(i - n + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题：<a href="https://codeforces.com/problemset/problem/126/B" target="_blank" rel="noopener">126B</a>，找一个最长的既是前缀又是后缀又是中间的最长字符串。</p>
<p>做法：首先计算出前缀函数，然后，用 kmp 看 s[0, pi[n - 1]] 是否在 s[1, n - 2] 中出现，没出现就看就继续看 $pi[pi[n - 1] - 1]$ 直到 0 即可。当然了可以有很多细节上的优化（例如 kmp 的时候不用每次都求一次前缀函数，在跑 KMP 的时候也只需要跑一次即可），但是此题不需要，<a href="https://codeforces.com/contest/126/submission/107155685" target="_blank" rel="noopener">我的代码</a> 也没优化，因为做题主要是测试代码正确性的。</p>
<h3 id="字符串的周期"><a href="#字符串的周期" class="headerlink" title="字符串的周期"></a>字符串的周期</h3><p>显然 $n - \pi[n - 1], n - \pi[pi[n - 1]], \cdots$ 为全部字符串的周期。</p>
<h3 id="统计每个前缀出现的次数"><a href="#统计每个前缀出现的次数" class="headerlink" title="统计每个前缀出现的次数"></a>统计每个前缀出现的次数</h3><p>首先以 i 为右端点有长度 $\pi[i]$ 的前缀，有长度 $\pi[\pi[i] - 1]$ 的前缀，等等知道长度为 0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 长度为 i 的前缀出现的次数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countPrefix</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = prefixFunction(s);</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : p) ++ans[x];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) ans[p[i - <span class="number">1</span>]] += ans[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) ++ans[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回 s 长度为 i 的前缀在 t 中出现的次数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countPrefix</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="built_in">std</span>::<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = prefixFunction(s);</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; t[i] != s[j]) j = p[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (t[i] == s[j]) ++j;</span><br><span class="line">		++ans[j];</span><br><span class="line">	&#125;</span><br><span class="line">	++ans[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; --i) ans[p[i - <span class="number">1</span>]] += ans[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题：<a href="https://codeforces.com/problemset/problem/432/D" target="_blank" rel="noopener">432D</a> 的<a href="https://codeforces.com/contest/432/submission/107155940" target="_blank" rel="noopener">代码</a></p>
<h2 id="BM-算法，Sunday-等一系列算法还是下次一定吧"><a href="#BM-算法，Sunday-等一系列算法还是下次一定吧" class="headerlink" title="BM 算法，Sunday 等一系列算法还是下次一定吧"></a>BM 算法，Sunday 等一系列算法还是下次一定吧</h2><h2 id="Z-函数，也称拓展-KMP"><a href="#Z-函数，也称拓展-KMP" class="headerlink" title="Z-函数，也称拓展 KMP"></a>Z-函数，也称拓展 KMP</h2><p>类似于前缀函数，Z-函数也可以用来求 KMP，也可以 $O(n)$ 给出 Z-函数，也当作另一种思路。</p>
<p>$z[i]$ 表示 s 和 $s[i, n - 1]$ 的最长公共前缀，约定 $z[0] = 0$</p>
<p>我们称 $i, i + z[i] - 1$ 是 i 的匹配段，也称 z-Box。</p>
<p>维护右端点最大的匹配段，记作 $[l, r]$，即 $s[l, r]$ 是 s 的前缀。</p>
<p>首先初始化，$l = r = 0, i = 1$（始终保证 $l \leq i$）</p>
<ul>
<li>若 $i \leq r$，根据定义 $s[i, r] = s[i - l, r - l]$，若 $s[i - l] &lt; r - i + 1$，则 $z[i] = z[i - l]$，反之，令 <code>z[i] = r - i + 1</code> 然后暴力拓展直到不能拓展为止</li>
<li>若 $i &gt; r$，那我们直接暴力求出 $z[i]$，</li>
</ul>
<p>无论那种情况都要更新 r。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">zFunction</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">z</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + <span class="number">1</span>) &#123;</span><br><span class="line">			z[i] = z[i - l];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, r - i + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">while</span> (i + j &lt; n &amp;&amp; s[j] == s[i + j]) ++j;</span><br><span class="line">			z[i] = j;</span><br><span class="line">			<span class="keyword">if</span> (i + j - <span class="number">1</span> &gt; r) &#123;</span><br><span class="line">				l = i;</span><br><span class="line">				r = i + j - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度，每次拓展 r 增加 1，因此总拓展次数小于 n，所以整体复杂度 $O(n)$。</p>
<p>类似于前缀函数，我们也可以求 KMP</p>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>构造 <code>s + # + t</code> 的串，那么我们可以通过计算 s 的 Z-函数，然后，在 t 中也类似的做，然后如果 t 中找到了长度为 s 长度的<br>z 值，那么就相当于匹配到了，并且注意到我们在这里不会再更新 r 值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回所有匹配在 t 的首位置</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">kmp</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="built_in">std</span>::<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">auto</span> z = zFunction(s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">-1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; r || z[i - l] &gt;= r - i + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, r - i + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">while</span> (j &lt; n &amp;&amp; i + j &lt; m &amp;&amp; s[j] == t[i + j]) ++j;</span><br><span class="line">			<span class="keyword">if</span> (j == n) ans.emplace_back(i);</span><br><span class="line">			<span class="keyword">if</span> (i + j - <span class="number">1</span> &gt; r) &#123;</span><br><span class="line">				l = i;</span><br><span class="line">				r = i + j - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动机（多模式串匹配）"><a href="#自动机（多模式串匹配）" class="headerlink" title="自动机（多模式串匹配）"></a>自动机（多模式串匹配）</h2><p><a href="https://oi-wiki.org/string/automaton/" target="_blank" rel="noopener">OI-wiki</a> 上讲的是真的好，就不赘述了。</p>
<p>主要用途，多串匹配。</p>
<h3 id="AC-自动机（Automaton）"><a href="#AC-自动机（Automaton）" class="headerlink" title="AC 自动机（Automaton）"></a>AC 自动机（Automaton）</h3><p>以 Trie 机构为基础，结合 KMP 的思想建立的。</p>
<ul>
<li>将所有模式串构成一颗 Trie</li>
<li>对 Trie 树上的所有节点构造失配（fail）指针（利用 KMP 思想）。</li>
</ul>
<p>上面是原始思想，一般都会做两个优化：路径压缩（也称建 Trie 图），后缀链接（也称 last 优化）</p>
<p>路径压缩会改变 Trie 的结构，即改变了状态转移，但是并没有改变最终状态点。它压缩了 fail 指针，一步到位。后缀链接压缩的模式匹配的时候不计入答案的直接跳过。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P3808" target="_blank" rel="noopener">LOJ P3808</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> &#123;</span></span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CHAR = <span class="number">26</span>;</span><br><span class="line">	<span class="keyword">using</span> Node = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, CHAR&gt;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; nxt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt, fail, last;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">charToInt</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; <span class="keyword">return</span> x - <span class="string">'a'</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> fa, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		nxt[fa][c] = nxt.<span class="built_in">size</span>();</span><br><span class="line">		nxt.emplace_back(Node());</span><br><span class="line">		cnt.emplace_back(<span class="number">0</span>);</span><br><span class="line">		fail.emplace_back(<span class="number">0</span>);</span><br><span class="line">		last.emplace_back(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Automaton() : nxt(<span class="number">1</span>), cnt(<span class="number">1</span>), fail(<span class="number">1</span>), last(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line">			<span class="keyword">int</span> c = charToInt(x);</span><br><span class="line">			<span class="keyword">if</span> (nxt[p][c] == <span class="number">0</span>) addNode(p, c);</span><br><span class="line">			p = nxt[p][c];</span><br><span class="line">		&#125;</span><br><span class="line">		++cnt[p];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; CHAR; ++c) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nxt[<span class="number">0</span>][c]) Q.push(nxt[<span class="number">0</span>][c]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> p = Q.front(); Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; CHAR; ++c) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">int</span> &amp;q = nxt[p][c]; q != <span class="number">0</span>) &#123;</span><br><span class="line">					fail[q] = nxt[fail[p]][c];</span><br><span class="line">					Q.push(q);</span><br><span class="line">					<span class="comment">// 用作模式匹配时计数的优化</span></span><br><span class="line">					last[q] = cnt[fail[q]] ? fail[q] : last[fail[q]];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					q = nxt[fail[p]][c];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 具体写法见题目要求</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">auto</span> add = [&amp;](<span class="keyword">int</span> &amp; x) &#123;</span><br><span class="line">			r += x; x = <span class="number">0</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line">			<span class="keyword">int</span> c = charToInt(x);</span><br><span class="line">			p = nxt[p][c];</span><br><span class="line">			<span class="keyword">if</span> (cnt[p]) add(cnt[p]);</span><br><span class="line">			<span class="keyword">int</span> q = p;</span><br><span class="line">			<span class="keyword">while</span> (last[q]) &#123;</span><br><span class="line">				q = last[q];</span><br><span class="line">				<span class="keyword">if</span> (cnt[q]) add(cnt[q]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	Automaton A;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		A.insert(s);</span><br><span class="line">	&#125;</span><br><span class="line">	A.build();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> t;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A.query(t) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外加强版例题：<a href="https://www.luogu.com.cn/problem/P3796" target="_blank" rel="noopener">LOJ P3796</a></p>
<p>我直接骚气的来一波节点存字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> &#123;</span></span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CHAR = <span class="number">26</span>;</span><br><span class="line">	<span class="keyword">using</span> Node = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, CHAR&gt;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; nxt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fail, last;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">charToInt</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123; <span class="keyword">return</span> x - <span class="string">'a'</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> fa, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		nxt[fa][c] = nxt.<span class="built_in">size</span>();</span><br><span class="line">		nxt.emplace_back(Node());</span><br><span class="line">		fail.emplace_back(<span class="number">0</span>);</span><br><span class="line">		last.emplace_back(<span class="number">0</span>);</span><br><span class="line">		str.emplace_back(<span class="built_in">std</span>::<span class="built_in">string</span>());</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Automaton() : nxt(<span class="number">1</span>), str(<span class="number">1</span>), fail(<span class="number">1</span>), last(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; str;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line">			<span class="keyword">int</span> c = charToInt(x);</span><br><span class="line">			<span class="keyword">if</span> (nxt[p][c] == <span class="number">0</span>) addNode(p, c);</span><br><span class="line">			p = nxt[p][c];</span><br><span class="line">		&#125;</span><br><span class="line">		str[p] = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; CHAR; ++c) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nxt[<span class="number">0</span>][c]) Q.push(nxt[<span class="number">0</span>][c]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> p = Q.front(); Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; CHAR; ++c) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">int</span> &amp;q = nxt[p][c]; q != <span class="number">0</span>) &#123;</span><br><span class="line">					fail[q] = nxt[fail[p]][c];</span><br><span class="line">					Q.push(q);</span><br><span class="line">					<span class="comment">// 用作模式匹配时计数的优化</span></span><br><span class="line">					last[q] = str[fail[q]].<span class="built_in">size</span>() ? fail[q] : last[fail[q]];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					q = nxt[fail[p]][c];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 具体写法见题目要求</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">query</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(str.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line">			<span class="keyword">int</span> c = charToInt(x);</span><br><span class="line">			p = nxt[p][c];</span><br><span class="line">			<span class="keyword">if</span> (str[p].<span class="built_in">size</span>()) ++r[p];</span><br><span class="line">			<span class="keyword">int</span> q = p;</span><br><span class="line">			<span class="keyword">while</span> (last[q]) &#123;</span><br><span class="line">				q = last[q];</span><br><span class="line">				++r[q];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		Automaton A;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">			A.insert(s);</span><br><span class="line">		&#125;</span><br><span class="line">		A.build();</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> t;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">		<span class="keyword">auto</span> r = A.query(t);</span><br><span class="line">		<span class="keyword">int</span> x = *<span class="built_in">std</span>::max_element(r.<span class="built_in">begin</span>(), r.<span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (r[i] == x) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A.str[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀数组-SA，后缀自动机-SAM，广义后缀自动机-Trie-SAM"><a href="#后缀数组-SA，后缀自动机-SAM，广义后缀自动机-Trie-SAM" class="headerlink" title="后缀数组 SA，后缀自动机 SAM，广义后缀自动机(Trie + SAM)"></a>后缀数组 SA，后缀自动机 SAM，广义后缀自动机(Trie + SAM)</h2><p>遇到问题再补吧。</p>
<h2 id="回文子串的-Manacher-算法"><a href="#回文子串的-Manacher-算法" class="headerlink" title="回文子串的 Manacher 算法"></a>回文子串的 Manacher 算法</h2><p>问题：给定字符串 s，求所有回文子串。</p>
<p>首先注意到以一个位置为中心的最长回文串的子串都是回文子串，因此我们直到对每个位置 i，求它们的半径 $d_i$ 即可。而 Manacher 给出了一个 $O(|s|)$ 时空的算法。由于回文串长度的奇偶性使得要分两种情况讨论，但是我们其实也可以在其中插入 <code>#</code> 来统一成奇数的形式。</p>
<p>模板例题：<a href="https://vjudge.net/problem/UVA-11475" target="_blank" rel="noopener">UVA-11475</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅仅处理奇数长回文串，这个实现像极了 Z-函数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Manacher</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">-1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = i &gt; r ? <span class="number">1</span> : <span class="built_in">std</span>::<span class="built_in">min</span>(d[l + r - i], r - i);</span><br><span class="line">		<span class="keyword">while</span> (k &lt;= i &amp;&amp; i + k &lt; n &amp;&amp; s[i - k] == s[i + k]) ++k;</span><br><span class="line">		d[i] = k--;</span><br><span class="line">		<span class="keyword">if</span> (i + k &gt; r) &#123;</span><br><span class="line">			l = i - k;</span><br><span class="line">			r = i + k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ss</span><span class="params">(<span class="string">"#"</span>)</span></span>;</span><br><span class="line">		<span class="built_in">std</span>::swap(ss, s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : ss) &#123;</span><br><span class="line">			s += x; s += <span class="string">'#'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> d = Manacher(s);</span><br><span class="line">		<span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (now &lt; s.<span class="built_in">size</span>() &amp;&amp; now + d[now] != s.<span class="built_in">size</span>()) ++now;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ss;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = now - d[now]; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> (s[i] != <span class="string">'#'</span>) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它例题：<a href="https://www.luogu.com.cn/problem/P4555" target="_blank" rel="noopener">LOJ P4555</a>，求最长双回文子串（即可以拆成两个回文子串）</p>
<p>我们定义 $l[i], r[i]$ 分别表示以 i 开头和以 i 结尾的回文长度。则 </p>
<script type="math/tex; mode=display">
l[i] = \max(l[i], l[i + 2] - 2), r[i] = \max(r[i], r[i - 2] - 2)</script><p>枚举每一个 <code>#</code> 为断点，更新答案即可。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅仅处理奇数长回文串</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Manacher</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">-1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = i &gt; r ? <span class="number">1</span> : <span class="built_in">std</span>::<span class="built_in">min</span>(d[l + r - i], r - i);</span><br><span class="line">		<span class="keyword">while</span> (k &lt;= i &amp;&amp; i + k &lt; n &amp;&amp; s[i - k] == s[i + k]) ++k;</span><br><span class="line">		d[i] = k--;</span><br><span class="line">		<span class="keyword">if</span> (i + k &gt; r) &#123;</span><br><span class="line">			l = i - k;</span><br><span class="line">			r = i + k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ss</span><span class="params">(<span class="string">"#"</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::swap(ss, s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : ss) &#123;</span><br><span class="line">		s += x; s += <span class="string">'#'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> d = Manacher(s);</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	std::vector&lt;int&gt; l(n), r(n);</span><br><span class="line">	<span class="keyword">auto</span> cmax = [](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; y) x = y;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		cmax(l[i + d[i] - <span class="number">1</span>], d[i] - <span class="number">1</span>);</span><br><span class="line">		cmax(r[i - d[i] + <span class="number">1</span>], d[i] - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i -= <span class="number">2</span>)  cmax(l[i], l[i + <span class="number">2</span>] - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i += <span class="number">2</span>) cmax(r[i], r[i - <span class="number">2</span>] - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i += <span class="number">2</span>) <span class="keyword">if</span> (l[i] &amp;&amp; r[i]) cmax(ans, l[i] + r[i]);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回文自动机"><a href="#回文自动机" class="headerlink" title="回文自动机"></a>回文自动机</h2><p>待补</p>
<h2 id="序列自动机"><a href="#序列自动机" class="headerlink" title="序列自动机"></a>序列自动机</h2><h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><p>我们称两个字符串 S 和 T <strong>循环同构</strong>，如果它们各自首尾相接得到一个有向环是相同的。</p>
<p>最小表示：与 S 循环同构的字典序最小的字符串。</p>
<p>我们记 $S_i$ 表示以 S 的第 i 个字符开头与 S 循环同构的字符串。</p>
<p>直接暴力是 $O(n^2)$ 的，但是观察到，若 $s[i, \cdots, i +k - 1] = s[j \cdot, j + k - 1]$，那么我们就要开始比较 s[i + k] 和 s[j + k]，不妨设 $s[i + k] &gt; s[j + k]$，那么显然 $S_{i + p} &lt; S_{j + p} (p \leq k)$ 若 $l \in [i, i + k]$，则 $S_l$ 不可能成为最小表示。</p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/P1368" target="_blank" rel="noopener">LOJ P1368</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPresent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">1</span>, n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">while</span> (k &lt; n &amp;&amp; i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[(i + k) % n] == a[(j + k) % n]) &#123;</span><br><span class="line">			++k;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			a[(i + k) % n] &gt; a[(j + k) % n] ? i += k + <span class="number">1</span> : j += k + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i == j) ++i;</span><br><span class="line">			k = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">min</span>(i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lyndon-分解"><a href="#Lyndon-分解" class="headerlink" title="Lyndon 分解"></a>Lyndon 分解</h2><p>Lyndon word：我们称 $s$ 是 Lyndon word，如果 s 的字典序严格小于它所有真后缀的字典序。这等价于说它是自己的循环同构中最小的。</p>
<p>Lyndon 分解：$s = w_1 \cdots, w_k$，其中 $w_i$ 是 Lyndon word，且 $w_1 \geq w_2 \geq \cdots, w_k$。可以证明分解存在且唯一。</p>
<p>Duval 算法：在 $O(n)$ 时间给出一个串的 Lyndon 分解。（待补）</p>
<p>根据 Shirshov 分解：$s = s_L s_R$，其中 $s_R$ 是字典序最小的后缀（从而是 Lyndon word），若 $s_R = s$ 结束；否则，我们对剩下的 $s_L$ 做同样的操作。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 图论模板</title>
    <url>/graph/</url>
    <content><![CDATA[<p>图论还是一个特别强的工具。 为什么没有图论的 STL？</p>
<h2 id="其他人的图论模板可做参考（其实我自己的够用了目前看）"><a href="#其他人的图论模板可做参考（其实我自己的够用了目前看）" class="headerlink" title="其他人的图论模板可做参考（其实我自己的够用了目前看）"></a>其他人的图论模板可做参考（其实我自己的够用了目前看）</h2><ul>
<li><a href="https://uoj.ac/submission/160478" target="_blank" rel="noopener">Nisiyama_Suzune</a> 的图论模板</li>
<li><a href="https://github.com/DQ9911/icpc_template_2020" target="_blank" rel="noopener">DQ9911</a> 的模板</li>
<li><a href="HDU_ACM-ICPC_Templates.pdf">HDU 模板</a> 也可以作为参考</li>
</ul>
<h2 id="存边方式"><a href="#存边方式" class="headerlink" title="存边方式"></a>存边方式</h2><ul>
<li>不涉及删边和反边（最简单常用的情况），可以直接用 vector 邻接表 <code>std::vector&lt;std::vector&lt;std::pair&lt;int, T&gt;&gt;&gt;</code></li>
<li>仅涉及反向边，不涉及删边（如网络流问题），可以使用 vector 版本的链式前向星（写法特别简洁）</li>
<li>不涉及重边（即使涉及重边也可以！其它操作随意，无向图其实也可以操作），都可以使用 vector 邻接表 <code>std::vector&lt;std::unordered_map&lt;int, int&gt;&gt;</code>（更快）或<code>std::vector&lt;std::map&lt;int, T&gt;&gt;</code>，当然了各种操作都要带个 log </li>
<li>如果涉及重边（逻辑上没法合并的那种），就不存在反边的概念了。此时可以用链式前向星，也可以使用 最简单情况的 vector 邻接表（也支持删边，只是比较慢）无论怎么，即使不用链式前向星，这种思想还是值得学习的。</li>
</ul>
<h3 id="链式前向星-（弃用）"><a href="#链式前向星-（弃用）" class="headerlink" title="链式前向星 （弃用）"></a>链式前向星 （弃用）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head, nxt, to;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; w;</span><br><span class="line">	LinkStar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		nxt.<span class="built_in">clear</span>();</span><br><span class="line">		to.<span class="built_in">clear</span>();</span><br><span class="line">		head = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL val)</span> </span>&#123;</span><br><span class="line">		nxt.emplace_back(head[u]);</span><br><span class="line">		head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">		to.emplace_back(v);</span><br><span class="line">		w.emplace_back(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="邻接矩阵存边（太简单就不写了）"><a href="#邻接矩阵存边（太简单就不写了）" class="headerlink" title="邻接矩阵存边（太简单就不写了）"></a>邻接矩阵存边（太简单就不写了）</h3><h3 id="邻接-map-or-unorder-map-存边（同上）"><a href="#邻接-map-or-unorder-map-存边（同上）" class="headerlink" title="邻接 map or unorder_map 存边（同上）"></a>邻接 map or unorder_map 存边（同上）</h3><h3 id="vector-版本链式前向星（见后面网络流的做法）"><a href="#vector-版本链式前向星（见后面网络流的做法）" class="headerlink" title="vector 版本链式前向星（见后面网络流的做法）"></a>vector 版本链式前向星（见后面网络流的做法）</h3><h2 id="树上问题转化成序列问题"><a href="#树上问题转化成序列问题" class="headerlink" title="树上问题转化成序列问题"></a>树上问题转化成序列问题</h2><h3 id="无根树的-Prufer-序列"><a href="#无根树的-Prufer-序列" class="headerlink" title="无根树的 Prufer 序列"></a>无根树的 Prufer 序列</h3><blockquote>
<p>A.Cayley 在 1889 年首先公布并证明 $n$ 个节点的无根树和长度为 $n-2$，数值在 $1 \to n$ 的序列有一一对应</p>
<p>构造方式：删除编号最小的叶子节点，并记录它的父节点。</p>
</blockquote>
<p>曾在 <a href="/catWithPy/" title="猫咪状态数">猫咪状态数</a> 中有记录过。<a href="https://cp-algorithms.com/graph/pruefer_code.html" target="_blank" rel="noopener">CP-algorithm</a> 中有详细的讲解和代码 无根树 和 Prufer 序列 互转的 $O(n \log n)$ 和 $O(n)$ 两类代码。</p>
<h3 id="有根树的-dfs-序"><a href="#有根树的-dfs-序" class="headerlink" title="有根树的 dfs 序"></a>有根树的 <strong>dfs 序</strong></h3><blockquote>
<p>本质作用： 将树上问题转化成序列问题，dfs 序是基础，Euler 序可以认为是推广。</p>
</blockquote>
<p>树节点按 dfs 过程中的访问顺序排序（进入记录一次，出去记录一次），称为 dfs 序。处理子树的问题很有用。</p>
<p><a href="https://www.cnblogs.com/bytebull/p/5929137.html" target="_blank" rel="noopener">这里</a> 给出了 dfs 序的一些应用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DfsTour</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, cnt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l, r;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DfsTour(<span class="keyword">int</span> _n) : n(_n), e(n), l(n), r(n), cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">		l[u] = ++cnt;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			dfs(v, u);</span><br><span class="line">		&#125;</span><br><span class="line">		r[u] = cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 u 的子树的编号正好是区间 $[l_u, r_u]$</p>
</blockquote>
<p>关于子树的问题，可以考虑一下 dfs 序。</p>
<ol>
<li>在节点权值可修改的情况下，查询某个子树里的所有点权和。<blockquote>
<p>由于在上述 dfs 序中子树 x 是连续的一段 $[l_x, r_x]$，所以用树状数组：单点更新，区间查询。</p>
</blockquote>
</li>
<li>节点 X 到 Y 的最短路上所有点权都加上一个数 W，查询某个子树里的所有点权和。<br>可以理解为更新 4 段区间，根节点到 X，根节点到 Y，根节点到 lca(X, Y)，根节点到 fa[lca(X, Y)]，可以用 线段树 或 带区间更新的树状数组。</li>
</ol>
<h3 id="有根树的-Euler-序列（长度为-2n-1）"><a href="#有根树的-Euler-序列（长度为-2n-1）" class="headerlink" title="有根树的 Euler 序列（长度为 2n - 1）"></a>有根树的 Euler 序列（长度为 2n - 1）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 rt 为根的树，只记录进入的 Euler 序（长度为 2n - 1)</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">EulerTour</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; e, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		r.emplace_back(u);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			dfs(v, u);</span><br><span class="line">			r.emplace_back(u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	dfs(rt, rt);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先观察到这个树的 Euler 序列首尾都是根的编号，如果把首尾连接起来，就会发现：<strong>这个序列中元素出现的次数正好是它的度</strong>。并且我们可以轻松的<strong>换根节点</strong>!!!，以谁为根就以谁开始转圈！并且如果删除某个节点，那么就会形成<strong>以这个节点为度的个数的连通分支</strong>。</p>
<p>问题 1：求 最近公共祖先（LCA）</p>
<p>求完 Euler 序列后，求 <code>lca(u, v)</code> 那就是 $E[pos[u], \cdots, pos[v]]$ 的最小值，其中 <code>pos[u]</code> 为 u 首次出现在 E 中的标号。那么显然我们可以用线段树 $O(n)$ 预处理，单步 $O(\log n)$ 在线查询 lca。</p>
<p>问题 2：求树上任意两点的距离</p>
<p>求完 Euler 序列的同时，我们先求出根节点和其它点的距离，由上述步骤我们能求 lca，那么树上任意两点 $u, v$ 的距离就是 <code>d[u] + d[v] - d[lca(u, v)]</code></p>
<blockquote>
<p>如果求树上任意两点距离之和：只需统计每条边经过多少次就行，显然等价于每条边左右两边节点个数，就不用上述做法了。</p>
</blockquote>
<p>问题 3：求树上节点到根节点的最短路径点权和</p>
<h3 id="树链剖分-Heavy-Light-decomposition"><a href="#树链剖分-Heavy-Light-decomposition" class="headerlink" title="树链剖分 Heavy-Light decomposition"></a><a href="https://oi-wiki.org/graph/hld/" target="_blank" rel="noopener">树链剖分 Heavy-Light decomposition</a></h3><p>重链剖分可以理解为 dfs 序和 Euler 序的增强优化拓展版本。</p>
<h4 id="重链剖分求-LCA-的模板例题：LOJ-3379，我的实现"><a href="#重链剖分求-LCA-的模板例题：LOJ-3379，我的实现" class="headerlink" title="重链剖分求 LCA 的模板例题：LOJ 3379，我的实现"></a>重链剖分求 LCA 的模板例题：<a href="https://www.luogu.com.cn/problem/P3379" target="_blank" rel="noopener">LOJ 3379</a>，<a href="https://www.luogu.com.cn/record/45492112" target="_blank" rel="noopener">我的实现</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LCA</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa, dep, sz, son, top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LCA(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="keyword">int</span> rt = <span class="number">1</span>) : n(e.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		fa.resize(n);</span><br><span class="line">		dep.resize(n);</span><br><span class="line">		sz.resize(n);</span><br><span class="line">		son.resize(n);</span><br><span class="line">		fa[rt] = rt;</span><br><span class="line">		dep[rt] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			sz[u] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa[u]) &#123;</span><br><span class="line">				dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">				fa[v] = u;</span><br><span class="line">				sz[u] += pdfs(v);</span><br><span class="line">				<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sz[u];</span><br><span class="line">		&#125;;</span><br><span class="line">		top.resize(n);</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> t) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">			top[u] = t;</span><br><span class="line">			<span class="keyword">if</span> (son[u] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">			dfs(son[u], t);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa[u] &amp;&amp; v != son[u]) dfs(v, v);</span><br><span class="line">		&#125;;</span><br><span class="line">		pdfs(rt);</span><br><span class="line">		dfs(rt, rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">				u = fa[top[u]];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				v = fa[top[v]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("C:\\Users\\dna049\\cf\\in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m, rt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; rt;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LCA <span class="title">g</span><span class="params">(e, rt)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g.lca(x, y) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重链剖分求任意两点路径上所有节点的点权和，求子树的点权和（利用-dfs-编号和-sz-直接区间查询或区间修改）"><a href="#重链剖分求任意两点路径上所有节点的点权和，求子树的点权和（利用-dfs-编号和-sz-直接区间查询或区间修改）" class="headerlink" title="重链剖分求任意两点路径上所有节点的点权和，求子树的点权和（利用 dfs 编号和 sz 直接区间查询或区间修改）"></a>重链剖分求任意两点路径上所有节点的点权和，求子树的点权和（利用 dfs 编号和 sz 直接区间查询或区间修改）</h4><p>例题：<a href="https://www.luogu.com.cn/problem/P3384" target="_blank" rel="noopener">LOJ 3384</a>，参考：<a href="https://www.cnblogs.com/chinhhh/p/7965433.html" target="_blank" rel="noopener">ChinHhh’s blog</a>，用加强版树状数组而非线段树算的：<a href="https://www.luogu.com.cn/record/45509401" target="_blank" rel="noopener">提交记录</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line">LL M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; s;</span><br><span class="line">	TreeArray() &#123;&#125;</span><br><span class="line">	TreeArray(<span class="keyword">int</span> n) : s(n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			(s[id] += p) %= M;</span><br><span class="line">			id += lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (id) &#123;</span><br><span class="line">			(r += s[id]) %= M;</span><br><span class="line">			id -= lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeArrayPlus</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// c[i] = a[i] - a[i - 1], b_i = (i - 1) * c_i</span></span><br><span class="line">	TreeArray B, C;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		C.add(id, p);</span><br><span class="line">		B.add(id, (id - <span class="number">1</span>) * p % M);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	TreeArrayPlus() &#123;&#125;</span><br><span class="line">	TreeArrayPlus(<span class="keyword">int</span> _n) : n(_n), B(n), C(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		add(l, p);</span><br><span class="line">		add(r + <span class="number">1</span>, -p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (id * C.sum(id) + M - B.sum(id)) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ((sum(r) - sum(l - <span class="number">1</span>)) % M + M) % M;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HLD</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa, dep, sz, son, top, dfn;</span><br><span class="line">	TreeArrayPlus Tree;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	HLD(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> rt = <span class="number">1</span>) : n(e.<span class="built_in">size</span>()), Tree(n + <span class="number">1</span>) &#123;</span><br><span class="line">		fa.resize(n);</span><br><span class="line">		dep.resize(n);</span><br><span class="line">		sz.resize(n);</span><br><span class="line">		son.resize(n);</span><br><span class="line">		fa[rt] = dep[rt] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			sz[u] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa[u]) &#123;</span><br><span class="line">				dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">				fa[v] = u;</span><br><span class="line">				sz[u] += pdfs(v);</span><br><span class="line">				<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sz[u];</span><br><span class="line">		&#125;;</span><br><span class="line">		top.resize(n);</span><br><span class="line">		dfn.resize(n);</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> t) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">			top[u] = t;</span><br><span class="line">			dfn[u] = ++cnt;</span><br><span class="line">			<span class="keyword">if</span> (son[u] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">			dfs(son[u], t);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa[u] &amp;&amp; v != son[u]) dfs(v, v);</span><br><span class="line">		&#125;;</span><br><span class="line">		pdfs(rt);</span><br><span class="line">		dfs(rt, rt);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) Tree.add(dfn[i], dfn[i], a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// u 到根的最短路径上所有边权值加 c</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (u) &#123;</span><br><span class="line">			Tree.add(dfn[top[u]], dfn[u], c);</span><br><span class="line">			u = fa[top[u]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// u 到根的最短路径上所有边权值之和</span></span><br><span class="line">	<span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (u) &#123;</span><br><span class="line">			r += Tree.sum(dfn[top[u]], dfn[u]);</span><br><span class="line">			u = fa[top[u]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// u, v 的最短路径上所有边权值加 c（可以通过 lca 和根来搞，但是会很慢）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">				Tree.add(dfn[top[u]], dfn[u], c);</span><br><span class="line">				u = fa[top[u]];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				Tree.add(dfn[top[v]], dfn[v], c);</span><br><span class="line">				v = fa[top[v]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dep[u] &lt; dep[v]) &#123;</span><br><span class="line">			Tree.add(dfn[u], dfn[v], c);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Tree.add(dfn[v], dfn[u], c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// u, v 的最短路径上所有边权值之和（可以通过 lca 和根来搞，但是会很慢）</span></span><br><span class="line">	<span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">				r += Tree.sum(dfn[top[u]], dfn[u]);</span><br><span class="line">				u = fa[top[u]];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				r += Tree.sum(dfn[top[v]], dfn[v]);</span><br><span class="line">				v = fa[top[v]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dep[u] &lt; dep[v]) &#123;</span><br><span class="line">			r += Tree.sum(dfn[u], dfn[v]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r += Tree.sum(dfn[v], dfn[u]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addSon</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		Tree.add(dfn[u], dfn[u] + sz[u] - <span class="number">1</span>, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">querySon</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Tree.sum(dfn[u], dfn[u] + sz[u] - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">				u = fa[top[u]];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				v = fa[top[v]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("C:\\Users\\dna049\\cf\\in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m, rt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; rt &gt;&gt; M;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">HLD <span class="title">g</span><span class="params">(e, a, rt)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> op, x, y, z;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">			g.add(x, y, z);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g.query(x, y) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; z;</span><br><span class="line">			g.addSon(x, z);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g.querySon(x) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// auto start = std::clock();</span></span><br><span class="line">	<span class="comment">// std::cout &lt;&lt; "Time used: " &lt;&lt; (std::clock() - start) &lt;&lt; "ms" &lt;&lt; std::endl;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="长链剖分优化-DP，例题：1009F"><a href="#长链剖分优化-DP，例题：1009F" class="headerlink" title="长链剖分优化 DP，例题：1009F"></a>长链剖分优化 DP，例题：<a href="https://codeforces.com/contest/1009/problem/F" target="_blank" rel="noopener">1009F</a></h4><p>这个题显然可以用重链剖分来做，或者说下面的 dsu on tree 来做（$O(n \log n)$），但是<a href="https://codeforces.com/blog/entry/60630" target="_blank" rel="noopener">官方题解</a> 用长链剖分可以优化到 $O(n)$！太强了。主要原因是因为，每个轻儿子节点最多被合并一次（它第一次合并之后，它的信息就被和他同深度的重兄弟节点给吸收了），后面再合并的时候就不算它被合并而算当前重儿子节点的合并了（妙不可言）。但是父节点占据儿子节点的时候有个问题就是用 std::map 或 std::unordered_map 本质上都会带一个 log，因此我们需要用 vector 保存信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始。</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dsuOnTree</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 预处理出重儿子</span></span><br><span class="line">	std::vector&lt;int&gt; sz(n), son(n);</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			pdfs(v, u);</span><br><span class="line">			<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		sz[u] = sz[son[u]] + <span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> (son[u] == <span class="number">0</span>) &#123;</span><br><span class="line">			ans[u] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> a = dfs(son[u], u);</span><br><span class="line">		ans[u] = ans[son[u]];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			<span class="keyword">auto</span> tmp = dfs(v, u);</span><br><span class="line">			<span class="comment">// 这里需要对齐</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> ai = a.<span class="built_in">size</span>() - <span class="number">1</span>, ti = tmp.<span class="built_in">size</span>() - <span class="number">1</span>; ti &gt;= <span class="number">0</span>; --ti, --ai) &#123;</span><br><span class="line">				a[ai] += tmp[ti];</span><br><span class="line">				<span class="keyword">if</span> (a[ai] &gt; a[ans[u]] || (a[ai] == a[ans[u]] &amp;&amp; ai &gt; ans[u])) &#123;</span><br><span class="line">					ans[u] = ai;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		a.emplace_back(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (a[ans[u]] == <span class="number">1</span>) ans[u] = sz[u] - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;;</span><br><span class="line">	pdfs(rt, <span class="number">0</span>);</span><br><span class="line">	dfs(rt, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) ans[i] = sz[i] - <span class="number">1</span> - ans[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> r = dsuOnTree(e);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树上启发式算法（dsu-on-tree）"><a href="#树上启发式算法（dsu-on-tree）" class="headerlink" title="树上启发式算法（dsu on tree）"></a><a href="https://oi-wiki.org/graph/dsu-on-tree/" target="_blank" rel="noopener">树上启发式算法（dsu on tree）</a></h3><p>先处理轻儿子，但是不保留影响，再处理重儿子保留，再暴力处理所有其它情况，再看次节点是否需要保留。</p>
<p>复杂度分析真的太妙了！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始，参考：https://www.cnblogs.com/zwfymqz/p/9683124.html</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">dsuOnTree</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 预处理出重儿子</span></span><br><span class="line">	std::vector&lt;int&gt; sz(n), son(n), cnt(n);</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		sz[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			sz[u] += pdfs(v, u);</span><br><span class="line">			<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sz[u];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 这个函数具体问题具体分析</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> mx = <span class="number">0</span>, Son = <span class="number">0</span>;</span><br><span class="line">	LL sm = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; deal = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		++cnt[a[u]];</span><br><span class="line">		<span class="keyword">if</span> (cnt[a[u]] &gt; mx) &#123;</span><br><span class="line">			mx = cnt[a[u]];</span><br><span class="line">			sm = a[u];</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt[a[u]] == mx) &#123;</span><br><span class="line">			sm += a[u];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; v != Son) &#123;</span><br><span class="line">			deal(v, u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; del = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		--cnt[a[u]];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) del(v, u);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">bool</span> save) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs(v, u, <span class="number">0</span>); <span class="comment">// 先计算轻边贡献，但最终要消除影响，防止轻边互相干扰</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>);  <span class="comment">// 统计重儿子的贡献，但不消除影响</span></span><br><span class="line">		Son = son[u];</span><br><span class="line">		deal(u, fa); <span class="comment">// 暴力处理除重儿子外的贡献</span></span><br><span class="line">		Son = <span class="number">0</span>;</span><br><span class="line">		ans[u] = sm;</span><br><span class="line">		<span class="keyword">if</span> (!save) &#123;</span><br><span class="line">			del(u, fa);</span><br><span class="line">			sm = <span class="number">0</span>;</span><br><span class="line">			mx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	pdfs(rt, rt);</span><br><span class="line">	dfs(rt, rt, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思想是这样的，到时候具体问题灵活运用，不必死套模板，例如 <a href="https://codeforces.com/gym/102832/problem/F" target="_blank" rel="noopener">gym 102832F</a> 我的另样做法 <a href="https://codeforces.com/gym/102832/submission/105273241" target="_blank" rel="noopener">submission 105273241</a> 更加优秀，快速。</p>
</blockquote>
<h2 id="树上问题"><a href="#树上问题" class="headerlink" title="树上问题"></a>树上问题</h2><h3 id="树的直径：先从任意点开始寻找最远距离点（bfs-遍历一下），然后再找一次就是了（易证）"><a href="#树的直径：先从任意点开始寻找最远距离点（bfs-遍历一下），然后再找一次就是了（易证）" class="headerlink" title="树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）"></a>树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）</h3><p>例题：<a href="https://codeforces.com/contest/1405/problem/D" target="_blank" rel="noopener">1405D</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> bfs = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	d[x] = <span class="number">0</span>;</span><br><span class="line">	Q.push(x);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (d[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">			d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">			Q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::max_element(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>()) - d.<span class="built_in">begin</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树的中心-：所有点到该点的最大值最小（直径的中点）"><a href="#树的中心-：所有点到该点的最大值最小（直径的中点）" class="headerlink" title="[树的中心]：所有点到该点的最大值最小（直径的中点）"></a>[树的中心]：所有点到该点的最大值最小（直径的中点）</h3><h3 id="树的重心：去掉这个点后连通分支的节点数量的最大值最小"><a href="#树的重心：去掉这个点后连通分支的节点数量的最大值最小" class="headerlink" title="树的重心：去掉这个点后连通分支的节点数量的最大值最小"></a><a href="https://oi-wiki.org/graph/tree-centroid/" target="_blank" rel="noopener">树的重心</a>：去掉这个点后连通分支的节点数量的最大值最小</h3><p>根据 DFS 子树的大小和“向上”的子树大小就可以知道所有子树中最大的子树节点数。：<a href="https://codeforces.com/contest/1406/problem/C" target="_blank" rel="noopener">例题 1406C</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中 e 表示树的边，n 为数的数量</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; degree = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">	d[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (d[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">		d[u] += degree(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[u];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> barycenter = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">int</span> cnt = degree(x);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n, n)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(x);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		w[u] = cnt - d[u];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (w[v] == n) &#123;</span><br><span class="line">			w[u] = <span class="built_in">std</span>::<span class="built_in">max</span>(w[u], d[v]);</span><br><span class="line">			Q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="built_in">std</span>::min_element(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>()) - w.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::make_pair(r, w[r]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最近公共祖先简称-LCA（Lowest-Common-Ancestor）"><a href="#最近公共祖先简称-LCA（Lowest-Common-Ancestor）" class="headerlink" title="最近公共祖先简称 LCA（Lowest Common Ancestor）"></a>最近公共祖先简称 LCA（Lowest Common Ancestor）</h3><ul>
<li>策略 1：其中一个节点一直往上标记父辈到根，然后另一个节点往上找父辈，直到找到首次被标记过的节点</li>
<li>策略 2：标记没个节点的深度，深度高的往上到同一层，然后一起一步步上去，直到是公共节点</li>
<li>策略 3：做一次 DFS 得到 Euler 序列，然后就变成找区间最小值问题了（可以使用线段树）</li>
<li>策略 4：树链剖分（见下面做法，目前我的做法）</li>
<li>其他：倍增（记录 <code>fa[u][i]</code>：表示 <code>u</code> 的第$2^i$祖先），Tarjan 算法，动态树<br><a href="https://oi-wiki.org/graph/lca/" target="_blank" rel="noopener">OI-wiki</a> 给了很多做法，竟然有标准 $O(N)$ 时空复杂度的 RMQ 做法还支持在线，太强了，太强了，mark 一下，有模板，但是并不想学。</li>
</ul>
<h3 id="有向图的拓扑排序之-Kahn-算法"><a href="#有向图的拓扑排序之-Kahn-算法" class="headerlink" title="有向图的拓扑排序之 Kahn 算法"></a><a href="https://oi-wiki.org/graph/topo/" target="_blank" rel="noopener">有向图的拓扑排序之 Kahn 算法</a></h3><p>给定有向图，然后把节点按照顺序排列，使得任意有向边的起点在终点前。</p>
<p>做法：维护一个入度为 0 的节点集合，一次删除节点（加入拓扑序列），删除的时候它连接的所有点入度减 1，为 0 就加入节点集合。</p>
<blockquote>
<p>一个有向图是无环图，当且仅当它存在拓扑排序。</p>
</blockquote>
<h3 id="笛卡尔树-：我去，竟然是-O-n-复杂度的建树（弃用没必要直接学单调栈即可）"><a href="#笛卡尔树-：我去，竟然是-O-n-复杂度的建树（弃用没必要直接学单调栈即可）" class="headerlink" title="笛卡尔树 ：我去，竟然是 $O(n)$ 复杂度的建树（弃用没必要直接学单调栈即可）"></a><a href="https://oi-wiki.org/ds/cartesian-tree/" target="_blank" rel="noopener">笛卡尔树</a> ：我去，竟然是 $O(n)$ 复杂度的建树（弃用没必要直接学单调栈即可）</h3><blockquote>
<p>从<a href="https://oi-wiki.org/ds/cartesian-tree/" target="_blank" rel="noopener">OI - wiki</a> 中看到的讲解和复杂度分析!，注意到右链是从尾巴往上查找的。<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506" target="_blank" rel="noopener"><strong>hdu 1506</strong></a><br>这就给出了一个 $O(n)$ 复杂度求出包含 <code>i</code>且以 <code>a[i]</code> 为最大值的区间的方法（最小值保存的时候取负数即可），太强了！<br>求上述对应的最大值区间，需要修改 0 节点的值，以及 build 的大于号改成小于号。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id, val, par, ch[<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _id, <span class="keyword">int</span> _val, <span class="keyword">int</span> _par)</span> </span>&#123;</span><br><span class="line">		id = _id, val = _val, par = _par, ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cartesian_build</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; &amp;tree, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (tree[k].val &lt; tree[i].val) k = tree[k].par;</span><br><span class="line">		tree[i].ch[<span class="number">0</span>] = tree[k].ch[<span class="number">1</span>];</span><br><span class="line">		tree[k].ch[<span class="number">1</span>] = i;</span><br><span class="line">		tree[i].par = k;</span><br><span class="line">		tree[tree[i].ch[<span class="number">0</span>]].par = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree[<span class="number">0</span>].ch[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; <span class="title">tree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">		tree[<span class="number">0</span>].init(<span class="number">0</span>, INT_MAX, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			tree[i].init(i, x, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> root = cartesian_build(tree, n);</span><br><span class="line">		LL ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> sz = dfs(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">			sz += dfs(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">			ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, LL(sz + <span class="number">1</span>) * tree[x].val);</span><br><span class="line">			<span class="keyword">return</span> sz + <span class="number">1</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		dfs(root);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 下面是求以 a[i] 为最大值且包含 i 的最大区间</span></span><br><span class="line">		std::vector&lt;int&gt; l(n + 1), r(n + 1);</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; getinterval = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (tree[tree[x].par].ch[<span class="number">0</span>] == x) &#123;</span><br><span class="line">				r[x] = tree[x].par - <span class="number">1</span>;</span><br><span class="line">				l[x] = l[tree[x].par];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l[x] = tree[x].par + <span class="number">1</span>;</span><br><span class="line">				r[x] = r[tree[x].par];</span><br><span class="line">			&#125;</span><br><span class="line">			getinterval(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">			getinterval(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">		&#125;;</span><br><span class="line">		l[root] = <span class="number">1</span>;</span><br><span class="line">		r[root] = n;</span><br><span class="line">		getinterval(tree[root].ch[<span class="number">0</span>]);</span><br><span class="line">		getinterval(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">		<span class="comment">// 要考虑有相同值的情形，必须要分两次搞，不然有bug</span></span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; updateinterval = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (tree[tree[x].par].ch[<span class="number">0</span>] == x) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tree[x].val == tree[tree[x].par].val) r[x] = r[tree[x].par];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (tree[x].val == tree[tree[x].par].val) l[x] = l[tree[x].par];</span><br><span class="line">			&#125;</span><br><span class="line">			updateinterval(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">			updateinterval(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">		&#125;;</span><br><span class="line">		updateinterval(tree[root].ch[<span class="number">0</span>]);</span><br><span class="line">		updateinterval(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; l[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; r[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>洛谷 T126268 「SWTR-05」Subsequence 有一个典型的应用</p>
</blockquote>
<h3 id="最小生成树-prim-算法"><a href="#最小生成树-prim-算法" class="headerlink" title="最小生成树 prim 算法"></a>最小生成树 prim 算法</h3><p>任取一个节点，然后开始找相邻边中边最小的节点加入，然后继续。<a href="https://baike.baidu.com/item/Prim/10242166" target="_blank" rel="noopener">百度百科</a>里的图解一看就懂，怎么明确证明正确性呢？（在保证连通的前提下每次删除图中最大的边，不会影响最终结果，而我们每步得到的是当前节点构成的子图的最小生成树）当然了堆优化常规操作，另外不连通输出 <code>INT64_MAX</code>, 例题：<a href="https://www.luogu.com.cn/problem/P3366" target="_blank" rel="noopener">LOJ3366</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function">LL <span class="title">Prim</span><span class="params">(<span class="keyword">const</span> edge &amp;e)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">	Q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [w, u] = Q.top();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		++cnt;</span><br><span class="line">		r -= w;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : e[u]) <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">			Q.push(&#123;-c, v&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt == n ? r : INT64_MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小树形图的-O-nm-刘朱算法"><a href="#最小树形图的-O-nm-刘朱算法" class="headerlink" title="最小树形图的 $O(nm)$ 刘朱算法"></a>最小树形图的 $O(nm)$ <a href="https://www.luogu.com.cn/blog/i207M/shu-xing-tu-shu-liu-suan-fa-xue-xi-bi-ji-xie-ti-bao-gao-p4716-post" target="_blank" rel="noopener">刘朱算法</a></h3><ol>
<li>对每个点，找入边权值最小的边构成集合。</li>
<li>如果这些边构成有向环，缩点后进入 1，否则结束，找到了。</li>
</ol>
<p>例题：<a href="https://www.luogu.com.cn/problem/P4716" target="_blank" rel="noopener">LOJ4716</a></p>
<p><strong>问题变形</strong>：如果不指定根节点，那么可以建一个根节点，然后它和所有其它点连特别大的边即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Edge = <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function">LL <span class="title">LiuZhu</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; e, <span class="keyword">int</span> n, <span class="keyword">int</span> rt)</span> </span>&#123; <span class="comment">// e 中无自环</span></span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 寻找入边权值最小的边</span></span><br><span class="line">		std::vector&lt;int&gt; in(n, INT_MAX), pre(n, -1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [u, v, w] : e) <span class="keyword">if</span> (u != v &amp;&amp; in[v] &gt; w) &#123;</span><br><span class="line">			in[v] = w;</span><br><span class="line">			pre[v] = u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判定是否无解</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i != rt &amp;&amp; pre[i] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判定是否有环</span></span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		std::vector&lt;int&gt; vis(n, -1), id(n, -1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i != rt) &#123;</span><br><span class="line">			ans += in[i];</span><br><span class="line">			<span class="keyword">int</span> v = i;</span><br><span class="line">			<span class="comment">// 注意到可能出现 6 型的路径，所以两个指标很必要</span></span><br><span class="line">			<span class="keyword">while</span> (vis[v] != i &amp;&amp; id[v] == <span class="number">-1</span> &amp;&amp; v != rt) &#123;</span><br><span class="line">				vis[v] = i;</span><br><span class="line">				v = pre[v];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (id[v] == <span class="number">-1</span> &amp;&amp; v != rt) &#123;</span><br><span class="line">				<span class="keyword">int</span> u = v;</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					id[u] = cnt;</span><br><span class="line">					u = pre[u];</span><br><span class="line">				&#125; <span class="keyword">while</span> (u != v);</span><br><span class="line">				++cnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 更新节点和边，也可以重开一个 vector，然后 swap 一下</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (id[i] == <span class="number">-1</span>) id[i] = cnt++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v, w] : e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (id[u] != id[v]) w -= in[v];</span><br><span class="line">			u = id[u];</span><br><span class="line">			v = id[v];</span><br><span class="line">		&#125;</span><br><span class="line">		rt = id[rt];</span><br><span class="line">		n = cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="知乎上看到-YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）"><a href="#知乎上看到-YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）" class="headerlink" title="知乎上看到 YYYYLLL 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）"></a>知乎上看到 <a href="https://www.zhihu.com/people/yyyylll-37" target="_blank" rel="noopener">YYYYLLL</a> 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">j</span>] 表示只经过 1～k 号节点优化，i 点到 j 点的最短路径长度。</span><br><span class="line">则 DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">j</span>] = min( DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">j</span>], DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">k</span>]+DP[<span class="string">k-1</span>][<span class="symbol">k</span>][<span class="string">j</span>] ) </span><br><span class="line">= min( DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">j</span>], DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">k</span>]+DP[<span class="string">k</span>][<span class="symbol">k</span>][<span class="string">j</span>] ) </span><br><span class="line">DP[<span class="string">0</span>][<span class="symbol"></span>][<span class="string"></span>] 是初始图的邻接矩阵，DP[<span class="string">n</span>][<span class="symbol"></span>][<span class="string"></span>] 就是最终求得的最短路长度矩阵了</span><br></pre></td></tr></table></figure>
<p>本来一开始是没法做空间优化的， 但是第二个等式， 就保证了可以做空间优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1003</span>;</span><br><span class="line">LL dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> cmin = [](<span class="keyword">auto</span> &amp;x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; y) x = y;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != n; ++k)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j != n; ++j)</span><br><span class="line">				cmin(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd-带路径-—-未测试"><a href="#Floyd-带路径-—-未测试" class="headerlink" title="Floyd 带路径 —- 未测试"></a>Floyd 带路径 —- 未测试</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1003</span>;</span><br><span class="line">LL dp[N][N], path[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(path, <span class="number">-1</span>, <span class="keyword">sizeof</span>(path));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != n; ++k)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j != n; ++j) <span class="keyword">if</span> (dp[i][j] &gt; dp[i][k] + dp[k][j]) &#123;</span><br><span class="line">				path[i][j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path[x][y] == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;x&#125;;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;x, y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> left = getPath(x, path[x][y]);</span><br><span class="line">	<span class="keyword">auto</span> now = getPath(path[x][y], y);</span><br><span class="line">	left.insert(left.<span class="built_in">end</span>(), now.<span class="built_in">begin</span>(), now.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Floyd 算法其它用途：</p>
<ul>
<li>找最小环（至少三个节点）考虑环上最大节点 $u$，$f[u - 1][x][y]$ 和 $(y, u), (u, x)$ 构成最小环（值小于 INF 才是真的有环）</li>
<li>传递闭包：跟最短路完全类似，只是这里加法改成 或运算，可用 bitset 优化成 $O(\frac{n^3}{w})$，其中 $w = 32, 64$。<h3 id="堆优化-Dijkstra"><a href="#堆优化-Dijkstra" class="headerlink" title="堆优化 Dijkstra"></a>堆优化 Dijkstra</h3></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> edge &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;LL, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">d</span><span class="params">(e.<span class="built_in">size</span>(), INT64_MAX)</span></span>;</span><br><span class="line">	d[s] = <span class="number">0</span>;</span><br><span class="line">	Q.push(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [du, u] = Q.top();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">if</span> (d[u] != -du) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : e[u]) <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">			d[v] = d[u] + w;</span><br><span class="line">			Q.emplace(-d[v], v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆优化-Dijkstra-弃用"><a href="#堆优化-Dijkstra-弃用" class="headerlink" title="堆优化 Dijkstra (弃用)"></a>堆优化 Dijkstra (弃用)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> edge &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;LL, <span class="keyword">int</span>&gt;&gt; h;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">dist</span><span class="params">(e.<span class="built_in">size</span>(), INT64_MAX)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(e.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">	dist[s] = <span class="number">0</span>;</span><br><span class="line">	h.push(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!h.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [d, u] = h.top();</span><br><span class="line">		h.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		dist[u] = -d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : e[u]) h.emplace(d - w, v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(edge &amp;e, <span class="keyword">int</span> n, <span class="keyword">int</span> x = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">	dist[x] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">bool</span> judge = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [u, v, w] : e) <span class="keyword">if</span> (dist[u] != INT_MAX) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dist[v] &gt; dist[u] + w) &#123;</span><br><span class="line">				dist[v] = dist[u] + w;</span><br><span class="line">				judge = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!judge) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(edge &amp;e, <span class="keyword">int</span> x = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	std::vector&lt;int&gt; dist(n, INT_MAX), cnt(n), inQ(n);</span><br><span class="line">	Q.push(x);</span><br><span class="line">	inQ[x] = <span class="number">1</span>;</span><br><span class="line">	dist[x] = <span class="number">0</span>;</span><br><span class="line">	++cnt[x];</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		inQ[u] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, w]: e[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dist[v] &gt; dist[u] + w) &#123;</span><br><span class="line">				dist[v] = dist[u] + w;</span><br><span class="line">				<span class="keyword">if</span> (!inQ[v]) &#123;</span><br><span class="line">					Q.push(v);</span><br><span class="line">					inQ[v] = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (++cnt[v] == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无向图染色问题"><a href="#无向图染色问题" class="headerlink" title="无向图染色问题"></a>无向图染色问题</h2><h3 id="2-color"><a href="#2-color" class="headerlink" title="2-color"></a>2-color</h3><blockquote>
<p>仅用两种颜色给无向图染色，使得相邻节点不同色，每个连通块考虑即可，每个连通块要么是 2，要么是 0（判断依据有无奇圈）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// 图以 0 开始编号</span></span><br><span class="line"><span class="function">LL <span class="title">color2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">val</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> bfs = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		Q.push(x);</span><br><span class="line">		val[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (val[v]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (val[v] != -val[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					val[v] = -val[u];</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (val[i] == <span class="number">0</span>) &#123;</span><br><span class="line">		r = r * bfs(i) % M;</span><br><span class="line">		<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Chromatic-Polynomial"><a href="#The-Chromatic-Polynomial" class="headerlink" title="The Chromatic Polynomial"></a><a href="https://www.whitman.edu/mathematics/cgt_online/book/section05.09.html" target="_blank" rel="noopener">The Chromatic Polynomial</a></h3><blockquote>
<p>对于一般的 $n$-color 问题对应的 <a href="https://www.whitman.edu/mathematics/cgt_online/book/section05.09.html" target="_blank" rel="noopener">The Chromatic Polynomial</a> 可在书 <a href="https://www.whitman.edu/mathematics/cgt_online/book/" target="_blank" rel="noopener">Combinatorics and Graph Theory</a> 中找到。思想就是破圈和缩点的做法。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> BINT = boost::multiprecision::cpp_int;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chromaticPoly of a tree with n node</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">chromaticPoly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">r</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	BINT now&#123;n % <span class="number">2</span> == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		r[i + <span class="number">1</span>] = now;</span><br><span class="line">		now = -now * (n - <span class="number">1</span> - i) / (i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">colorConnect</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	std::vector&lt;bool&gt; v1(n), v2(n);</span><br><span class="line">	<span class="keyword">auto</span> r = chromaticPoly(n); <span class="comment">// 可以先预处理出来</span></span><br><span class="line">	<span class="keyword">auto</span> subtract = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; &amp;a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; b) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != b.<span class="built_in">size</span>(); ++i) a[i] -= b[i];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(<span class="number">0</span>);</span><br><span class="line">	v1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> enow = e;</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		v2[u] = <span class="number">1</span>;</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!v2[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v1[v]) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; ed;</span><br><span class="line">				<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, now = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">					<span class="keyword">if</span> (i != u &amp;&amp; i != v) &#123;</span><br><span class="line">						p[i] = now++;</span><br><span class="line">					&#125; <span class="keyword">else</span> p[i] = n - <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i != u &amp;&amp; i != v) &#123;</span><br><span class="line">					<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">auto</span> x : enow[i]) tmp.insert(p[x]);</span><br><span class="line">					ed.emplace_back(tmp);</span><br><span class="line">				&#125;</span><br><span class="line">				enow[u].erase(v);</span><br><span class="line">				enow[v].erase(u);</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> x : enow[u]) tmp.insert(p[x]);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> x : enow[v]) tmp.insert(p[x]);</span><br><span class="line">				ed.emplace_back(tmp);</span><br><span class="line">				subtract(r, colorConnect(ed));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				Q.push(v);</span><br><span class="line">				v1[v] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		e = enow;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">color</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> <span class="built_in">connect</span> = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visc(n);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		Q.push(x);</span><br><span class="line">		visc[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!visc[v]) &#123;</span><br><span class="line">				visc[v] = <span class="number">1</span>;</span><br><span class="line">				Q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, now = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (visc[i]) &#123;</span><br><span class="line">			p[i] = now++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; ec;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (visc[i]) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : e[i]) tmp.insert(p[x]);</span><br><span class="line">			ec.emplace_back(tmp);</span><br><span class="line">			vis[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ec;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> mul = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; &amp;a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; b) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; c(a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != b.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">				c[i + j] += a[i] * b[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">		r = mul(r, colorConnect(<span class="built_in">connect</span>(i)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">			<span class="keyword">int</span> u, v;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			--u; --v;</span><br><span class="line">			e[u].insert(v);</span><br><span class="line">			e[v].insert(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : color(e)) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连通性问题"><a href="#连通性问题" class="headerlink" title="连通性问题"></a>连通性问题</h2><h3 id="Kosaraju-算法缩点"><a href="#Kosaraju-算法缩点" class="headerlink" title="Kosaraju 算法缩点"></a>Kosaraju 算法缩点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Scc</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, nScc;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis, color, order;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; e, e2;</span><br><span class="line">	Scc(<span class="keyword">int</span> _n) : n(_n * <span class="number">2</span>) &#123;</span><br><span class="line">		nScc = <span class="number">0</span>;</span><br><span class="line">		e.resize(n);</span><br><span class="line">		e2.resize(n);</span><br><span class="line">		vis.resize(n);</span><br><span class="line">		color.resize(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e2[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!vis[v]) dfs(v);</span><br><span class="line">		order.emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		color[u] = nScc;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e2[u]) <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!vis[i]) dfs(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = order.rbegin(); it != order.rend(); ++it) <span class="keyword">if</span> (!color[*it]) &#123;</span><br><span class="line">			++nScc;</span><br><span class="line">			dfs2(*it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h3><p>Kosaraju 算法通过两次 dfs，给强连通分量进行染色，染色数就是强联通分量数，最后缩点后得到的就是一个有向无环图(DAG)，如果有相邻（仅取一个）节点在同一个强连通分量中，那么显然不存在解，否则我们取颜色编号大的连通分量（一定有解！）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n / 2 对 (2i, 2i + 1)，每对选出一个元素，使得无矛盾</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twoSAT</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, nScc;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis, color, order;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; e, e2;</span><br><span class="line">	twoSAT(<span class="keyword">int</span> _n) : n(_n * <span class="number">2</span>) &#123;</span><br><span class="line">		nScc = <span class="number">0</span>;</span><br><span class="line">		e.resize(n);</span><br><span class="line">		e2.resize(n);</span><br><span class="line">		vis.resize(n);</span><br><span class="line">		color.resize(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e2[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!vis[v]) dfs(v);</span><br><span class="line">		order.emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		color[u] = nScc;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e2[u]) <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!vis[i]) dfs(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = order.rbegin(); it != order.rend(); ++it) <span class="keyword">if</span> (!color[*it]) &#123;</span><br><span class="line">			++nScc;</span><br><span class="line">			dfs2(*it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Kosaraju();</span><br><span class="line">		<span class="comment">// 选择颜色编号大的强连通分量</span></span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">choose</span><span class="params">(nScc + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> c1 = color[i], c2 = color[i + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (c1 == c2) <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">			<span class="keyword">if</span> (choose[c1] || choose[c2]) <span class="keyword">continue</span>;</span><br><span class="line">			choose[<span class="built_in">std</span>::<span class="built_in">max</span>(c1, c2)] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(n / <span class="number">2</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * <span class="number">2</span> &lt; n; ++i) r[i] = (choose[color[i * <span class="number">2</span>]] ? <span class="number">1</span> : <span class="number">-1</span>); </span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此内容包含 <a href="https://oi-wiki.org/graph/scc/" target="_blank" rel="noopener">强连通分量</a>，采用其中的 Kosaraju 算法缩点。参考 <a href="https://oi-wiki.org/graph/2-sat/" target="_blank" rel="noopener">OI-wiki</a> 和 <a href="https://wenku.baidu.com/view/31fd7200bed5b9f3f90f1ce2.html" target="_blank" rel="noopener">百度文库</a>。<a href="https://codeforces.com/contest/1239/problem/D" target="_blank" rel="noopener">例题 1</a>：<a href="https://codeforces.com/contest/1239/submission/98425115" target="_blank" rel="noopener">答案</a>，<a href="https://codeforces.com/gym/101987" target="_blank" rel="noopener">例题 2: K-TV Show Game</a>：<a href="https://codeforces.com/gym/101987/submission/98427737" target="_blank" rel="noopener">答案</a>，有些特殊的 2-SAT 可以用奇偶性解决，例如: <a href="https://codeforces.com/contest/1438/problem/C" target="_blank" rel="noopener">1438C</a></p>
</blockquote>
<p><a href="https://oi-wiki.org/graph/cut/" target="_blank" rel="noopener">OI-wiki 割点割边讲解</a></p>
<h3 id="割点（无向图中删除该点使得连通分量数量增多的节点）"><a href="#割点（无向图中删除该点使得连通分量数量增多的节点）" class="headerlink" title="割点（无向图中删除该点使得连通分量数量增多的节点）"></a>割点（无向图中删除该点使得连通分量数量增多的节点）</h3><p>首先 dfs 序给出每个节点的编号记作 <code>dfs[i]</code>，再来一个数组 low，表示不经过父节点能够到达的编号最小的点。显然如果至少有一个儿子满足的 low 值不超过它的 dfs 值，那么此节点就是割点（但是根节点除外，根节点始终满足，如果根节点有大于一个真儿子，那么必然是割点）。不难看出这是割点的冲要条件，因此问题就转化成求 dfs 和 low 了。</p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/P3388" target="_blank" rel="noopener">LOJ3388</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cutVertex</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">	std::vector&lt;int&gt; dfs(n), low(n), flag(n), r;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; Tarjan = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		low[u] = dfs[u] = ++cnt;</span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dfs[v] == <span class="number">0</span>) &#123;</span><br><span class="line">				++ch;</span><br><span class="line">				Tarjan(v, u);</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">				<span class="keyword">if</span> (u != fa &amp;&amp; low[v] &gt;= dfs[u]) flag[u] = <span class="number">1</span>; </span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], dfs[v]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (u == fa &amp;&amp; ch &gt; <span class="number">1</span>) flag[u] = <span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (dfs[i] == <span class="number">0</span>) Tarjan(i, i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (flag[i]) r.emplace_back(i);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="割边（无向图中删除该边使得连通分量数量增多的边）"><a href="#割边（无向图中删除该边使得连通分量数量增多的边）" class="headerlink" title="割边（无向图中删除该边使得连通分量数量增多的边）"></a>割边（无向图中删除该边使得连通分量数量增多的边）</h3><p>与割点处理同理，只是不用特判根节点。注意到做一次 dfs 后，—<strong>不在 dfs 路径上的边不可能为割边</strong>！但是为了处理重边的情况，没办法只能用 vector 版链式前向星存边了。</p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/T103481" target="_blank" rel="noopener">LOJ T103481</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CutEdge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, cnt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e, flag, dfs, low;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> inEdgeNum)</span> </span>&#123;</span><br><span class="line">		low[u] = dfs[u] = ++cnt;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i];</span><br><span class="line">			<span class="keyword">if</span> (dfs[v] == <span class="number">0</span>) &#123;</span><br><span class="line">				Tarjan(v, i);</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">				<span class="keyword">if</span> (low[v] &gt; dfs[u]) flag[i] = flag[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((i ^ <span class="number">1</span>) != inEdgeNum) &#123;</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], dfs[v]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CutEdge(<span class="keyword">int</span> _n) : n(_n), g(_n), dfs(n), low(n), cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v);</span><br><span class="line">		flag.emplace_back(<span class="number">0</span>);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u);</span><br><span class="line">		flag.emplace_back(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (dfs[i] == <span class="number">0</span>) Tarjan(i, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : flag) r += x;</span><br><span class="line">		<span class="keyword">return</span> r / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="图的匹配算法"><a href="#图的匹配算法" class="headerlink" title="图的匹配算法"></a><a href="https://oi-wiki.org/topic/graph-matching/graph-match/" target="_blank" rel="noopener">图的匹配算法</a></h2><p>OI-wiki 上有专题专门讲这个的，分最大匹配和最大权匹配，对于特殊的图（例如二分图）有<a href="https://oi-wiki.org/topic/graph-matching/bigraph-match/" target="_blank" rel="noopener">特殊的算法</a>，例如可以增加源点和汇点转化成网络流问题，用下面 Dinic 算法在 $O(\sqrt{n} m)$ 解决。</p>
<blockquote>
<p>其中一般图的最大匹配可以参考 <a href="https://uoj.ac/submission/221981" target="_blank" rel="noopener">Min_25 的模板</a></p>
</blockquote>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="有向图-S-T-最大流-Dinic-算法-O-n-2-m-（对偶问题：S-T-最大流等于-S-T-最小割）"><a href="#有向图-S-T-最大流-Dinic-算法-O-n-2-m-（对偶问题：S-T-最大流等于-S-T-最小割）" class="headerlink" title="有向图 S-T 最大流 Dinic 算法 $O(n^2 m)$（对偶问题：S-T 最大流等于 S-T 最小割）"></a>有向图 S-T 最大流 Dinic 算法 $O(n^2 m)$（对偶问题：S-T 最大流等于 S-T 最小割）</h3><p>参考资料：<a href="https://oi-wiki.org/graph/flow/max-flow/" target="_blank" rel="noopener">OI-wiki</a> 和 <a href="https://www.cnblogs.com/owenyu/p/6852664.html" target="_blank" rel="noopener">最大流算法-ISAP</a>，<a href="https://blog.csdn.net/lym940928/article/details/90209172?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">需要反向边的原因的例子说明</a>，下面代码借鉴于 jiangly。注意代码本质上是支持动态更新的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur, h;</span><br><span class="line">	<span class="comment">// h[i] 表示 bfs 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路。</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		h.assign(n, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		h[s] = <span class="number">0</span>;</span><br><span class="line">		Q.push(s);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">					h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] != <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// f 表示从 u 点出发拥有的最大流量，输出的是 u 到 t 的最大流量</span></span><br><span class="line">	<span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, LL f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t || f == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">		LL r = f;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i &lt; g[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = g[u][i];</span><br><span class="line">			<span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">			<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> a = dfs(v, t, <span class="built_in">std</span>::<span class="built_in">min</span>(r, LL(c)));</span><br><span class="line">				e[j].second -= a;</span><br><span class="line">				e[j ^ <span class="number">1</span>].second += a;</span><br><span class="line">				r -= a;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f - r;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dinic(<span class="keyword">int</span> _n) : n(_n), g(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (bfs(s, t)) &#123;</span><br><span class="line">			cur.assign(n, <span class="number">0</span>);</span><br><span class="line">			r += dfs(s, t, INT64_MAX);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用-unordered-map-直接存边的-Dinic-算法（注意结果是否超-int）"><a href="#使用-unordered-map-直接存边的-Dinic-算法（注意结果是否超-int）" class="headerlink" title="使用 unordered_map 直接存边的 Dinic 算法（注意结果是否超 int）"></a>使用 unordered_map 直接存边的 Dinic 算法（注意结果是否超 int）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator&gt; cur;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">	<span class="comment">// h[i] 表示 bfs 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路。</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		h.assign(n, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		h[s] = <span class="number">0</span>;</span><br><span class="line">		Q.push(s);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : g[u]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">					h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] != <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// f 表示从 u 点出发拥有的最大流量，输出的是 u 到 t 的最大流量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t || f == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">		<span class="keyword">int</span> r = f;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it = cur[u]; it != g[u].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = it-&gt;first;</span><br><span class="line">			<span class="keyword">if</span> (it-&gt;second &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> a = dfs(v, t, <span class="built_in">std</span>::<span class="built_in">min</span>(r, it-&gt;second));</span><br><span class="line">				it-&gt;second -= a;</span><br><span class="line">				g[v][u] += a;</span><br><span class="line">				r -= a;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f - r;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dinic(<span class="keyword">int</span> _n) : n(_n), g(n), cur(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 注意这里一定要这样！</span></span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u][v] += c; </span><br><span class="line">		g[v][u] += <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (bfs(s, t)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cur[i] = g[i].<span class="built_in">begin</span>();</span><br><span class="line">			r += dfs(s, t, INT_MAX);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="有向图-S-T-最大流-ISAP-算法-弃用"><a href="#有向图-S-T-最大流-ISAP-算法-弃用" class="headerlink" title="有向图 S-T 最大流 ISAP 算法 (弃用)"></a>有向图 S-T 最大流 ISAP 算法 (弃用)</h3><p>核心就是一句话，Dinic 算法中，每一轮需要进行一次 BFS，可以被优化，并且还有许多细节上的优化。</p>
<blockquote>
<p>折腾了半天发现并没有比 Dinic 快，本质原因是计算 dfs 完之后更新 <code>d</code>，按照上面的做法会极大的增加 <code>aug(s, INT_MAX)</code> 次数。但是确实比 <a href="https://codeforces.com/contest/1473/submission/104862713" target="_blank" rel="noopener">直接更新 d</a> 更快（可能时因为直接更新高度代码会写的很绕，因为可能变换的高度不止自己一个，父节点的高度也可能要更新），而在下面 HLPP 中用这这技巧又会特别慢，可惜~</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结合 https://www.cnblogs.com/owenyu/p/6852664.html 在实现上进行了相应的修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISAP</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, s, t;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="comment">// cur[u] 表示以 u 为起点当前没被增广过的边</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur, d, gap;</span><br><span class="line">	<span class="comment">// d[u] 表示残余网络中 从 u 到 t 的最短距离，注意到可以把 d[u] 理解成连续变化的（否则很难正确的更新 d)。</span></span><br><span class="line">	<span class="comment">// gap[x] 表示 d[u] = x 的节点个数, 用于优化</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span> </span>&#123;</span><br><span class="line">		s = _s;</span><br><span class="line">		t = <span class="keyword">_t</span>;</span><br><span class="line">		d.assign(n, n);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		d[t] = <span class="number">0</span>;</span><br><span class="line">		Q.push(t); </span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">int</span> v = e[i].first, c = e[i ^ <span class="number">1</span>].second;</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; d[v] == n) &#123;</span><br><span class="line">					d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		gap.assign(n + <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : d) ++gap[x];</span><br><span class="line">		cur.assign(n, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从 u 开始到汇点 t 不超过 f 的最大流，如果取到了 f 说明后面还有增广的可能</span></span><br><span class="line">	<span class="function">LL <span class="title">aug</span><span class="params">(<span class="keyword">int</span> u, LL f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t) <span class="keyword">return</span> f;</span><br><span class="line">		LL r = f;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i &lt; <span class="keyword">int</span>(g[u].<span class="built_in">size</span>()); ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = g[u][i];</span><br><span class="line">			<span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">			<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; d[u] == d[v] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> a = aug(v, <span class="built_in">std</span>::<span class="built_in">min</span>(r, LL(c)));</span><br><span class="line">				e[j].second -= a;</span><br><span class="line">				e[j ^ <span class="number">1</span>].second += a;</span><br><span class="line">				r -= a;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cur[u] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (--gap[d[u]] == <span class="number">0</span>) d[s] = n;</span><br><span class="line">		++gap[++d[u]];</span><br><span class="line">		<span class="keyword">return</span> f - r;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ISAP(<span class="keyword">int</span> _n) : n(_n), g(_n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span> </span>&#123;</span><br><span class="line">		init(_s, <span class="keyword">_t</span>);</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (d[s] &lt; n) r += aug(s, INT64_MAX);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="有向图-S-T-最大流的最高标号预流推进算法（HLPP）-O-n-2-sqrt-m-算法"><a href="#有向图-S-T-最大流的最高标号预流推进算法（HLPP）-O-n-2-sqrt-m-算法" class="headerlink" title="有向图 S-T 最大流的最高标号预流推进算法（HLPP） $O(n^2 \sqrt{m})$ 算法"></a>有向图 S-T 最大流的最高标号预流推进算法（HLPP） $O(n^2 \sqrt{m})$ 算法</h3><p>1988 年 <a href="https://www.cs.princeton.edu/courses/archive/fall07/cos521/handouts/p921-goldberg.pdf" target="_blank" rel="noopener">Tarjan, Goldberg</a> 提出次方法，1989 年 <a href="https://www.sciencedirect.com/science/article/pii/S0020019099000198" target="_blank" rel="noopener">Joseph Cheriyan, Kurt Mehlhorn</a> 证明了该方法时间复杂度为 $O(n^2 \sqrt{m})$，直接看 <a href="https://oi-wiki.org/graph/flow/max-flow/" target="_blank" rel="noopener">OI-wiki</a> 最后一张图（下载下来放大）还是很好理解的，Push-Relabel 那段没讲清楚，跳过的看就行，再结合 <a href="(https://www.cnblogs.com/owenyu/p/6858123.html">cnblog</a>) 理解一下优化（不要看代码）就掌握了。然后自己写代码即可。</p>
<p>个人理解其实此算法 ISAP 的优化，Dinic 和 ISAP 都要递归找可行流，但是此算法，先给了再说，多了的再取出来即可，这样不用递归了。</p>
<p>模板例题：<a href="https://vjudge.net/problem/LibreOJ-127" target="_blank" rel="noopener">LibreOJ-127</a>，跑的太慢，有待提升。</p>
<p>注意到每次推流的时候，当前节点时有水的（且高度小于 n 的，高度为 n 说明水是积水）里面高度最高的，因此更新高度的时候就不会出现问题！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HLPP</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; ex;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFlow</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		ex[e[i ^ <span class="number">1</span>].first] -= a;</span><br><span class="line">		ex[e[i].first] += a;</span><br><span class="line">		e[i].second -= a;</span><br><span class="line">		e[i ^ <span class="number">1</span>].second += a;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 首先初始化 u 到 t 的距离得到 d[u]</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		Q.push(t);</span><br><span class="line">		h[t] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">int</span> v = e[i].first;</span><br><span class="line">				<span class="keyword">if</span> (e[i ^ <span class="number">1</span>].second &gt; <span class="number">0</span> &amp;&amp; h[v] == n) &#123;</span><br><span class="line">					h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] == n;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	HLPP(<span class="keyword">int</span> _n) : n(_n), ex(n), h(n, n), g(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (init(s, t)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		std::vector&lt;int&gt; gap(n + 1, 0), vis(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : h) ++gap[x];</span><br><span class="line">		<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">		<span class="comment">// push 之后 ex[u] 还大于 0 就说明当前超载了，需要提升高度</span></span><br><span class="line">		<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ex[u] == <span class="number">0</span> || h[u] == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">				<span class="comment">// 注意 push(s) 的时候不用管高度的问题</span></span><br><span class="line">				<span class="keyword">if</span> (c == <span class="number">0</span> || (h[u] != h[v] + <span class="number">1</span> &amp;&amp; u != s)) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">int</span> a = <span class="built_in">std</span>::<span class="built_in">min</span>(ex[u], LL(c));</span><br><span class="line">				addFlow(i, a);</span><br><span class="line">				<span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">					pq.push(&#123;h[v], v&#125;);</span><br><span class="line">					vis[v] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (ex[u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		ex[s] = INT64_MAX;</span><br><span class="line">		push(s);</span><br><span class="line">		h[s] = n;</span><br><span class="line">		vis[s] = vis[t] = <span class="number">1</span>; <span class="comment">// 起点和终点不会丢进队列中</span></span><br><span class="line">		<span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = pq.top().second;</span><br><span class="line">			pq.pop();</span><br><span class="line">			vis[u] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (push(u)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (--gap[h[u]] == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (h[i] &gt; h[u]) h[i] = n;</span><br><span class="line">				&#125;</span><br><span class="line">				h[u] = n - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">					<span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">					<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[u] &gt; h[v]) h[u] = h[v];</span><br><span class="line">				&#125;</span><br><span class="line">				++gap[++h[u]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ex[t];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="无向图全局最小割-Stoer-Wagner-算法"><a href="#无向图全局最小割-Stoer-Wagner-算法" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法"></a><a href="https://www.cs.dartmouth.edu/~ac/Teach/CS105-Winter05/Handouts/stoerwagner-mincut.pdf" target="_blank" rel="noopener">无向图全局最小割 Stoer-Wagner 算法</a></h3><p>无向图的 S-T 最小割可以通过 S-T 最大流来做（在 addEdge(u, v, c) 中两个边的权值都是 c 即可！）。<br>对任意给定的 S 和 T，全局最小割必然是 S-T 最小割或者 S-T 结合成一个节点后得到新图的最小割。Stoer-Wagner 的论文给了一种简单的方式给出某两个点的 S-T 最小割的办法，那么这个最小割的答案存下来，之后再合并这两个点再继续搞即可。而这个方式叫做 cut-of-the-phase，具体说就是，任取一个点，然后每次往这个点中丢 most tightly connected 点，论文中证明了这种方式得到的图，每一步都是最后两个节点的当前图最小割，所以所有点丢进来之后，最后两个节点的割就是原图的这个两个点的最小割。（直接图原论文很好理解，而且有例子说明）</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P5632" target="_blank" rel="noopener">LOJ5632</a></p>
<h3 id="无向图全局最小割-Stoer-Wagner-算法，邻接矩阵-O-n-3-实现"><a href="#无向图全局最小割-Stoer-Wagner-算法，邻接矩阵-O-n-3-实现" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法，邻接矩阵 $O(n^3)$ 实现"></a>无向图全局最小割 Stoer-Wagner 算法，邻接矩阵 $O(n^3)$ 实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 做完 minCut 之后原图就毁了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoerWagner</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; del;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		del[s] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			g[i][t] = (g[t][i] += g[s][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StoerWagner(<span class="keyword">int</span> _n) : n(_n), del(n), g(n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n)) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u][v] += c;</span><br><span class="line">		g[v][u] += c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> cnt, <span class="keyword">int</span> &amp;s, <span class="keyword">int</span> &amp;t) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis(n), d(n);</span><br><span class="line">			<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">				vis[x] = <span class="number">1</span>;</span><br><span class="line">				d[x] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!del[i] &amp;&amp; !vis[i]) d[i] += g[x][i];</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">				push(t);</span><br><span class="line">				s = t;</span><br><span class="line">				t = <span class="built_in">std</span>::max_element(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>()) - d.<span class="built_in">begin</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> d[t];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, r = INT_MAX;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">			r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, f(i, s, t));</span><br><span class="line">			merge(s, t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r == INT_MAX ? <span class="number">0</span> : r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="无向图全局最小割-Stoer-Wagner-算法，邻接-unorded-map-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法）"><a href="#无向图全局最小割-Stoer-Wagner-算法，邻接-unorded-map-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法）" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法，邻接 unorded_map + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法）"></a>无向图全局最小割 Stoer-Wagner 算法，邻接 unorded_map + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 做完 minCut 之后原图就毁了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoerWagner</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d, del;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;s, <span class="keyword">int</span> &amp;t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (g[s].<span class="built_in">size</span>() &gt; g[t].<span class="built_in">size</span>()) <span class="built_in">std</span>::swap(s, t);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [x, c] : g[s]) &#123;</span><br><span class="line">			g[x][t] = (g[t][x] += c);</span><br><span class="line">			g[x].erase(s);</span><br><span class="line">		&#125;</span><br><span class="line">		g.erase(s);</span><br><span class="line">		g[t].erase(t);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StoerWagner(<span class="keyword">int</span> _n) : n(_n), d(n), del(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u][v] += c;</span><br><span class="line">		g[v][u] += c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> &amp;s, <span class="keyword">int</span> &amp;t) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">fill</span>(del.<span class="built_in">begin</span>(), del.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> [i, c] : g[x]) <span class="keyword">if</span> (!del[i]) &#123;</span><br><span class="line">					Q.push(&#123;d[i] += c, i&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">				del[x] = <span class="number">1</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				push(t);</span><br><span class="line">				s = t;</span><br><span class="line">				<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">					t = Q.top().second;</span><br><span class="line">					<span class="keyword">if</span> (!del[t]) <span class="keyword">break</span>;</span><br><span class="line">					Q.pop();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> d[t];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, r = INT_MAX;</span><br><span class="line">		<span class="keyword">while</span>(--n) &#123;</span><br><span class="line">			r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, f(s, t));</span><br><span class="line">			merge(s, t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r == INT_MAX ? <span class="number">0</span> : r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="无向图全局最小割-Stoer-Wagner-算法，邻接表-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法还是-TLE-属实可惜）"><a href="#无向图全局最小割-Stoer-Wagner-算法，邻接表-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法还是-TLE-属实可惜）" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法，邻接表 + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法还是 TLE 属实可惜）"></a>无向图全局最小割 Stoer-Wagner 算法，邻接表 + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法还是 TLE 属实可惜）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Edge = <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function">LL <span class="title">StoerWagner</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; e, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;]() -&gt; <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">		std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; in(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [u, v, w] : e) <span class="keyword">if</span> (u != v) in[v].emplace_back(u, w);</span><br><span class="line">		std::vector&lt;int&gt; del(n), d(n);</span><br><span class="line">		<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [i, c] : in[x]) <span class="keyword">if</span> (!del[i]) &#123;</span><br><span class="line">				Q.push(&#123;d[i] += c, i&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			del[x] = <span class="number">1</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> s, t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			push(t);</span><br><span class="line">			s = t;</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Q.empty()) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!del[i]) Q.push(&#123;d[i], i&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">				t = Q.top().second;</span><br><span class="line">				Q.pop();</span><br><span class="line">				<span class="keyword">if</span> (!del[t]) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &#123;d[t], s, t&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, r = INT_MAX;</span><br><span class="line">	<span class="keyword">while</span>(n &gt; <span class="number">1</span> &amp;&amp; r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [dt, s, t] = f();</span><br><span class="line">		r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, dt);</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">id</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i != s &amp;&amp; i != t) id[i] = ++cnt;</span><br><span class="line">		id[s] = id[t] = ++cnt;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v, w] : e) &#123;</span><br><span class="line">			u = id[u];</span><br><span class="line">			v = id[v];</span><br><span class="line">		&#125;</span><br><span class="line">		--n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r == INT_MAX ? <span class="number">0</span> : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h3><p>在最大流的前提下，追求费用最小。一般通用的做法：每次找一条费用最小的可行流。<br>反向边的费用是原边的相反数，这样就会出现负边，但是因此初始反向边容量为 0，所以初始情况可以理解为图中没有负边。从源点到汇点的费用必然是非负的（因为我们每次走最小费用，所以每次的费用都是非降的，而初始没有负边。）当然这并不代表途中没有经过负边。至于为什么可以用 Dijkstra，很多博客都有介绍。下面代码中 h 为真实的距离，注意到 <code>h[s]</code>始终为 0，对于同一个点，每次的真实距离不减，它将作为下一次求最短路的势。这种思想也称为 Johnson 最短路径算法算法。可以 $O(n m \log m)$ 解决全源最短路问题。</p>
<p>我们这样再看一次：每次我们找一条最短路径，取流了之后，相当于给这条路径加了反向边，其它的都没有变化，如果我们把当前距离当作势，那么加的这些反向边，其实都可以看作加入了长度为 0 的边。那么我们一直这样搞，就相当于一直没有加入负边！搞定。</p>
<p>由于一般费用最小的路径只有一条，所以我们不妨在求最小费用的时候把前缀边找到，这样就可以直接求路径的最大流了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flow</span> &#123;</span></span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h, path;</span><br><span class="line">	<span class="comment">// h[i] 表示 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路，作为下一次求距离的势。</span></span><br><span class="line">	<span class="comment">// path[v] 表示从 s 到 v 的最短路中，path[v] 的终点指向 v</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">fill</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n, INF)</span></span>;</span><br><span class="line">		d[s] = <span class="number">0</span>;</span><br><span class="line">		Q.push(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> [du, u] = Q.top();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">if</span> (d[u] != -du) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> [v, c, w] = e[i];</span><br><span class="line">				w += h[u] - h[v];</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; d[v] &gt; d[u] + w) &#123;</span><br><span class="line">					d[v] = d[u] + w;</span><br><span class="line">					path[v] = i;</span><br><span class="line">					Q.push(&#123;-d[v], v&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((h[i] += d[i]) &gt; INF) h[i] = INF;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] != INF;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Flow(<span class="keyword">int</span> _n) : n(_n), h(n), path(n), g(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c, w);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>, -w);</span><br><span class="line">	&#125;</span><br><span class="line">	std::pair&lt;LL, LL&gt; maxFlow(int s, int t) &#123;</span><br><span class="line">		LL flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (Dijkstra(s, t)) &#123;</span><br><span class="line">			<span class="keyword">int</span> f = INT_MAX, now = t;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">			<span class="keyword">while</span> (now != s) &#123;</span><br><span class="line">				r.emplace_back(path[now]);</span><br><span class="line">				f = <span class="built_in">std</span>::<span class="built_in">min</span>(f, <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(e[path[now]]));</span><br><span class="line">				now = <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(e[path[now] ^ <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : r) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(e[i]) -= f;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(e[i ^ <span class="number">1</span>]) += f;</span><br><span class="line">			&#125;</span><br><span class="line">			flow += f;</span><br><span class="line">			cost += LL(f) * h[t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &#123;flow, cost&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a><a href="https://zhuanlan.zhihu.com/p/324507636" target="_blank" rel="noopener">上下界网络流</a></h3><h4 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h4><p>首先每条边先满足下界，那么对应两个节点的入流都要改变，那么为了让每个节点平衡，我们可以起源点和汇点。比如入流多了，那我们可以把它从源点给它连这么多流的边，求最大流的时候，自然就会有出的跟他中和。</p>
<p>这样只需在差网络中求一下最大流得到的必然是可行流</p>
<h4 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h4><p>从汇点到源点建一个 下界为 0，上界无穷大的边，就变成了无源汇情形</p>
<h4 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h4><p>求完可行流之后，再根据原始的源汇求一次最大流即可。</p>
<h4 id="有源汇上下界最小流"><a href="#有源汇上下界最小流" class="headerlink" title="有源汇上下界最小流"></a>有源汇上下界最小流</h4><p>求完可行流之后，再根据原始的源汇（源汇互换）求一次最大流即可。</p>
<h4 id="（有-无）源汇上下界最小费流"><a href="#（有-无）源汇上下界最小费流" class="headerlink" title="（有/无）源汇上下界最小费流"></a>（有/无）源汇上下界最小费流</h4><p>附加边费用为 0，然后按照最小费用最大流跑一次就可以了。</p>
<h4 id="（有-无）源汇上下界最小费用最大流"><a href="#（有-无）源汇上下界最小费用最大流" class="headerlink" title="（有/无）源汇上下界最小费用最大流"></a>（有/无）源汇上下界最小费用最大流</h4><p>附加边费用为 0，然后按照最小费用最大流跑一次就可以了。然后再根据原始的源汇跑一次最大流即可。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>线性规划的单纯形法</title>
    <url>/simplex/</url>
    <content><![CDATA[<p>在 Codeforces 有人问了我两个优化问题，一个是非线性规划（具体说是凸优化问题）。一般来说非线性规划没有什么具体的算法，但是凸优化，可以转化成凸包，然后转换成线段（如果是二维的）上的最值问题就搞定了。另一个是线性规划（所有线性规划其实也是特殊的凸优化），线性规划有著名的单纯形算法，7 年前就学过，但一直没写过代码。趁这次机会重新学习一下单纯形算法，并给出代码。参考教材：<a href="运筹学.pdf">运筹学 第三版 清华大学出版社</a>，另外 <a href="https://oi-wiki.org/math/simplex/" target="_blank" rel="noopener">OI-wiki</a> 上讲的简洁清晰但是不够全面。</p>
<h2 id="Gauss-消元法"><a href="#Gauss-消元法" class="headerlink" title="Gauss 消元法"></a>Gauss 消元法</h2><blockquote>
<p>之前一直不写这个模板的原因：可能无解，可能唯一解，可能无穷多个解，double 有判断，很烦。</p>
</blockquote>
<p>求解 $Ax = b$，如果无解就输出空向量，否则输出（某一个）答案向量，无穷解的话随便输出一个。</p>
<h3 id="浮点数版"><a href="#浮点数版" class="headerlink" title="浮点数版"></a>浮点数版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">Gauss</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; A, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-12</span>;</span><br><span class="line">	<span class="keyword">auto</span> findNonZero = [&amp;](<span class="keyword">int</span> i) &#123; <span class="comment">// 实际上找最大的比较好</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i; row &lt; n; ++row) <span class="keyword">if</span> (<span class="built_in">fabs</span>(A[row][i]) &gt; eps) <span class="keyword">return</span> row;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> triangleGauss = [&amp;](<span class="keyword">int</span> sz) &#123; <span class="comment">// A[i][i] = 1</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x(sz);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">			x[i] = b[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; i; ++row) b[row] -= A[row][i] * x[i];</span><br><span class="line">		&#125;</span><br><span class="line">		x.resize(A[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> sz = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, row; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">			row = findNonZero(i);</span><br><span class="line">			<span class="keyword">if</span> (row != n) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) A[j][i] = A[j][m - <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">std</span>::swap(p[i], p[--m]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = m; row &lt; n; ++row) <span class="keyword">if</span> (<span class="built_in">fabs</span>(b[row])) &#123;</span><br><span class="line">				<span class="comment">// std::cout &lt;&lt; "\nNo answer\n";</span></span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			sz = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (row != i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(A[row], A[i]);</span><br><span class="line">			<span class="built_in">std</span>::swap(b[row], b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		b[i] /= A[i][i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) A[i][j] /= A[i][i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i + <span class="number">1</span>; row &lt; n; ++row) &#123;</span><br><span class="line">			b[row] -= A[row][i] * b[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">				A[row][j] -= A[row][i] * A[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if (sz != A[0].size()) std::cout &lt;&lt; "\nInfinite answer\n";</span></span><br><span class="line">	<span class="keyword">auto</span> xt = triangleGauss(sz);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); ++t) x[p[t]] = xt[t];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; <span class="title">a</span><span class="params">(n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(m, <span class="number">0</span>))</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : x) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : b) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="keyword">auto</span> x = Gauss(a, b);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> t : x) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有限域版"><a href="#有限域版" class="headerlink" title="有限域版"></a>有限域版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">Gauss</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&gt; A, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;LL(LL)&gt; inv = [&amp;](LL a) -&gt; LL &#123;</span><br><span class="line">		<span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (M - M / a) * inv(M % a) % M; </span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> sub = [](LL &amp;x, LL y) &#123;</span><br><span class="line">		(x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += M);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> triangleGauss = [&amp;](<span class="keyword">int</span> sz) &#123; <span class="comment">// A[i][i] = 1</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; x(sz);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">			x[i] = (b[i] + M) % M;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; i; ++row) sub(b[row], A[row][i] * x[i] % M);</span><br><span class="line">		&#125;</span><br><span class="line">		x.resize(A[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> findNonZero = [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i; row &lt; n; ++row) <span class="keyword">if</span> (A[row][i]) <span class="keyword">return</span> row;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> sz = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, row; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">			row = findNonZero(i);</span><br><span class="line">			<span class="keyword">if</span> (row != n) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) A[j][i] = A[j][m - <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">std</span>::swap(p[i], p[--m]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = m; row &lt; n; ++row) <span class="keyword">if</span> (b[row]) &#123;</span><br><span class="line">				<span class="comment">// std::cout &lt;&lt; "\nNo answer\n";</span></span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			sz = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (row != i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(A[i], A[row]);</span><br><span class="line">			<span class="built_in">std</span>::swap(b[i], b[row]);</span><br><span class="line">		&#125;</span><br><span class="line">		LL inva = inv(A[i][i]);</span><br><span class="line">		(b[i] *= inva) %= M;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) (A[i][j] *= inva) %= M;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i + <span class="number">1</span>; row &lt; n; ++row) &#123;</span><br><span class="line">			sub(b[row], A[row][i] * b[i] % M);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">				sub(A[row][j], A[row][i] * A[i][j] % M);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if (sz != A[0].size()) std::cout &lt;&lt; "\nInfinite answer\n";</span></span><br><span class="line">	<span class="keyword">auto</span> xt = triangleGauss(sz);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); ++t) x[p[t]] = xt[t];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&gt; <span class="title">a</span><span class="params">(n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;(m, <span class="number">0</span>))</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : x) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : b) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="keyword">auto</span> x = Gauss(a, b);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> t : x) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面做法是先化成上三角再求，其实也可以先直接化成对角的，两种都挺好，就不过不改了。</p>
</blockquote>
<h2 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h2><p>首先无论是什么样的线性规划问题，都先化成标准形式：$\max z = \sum c_i x_i$，其中 $Ax = b, x_i \geq 0$（这里输入的 $b$ 必然都是非负，否则显然无可行解），并且保证 $A$ 的左边是一个单位阵。简单的说通过 “大 M 法” 使得 ($b_1, \cdots, b_n, 0, \cdots, 0$) 是可以可行解。</p>
<ul>
<li>求极小值通过 $c$ 取负号解决</li>
<li>$\geq b$ 通过加一个变量变成等号</li>
<li>$\leq b$ 通过减一个变量变成等号</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> VD = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1e10</span>;</span><br><span class="line"><span class="comment">// make sure that A = (I, A') and b &gt;= 0, compute max cx</span></span><br><span class="line"><span class="function">VD <span class="title">simplexCore</span><span class="params">(VD c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; A, VD b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i].emplace_back(b[i]);</span><br><span class="line">	c.emplace_back(<span class="number">0</span>);</span><br><span class="line">	A.emplace_back(c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			A[n][j] -= A[n][i] * A[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> check = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt; m; ++j) <span class="keyword">if</span> (A[n][j] &gt; eps) &#123;</span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (A[i][j] &gt; eps) &#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> ch = <span class="built_in">std</span>::max_element(A[n].<span class="built_in">begin</span>() + n, A[n].<span class="built_in">begin</span>() + m) - A[n].<span class="built_in">begin</span>(), hc;</span><br><span class="line">		<span class="keyword">if</span> (A[n][ch] &lt; eps) <span class="keyword">break</span>;</span><br><span class="line">		assert(check()); <span class="comment">// otherwise unbounded, no max solution </span></span><br><span class="line">		<span class="keyword">double</span> theta = DBL_MAX;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (A[i][ch] &gt; eps &amp;&amp; A[i].back() / A[i][ch] &lt; theta) &#123;</span><br><span class="line">			theta = A[i].back() / A[i][ch];</span><br><span class="line">			hc = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::swap(p[ch], p[hc]);</span><br><span class="line">		<span class="keyword">double</span> tmp = <span class="number">1</span> / A[hc][ch];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) A[hc][j] *= tmp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="keyword">if</span> (i != hc) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) <span class="keyword">if</span> (j != ch) &#123;</span><br><span class="line">				A[i][j] -= A[i][ch] * A[hc][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) A[i][ch] *= -tmp;</span><br><span class="line">		A[hc][ch] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">VD <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) x[p[i]] = A[i].back();</span><br><span class="line">	watch(-A.back().back()); <span class="comment">// max_val</span></span><br><span class="line">	<span class="keyword">return</span> x; <span class="comment">// point Corresponds to max_val</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// compute max cx, with Aqx = bq and Alq x &lt;= blq, end of 0 can be ommit in A and Aq</span></span><br><span class="line"><span class="function">VD <span class="title">simplex</span><span class="params">(VD c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; Aq, VD bq, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; Alq, VD blq)</span> </span>&#123;</span><br><span class="line">	assert(Aq.<span class="built_in">size</span>() == bq.<span class="built_in">size</span>());</span><br><span class="line">	assert(Alq.<span class="built_in">size</span>() == blq.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">int</span> n = Aq.<span class="built_in">size</span>() + Alq.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> m = c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bq.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (bq[i] &lt; -eps) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : Aq[i]) x = -x;</span><br><span class="line">		bq[i] = -bq[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blq.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (blq[i] &lt; -eps) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : Alq[i]) x = -x;</span><br><span class="line">		++m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; <span class="title">A</span><span class="params">(n, VD(n + m))</span></span>;</span><br><span class="line">	VD f(n + m), b(n);</span><br><span class="line">	<span class="keyword">int</span> now = n + c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Aq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Aq[i].<span class="built_in">size</span>(); ++j) A[i][n + j] = Aq[i][j];</span><br><span class="line">		b[i] = bq[i];</span><br><span class="line">		f[i] = -inf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Alq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Alq[i].<span class="built_in">size</span>(); ++j) A[i + Aq.<span class="built_in">size</span>()][n + j] = Alq[i][j];</span><br><span class="line">		<span class="keyword">if</span> (blq[i] &lt; -eps) &#123;</span><br><span class="line">			A[i + Aq.<span class="built_in">size</span>()][now++] = <span class="number">-1</span>;</span><br><span class="line">			f[i + Aq.<span class="built_in">size</span>()] = -inf;</span><br><span class="line">		&#125;</span><br><span class="line">		b[i + Aq.<span class="built_in">size</span>()] = <span class="built_in">fabs</span>(blq[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); ++i) f[n + i] = c[i];</span><br><span class="line">	<span class="keyword">auto</span> x = simplexCore(f, A, b);</span><br><span class="line">	<span class="keyword">return</span> VD(x.<span class="built_in">begin</span>() + n, x.<span class="built_in">begin</span>() + n + c.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> nlq, nq, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; nlq &gt;&gt; nq &gt;&gt; m;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; <span class="title">Alq</span><span class="params">(nlq, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(m, <span class="number">0</span>))</span></span>;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; <span class="title">Aq</span><span class="params">(nq, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(m, <span class="number">0</span>))</span></span>;</span><br><span class="line">		std::vector&lt;double&gt; blq(nlq), bq(nq), c(m);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : c) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : Alq) <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : x) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : blq) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : Aq) <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : x) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : bq) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="keyword">auto</span> x = simplex(c, Aq, bq, Alq, blq);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> t : x) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输入样例：（和 matlab linprog 样例一致）</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">6 1 2</span></span><br><span class="line"><span class="comment">1 0.33333333</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 0.25</span></span><br><span class="line"><span class="comment">1 -1</span></span><br><span class="line"><span class="comment">-0.25 -1</span></span><br><span class="line"><span class="comment">-1 -1</span></span><br><span class="line"><span class="comment">-1 1 </span></span><br><span class="line"><span class="comment">2 1 2 1 -1 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 0.25</span></span><br><span class="line"><span class="comment">0.5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://doc.sagemath.org/html/en/reference/numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" target="_blank" rel="noopener">SagMath 线性规划文档</a> 以及 <a href="https://ww2.mathworks.cn/help/optim/ug/linprog.html?s_tid=srchtitle" target="_blank" rel="noopener">Matlab linprog 文档</a></p>
</blockquote>
<h3 id="对偶理论"><a href="#对偶理论" class="headerlink" title="对偶理论"></a>对偶理论</h3><p><img src= "/img/loading.gif" data-lazy-src="dual.jpg" alt="对偶理论"></p>
<p>例题：<a href="https://codeforces.com/problemset/problem/605/C" target="_blank" rel="noopener">605C</a>，利用对偶理论之后，此题两种做法，一种是利用三分法搞定，当然了要特别注意精度问题，另一种利用半平面的交（可以查看 HDU 模板）。</p>
<blockquote>
<p>以下内容以后有空再补吧</p>
</blockquote>
<h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><h2 id="混合型规划"><a href="#混合型规划" class="headerlink" title="混合型规划"></a>混合型规划</h2>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>$R, R[x; \delta]$ 的素理想关系及 Baire 空间</title>
    <url>/primeInOperatorRing/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">math</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="21d93c5e768aa6b6c93282774db7c39621a5c1bb3f88678f92b889da4a4d5219">e8899ed765713659fea7e6a843ae8311114a819ea3354d7df10e7abd6f6bcfce0f817463f574765ab057432b9eb31aa870ab688509757d3abe2d06e79f15a8637463bb713d5876dfb05e212677ea21065dabc568f137c5405aafc53064b862567998bab1697cb2a488a34e0c125054c16f3f25703b284da12acf9ca83b32db2655f7c8e5e9c502d665a0d97922cb516fd398a0452cfaf4d0cac5e3619cc9825ca0288940c6d1096d87ca70101a0a38d6d8dc13c9d3eec8a6e2c77d964658120fdea98f2978732db175fc1d69831d87acd99e4ed78958366abbc29249ae8b42cabe14182fa835ddcdca0a91632794d62022d976e1ea09f203626f6bc9b1015321b4f77d2c22eb7408b3a58de6ec52232398abc527280e5dcd7883e8848889ae5442f790a92bb262565b1f69ab155ee486d0517d0331db24704c71ea613cec80e7c652bf0e9e119ff62df66a9a16fecc8812592f286365f9368fbcac1bdbee6eda5cbdbbe45833bb351d2963d90b7fff0bb1ab13ec427ec34e2e7ca213e56cbd9ef17126328517a2cc780784736ddd9d5bd1c1645e6191aa949e2fa843ea06e9d9e8a5e67451ce95278b27b02e93aac31be7cb83b991a0c2b205696b3b07004cca64e8c0a16af19e59f180a43feeb8c74d877769857fb9d54d7677e3233f3e287cd382fa32d032908f8a38fe199a88539de1fe06aef3cc0a9fd6a828fd3914343abf6dca583f4f59c74326ed749e7b504cabff3252cc9a2a47cf8d3af29fe3ab44f74ef445614ab9dce4c32f895080c2c54ccdf8a0325edb7b4bd58ca3d7febb8c7646a86ff85efb46f01368ed523c9fca04520bca3461efe3e7120d45840000128113c7710cea322c1fb0520bbea8cdc859591d78332c04f0778258fa5c632bc79df78c195ca10170804b86dae79d6805eb99da0c41fd811617ecc2bcd39218adf4278dff7cc98f1007291135abdc4ce7d9097f86756ea4f7c45f98b2d237906af31c12685fa1c6ae25c64c0c3bd51005da465e91809d48f8784ec2f83690bb363bfc79b4614f7d5da4521b6fa3595dfe16935e622b6418846d64400b2e992751c954399f5881921bf50359ade89c728c87a7b175a4227e2642794d01ff16cc8fa47b8b2698e0554ecc3237b4fbfd63cda570615d26564c719b5203f469edaa025f61495aab1cc8e3556487cd5e924c65154a18745492f7edb18257762a96435355c4da693985b407754faf6c6eca1035cdc8fbf599d2eb6b43bffe2d13f9d7dbb390aaef519a683f108b78fbd4fd3844ddd9579c7e84b1ccaf617f2f72ada350cb58ca2b4dce249dd8534529f481a29fa13283cf4cac00ea0ec6b5819c183d78f5a3ff575c816a361791f85bad8fc920087dac81777e68f29060118e456da27c8c6d325b42d1673cb2d94ea9c56a69a098242a4a9ea98c004488b74307265f37e3f290677e2d3427a82745164d5f22d4d3933d40be35def9f212225229b3bccb143ee8be824a6f4222e80d0c5d8521b771d21e1ad0b2fa61aa8357e15441e9fa6811808fe147fcb4dc5d706ca862023ebd9aaeedc2308368313590f91981f04bca8e2317f96bba711620a0e63bb841dfc89c3b3409cc35552e34bb9ae7bb5722bf47ff4ff46b1c8f98f989c1f8cff8938f1637600cc171114b2356b316b2bbfb2d240f9032747c540e24cdfb931e1e517f3a9c5d022141dce1dc91542044d4b2a41a3cd9e290384abb5384edd0a9333c2cb4fdd5299e9e26049275d25e4d127d0c77e972e34fbe8d7a2ce681d9a50ea1082ed24cd31404518c5b5f1328c8e75088f1a3fd4f9c6da83efae22fcfec0ae55ac9a9ee191844d47733ade7e4a4841eb0d613d4652af11746d8a2af2e277d6e98a65b34a972d6f899da0e2f772c2682e817279cc2b10830a22374bc08efb80e5cfd8a1ff7540aaca683a42e9505e81911499514ea34f0c0a43ee5b4cb200602afacf0d98db2e649b59ed064843a1c828966da4978cef85b5c05ec29fd4853f92eb9420cdf3a0d313db3cb6aef98df56aa833dafc5f1f13cc9c4b1c17108fe6c2d6b655d394d1fd6c8610018734bafafa3ed2da5a7e25c24a1af91f399421f92391804f0d9f914691a1cd22ba2f3b4bdab0cd6517e37a1194ee25e471af8b47dc8b0574f3337891444652026c5428b54b5517355275445ae8733605d763b12f2f8ab171a230d419302348ccfcf7649755e2fd78ab712cbe1813812e788beb342499e688bccc3059287e42bca7d6ed27b9929235f7af65a3c865f4d8dad7aeadbb2dae6234d2371173463b4d26053558d7d7d7956e878a62f2b2ecd5a926d24f92a6fed5e43f2ca7a2c59e7bc8d430f92914bba76d3a809b2c2401659e2b3d54a57c7281bbcaae6c2675391cfd6c6da8d9db452344181d51425c1786a988d054915af0eb11e660e2e46f98a6a42355cdf90bc779d64e59f2f0b375fc4934f92398a78ae37d71967ba0781547461c11ed01457c83a69fb44fb59ac3d0a0cfae41db074ce992c0c1c4fcbe9072bd57436d06c13ed9f915243b506ad2a4fe47ccb75a66765ce12253742c520bc1dc38953fbed13ed1af938c97081476d03360b4e4f51ee342f32eb95641aa6f9ec1bd4a1929d1a34ab4fc1ff2987c3a4ff54c99eca6e5d8dfb5db1f343fdc406ac64a3b27b6dce57838efba5a0cfdf5e0f785697e624770e853d0c0e388aa993c43385576509744fcf1fe4bb291f537312009a4abea476bbf4dc6d32bf52590ef79a12cbdca7b71cb9a2c3a33f124a6842d9dcf9790ae227a3ab7d2b2cb0e21887ed1675a70927ba54d7a3d635a5d0283e1695acdde9a59abce3eb9aa15057cf6790d33acce5c843c8bfdf0d836c38e34fd857c9e87662264e4d818c5063acbef0cab3d081612206173822810dc656d479ad97405cf09d691e77cc2ca09d0b302495a3c3dd459387420a3c05b41019745f4109826a18572d797be812c43fbd055f5d01fb9b70adc328dddfb093893f59ebc4a98535692594334dda3156f6f98a8ac5957a7a126eb3b98fb5ef90fc0c08950d7726e533214dc62f2237f6bc265b1983e791377bdb68d2c948ad866707f4f9e825d96467b43ab43dd1bab7649fcd15a5bc29ec7d37b3c477c555e3e519158592e234814ab9e3bc33aee0be121c9b91c4b40568d755f26102cb921bcc7bd21e42cb7cd5164a948cbb4e6371c86367ee19d5815095f42ebce4a3268a8e2c5a5d49b4b08398d503b17ad06851bda347dad7c804b82726dfd778e83956984120dcdd5b8419a6cf898a6f94598cc62d11a411335c0d38fdf53571807a3a44d9cc9e632d8bf13290d077faa4804895f2c8b01d011c4ff84907a51b937d2c178355dd78419db862b267ba414f5f227f132032b68e291fbdb9aa2bdf1b6f63842c018c5cb04e4970f772429419fdeb4b052b86cffe304e8b2c85af530c137bd5a333f16d270f7bb12bf81f6b348ecca0ea7887ff8e8a12b32a1e5a2eed978da21e86ae71c426c25686c51aeceb321ff9c374794afd3e8d0ccb37dd9cd5fdd97a7f97720225b1c64b277f059402861ce89850394b1d0e401bdc8bdd0cf85415576a45866115f281c38fb676ad049c290b6c5e5c1549e7fb965a671b4dc91da1b3e30ef6ea7eac9b522c879429e948b5256a18edde2a7bbae2d1d46e0ae01494774492f0ee21a8e5cfa3e30818ec009351ed0dc1944d13b6eaebc13916e94cdaf78039847e67faea0bf55d7e3c26a5894e191e54eb39ba9a0e82a3aa10d5cbe4197e18afe60733ac9931af5a6f545a5ef621e2f71f05acd8f096f7f6f02870f23fa0c7fb2d9fae902914ee1aa68ae21dcae9b89105960d78be480cb6d76f36e7bc65b612addff280263d15947b9605b8b7c6bd17ded19d68756b8c2067e4d1a60a8592beb1c13efdbd3aa9490ff003dd9e4ce95a30f9c03cc3d67b633970f8dad9ba0b82c31580ac6789b8bf9eba070aa28b4c02209187725649f2368dff317d5c34697b2f34837a0af084a847cd238693dd05c07dd1be2cb1b6155788cf560381746e64a05ce632eadea36158816abf23ebc8a521145dd79499415bc9b3541caea61cac3cb4f092f746ea36db49eaca0893fee4cd5f5249e8e9403865e93d89b6a7c0d2af6bbdf61936cabb89dc4ea0da84058699aefcc335136df15b64377a257fa01d69263be14d0478a07da0a826f6a40a9e1ed2adf00e064b43b09552c6983f3cf8398b5be1a9a98b72185db28a2dee73dd90f023cc006504dd7f0490838e569d66e7e3f0f27342daa3a80c26598a63644aef8972a75081c9c9fa9c5aaa89ae55331ebe80d8877c44c76f927ae0322c4d7888c0b7226fe4c06a8629fffd1ef9dae480fb0772d7d41570612ee52eba2ac92d1abc484aa03fd6c56bcd64c1cdd11f772927cace7cc57f74ff881616e1c3dba3ecd06781c87f14c2bddda24a19168521abbe309f82401f6a8456d6096bbacede733e0a233c3086ded4f7c2276577f8135c654522121eb67f1dad9852b453f49abbb8ceed01c1f85dff6567e79cea41c74bcf202fde5cfbe245793adba3dcddba98b020ddeecb8d27cefda2df701ba4e9467b64baa3393463350465bc9bc8a1d3f415b0657f8eb2ae0be1f9d462acf8e57f0e8b1ac90b4a58bea1fbcdb7d03f99219116d33e1f40e18d48d74e180b9a1569693207c70eaf74e0e16e32048b8221adf6fcb616e14ec9d200a30dd548b6328ee25c57d826d72c705ad4fe638052c00821aeaa7ae72b06301e6e5ef2c18ee6c8c1621b3b09c96ffd01d26f0f38663ce39c06233e67124d5334104f7e1e39b29f44b83ee37f8c541621654986a5c17c4e9961a8242f8301cbfc83c471c1e0aa0c9f3bc092c7c301cb52d608a2f486c61cd70937eef391d06b4c2c6652383e1918e00d758191e99785e4b8f30644e663e1c775a6fe078b6d9c9de880014685638334f84592ef1cf6350ab2e98496092410edeac8b1f43fadb90822fbff61b70f8800f436f929b1f7d44b299b5b83ecc8915fb0092920b730e23f7c85e41622e882c3cf7a831cb025bb99dedb3bb934d2081162692864fedc4bf10f461ffed96de6012c74dea2e17bce298bdf75318f4943647e7e9d119e6fd23deb6e4e61fa18fd856cfb16d98b7692b3d109d781ad9bcb10c405b55b0dde3631d8936c85f245fc2abaa67cbef0488468a80ce04e36ead92049e331f41ea94fb83a6af11744a507d2a032e80f3d4fff6d93a79eab45ce54a8d2a287084d5472ae77362743babdef7c987d1de20614775c2b541f6a9f1ca99766a1a68bfe0389e41306bb3b77379d125bde2c8c4e872eddc8552d6909677742145d54a89519acdf6fc3b1690ea1c64962b9a91c5718161f747fb115d1fe0d85f588ad3ce9eaf276ffd702537f2de171f74bf4bb661f838a5c4de5e6556a747c90f81196023f505d64a35e9f2f159eff1f088e84cc7adafaa678d521849d5add999bd8dcd6a82d1354490b96ed34dafdd169354413d756e433dccb5275b7a8a02deaa965f1dffc2bc39dae19f84cbd5b0f80e87a795be4b755ddcdcdbe7880611889cbb322874115ab94c1aa564f48e319d48ff66ae9bb29bd23eb0013e232815f3037236058865f1fffdab39171eca4a5d454f2d1802213b6089560516a61708b3c552730d953321c3a9cdd6fe278420188784ecb81e8e1dd62bb6a6528814bb7b5e9dc9a1b9c1fbd74a5c45e5fb14d09f8c54095b32f97d61442b1cda9eb7b52c35ac26b86c827e6fe71c5b55a312e8e08515e182a93ef316cb953f4557d90bf7a9e590ccf36965d85a959d0303733e210a3940429b8992b1fd4c9c595694199c676ec6aa0c6ea65e15081842cbe78a17a4d5b5a2f1fd721e975289f34def20a46728a3d6871114b51148ebada6cc81d8fcd462e1b9c624a336785f24241d623c144d6ab0615498e7f314a2563437c9053aa07f3770cabea2db08961f586b89067868f1df0e61a7722978004b009d108cec1a9c43e525d117a9e267e505b4b1e384a759711fa0e6a28e3d648c5b2635560f9e249ad24d11bf406e8971eac23ea4f568c32b11bb3cc8180d0c503c01178770987ad9f916e6c172d49ffcd80c4e314866ff6b271ce6c7f4e8d0dbafde6133900fb6f61dc6f0ee658de4e0cd48b7fa5667b7a520b02257fa254a30d68f420abc26638c80d8bc723b6309f1589f15bcc7ef865ce77cb7d48c539143e4781da9f43012dab3eeba9a75d46715c1791b31bc4b7419ac6b1349072f49ca9cd412a28042f3a9a9962eb7bde839bb9f2e133c966340623653ada6e5662c699b63f3f6a6347145c6ef989f29f5bbe74583cf2d48aa44912d3d7c272cadb20814e747f133b4bd0b858446c78da6a1734e1935bbb3983f10be028808c825c437aa62298c8fe8995cba1dd6fb82f4339813cb2a245154cc829e646ae192174fa5af421a6afab7a7a58dc258a3ec0b9fe1bb10ab1ccac0ba0465ff5e3804cdaea4198c20ab7ba3815234a13db04ccb756500e473d2cb1ec001dd675c97ebc572ab7a04e7aa7076c54092227d1007648fba2f12e882fe99b26c3db0f340dcc9cf097e3b64980f97b179e6d72fb0b4b06076a90ea0ce673d1be6500e27988ec172c37f068a81cd031e73336cd6d26130b505aec4607693ca6533dbe8cfec214ddbdd97ccc49b3549f034c6d2149a18bca22e114c4f0113a319f1d274aea2179f38e62271ec2736bd3acc9d73239a4fc3b5aa65797e4020a55f354d2eb6e20b446478347688d04fc4ee54e22d7d66716feeaed5cc50796cfc5ae668d6095600dd84d336d3c3d375902ade852038efdadb4ba45c05a87d423dba47a0dda1e4e0af9bab778036e240b1e9a72ff8eb44e4eda7f0aa425447a01047d07046a0e2b80d7948eb5508efcead583ceef151cca64fa46a2501c5e2a9f99cd94aeb42c3f14f6125bd62291ff3ca9857cbe59370cde5fa45fa3bea3aabaeaa1ce5099399e60dac1ef271930b27fa1cd1c95b32f5b2783fcffc0154f5b40e4ebd9860f340acb659d15ba8728ca03b9e11a452c59ca3a22ad264ed5aecf42388a5ecdf68bf94aedf546788ddad3da50837056af56ff5489cd3d6fa43db24c08f9a0949b7b338a2f604489cd08e4a634755e6425ff2646144c657626dac2dd5e7eed0e235becec1d7687dea37d2a5b6062869aabeaeecf65df7dfd2d6247459f9e843d03c97534b8f92586b87b56781d4376970b45a226ce3432749f2f76239bafc3903e3912b2564132aeaeb6897c9e6f9b726f7372faca6ff521000384dc675f634f582374bc615363fb9ec6c33b25ac602314e46e53d4b4e90471e6244b200608b8b52d823a06f5c0207aec7d481b04db1a230435eff475478986a0404efa9f42ad0585feeb8c1ac4b846e528fa95da79bd17f94da2643ed0129cb17ad86fd5022e83329e26610f1c577ee686b9a420379ec3e16af33e8c8c12eabfdfeb83ee27d63afa3067081b15e3c8c060e43371e51e89d0dab9bb2cfa630fa00b2e72641e0db6845828d12648786c867d98b5f951b06d96b29e6015d2019d40894fc14912e8b3661a1713f8f6a7dab78c8983d8e83bc2a534edec8bd1aeb12cc4a93e3172c7ee9f080fc9a9021ffd91b4ff37341be084491fe54107025ead9dc22af48e59079452f7c91104fdd58fdd6503bdf2b6b1116f074ba764ec4ce2ef84f205b8ffac0ef385682b535cb159cd0901d94d0d557db34bce2522d5424ce2b33623485d927aa2d3ec41c492b782273bf53f3a775fe23bec0427dccf5428cb19ca1ec7ac438c0e4a1e110ec95f8e8148da6b8953fe7ee4668d9fd0af3659fa332f1cfb8b9165372113955fc1cdfc4c120db7347e30169ac7b549c5056a487a0115bc02322cb7756702ef58c612372d73c62c07b17e164fb44e9861bdc1d6b60b9a247a81ef88c75f9d6f4834cb991998c7d09d1c54c11b05d4df61432623338ba0caaa158e635a3a9a109e3e891bec5c0a563b638cf96a91051b8dc35699184a9b498631fb3cf68191b3cb8361b19dc3596df4cb05d5c7d912b10da373be8db558e41bc1fd4cc0bb0137bb2f8cb1d9c4392487f57b8a56dcba36feb3eaad34115bf307dbca09981bc14730240a3a67c24a3ae091807f738871fd5315e45a78d0788cffa477b7d1999c85e60cd11fae45889ed434c4af3c00ce7a9f30c869cbbf91667f2e4fc66a8197318b5b416b5f1709a7ab750f060480b26ca50e570fd701f170b491e83d2bd42dd0c952a818574ad48b0d0ba0b0ddea09f06272d650eaa1e1a8516554f0bf3b927061176bc42d65eb36792be8d7b1c5df302366a2bb7c70408fea90f83279b1e81a834bc6d20a94ac86edf22c4bf34c530f9b12798a78ca98a91fb396b790570540d0acc353f2e2613605f3c479892a6286bf7214396a855bc52dd531e50f769cc2ddbdd89736233a42657982b834aa9bd87ee485f4f93c6311baf0cede1e617d2d834beb21b7124598b12a64a19d51cff5b6fbdc0fee03724d08e454ad06fcb6ec72cfbdf07ea70d76f7763158fb60e51ba3a588ed2f1e07d16a3c6e8dc570b9e5ae53ab309773910d77726c1f6a843be159c624bf306d183e3145be9bbc60a513ece495d11f33a3f483a9e7eb02a19f63bb175e9ec1bfd35ef03773d0524e975c938b5999844ddf9ec93a179bd08cbdfb3453aa146c95db89c6803cc94fa7c289ca25fc431d71584d7f0b2235dee70b7ed6e276e5e7cc84f206239b8310f1cb9332862327e1492cc2ba5f8fa4cf21f4fca2cbf0575fd1a8a4872a0545368b82a70bd00e70e686493ab71616b4da141c7b02771903165dcd975266901d366ccce6195f997019010c17082acb7574c6eca0860de0c133031142507a40695237a5671f1e5911b93df9e9c45f011e4243f9a932af7b32356d3d092450ff1d350b4680ad845eeaf2244d8eec3bff60e70e04de239035df1e4d28b08145e3a17d745106ef826db6f99ab169cec8d19a5d49aee4c6aa70d9b8013e3274ad964a42b0af07b87b1da5a55274c3f97b7670745c4ac1eb70bc033b31b0411945ca9493170b8629b5e9087e188f2fe9b77ee7c148865cab3af2db92025fd59a35fb0a83c279a687fca8e1ed611fa08130f79198269b365c5423557c65d501ef2ebcab1c397e2f3512c8998ef3b741d807d91d7de3707fbd9bf8daed0f997ac101c33fcb7b987f863576b1fc86fbcb9eb68f663da64c5b9b36e38d1a5f7de26654be6c7d027336aeab7eb0aba073b5f0e05ee70cb8f01f5827f25fc113ffa26f87a540c85b5c5947522ef3f4a251aafaee60c6207e15f8ada049dd631b7c017a184b239b8407ce57f74be99243fd12b4a2d9c65bb5604c333116949015c6105a873c1825705618ed978d1bc09ebf50cd1e491162ced70c2954a7e9b1879c616c7378a8b1c6fe29e2afc66a61ccdc05c54abc53a3626073f12d7d8d1724e6e441fb7a523206c5a1c46194a191810dff911a4837abcb2db15b2978af3e86815e65a420d978eaee0c31123810dc9abbd33d3a151a6643703058fc4feff7e9091a441b4fbd8286641e350d30cace6546a1837281f12166e2bb6de3efab8839654223a6b470d93986514a8fe9a832d69c6b91dea2b7244cdcaffea21c7a213b1fb96c94c085a92f108d91453b262dfd90c2f8bd68b054c82cc974140cd7df3c8b154520364181c9262c141af7475ad216eaab2b70f350abd840b7ac8e0b0d34b13f1e47dd6646a184df605e79c89a184f45366325e48e191ecef905de890c6355e671f07f72ba3e8381d313648021199a798f1dafe8a4974b5b9bbe8ceb951a1929229edae0a016585d2cfe6ced1ca0993b3d0b53816b8d9c3b1acd84f8174d8b95bba76f86c6436a3f95cc773a5d8f5495647a8db4ac1a3d9602067f9022f8c347ff5ec7a588a80bb88ab99aae091620efff03b690b4e518abc1414107c5029a1ec2395c6ea779e4f20c37d0abf6d6e640c8b2f2585a2d240d357b56146cac6bfc982457a485f8427987e811028be0f4657b6233b84ea0b8f197659756cea23e8025b702a62943acc5813f12dcf3222dba6249f06a96de367e67502206f1f521fd9b5a3718e693e5b238509f7d616137b3501c2270d1a35185c371159af1893e8ca758b42039ffa107c538a8ed6f1b3d8b0bdeb7ad0072f55999aa3cd7d5ae0fc11752196d6c155c0587e68708a2b13ba16c5b61578b12ee811b461ab49c785b93a9d75ed71e1bd5158e216ca6fbd3d91ced61aaf782c7b882f2af5f171d11ac0c69a504f23accb5aae7f782eea157de793685a8fd7588edc894e861858e31ef94e6a031df9611bfa52664fca998d68acd0c9c33e2e93b98d0a61d725a6b444512377ad597072ff225bdb3a9512f1edaa7353cd2043596e026ce182dec6ff77ff0848b220f90a3be00bfc08949fb903e0223d75695dd003b910e1fab3282a96e4a564b9b7c239c195441f111e2e6a03850756c51e889be5b7aa337f80cd2ef791c0806556d9c9548c0b1832376353c3143d47c36734304a104853a9165baad1d700bd9ebe7c3101dbd7c9468382a87c08373e80d53d0e9f9c169af129c47e6e6c3facd0043a7630d4934620f52edd92f91f2019e8b958ea522027d3e0eb7fe75c06822b17c5fd8c439ad04515283693fedeec9d3ed5acb7ecc523157716bd070b901e1704f332648ed380e092736a0aa5e75051569d3b98b7c3bcaf9ada2401191339b2ee4e4449f20ef632a463bfb56edb7df08e1b70dc4fb1c67bc1806b1310bca9b3cf376f4d2fa631a2a7e0c352650b2048a2c5e8c128ddff81b62ca9cce61b73e0ff79312760fde5fdad1f554bdceecf4cfe11a3d7c49196eaa7fd459ec4c6bdba7a6f5b28a2780a9b7ef4c75eddcc201d416f9c77f199aaaa15abc6b26e8905267071c2a251c986994484ba82638b781aa37e8993da3de11ff21c41c49abc37d5e06bcb1ce869d66656920f72f62fa6a81edaffbbfc1af6a42c4f00c7385e1b89eb751c41241484c28af2184305afcd31532fc4b8dfda3db447798fa933332d66a7ba0e70667fceb7e87acc597f56d59020e27d072e4ee30e44eef2447c5d2839194b187ac62c3da2447e4a3fcfe16aac45f09031a2434ef80071257c246da74e418a169ea04ac881d9c823567595f114937780030737ebc99b778e7234e606bf51bb069aef6de2db3bc9d290c59a8b536f1ca88500864fb4c512e9d21d6d97fd10122a5815b5e0d72266f8b7a127f37129b05df58c1f889403e0bea02e5d77ae318f1f6801fb15230552f0619e851dd031f9b7a61b60e9489c12955c4a9b8e96b9b1b4c1dea905c4ba2c7e82e4c074d8f8c6bfc2fc3a3222f3fcdaba3077d7019d59ec3fe8491c122899502e30ea57888bedbe9052de26b96eb1e86024595477c4bc3f965618e5e77735558f976873db2fd42393c5c5eeeb631eb30f3d54e155e8b0503fd80288fd2d28488d6a83b040637d763b89aad68d7b6e980397add816eee714958e8bd94e8cea8ccf6f76a29bbf4c86abd2049953340da79a983631adcc89ef637439af8ff646001f1f89211825d3ef72790f6a58bb83d850f5e55f70f594195f422a74d63a9b2710e35abe21b62803af9dad5765d679c1ae03af47d4701efcaadc734fddd517f630dbf386cf7f4a410b2d014ba7c706c6d9ce4f0a8e078714a96ad0b372d81f5331cb46f654902fec4cc5fb33ee308db8e2481d48d384ee9759207ab056f707b2168d4d65ca6cad04b8f94137afc2d8798bf3d18a4414e843e9bb92cb1d9af2b9db073e94ca1496f1638716832e8b937ab9deb4ca07d12a96f01bdc35b7bfeb43acb98f3620fee74381ed3bf774fe08c9eacfaabf2324422e457a2cfaf3e2535eecd0f69d2968ca08972aa7d20627bfdc4c69ede9061995dc884b11540af1a94511dc687729efc2a197c05d4a2e55a82d72bd52f38a7b429e2bc847b415cb681e60625262572f64f4e11dde7f71af82a9630017691fa0fc6c8431bcd26c0f9fb91fa66b2b101668dbcf7523236b2a243d173a1f0b097d71b4a3400697bf802cf79cd3b19b2234201cfc21a40da0a08d6790b8fb44ce99638c0aaf3950d56de068860797be88caa89963206d5d58c212c37f0515a209481377b20f4b2f5c143dc381de5b9c9a16a5d3348a7fa450dec37bae9da4e6671ec8bedabc888058c211cf235d6e35a07210654260d1aa5717558d6cf6e44cbd802f1c0cbe3627a7618f7d03018b7d84edc2dc900bcf5241deaa344c86a735c47bd5db8645cf9d5de5409c02b17c651251c3f74afe25509cd80ab165143c0fec6763f49d200efaf820b75864069332eaaa7a4c34d37b445c3540befaaaf740498ba6e4993dad49d11ade2a534e93be4abacbdf054ba08f5802774b53318aac8144511ee2af3446d9385dbc6b82b1f3410c75cbcb9b5b860df4e8af8c3d92117a7abfa24903b17855af13959fd8df9e21693a94bd252cde173b39f0684fa663b1fe0ae23651d3792ebecaefab7c7c0aaf075720e77a2457aa73e5b02ed6f9a361b219612a2abb0ca7729ab79492b6bf77c95048ab1968296d45b1b1d7e0d98a9c79e92a8195ce5b0df4ea91299ae6c2f8f9d6f277eb20ad368e48f6a807c1384e4e37625388df1ff69a0cf29a571710bfd3e853b816afc5856df0e2447ad4e4004399143522e0c38b4a6cd776f0d7596a3e0bd55cd91b74e17d3c0d0ef4f769159935ed087657318da1b9944522abf6fe043364a9f50cab2fc9596affa8ab9d7208ce35c9856bb336452929064a2ce205a21a172ee78f793da3c0dce6ab6d5c7043a044ba99ad2f03ae0860d40956e8d34f45a1d0315ca3be573cd3003bde9e4e725d2ecbae296c06fbc6661b1c0a71336d191b351676ec31d6ac75c5953df958a48cdbc668cb473bcd7e5a712d54d245a1e6c78bbc591d65760cf3d55b47ec71e65cecb59c149cbf2c8b179fa47ac2f455951e6be003dfaa8c24e2ec40ae64cd2ff19809642630898cdb7a13db329a997200c93da2fcd6851963533465f3dbe6ad0fd9082edfd46df5b02e3a81eb89d89bc26ef7e28c39e7051d2f069cf1e693198d96ebb0039ff85114aa864e93d32e370c70f8a51f6526d9db95e8fbfcee0985ea7361685adb4891539d18e707f64127e3f00932330fe466b48b72888561b4030da65a99a703cd968272cf9811ed7e5647cc3281c9be769c6e620eec0c3a2ce283d5c31f41632e66de85bc8cb7088858dee4020146808a8bda397bf960711b75c23126f368a6486259aa2a14eb508cfd8b01ab7132baae7541dc0dcfaa4dfa102e02d29a9f14ec1c98222c42a9add8d627b67422ff1bc33a541c2c21b4f43d8a994061bb3a713cb6d08ace6bb698f6e79a90d678bf3613598b1d320da64f751f4b01fdb3bd73d5bb0fd8bae1c82bd332a480c3d27028ae15c21e50a1a19db368e6f01c2b5da15c5a1352c4bb64f15b48a918d86e98e57cc19054c3320b49fdd7cb62a2e2e76de89fb49d7003f542c5187f1301f494db65a842e5ce5170fcfd39449d03329d047f6d675e60e8e0aa072803423343dee42e56ed94b135a437c776537a81dfd6baf7c180de79bc9a23f9f4051eb0bb2185df6320a896b0afd95cc1497409f92de129fd961f405913ff9602f1e86bf47d52e1667d839c0b0b1bd96e693dc2875923688f62ec1865c7916a71cb9afe8a0cedc5acc97b0cb8bc1eda5fe10a2c8a1f57155c85650be6e3b701ecefea0bb1579c73df7043458ece39e5712ba23381b397f92cf9c29beab0942dc2f35fb24e858154ef42274487f939903053ef496a43cde2bd1d3c27590d19b157328a19c2877712d6525055c66647c5c8c1999bf3f4a66c484590c69e8bb5b3c2a795412351079a4c79f83d9f0fd0b329ccdfb575b47093763a5e41d5d2352fe902d81af88861f6268b8b96d7fa75c429e8a2c67c62a4a33ff4ca62a92a132431a64de01c8973fe99c5533fbd62b331ec267b0c8659c40690a9e0e843c08b8b070372c6b59e9842690a6784b77f41f7fbd13e6c083358e2bcde6d9b2baba6998aa11c16f62711846a4ba524e72a040a99a40a11122dfc987af958156deadd3717165fe51d33c6c800a2b4542702b0ec378f3bc4bcd32b5f3b405e4ef99c8ed6c519c6be39abcfcd556bab16825608355666e2b10f7267727a0e6b4d5d9b52339aea6b257d6a0d226e5ab5367a5e1524bcb5781e434525420474a59564d9790167b350a15abfdff78820de17b6dd6542819865ef3c3fa66f5f11691477e977a81c554da4e9494a52420505ee078b58ca3ca421ea18eaae211a5fd65800e0ca602229bcbec8f2c0c4ae957556799d5ddf29e58b479cf95c36f1078075b05754f2774d87246f1db5f33d300544dd20a3049ba25678758edf18c45a7bc2e7ad6b442ba31140dda10fe59cc8d80f62aabdf59be6eb8a7815dac485fc1acb356f63e244a68553be18b6a59a9c59932035d24b082cfe881c8821deb347c43a94f9c67305708647b3afd84a50c922b75736b7c43d153c74e486018df44d3ccfc36fb2b3af82914f57894a04e1491eb1587f6150fa25792d9b4dd0d4a5a8b3bf6a556279d11e187c81832175dc33f7c22679a539ce57d938f035f6fb5e2e53c58fe7e3f25b3bf228b73800ca555bc5091fdb5c302ce7c55382bb7864b408815645062940c68472c37e35e3d8d4b667bbbbc4a1d68bc6d47288abf7bfc61eb2d4cf7abcbd1784773adb262b8f33a752a6ece4a7c633af88c8c8a453b8f325356e012397d0807acbf2dac647171a0f1eed56513cf9b06c2d39cfe262d516d832a9abd42ef8a58341a4a0e0844cc9d870548acbf6635cd9c94919049b18269c232267dd69e84ced566c989ce7b0fa084cd1dce027d06bced32f11a3fe1d06320d1db970ec92c7c977850b79fd1f45a1253fe82267f4db7e9fa2d4252dc81e57378d5f55015033472e902ef5f314668b80d4cab620ff82a99a81bb1b7fdbcdf6e69268bf524d4dca72d106f4d040e1d64388a1416c5ddc90028893ccd5affc851818c669b6b3ff75819f42d68d4ac21da7474e836d836015e158c7f5f0eaf272ff23d4a5009e6408b6bd63f6392ac83d75c33c4eeeab60f73c427ee70a8252998807e0b3924be5bbf497da8bbd6a9bc75c682e679a4b6a0aba24b520e59c2af45b479a5b999fd2917e5841ac901260258a4267bd8c722638376dc8b532e80d21cd105acb815036e6d51e442a130131973cbb29abb7cc95b27a425e31f5e395a1e379434c18c41b0dfd8f57bec20b622b0f102a82ffb8ce0a634c71d7d41ad1eb8ad4d606246af0def674ef43d66660a9ae936fa66697f95dcbec701659ac57112ac6d7744967650ff5a42c61213db7ddedaf9d89da434ff596447e0f9ab884d2e1cfc39129c978dc0031b106717478f63e653cbb67023322a0ed15ddb8bcf28a0132919e44ea2ab83300f06212d4d1592796ff2b07a350126adde4d349f1ecb71f0c804008fc76de0b86e0cf475dec17767fef013c61ff12950c194f13dab5923fdaa0a251bd1cc046b795926c57bd20ed2d1f625f5c8e10a8f4a4f379bd75c585297e1c4bf6185acdf1aadb18881d4b75369232307c15e1c62a4b8b28cd582060767565665ccf1d6740fdbc588477f3d10ad5a0ce5f3d9a45ccc40636f0fd0353becb5db3aef488a7a008f49a6b4013c5e3f2b499a32bd90f57523b921c2dd41b7338b1c318ccb24a5348fc54e148a2f6b573b1f2cf04751b87a2b3a5f76990453ecbc30d7ff7b494243625aba1240a4c0885c15d0a311ae84319f7e22f37ae034437c1ffb9dc1f21269ccf58d72044790b9cee9f729046bc8875d1d96c6f349e69ada1b8c468e50c2022cf753d741e9c2bbeb8f6b443fd261889e4a8bdfa2bf3891aaf917c1fe43988f1639468a3aa754ddd21ed9f81273ab54d3fcefd4d312ac2d9c3614f4f6a3a96643f66bd725fadb31a13e4d65a232de8ac6cc3f3c3dd659f238bd0d0e4cccb7b87b74ebac74e7d76218cc9d7eca60d9f41360409adeeeb9b5190a5229f59affac729264446e37c20dd165d9b6dc0f252124941975c9cc2a3cb281116a8bba045fa4515ccf5d02fc91f5fd4fad3bfc52ff3f9fa516ce37c5428b89eea71d4eee22259a4a218327e95f738a8d2df8e7450a785cb7e5c16dc5f74f3d8a83e5d9529d2dacb80ce746e1fff2f6a18feaa13a39003d0af8d50494abf87c798567a40e254bd826b38befe2c1cc836b4356c9c306c84d13ec9905ec1054f64634e2f71f648a1fbf98a9648292c633c5a6daa18a46a98cc6485dc4b357fd2a8e23b569ccfc2ce6136d54421cc63f09dce6927a2e997d57b7949e0b4c95b33ac06dc548210883067e8f858f84f587934d19490ad9c742cf0ae7173307b9922848107df710ca476ab525bba7f49bb826b1833ab78c6c79a87d6d75c05f6a488b39684da603e1a9b0a26a7b7ec78648a7efa2130808c511f41ef37d4ed0963db943fb0fb147f2a0bfdddeff5f899a5d39d530259d477ce5f34e28a6825ce8254f823f7c36505f04aa15aac5aba21383255e2cc2a4495d650fec63f16d23e4b063621d6c9b4e3837257c7c2de023121eba4f443b6d8f3da6100b5e3f7754739d4498d8b575bb0ed1c21fdcb3829f3bc716554066fad89d39e20b0e9919ef04c16bd6ba8742e53d766141d60d4884ffb41e685829494cc1acb7ae5022484f0d0aa07fe835a6c354f50784ecd4422b754db07bcd3761c17bc5bf905e62fecd2a59559413ca5e1383482076c2e1ed822a3ce12278bc35cb56fa56b2adda29d230751cbf78c181b5d3d26a1730bae2dcba1bd768326f9f50c8de2d3210accd6a0d3b3c6166e98b7828eaf4aff3a91a6a1b396a12bf5e11b214b5dc91171059d870ea2f29c2ff31239c7b6d8d3b5d7ca62ffca95146d409d8acc9a301afa53b9fc8bc38c625de4b58011a8ea7b0b30ba0e19f14df6ec67a4d5aea13d6e404d49cd4cc45f755ca25821e6022fa0ee27a4ae5ab590d8ca8b976cf140223967a0c88c3790c35e1b73e1720638830ff5b751161f3bb812976bbaf2e1954a3855e13b3965dc2de0777f35cb4516a931b5d281448f3b1d3a12d5dc250e92144a3732e678127766ca26bb2725e2e98357aedcbea0a228840f96e158aa9c03dc746246983a7c598c5492ea5674967562638b300657c541893cd5af3976347ae4e38b443f41cd939ad8032674cbdeb85554e871bad4762de7354d2a01d0261a7eaddf5ea86b9bd86bcb905870453e4589d6508c29d846f3f2d52afa0524fba021f26bf6a3b5595fb585f9af3992f2050b16e9c6c74873cf2dc37334255159e10ebfb64b5a3ab2b8938ec51a405440725cfb622b1bd3434885539dd06f1e4f2d3c41aae96d7729ae75e29ffc8ffbd2329508b9711f8d5dc748f00ecbc4dbc7f960ff07e6b3f699b3cbadb7a5a6ceccba5dd074bc8266715f381cda14188de8ef4f01808c01e2d0455f760ec819681ca28cf44f4c2f7271d29eb47e9fdac91377b0d7e71cc705a4014124ffac836dcbae46ba49156df4640868fb019d0b6fc584bad2384ad455ab4f4c61a936363254604b673e260077b629666e32899e8dfe8c402b7d184fcb2ea41d57edf024d74b4c3f8f8d7a771df198ee6fa43195c77222f0502426d02d2c4d14c69d9d8dbb39682edf3409984f2b53eee7e6505edb9af6ecce33773e60be4c9f1587e878a06f84e5ab16c165374c8722facdd532ea01b91380a157c25fa52333c7d2bfc87d335341542f53d4f21210b9360856094ab30ab1009f5ad08c49828a189a74a4c0cd7ad8e5c0099875863697cf463844e18b40a1aca9107fd8dc19357b4e0eac62e14ce96147d7f98f38e06dd2572ed6fb8d1cd574b675a7ff635f864003619e2cf2a8abc3821b3e1843eb98dcc4f2a63f08d6e69092886e6d65239d193343c7c6a8b87bedb5592877c815afdf415155cad9c87334d56e8d9c23133eda81173eb4e8fb318928440a460f8569b699408e516532628a170cef0c17ca59138eb75760be8adb146324be2912aaf7c29f0bff6c64c16d1103ece699c1500b86e2bcde1e506f4550e295144736d25385120d7946dd46b935c3183a3879fd039d2afa76ef5bcb16ab53f9573a2165c949d7b7cafd0cb555a31311a8c1918b3c1b159711d1f3988c123a7885975a327ed88cca642bb5f6d00f8a6e179c66000a73cf25e7fa6c49180fcffb850e05a82ae81a9fc7597e0bd594a27f2f95a2d206238be8718e19ae1e15309d9db3879bd9090a2a480fbaa9c7f7f1439d6ab232e449a62681fc7cd8cac826988f613aa6b1d102211d2f57c1bfe9e140f6bc30b7b88a12adda1148deb7972f0065b0a0aaec46da48d8f64e020a623a1735f08e6dcc7e368d5583299bd527d56b93fe4db2f388051afb70d445a4eea76a8f7dc40bcd1c9c9c79c20c3be551ed5cd17eae663dd9e7fae383282254bd6d1608e8841bb0208593ecf2fad45fa6620259d84258da6262c972298676eccbb9bd237b43af3baa879acafff3c2915251af26e76e8d017f9283e791e4e997871137c7dc1fbbc6767b4e5ad997eac26436d675fcc7fdac63454274652b1313dae521239e12613f35f30a002ed4a52df687de369edc863da1c42a15c88dd1e084ea6f8b5774e29d2c0af6e31d615c9263678c75e471ef9ca37d9a21cd2dcfecb6e7eb786c11baf7fc71d64399d2b1649d30ea28372fa208744ee0c801011f03308963ff8b139a2b2f977d807a2216628fc4d2f9c15d136f734469e13e2fa32866a1474fa1b731de2034cee5c476ab293e82183defa3deca9f6d36b9d3326d791416d816b5fa012dc9a3325bfe712a04b1a06c9dbabbd4d4058fd24069e47beb07d2410145451ea26f9e2fc898e02c9853cd20745da1e0237813f8c5b65ee1bd433b56a79afae2107b7dc7c8771f4f505c6e621f1b7754a00155ba03fa13022d03ebf3768899b4a2ec8b605766ebd3f65fb3955a4cf096decd36a60ada141bb3c059220639fed1529ca9111aae3736667df6ed528c911e5e84d415935422a941fe3ccd8d99b6c5bc5769b30c48956a5ab7390e494d4509a0aca5f7ad422a28c3b8701b14d72267fa25ce1ea3990041a3bf75ada9cf3f3424807eb603ba485b78cccbed3bdf9ca58bb9fb29a659de2b662e1c2fb5eff293d50dd04541db18753646726a55b35ec76c62f2dc34628b5e54de61e5a4e61266f29843052c756b403099765473f87489a4374f3f0c8413c9283ae55a9b19388a37e4961c339bd4ab8b60bc3eaaea863eb9e5685f584cf0fe92438c533cd4e11ae8cd56b1b7393d2deb92d909361943eb5bce54fa5787dc7e333a15d3ba7d148fd11846cddf2579c05bf89769dfd0ee3b739424492520849815aadf75e89e686a9ae655472a265993b3c1d0dc96986373263954ef46d6fd9a4397d90916d26467faf6bffb9a036d2c75bbc75664cc6f980830d3ab2f891ed24e58d807f5885e6d21821d173044428822d0bc051349f13ff4e94b132924a18b264b61a948788480684d654b00be353da559c1a829a659d68e7d25169ca0f04a0d3dda55278343d3b4ad5349abde84488805d9b957b0dbb3a331f12d8fe720be222daeb090c66f813ad56f37cdd3615056b688c44d5414d9545e457650ec701b4070fc921f0dcad21ed1d34554f9d0bd45d5820b4c1296a5212ca2d8eecd7a9c5ab61b071fdc89816ed24bec9173a95215ef78945df645cb3254ac0420cc1de25cc2e4ff731424d67c7c3e723da6b7efc46ca39b8b1bbab1486664482379038841640311197889d6665ec45987c2507dc2599ecf61b4e8db421615bec00186dfc04ac388712c6eba0ad5f8802fe18512f39298e1216494015e07820379d680ce9dce5735a86ed813ac0a49b89b94532f717b4c09b8d396b08c8df969f41a09782695e6c546fc1043b430c6c8e17a69f8d057af34f7f99d240fd97adddfb3a0ed1216aef8de4eaf11aa90915e228c8f67a1c8ff82435b1b7acd4b5b9c1d1712bc678f6e3c08b60ee37c8517acb261a7e6faca50bfb5647907923debdf589adaee2b6719d27e4cc8ac1f15a25e095cd87be71bbc33a4a64db9fba2c5d32954ab38ff12d28f4fd7bf45e9009a2516728a65dc769611f2811b7925f2620344c75587038a2c7b6b49dab76f86968a47bd9a0edf4028dc4e456c97304b02687d311a87dfee82d37179fc948401633540f91fc2b04f612e84884b7bd28e649ef14af7c69cdfc17773584db0afa4783ea3e67293dca84510b174865845e50435321f106f23605b83077c7c5d58ca2135f4d2bd890be3f5b47b3d54832cb548733b7257846a7a33d8ae74bc6bd4323a5db112d83765b2b763f69c35f0493f5638ed565cee17e9aaa0da5c057fafb31bc4a44c563a4ebffdf3ec618c64950c3c48316be4b76f231f24c623c76fd3a84e22872cbd27b268c06730130c602c2f9da0971ce8ad890868b3c9a2f083a0bc7224e96116d02cd18fe6583bc14fb50a2cb29ee183e5253a654ec6789e9a6ae0e97718c8361a7008896f7ed99bd2328146fae92c785b4a690f65701</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>$R, R[x; \sigma], R[x^{\pm}; \sigma]$ 的素理想关系</title>
    <url>/primeInPolyRing/</url>
    <content><![CDATA[<blockquote>
<p>该内容来自 《Noncommutative Noetherian Ring》 P392 - P400</p>
</blockquote>
<p>约定记号，$\sigma$ 是环 $R$ 的一个自同构，$S = R[x; \sigma], T = R[x, x^{-1}; \sigma]$，注意 $\sigma$ 可以拓展到 $S, T$ 上。本篇考虑这三个环之间的素理想的关系。用 $\triangleleft$ 表示理想， $\triangleleft_l, \triangleleft_r$ 分别表示左理想，右理想。</p>
<h2 id="lemma-1"><a href="#lemma-1" class="headerlink" title="lemma 1"></a>lemma 1</h2><ol>
<li><p>若 $A \triangleleft T$，则 $A$ 是 $\sigma$-不变的，$A = (A \cap S) T$ 且 $A \cap S$ 是 $S$ 中的 $\sigma$-不变理想。</p>
<p><strong>Proof</strong>：$\sigma(a) = x a x^{-1} \in A$，$A$ 中任意元都可以通分一下就有 $A = (A \cap S) T$，显然 $A \cap S$ 是 $S$ 中 $\sigma$-不变理想。</p>
</li>
<li><p>若 $B$ 是 $S$ 的一个 $\sigma$-不变理想，那么 $BT \triangleleft T$，且 $B \cap R$ 是 $R$ 的一个 $\sigma$-不变理想。（注意到 $BT = TB$，证明显然）</p>
</li>
<li><p>若 $C$ 是 $R$ 的一个 $\sigma$-不变理想，那么 $CS, CT$ 分别是 $S, T$ 的 $\sigma$-不变理想。并且 $S/CS \simeq (R/C)[x; \sigma]$, $T/CT \simeq (R/C)[x, x^{-1}; \sigma]$</p>
<p><strong>Proof</strong>：注意到 $SC = CS$，从而知道 $TC = CT$。同构根据 $S \to (R/C)[x; \sigma]$ 和 $T \to (R/C)[x; \sigma]$ 的 kernel 也是显然的。</p>
</li>
</ol>
<h2 id="lemma-2"><a href="#lemma-2" class="headerlink" title="lemma 2"></a>lemma 2</h2><ol>
<li><p>$\sigma-Spec(T) = Spec(T)$（其中 $\sigma-Spec(T)$ 为在所有 $\sigma$ 理想意义下素的 $\sigma$ 理想），若 $A \in Spec(T)$，则 $A \cap S \in \sigma-Spec(S)$，且 $x \in A \cap S$.</p>
<p> <strong>Proof</strong>：首先 $\sigma-Spec(T) = Spec(T)$ 是上一个引理的结论，$x \notin A \cap S$ 是显然的，否则 $A = T$，$A \cap S \triangleleft S$ 是 $\sigma$-不变的。 若 $I, J$ 是 $S$ 中 $\sigma$-不变的理想满足 $I J \subseteq A \cap S$，那么 $(IT)(JT) = IJ T \subseteq (A \cap S) T \subseteq A$，从而 $IT \subseteq A$ 或 $JT \subseteq A$，从而 $I \subseteq A \cap S$，或者 $J \subseteq A$。</p>
</li>
<li><p>若 $x \notin B \in Spec(S)$，则 $B \in \sigma-Spec(S)$</p>
<p><strong>Proof</strong>：$B \supseteq Bx = x \sigma(B) = x S \sigma B$, 从而 $\sigma(B) \subseteq B$，从而证毕。</p>
</li>
<li><p>若 $x \neq B \in \sigma-Spec(S)$，则 $BT \in Spec(T)$，$B = BT \cap S \not \subseteq x S$ 且 $B \cap R \in \sigma-Spec(R)$.</p>
<p><strong>Proof</strong>：首先注意到 $x \notin S$，则 $x^n \notin S$（这是因为 $(SxS)(Sx^{n-1}S) = S x^n$，并且这两个理想都是 $\sigma$-不变的定义 $B’ = \{ b \in S \mid x S b \in B \}$，显然是 $S$ 的一个理想，所以 $B’ \subseteq B$，若 $B \subseteq xS$，则 $B’ = B$，$B = xSB$，比较 $B$ 中最低次数可知矛盾，因此 $B \notin xS$。因此对任意 $c \in BT$，存在 $n \in \mathbb{N}$ 使得 $c x^{n} \in B$，所以 $\sigma^m(c) \in BT$，若 $c \in BT \cap S$，则 $\sum (S \sigma^m(c) S) S x^n S \subseteq B$。这两个理想都是 $\sigma$ 不变的，所以 $c \in B$，所以 $B = BT \cap S$。从而后面 $BT \in Spec(T)$ 也是显然的。</p>
</li>
<li><p>若 $C \in \sigma-Spec(R)$，那么 $CS \in \sigma-Spec(S)$，$x \notin CS$, 且 $CT \in Spec(T)$。</p>
<p> <strong>Proof</strong>：根据上个引理的 3，只需考虑 $C = 0$ 的情况，若 $IJ = 0, I, J \triangleleft T$，考虑它们的首项系数构成的理想$I’, J’$，从而 $I’ J’ = 0$，从而 $I’ = 0$ 或 $J’ = 0$。所以 $I = 0$ 或 $J = 0$。从而 $T$ 是 $\sigma$-素环。考虑 $S$ 的理想 $I$ 对应的 $T$ 中的理想 $IT$ 则容易看出 $S$ 也是 $\sigma$-素环。 </p>
</li>
<li>若 $A \in Spec(T)$，那么 $A \cap R \in \sigma-Spec(R)$ 且 $(A \cap R) T \in Spec(T)$。（前面的结论自然可推出）</li>
</ol>
<h2 id="lemma-3"><a href="#lemma-3" class="headerlink" title="lemma 3"></a>lemma 3</h2><p>若 $R$ 是（单边） Noetherian 环 且 $\sigma$-素环，那么它是半素的。（不要 Noetherian 条件不对）</p>
<p><strong>Proof</strong>：$N(R)$ 是 $\sigma$-不变且幂零的，所以 $N(R)T$ 是幂零的，但是 $T$ 是素环，从而 $N(R) = 0$，证毕。</p>
<h2 id="定理-4"><a href="#定理-4" class="headerlink" title="定理 4"></a>定理 4</h2><p>设 $R$ 是 Noetherian 环，若 $P_0 \subseteq P_1 \subseteq P_2 \triangleleft T$ 满足 $P_0 \cap R = P_2 \cap R$，那么 $P_1 = P_2$。<br>首先不妨设 $P_0 = 0$，假设 $P_2 \cap R = 0$，所以 $R$ 是 $\sigma$-素的，因此是半素的。所以 $R$ 有商环 $Q$ 是 Artinian 半单环，将 $\sigma$ 拓展到 $Q$ 上，则 $T \subseteq Q[x, x^{-1}; \sigma] = T’$，从而 $P_1 T’ = P_2 T’$ 是 $T’$ 的素理想，且（$P_i \cap R = 0$） $P_i T’ \cap T = P’$，但由于 Krull $\dim T’ = \dim Q + 1 = 1$，所以 $P_1 T’ = P_2 T’$，所以 $P_1 = P_2$</p>
<blockquote>
<p>下面证明定理 4 不需要 Noetherian 条件。</p>
</blockquote>
<h2 id="引理-5"><a href="#引理-5" class="headerlink" title="引理 5"></a>引理 5</h2><p>对任意 $t \in T$，我们定义 $\hat{t}$ 为它的最高次数项，$length(t)$ 定义为它最高次数和最低次数的差，特别地，齐次项的长度为 0。</p>
<p>设 $0 \neq I \triangleleft T$ 且 $a \in I$ 是 $I$ 长度最小的非零元素，$0 \neq b \in I$. 则</p>
<ul>
<li>对任意齐次元 $t_o \in T$, $length(\hat{a} t_0 b - at_0\hat{b} &lt; length(b)$ （这是由于这两项最高次数相同且系数一致）</li>
<li>对任意 $t \in T$，$\hat{a} t a = a t \hat{a}$ （由上一个结论可知）</li>
<li>对任意 $t_1, \cdots, t_{n-m} \in T$, 则存在 $c \in T$ 使得，对任意 $t \in T$，<script type="math/tex; mode=display">\hat{a} t \hat{a} t_{n-m} \cdots \hat{a} t_1 b = atc</script>  <strong>Proof</strong>：对$n$用数学归纳法，当 $n = m$ 时，$b$ 也是次数最小的，因此，次数类似上一个结论，我们也有 $\hat{a} t b = a t \hat{b}$，考虑 $b’ = \hat{a} t b - a t_1 \hat{b}$，应用归纳法显然。</li>
</ul>
<h2 id="定理-6"><a href="#定理-6" class="headerlink" title="定理 6"></a>定理 6</h2><ul>
<li><p>若 $P_0 \subseteq P_1 \subseteq P_2$ 是 $T$ 的素理想，且 $P_0 \cap R = P_2 \cap R$，那么 $P_1 = P_2$.</p>
<p>  <strong>Proof</strong>：显然将 $R, T$ 分别替换成 $R /(P_0 \cap R), T / ((R_0 \cap R) T)$，我们不妨设 $T$ 是素的且 $P_0 = 0$， 设 $a \in P_2, b \in P_1$ 的长度 $m, n$ 分别是 $P_1, P_2$ 中的最小长度。显然 $n \geq m \geq 1$，由于 $T$ 是素的，因此存在 $t \in T$ 使得 $\hat{a} t b \neq 0$，从而存在齐次元 $t_1$ 使得 $\hat{a} t_1 b \neq 0$，由归纳法，我们可以找到 $t_2, \cdots, t_{n - m}$ 使得 $d = \hat{a} t_{n - m} \cdots \hat{a} t_1 b \neq 0$，由 <strong>引理 5</strong> 知，存在 $c \in T$ 使得 $\hat{a}td = atc$ 对任意 $t \in T$，我们可以选择两对齐次元 $t_1, t_2$ 使得分别使得 $\hat{a} t_1 d$ 的最高项和 $\hat{a} t_2$ 的最低项不为 0，我们可以将 $t_1$ 乘以 $x$ 的一个幂次使得 $t_1$ 的次数等于 $t_2$ 的次数，从而 </p>
<script type="math/tex; mode=display">
  length(d) = length(\hat{a} (t_1 + t_2) d  = length(a (t_1 + t_2) c) \leq length(a) + length(c)</script><p>  另一个方向同理，即</p>
<script type="math/tex; mode=display">
  length(\hat{a}) + length(d) = length(a) + length(c)</script><p>  从而 $length(c) &lt; n$，即 $c \notin P$，然而 $a T c \subseteq Tb \subseteq P_1$，所以 $a \in P_1$. 然后用归纳法证明，$P_2$ 中每一个元素都属于 $P_1$，注意到对于任意齐次元 $t_0 \in T$</p>
<script type="math/tex; mode=display">
  length(\hat{a} t_0 e - at_0 \hat{e}) < length(e)</script><p>  其中 $\hat{a} t_0 e - at_0 \hat{e} \in P_2$，由归纳法 $\hat{a} t_0 e - at_0 \hat{e} \in P_1$，并且 $at_0 \hat{e} \in P_1$，从而 $\hat{a} t_0 e \in P_1$，即 $\hat{a} T e \subseteq P_1$，但是 $\hat{a} \notin P$，从而 $e \in P_1$，从而 $P_1 = P_2$.</p>
</li>
<li><p>若 $P_0 \subseteq P_1 \subseteq P_2$ 是 $S$ 的 $\sigma$-素理想，且满足 $P_0 \cap R = P_2 \cap R$，那么 $P_1 = P_2$</p>
<p>  <strong>Proof</strong>：同样的我们不妨设 $T$ 是素的，$P_2 \cap R = 0$，若 $x \in P_2$, 那么 $P_2 = (x)$，这是由于 $P_2 \cap R = 0$（所以无常数项），若 $x \notin P_1$，则由 <strong>引理 2</strong> $P_1 = P_1T \cap S \not \subseteq (x)S = P_2$，矛盾，所以 $x \in P_1$，所以 $P_1 = (x) = P_2$，所以不妨设 $x \notin P_2$，那么 同样由 <strong>引理 2</strong> 知 $0 \subseteq P_1T \subseteq P_2T$ 是 $T$ 的素理想，根据 1 知 $P_1 T = P_2 T$，所以 $P_1 = P_1 T \cap S = P_2 T \cap S = P_2$</p>
</li>
</ul>
<blockquote>
<p>这个定理可以推广到群代数上吗？</p>
</blockquote>
<h2 id="引理-7"><a href="#引理-7" class="headerlink" title="引理 7"></a>引理 7</h2><p>若 $B \triangleleft S$ 且 $A = lann B$，那么 $\sigma(A) \subseteq A$，更进一步，若 $B$ 是 $\sigma$-稳定（即$\sigma(B) = B$ 的，那么 $A$ 也是。</p>
<p><strong>Proof</strong>：由于 $x \sigma(A) B = A x B \subseteq AB = 0$，因此 $\sigma(A) B = 0$，因此 $\sigma(A) \subseteq A$，若 $B$ 是 $\sigma$-稳定的，那么 $AB = 0$ 当且仅当 $\sigma(A) \sigma(B) = 0$ 当且仅当 $\sigma(A) B = 0$。</p>
<blockquote>
<p>注意 $\sigma(I) \subseteq I$，并不能推出 $\sigma(I) = I$，即使 $\sigma$ 是 $R$ 上的自同构。例如 $R = \sum_{i \geq 0} k_i$, 其中 $k_i = k$ 为域，并且 $R$ 上的乘法满足对任意 $i, j &gt; 0$, $R_i R_j = 0$，$1_R = 1_{k_0}$，我们定义 $\sigma R \to R$ 为 $k_0 \to k_0$，$k_{2n} \to k_{2n + 2}, k_{2n + 1} \to k_{2n - 1}, k_1 \to k_2$，然后取 $I$ 为 $\sum_{i = 1} k_{2i}$。</p>
</blockquote>
<h2 id="引理-8"><a href="#引理-8" class="headerlink" title="引理 8"></a>引理 8</h2><p>我们称 $P \in Spec(R)$ 是 $\sigma$-半稳定的，若存在 $n$ 使得 $\sigma^n(P) = P$，对任意素理想，显然 $P^0 \doteq \cap \sigma^k(P)$ 是 $P$ 中最大的 $\sigma$-稳定的理想，被称为 $\sigma$-cyclic 的。</p>
<p>每一个 $\sigma$-cyclic 的理想都是 $\sigma$-素的。</p>
<p><strong>Proof</strong>：若 $I, J$ 是 $\sigma$-不变的理想满足 $I J \subseteq P^0$， 则 $I J \subseteq P$，从而 $I \subseteq P$ or $J \subseteq P$，从而 $I \subseteq P^0$ or $J \subseteq P^0$。</p>
<p>对于 Noetherian 情况，反过来也对。</p>
<h2 id="命题-9"><a href="#命题-9" class="headerlink" title="命题 9"></a>命题 9</h2><p>若 $R$ 是（单边）Noetherian 的，且 $A \in \sigma-Spec(R)$，那么 $A \in \sigma-Spec(R)$，那么 $A$ 是 $\sigma$-cyclic 且 $AS \in Spec(S), AT \in Spec(T)$</p>
<blockquote>
<p>首先仅需证明 $A = 0$ 的情形</p>
</blockquote>
<p>由 <strong>引理 3</strong>，$R$ 是半素的，设 $P_1, \cdots, P_n$ 是 $R$ 的全部极小素理想，$P_1 \cap \cdot \cap P_n = 0$， 且显然 $\sigma(P_i)$ 也是极小素理想，因此 $\sigma$ 是 $\{P_1, \cdots, P_n\}$ 上的一个置换， 设 $P_1, \cdots, P_r$ 是一个置换圈，记 $C = P_1 \cdots, P_r$，$D = P_{r+1}, \cdots, P_n$，那么 $CD = 0$，由 <strong>引理 7</strong> 知 $D$ 也是 $\sigma$-不变的，从而 $C = 0$ 即 $0$ 是 $\sigma$-cyclic 的。</p>
<p>假设 $B,C \triangleleft S$ 满足 $BC = 0$，不妨设 $B = lann_S(C), C = rann_S(B)$，那么 $\sigma(B) \subseteq B$，从而等到一个上升链， $B \subseteq \sigma^{-1} (B) \subseteq \cdots \subseteq \sigma^{-n}(B) \subseteq \cdots$，从而 $B = \sigma(B)$, 同理 $C = \sigma(C)$，同样它们的首项系数 $B’, C’$ 也是 $\sigma$-稳定的，从而其中有一个为 0，因此 $S$ 是素的。</p>
<h2 id="定理-10"><a href="#定理-10" class="headerlink" title="定理 10"></a>定理 10</h2><p>下列等价（证明略）</p>
<ul>
<li>存在 $m \in \mathbb{Z}$ 使得 $\sigma^m$ 是 $R$ 的某个 $\sigma$-不变的商上的内自同构</li>
<li>存在 $P_0, P_1 \in \sigma-Spec(S)$ 满足 $P_0 \subseteq P_1$ 且 $x \notin P_1$</li>
<li>存在 $I_0, I_1 \in Spec(T)$ 满足 $I_0 \subseteq I_1$ 且 $I_0 \cap R = I_1 \cap R$</li>
</ul>
<h2 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h2><p>If $P$ is $\sigma$-prime ideal of $R$, then $P$ is a semiprime ideal, and $P = Q \cap \sigma(Q) \cap \cdots \sigma^{n-1}(Q)$ and $\sigma^n(Q) = Q$.</p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>The Dixmier-Moeglin Equivalence</title>
    <url>/DixmierMoeglinEquivalence/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">math</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="7533349d55f7662c45206a3ddc1bbda6293a305d68598be756092d96e5e41802">a66cc1525ac85789d9663007a0dc9fcc3bc1dd059e09390d30cf3cb850ea4abeb92edc8157e7e7206b9809dd19b090e065b90321a48c6a6918142713d5acf58b64c5e57db63ae69458d039cf99b058ce4490e35a1273dd816e383fc33f16a8613f38ca3256ce6b890ab29d9e24b918ae13da5b845d7a657ea8f37fb671e090f812a0e8dae5e545ed7ef94706a4b83d70ccd74a3a71e857cf3a964c3f81750ac8362cff7da71ad5beb1dd5faa7d3be38f55768d0c99127bf87744c200641ef5e26630af19b612b1df1f53e81e8f8159e8bedccf7489121a3c2141998fa37cd3e4e47b4ef88d34044563f05638802b22e264ceaa99b84bb995f5dadc7540c1d3853814a902a06431c3fcf9686b8ae1e60fb442e62e17d3e3a36505f1634a828705403bf101fd4e3769cc7069dca3c570577a81e53832c4c801963d37c48ce0514e6c7920cb4f80fcf2877f93ce7ad101cb95511ae3aea9dd7d6b05fefdd3cbed0560fcc40db65c798a14348b1ad51ee886153523d430662e68806b24a1f87d508716074a3f498c3b94062f4025f0fddeddced58a86fa1365e6f1e4fce3ea02c7cd1b9b7f0088e36686fb6ebe4eac3e9c85ed037e938ea2398889487a55dcfcc06d96e370fe8bfcc76fc156b168a8d17d0258b4762265b8df33ab43bf9b25384aa3cfa78c20251228a5c59c2ac17e42bbc4046d1cda91aba5150f589751dd289cc67e74307d9f6a10a905e12d22a4e05084217d2d117b7d667aee1b0e6e2dc98e5de492867daf31789195b13287303b537673401f8c8445fa1a2bfe610b96cf2e1e359fad1bb1a4dc4c0f2d1a76687d8a1a454dcee70dc8648f785e4b6128f845654db5c50fc935b2884fb3a880526da7da09d56e6881c77ce65534e6d1500765311b39073ff7efe71756a73eb243d9eda3a3742f845ffde943fddc8c55bc896e9ca9f4a7d91c023e4392c351249fe0612f82bf37de54668fbd58aec57363c01b1df6cd42f7f228737d070022de909851b1236b516f39383266055e9d13fe424f8db88ae474db56605fbc473a0d8de54400e4005bbefa8b767ec5217c7920cd540e496d8970af807119384a0c6bc901ffc1d049c72f827852c9e0c0ea1d3f64c09bcc61c62377f64060846561c855db62fba15bf0e1622f4e6a410b8eec5cbd347ba28e6c2196f48c0ebea74c1c30c026922f2b361da733d898cae851c0dd01cb7f1de8b03c772c826ca27bfd07b98600394be4cf5512a487e775bfddde63ff50ceb928f94d179d0f6fa354f94b3f71a3eeb5573283b1d789c8cc458657d8f64b6c7cc8052d62e8c69efca97ad16f8eaf5d7d94aba3e098c08edb48435b06c186e401d0bf2a2b10732a45d4072e171608f1b38b7a45c7710b2d413d5e436246b48ec1a2bf800f1b43e7e296a6d2fbc8af56b48365c5f81cf9bd7e18f40b21d7288a8e4e868bb6a7170543a55b2ae2e56ef0baef06dcec6ca6a12d2983daba550dfbdea15ea67b50d7e48a8a5d293db5bc41d8a4be7be49d892d77e6b5e9eae0e909598a898cd04f5bd1e93e766d94697a4e4d1647a2a1320b1c095e4312d641d7d48e2fa8e26aa71d689bde6f1d1e0c9494f30f6922774883c4d9b73f3a1fa1d4631a3f973869e4c31100a77ef20748cdc8aa12d49a320d724b60289b1899d12a5ca2ff50cb272aa8348575536cdb27e564f28337c67b4abe16a41a13992370681cb82736ee2dcac06b5ae3fe23897d3e124d261d28482ae77b625338d0f4c646d067ecf7b359f3e86cdcc6f5fa1d4a894d85524908d9d75f4ed97f49bd7f360b79eb3621560199dd4bb0594ea9d817c6662fd142541954e8cb7f6b66a5007ccc4cb931afacdfd235fd6ea5584a98697121c9d0954be9a46b3baaafb20aae86b03c9b495d4123934b74c28687f9a7d399b8bd5b107515306ad59a4ea708ce684cda403a81325585e3bc3d94dcfbebd05b0cdb45753811e91bdeefba78f6860cd0945954a83a2a4ac59e5085732130d62a5d0609d6c99484adbba6f8cb21bf2b14678b91de3c9ca77d584f8515571f60d8bdd1e398b01a9e7a543cd4040b9e7f231c9f96b387a96c127b819b649249ef20f203f21ce225d7514333e9cf3dfb892693353aab460353459cc33f0ca626b9c92794075a9ff5c0132c220692e29be113d3cae362482ae1d8b071c8062bbf04c11b985a6b63e03982be56982d69773516f04ccbf1556521d43fcb1e696c1a6cb03f954be7e0cf5f76c5e626d7c1a144199a6915899eb12ca777817997e7ad915f039c43d773d00f64b0e7bbe0354af7017817cf837813fd8cd5878fdc990d0320eb8e37f9a6885a91ac25d21ce7d093200cb42e8b5d99e8fd1bedaf2bad5d18b4deb769c72dae10320e7a0fee32b92ede81b264ca99b8d170d310b8e18fba4701ab6387101782490bde1f2c0d303f96d50c8d2225b9de16d3a4225ce59a8f60f5e5c8dc73310feb5e236c31ab2d65760e3d24a91a9f3d438efa2d5628d16c1575e156673e7851526159a9402356ea0c723e8657b9a41d78379b9ebc9f018664eb4ab2f343bc44610f42df4db1f179733248178a96dce3c88533da67a6d03dffa4b6f619bef27fda4f4135f185492f0dfd0af094bb6ad41a9cef16ff1db61e8b56fc3a25a3ce0e5f6103412a150ac5a4d8a6a56b9687ccf8c34eb8084e0b29d9325470c72b447c69922be3b19c1c558da737788985bbecfcf5a86e656b373ff7b372359570eb26753e2673ca59551166a1b597639eb0997b81a18545d2ca6abbc88626cffc8d333ad26dfc9994756e1d6a3e3b1e7650ee43c3dda56cb9e6cd5a448fcaf598d7ecce9983ce884e2cf83c42b7963ca4feee67a490e577d4fb2c5d44e6ba2d091b9d33d9570f605014998ff7e30eab1f417a2fa3e136c8a5a89f7d1fbf95d609223d044480c55325243cccd4f838ec389647079e9d772995715fc86b591acf49792926a4a8eda9a0263008d1a8ad2e64bb66583094422db998c18a1caa7e8e4994115460c145e9b8691f5c4b42e5f8111027b281768ed53b1c2e1d76a3513f75e37d34e4a271c8a924251d6df85f3547513f190c49106bff30fe00f87813eb8d2429713bca2547120ee3210ccd946291cf24f90cdb4e8866b24e020aeecdcffcd313112db9c131f18cb8315f7ef6e3f66a93e6d53d30f1bf9ab0c00ef9229c817efe00749fa17ec2e71b58c2e992362beff211072dda66118a62cccbd38350d58b38f0030133c153739598a3ad0a176795a4fbec735dc6d7d080b8bc857620b61fffd8ecd7dd663e206cae9f9ddd6d635f84ceb179f49e853b0e17fa3446e94375e92458a0ad1a3080c0f97add71c02273f38f90cb8c3c7a58e48bd9bfa5793bb6ed926f672c0cd94bad129c0c02a76cfb6508d503c54afc9423c44c6247d98e54785d01af32772a07e2fa338162ded74ee23f3129fef7179754be100061cd2932b8dff547cb372c4d12c43db00838365d93899357e1bc6617d7266c4b8919382afe773c79e65083e778e8445116fad5ab67e389dbbd7fb583fcdbe5b1a477a76895546b390855b9e627c3b015ce91993446081dfe7d39ad683cf97b6d9db47fa2788d822caa0307aa87a4ef10f37215b64c88a21b726f0a910b428021b6acd5de594f5c4a72c69c2457e5eafe1161bc6574e8680dce061e8372653debdbd5a6c9613fdb854ba22172b22a32ac4f8ba40a1e57dc2006b16ef35504a8e69ee75aa17b744c28af6bcfb11b9eb0b282e8f6ebd03a811b9594df56afcc45a03c63087e0f301b61593ba7a0ea1bb2059a1870b427e94dbae109e68be57c46095ab43411bd0f7e9adb2bfbffbef05e1f544ab9a69dbe1c050a28ebe9d02e0597aff183788c655b8dd51d5d435e0d396492046d12b12d5bc139a2c5cc25cc3153677a03f0cc37e888d735a457aa9a8ea065ce2348899f2719ff8d18c34d615fbcc125f83f42edaa7f0ccbd9fc1132a5788c0a7ee98c6bda474b8de151ab956611e618993ffb62dbd8d2d435e8afb7baf044a1ed553477cb5f8ed6f04447c61883a4ae47746c810e14a8a3d1c26d841e7f0bde776e47ece600d0eb681cbffbe1b598cc037b8308b19d40cf5432d25f9677a212ac81a3382861bf69a91e93c3b3a0f9e632a9a6fab23142af4d14723238ff188928846328d5495c08a234e92e3693e1e705e608c052ca703df4975c10960931b5d371e867f93ef62dcd94dd4e436b3cab82816dd01e20065cc8c8befc6115081ebac60c2b0cc27474767fe52fca5cd7eb4163b026edbcf69e9cfca786925fe151d0d5c23c01d0ab749b013bb72220ed08376644f37792fd1734f54360aa48946ab61b99cd1d449df6bfad9f12dae8034045a51b7d6906935676857f1f8d951fa35c27be8420311fb759093b977ca5e71193d4c16be778b92180ad92b60a23b548046491e19f5195ced9a3ce3fc60109cd8091e1dec4271f8b8d1055429d2f6d8072b04cc34b92ba7e8ad9ff109a0896a8edfccc35cd0d7920c538ac70de27bb62261883c27b70f68b11b115d79c1efe35c9fa60635d41772bace46569e99de134060b54c98807c19d0cb27e5a453da7e01ae2f95434c1508e32c139d10a2348dbc04991c244682a6cd45a38ac83975b54ec3a61ea512b076f8f867dd059afe62150d2fffadd3eba290875d08f5ab57878a7d3342184e004d452ac728dab8f22cfabf49f67985ed6d9fa27814872fc81a7f83227c10459bf617777fc66115b8c9340ba4178eb4dda0ee558d687188841eeb1341f8ad2825d6eef6427e55906cd44407b463104c19f99e5d4fd981a86b88e178cea6f8ad3e9c434324e2d9d106f2849e5cda31234213546065278eb66d4bdd6529ec19cc8c8eb0f606ed4a6bcdb005491dc03c4a4a34d9a8215c6f3788ba5bf12797a8c7f41700d22419c19a41c23ce0eafb2ef605b463dd45728c8b9aa03c23cf9db5ffc1243b02afb88717d8fb351992e68419664909532089a6252edd0613b233afcb28dc99559c3fc69bd34553b2fc7d3d142bd2ee4e1d48789358cfc69959870ae798606e6859409b3622a044eb8fa26c5e171d645d338352d6bb6a9e225272158d318b695d648df0853a9e6c12e488dbe0ed5ad43670b66424fb731e2d7b1119cf26c2f9680aca0624cdc5694d64650dec1de1a7bed875a5d5c8fda07d51c98186d13c8db6be3afc183a4bcf60bace6c01d5454c254e8653a663cb5fe8c2f565271df87418e9c4eb5f2dd213fb5ec58b63d8811a43494c7e8d7a11971cba80b542bd4193c041e93c7807f13d7f038c5647170dea86f2c8cebd284e95b0485d1303dec062a5b5425495c06abedd7fcd92ca6c22c8943e838de46a6aa92671222a313431e19f18935dd0ef9eed888348d90f7011cbf9f4d96439342ca71511344a6c7e3e5c3c900791253d0c50baa8470667d1ac84351176ec82b9d89c4dc4bffb64bedf22f0cd2697293b06a3427fe69f592381aed2a511df916b5f0d2a4b2ec986a8a39b5e995ba7c892173b4b1a3ae61ffcdfe9f7334e5edf2a31f4ca999586da28d587b26ed43cdb4dee6a610e6c28c9f9613e2a7950e5552503fa2ffe0f7786e00deb6279d47ac437311a16fa069bfe9f56564dfc3cecda6ecc07c90117b138af6c4482dd561ba2d697a57f0326cdd19c96a8e4cf3eadc13fc19b99795de0051538120753229394072665f6515b2e88630487eb48e15c0365ba7e7f25907eb1ca46f7f421aec3d68b46f2987add3119d121a77057a9c03464430fb288824417abc43f513b24487ee9dfe1386cb51446f42f0e58e09676f71a0e9dd0db5c10e607c8cf4a8b62f2e866c88fd10a791c0b58d8ea0a49bf5f36a8038f5ef71f5842c06c2ddac84dd63ee667c06d550829920a1126bd010536733d47c40b2fc4c9aedc12443de4d70b87e6ac818bd8532cba35eb83431614006e5a3de863c1d862cd9c596bfe1d2b438b1b4ed636cc707630f348d8a184ec544fb57ff127182b4d525829a455737be6d63ec74f1907c79490e0c40e6f12551a244836b4fac7679c69fe0709fa3b096144feab09d77fa8ba1c9de5371b9f35cda4160ab203b5429d50924b1d139957677bdfe481f1b5abeecbb85db91ddfcf8cb31790743bfb48ed6c8cc3cd14edfbc98f78ee1e64f4a7e66b9c1ea0748a81f630d0de26ba7a357cc3b33e032c847d0cfca52beaf1e41345c3d2a198cf60f4e9a7a618f81c9fce3001dbfba57d49423ac5ddaf1f883090d3918acb68014e9e739f01899f49d1836336273e3ee978ea4ef7b7966de885a6ae8add2b862b3ed9aeeaeac92501b8752ddfd7eccf11aa8d5da4490292e0cb5b0f9284c41157ec5e9126ea25cdaa8b063123090f1249fd20585319f081ee2f9d0126d91ef5ff8bfbfdc554da16155d408ba8890245459a57994ae0245533dfe43bc113a1bfedbe4ecc9ce8e527a94ca4504c2dfec3eec01b4563af6a892f8107f404a087345e6900ee6ae281ea2dc427a55723ce0bc752f478e0567f2730481a73c172543dffd8f6cdc341e7a707a9825147e16b10ad5a12d963f72533620fe7ab9b62b9c53e5c928c3ee4debf463fb2a8ad8247c672d08aa22edd4f34525a916e5317b482dabf58abd0028ce15baaf41f9247ef69148d1289df269d2a120b81ee73f55d9346ed23f460ae4226c50064c452a1b012f884111da9c8ad1538361b867a7483d0cbbb9925b40a03af50b5d393b540f828cf077045bd357b350ca1cb3f157743692a5482c6df9c2d2d2b9ce65b90b8aff4fc476a6b432d36ab3a2c647ca1afefb7e8f2f99d9539b086d93e9743a041162cb7eb39419dc86ba2fe5b3393e058b29e845f052416d8a93b75c02835af32b84472ba8a9858ba84a18abba79a3340b58688bd1a0b7d64c60839594227fe0e007e5bf34ba6793502976f12a7c32a204d360f6e5a3a0e05b1bbeb3e1cb6e2f5f9c9645540f5d87e34e2384ef2a80c548d8794f4ac3cfeab69cac7fb55a456aa3dbcc6781b835580dc3741f4bc8b6f8c818b0ac7892719b1f84a6fa66ef389535414d4df7b1b4013168b493e0ce2315b2fa54feb3830c83f7dc515706c8a09967bc1d69e628b13439dd170953ecff6bd8bc2d3b223e61f729bfe30303a0bc6385d4fddde29aba35b6ff31e604f627447b390bd7af981754c869ea85454f80631cde28219456ce6c1980b5faf7ee11b595dd9812fbd7b3eb4d2c49b8f47e0acb554e390da42f4a9c27b3cd6d57661d28904f53952066fb4b19e555f910dc8ab322a8fbd5c77844ec7e4a1df66a6230125eda6e0a0936bf3285dc16a0a35f46832fd641be28b2fa50235d66c6e256ca65e3cf036e469a8de9ff7b1608e3c435392f9b2b994f3f9868e1a84ae70af7613da5a5543a11ac47af09795a1dcda46d03059e66933b9158f95444e668b29f0d63332d12eb5cac6727ccf4152c686ec75ba293ef55c58c6f00b392b89ae382a45d6e6b4d25defb783a74c58bf6dc723b8cc3c43e65639074089464c5e2af04b88badf24792d9c3a55f31434f69b63ca3e476eeff9dbc6a3e9a080fb4a992b9bbcfadfa476e0b5fb36d0709cc3da9c03319da4bee9f3b04133b328b087682d0bf5bcb18eb6d10cf116ea534cd0c2548fd1d0b2ee346a9da3a216d6577127318689c22ff8bd18fd2fae9f0da5fbf23699e290d06878710db932c7e05141d459d7091acd6d5dc53896cd58031b83c0339d0933212078342c116dff1f391cdd7f75f20c9f4c7188ae9239853396876d13dd3fa604aaf6f1f94444e5339a047c47bf0124971a15355ab9caf63ef774d12893b1ffd1f475c5ee1e4000287b1af9bba114a9d7f17792fb4f0d4a3faedf1c3f2e81d52771c4e4d36369be9242de9e29f855ad310f0dc8b4ae1e7181205858b45ea613debe9b822c4d5c9f81325cc1ee2ec8fe5314bc5cb21326726a81273e8afce1a29858a1a9827997008519f2bd2674ac2a4a17826ca9a6047da764d5594c54aa6daea61c5dc01a3ce86ae5de1d0b167f14c076f4923707ec45f71730c55912abc850097bdadec43b706ea559d02fedf3d29b6cdd7c5b69b6c61f20b52566b79c92cbdf3656a1572f13839f9fa0ba13998eb8bce7bb5ffceabd3319655ce5bdf1e14e19025efa373958d88f2d68cebcba3d98a377f141755c74f42299dcdd8e2209861962e7aed60d17d363b167df7f722491cebeb20634737cbac887fd3b47eea2f6f6aa6a85417c2322b1623d602a15ea2f54c3f5b80eb366c906bf91e3b318fb8dc621d2e1276a53e85c7dcd0e7b92dbdfa2caa509327a2d3e905f9e4c18f96150da58f3bcd39293b82f2c022af4977a1f494ff7e8f029ecec5b23e72516124418dcb697483b4bdea1e58557148e30a72587fe15ef203c7c2837b516081645ca11c23230f7964834249b7985577fbb2039b27ae1f066717bca0fe5f506c2f352af316048c5379f36f8769aadb542401e64c2904c31359e3a394a48cb5a76bcb6bc9bfaf66f38eb3d843c598f4bb1e42c922b9114f5e2bcda9ba17bea6a1ac0f01df5949aedec767c2ce49c78d38913f5ddc21b4c79e82fd1ce7398c2925605ab767b3a39b87f7a298c44a5b07157e01a0f0c929fdc1d07caa155823563eb8eedbb34424c422fcf9079261e1afc3a5a9ef2e9992cd766b2b39a1440938a7905f5914dc196d84392d49de3fd00b26c447e19712b38d1b64c700b84ba1d3c563fa326164e4d1131faa13286cbb3f4ea93943480bde63add0186cde02cd20fb47f7ce95fa033d06715b73dee2e7d1ba16740feac76670e5bc107eba31636d254cf8b7dd552c9f321b350cfd706b979dc7c6df46e72a312279cf090c47f664fcf5fa0f6cb21048f8e9f8f787badd97767b4f54ae11205cc9e6383a6ed20135d24eb886fb582a121f1c059f81e45bbb9d39ecddb58a0593dd1763d21fc5d16b9af09e7f23154554e92f7abb058ea466f5e7ad14acec169ede4154154105bb257ea38d0846f155006db4b6e573e5b0016cdfe18f04e31f47b6fba1f9edccb082e547ee0ca5e3fd9ea8cc87e29296b38188203691d54ec53331807403386db87966a6a305c2a8b94905a697487c997fdaba2cac85d7c50565f04ae2194e22999ee8dd53fcff7ea8835a7f35b2a4e39eb6968039f1d7e4c6fb3d1ee93512b9c186952eaf9dac2bc38f614fd7483dc41f986dfa3437c85c7e959f8846abd9698b0a3a9ff0baf35f80361ddfaa137239e3b53b0156e7586777f0536b74d4aae3f34443159ae31d5497685b313f345b792e73e544818fcece830f2b727c3e97b3b9eb84c976a04dac6d9002b488168cef989dd3af3e0ea08b271fa4af8b8d4f635725d396f7a7bc8b30ff379944c8619735b590323f83b053f3927b70975d1a9759c7775e32ea51283be39da9ede6c4d5203e7903b14f4c3920ea58d632af1acaef30d8a19a71e25e44793d534b0e87e17f70b25aea1852c15a5f261a1203fe9c43fcdedb10737028fe574fe89004177a42c5c556ebdd83aa466e6884c8f1a6fc92fae44a60ef5d4903a369ef6cf4a0dbe3e5aba04383006e01f1c9f54556e67fa575ab7a749b800274e8fb4a41a204421b2c7227be19496babdda38cbb46a47d593f0b373cadc4fee291db7e7f9bbeeaa67666485ab64bd64b992a8c3464cbe6e0a5890965bce79fb5a975a751fd2f3081338002265acc84c1c3285fbe9a9db8628c29d42b32274f5d3e85c28aeb16fbfd37450d141a14050c372e7b392a854bd0b16a515dd022ef8c811c6cbe990a8850edb7d22db4e47f31f7aa8c0bcf3cbee988c9c917c1d9db43017dfdaaa8e34dfbab5d47b40fd01811a4ac2be74ecc0a042e514752a0c9075d1785756324101d4a2c2305d63b0c5d61d50c7d6facdd6f7a3c0d3492ec58130c3fe00af36a852282b44e839bdd3f21cb57ce747eebc22428b8f3313f15e44dac2579ca27139391efbb830b0212916abf359fd0b659e6efa55a18ea1cf9ab076ad9071b0ae3d10aaaccbcf4d227926086a3fca22174caffbd40df67b1acd2178a722b341392bcdf8455ae3bd360c16325bf3d3b020899da14ca3e08cedc3cde112e443e145ca5b97dd8851658f628b95deafc8a5eaab8d933047365b4fc1dbb3cb6c5fcc2b73f04ff6bf20dbee3ee61e41a6815314c140f8b17814ca1664f35f8ecf04ab5ff6c2b7f77e621a44b7af23f65459a5f84df50304d8697bb1a5e914b9360e6af7ad55c5869090c6a6164e1e696b8afc0e499f280522bd2a434fe698a7cab418a889c888b6b17d49679953d5249ed99ec68d6cb17e190c9d21997f5a3539c21ad8326362c195848d6339fabaeacbc202281fd949770780c89feebcb970618b203e0c28cda76ca02b69997495a8c6cf715900ee9ad6d920004dafeb07887a3ff3ebcb50141da0b1b6186bf4b698a68fcff47c676f88ef517fab5dee25d99a364d867fe4939e4493d57746b6e9f74aaf35d174abeb21ff2b8fe6212aa24d95432c98e524b4b783e78271b9e5e2623b4b74af8b10230d108193f2822990f66b57d4fe585045c43fed28a3b3690cd2b8a8e469e83589b6ba5c091c79f449d6bb4a4c0a6252010ccc887357985a243f48e63004a8159c80f642dc355b2211e759dd522d263d426339d46afd57ff43f7883c97b4e10be774b002647d5c5cc8baa15cf23200c6419eb05870ef4675a5abc40b7ccdd5759ebd4e086cda3fdb0c1979bbf676b8970352552080d4653e81c3ee55c25459654748b9128117480a9022e161d37615bf119f97a48809346afa49f05d43d0ffe5afbc66e0ec37e89dc6aa08b35c3c8b13236a571c0fbf71a8a7b3b25b00b3949d16835c0045bc2bc2e034cefeb0c430d1ea5e0962466b3520c3166fa72be0d95a833a389f638a572fe5e9ea7f5c138511a02ff67ab939e23e1cf30a20f841141ec43c67236f6cc915a21f64919881ff7fa99e850569b5a0dbd716a535dfd4ed2f33d881ca0eb383b92e67718a4a40700a8636fa33072d6ac1d4a5455a74de5bb5cd0eeab74a809031dd3bd5d2968de83744a6d143df8f492885e502e22cc42314bafef7ca4f18e52049f59f40cb4303d045a47d94eac13fc8a5850e06fdb4432582f5885f919485a1d5f270fe78312832d2d628f759f9a5f17da04e2a5209272aa3000270e8734463d19fa5783fc3a48fac02163b997107e6bb2f4564600e3e39f235e535cbc96989bbf517a7557276cd389417a6d107f6e0009ca32b3b4b5b0d8b1a97bf2eb73198699b818ac81633521a8298880bcf26c8420c06f66e53159595223932a563bc5de719ec7aaa0d9b83b31f93715e40c1e984a0794dacd713203e415514f9465c6b2b814b9868a15a1d27d50f89fd9513b0c93c8c7ec65c52856859702a4a3a2a8184cddf6c78d79aaa465f7190e7146528687334388e3aff1c1835352ac2558a9278ae0ea49f6c8ead2aa71d82c2610b449698fc5d2dab397226e253237084a8f892884755451ab76d4dea687cd084f71732af49f83284958c7302715951154b0785ddb03fcad9694fb7f6d05c47601d0892bfd23ce2c0c3aab65e0bebb96e133067d74d4120228d99c4bebe4094f7d9d9d1f518da8123326404c7ef60ba8d71fc30fde1c07c74b0e08f75c770cf22682a80e192709db570c7230f31662aa0112cc24236f6dba418d12765fba6556d64a1e78aa5e221544d45d1de1a0bc0e37a1420152abde93b89e49563c280033851d9b4a8b45750b91c5a6610e5dbf5eba998b602e7bb4a16d3f83429bea3b5cef709118fc77eb26adb9eb10929cd67a26867ca6b338059aece9bd0c29a4314fc4163bdd35b812beb5ffed7073e8af935b7bf14e0493b807c85da8c17a3389451dd68d25cb62a5e3261331985eca7dc8f75c6c7d6f11ff4dd13bf9ae6c87e53c7ee0b9724e89a43ff765798d3bfe6aade202b19e0323fac49042d34aceb7e46726a89c414a0d1e7ad1d80272f48899065f4af206b43c70ffc96840ba04263e0cfb610910c74b8722ab839bdae7229ebf9631a823c45bc3651ed183aca26832db84ad337453b7adaccdf9940104f9bea429fabb4135fac33ac3d581cc871ee04df7e4188aabb3646c954cf1bbfe503a54c50087a329fc2164a20cf2d68e9c847e2b1e573985bf6a08df10284da06497eb41e79eaa6a4ab1848781bcb84fee6df6dd3e875dd6820a9a3982f760d27f370dfd38d3cbc9625e99cf8bb55f175c05e2959b5977579e05dc11013dc4d17e2af563fdd190a4036367ac6d3cb4d9693753eb8ec696d52d6b7ee78d9cf865dcefc419707c15b46e1ed45779e2d6ec3df437da545b1cc78ae2be2a85763fe9cd0efdb577884f33574ed73c698f7c093f01050d5b4482023d2acd34fdbe26daf81594bacbd2b87df134c1f0cb23cdf4827ab82f80a392efec11d9e3273b123322a6d22a371026e5cd3f14bca5bb201ee387ded559f4d11750f3049fe6439b8b6844f780ad7477db0f1cb75ebfc54aea96d45e534338392eca3113fd16a889ac50744bc5fcfd59f77b66327ea99f5a46b046d5f8cd8cb86ebd648d1f76e2f77a14c67ca4758e57e8b7b27a5ac6581e4c2e69e80de68d878a15ab9490824a0eb0b3eea68b98b3245974f515ab3f3e8746ebf729f883eda98144135207e9b25543a8fdbd0149be3d41ed344c3017d8b36d2ad5465554e0c54c5312e882f669b644c705259a84083512cc7c304ae6a822425e2b9c8e769e637ec06e2fea9258ef35634dfe5f287234cb6572ca4472a54330b1cb8dd5b21e2e2d8e2998e393893be24938d284726ed0f76f8834fdb87d6c258bebeb631b38d36535a434e80f7138054ff3d5b6d50c880623fe053db3f121183bbb85e3b87a76e67985e61057064aeba92cc47d17426b77eedca9159d00f54965a88229536dade1c76a2a8d972956132d453e0f66e82136a62986d76984172b702a41f409cdb4befebbdda57364055d8006d27df9fbac9480a813852bfefbdc01016b6a71c38fb3fe267546f674ee783e4fc6b1f69d223f73d5a39f75940d26b58eb4bfe3249f81acbc6be57a7ef668cc133ee84c6e99dd7e9556f096ad4b5928fb02767ec37f439eed2baac54d7cd16eeb9b8da95097eb88e917221fd10033b562846fdaea5d5945169e3244fc5e25d6e5fcc43510af1d04a4ae28c422554f289dfb614f102085cc67446e7dcae601fdf04f7a469458b749edac56241d7d76a36d0e12ffa3aece3028162561d59ab6e3a99248c3f7b430677e0c481196bef44611b381b343bb99994c10b645cfa5401eb996daca1a9e7aa39890152f14fc8625b0c65c7db76428abed176a9791bef09b70cee7a1b548199c961155e5ab8337f34cf87545857113472f03aeba4e1e53a39d5e34cadefa994b5531dad37d4c84726d9afd4d5a92e9c8b6ffacb447a9a9ad3a4026d43bc62983cd2d5d1f016b2c4351a79874b3413ecf506ea0ebd5cae5a4c458b5295bfac61d6518b24aa1033322bf55725cdfbc88b4e273bf5da82e960f7764deeb1d7c87f2bc88d0ba2c8637f7d00829a161060699d0fedd11018cabc3030b132a4d17b79988c6a05e48091abead24b9536ba21cb25209238ea8d897ba47cd1eb025995b69d7d49350100906f6c6e3d632042f9f1175cb6704d6a389023e291a06be2e9e6b975fa59b8b8efc4e553446a7ba38fffbcbe0127a455a686b59a011b7819ff10de6e2671ae3b6d6de4ad3ab25e22ad163e12144a7cd0f57ee934ee6ef277a792abc2217ad029c4c16fcc24625f35ff18dc9fed1935b1238a7c4d3d638164b1fc9b5614f2e8a19c9214f314dc1e2ded146681d93bbee22217f2c3c82f42f7a77f4c2dd61bb4440e0562ed2023c7c7016d0b72aaf953c52e43df9e24daf13a9ecc5a782dafb4705269449b8b58de2892f9d2f348a18b2c850af6538aa56cab5fce6388d7f0ec116fbc36000287dc36ac5b4ef311f150c4eaeba3f7fe92b3abba7e318678b106f368bdd0962c4fac94253d48b2ae3c40f948ef8724c05ef68d543cd9f950bf2a0a6ac6e25c72065f14a6e855b2cbf3b185eb3272ed207825532dc93234537c7826ac568e56305dcfcb76fd813d3e323269345a05671ad47c6e402739a24e0e0394f4e713ff95e3ed020e06629d40c2e53d16c2f28c747280203d2d7ed77265fdd2a0cfe261fffa7965a7bc132c51f3cef14acc558b4ffad7fdcdd92392f1fa90ef0ba8ddf309ad832f505777cc5fda7e63fbec949599a67e6ce064ddfa9fdb51002ba3df75d1107877ba83832cc638e4de76937d1b3977f0cdbb14cf732cbd2f1c0153eceb4a177d4be9a68caf5c1fbc11ce3a45ecf96a92e43b445289c30995e1c39a79897beec9083e792e4d47aa44ad9b0a825561059a9c0f3c77322f09e6918e0af91d407d643853dfd7eeeb802c0fe6eea51cb0cc434366c6c1f8bb1e138fdcd42551b0df1c041c616bcc49db2b90a0f9d75eaaea322ed26ff9354c3c11e91be0f15ae9c17209b359d9e3c8bfccff134662c27fd9ffefd7760e304b8d53f072d42b6f0cc48513bc4fa3ad46e6393e5a390fde1a7a6890ec8d9c339219cbe98b86cb2566acb822fde493ff400ec2a474858f9bad52127e153fff5562d2c23edb3905aef16794cdff2197afc605162b432cf8d2a8de85e1f7561b4b383543a795f43447a633d97e7beb5f4d8d9d4230d49f4b2d05d88b0a3eab2c24f841f41f29adc1f95b04bb6266d5320b9247a8cd0fe63c6afad1d3440a1aaa77503f7848332e94d6f4b1f4153d44bdd0cb39e25043d311e7ba9f601326245802d2a1bf9e49bebe88124bcd56b580a5cc3651cf2f6dcfe310dc7795ba83e0b1218696ebc7ff27dfebf20759a678fa8045797e37dccbbdb27de3bfe94c79048001a453ff647cdd5739376dc3e8178292711206365429cf59ff157d2dcec4b2de94c3e6ddaa81f00672dc032b708a33d63868ef737abd6786b341cc3fdc0a5f4e5b5c93623a776aadd59a069ab1127f7a8185747864637f2d09cf1d1c42cb3631f903fe4db6a6ce272bf648caff14e2264a4e21b74bc4a3b66c91dbd98784c131c2c197aa649ad7d5d18af52c3189225e74158be87ea26d752ecbb8846ea034000a2f2d3278267afd82fec21e224af71e4c84e668945506f2d02ad90446051f4079849e87283944b43f6667924b0d5e6f9bed5f423ef3a63fcca874023ef6a7906c1476ac42c8b8fe8c0e065abfdba0474b9f111b782dc566c39a85bed24827c20ed089bff871aa01f7cdf55c1810e9710d58fb91178eae3284bdfd78660153a373f2ad86526dce2e204acd19b1ebfc9264df5c80a18740b216c8c31e702352e8818ffdc15a31056fcc4d6fbf1734b86c105f4d0e97834cd205e679d13f30483fba5462b75f419f7ce8abeee880cb3ae8c91a8fe4ef840af3a90e908599d719562529035c1e3250216acf6d6ee5bbbcefa84133d2a77212b6b667e518429325c6b5968cfe16a4866f279157da207bdd5c94ee00be7cdc3c2d01f0cc64e6f5595adf04567167ec1c2e6e86645260dc1f30e1bcd18e2c9775a2a763f1051aad39f1dafab7779a39effae1ec3a797c55a58efd627949a27944b8dc9f96efcdd1119aa47884d2eb060c4c56ef4aeebb0e92de475191ed691bb1f4d3f8c880b4dfc4a099cc1ebc6b9c0335f6eb5fdde5745aa35c4f6048dc8106df4a5c7489e9020aff4ad26d030f082a3cdd20d8905bff6c511f88517791ee05638d7c39753c0c72478f49f846d45f028a1574292f29dd8383b46c5c00b9dd0d8a13bba88ba5a4984a801ef3475368a4420c18349ad3d9fd2565c11c02cbaa4a904e966f1e5abfc58025983a370e1c4026f8612ecf3c08ca2cef04d7c33c1ec8a7abc917afacae89a670a29dd1948e70e1e68ba78b09329016adc2d181be94af68b4835566b6faf07781a39ce57fa8a32ea8a6747c260370b1a34a19e5935bb859f933bd627ad479b38bcb113e962d22b71f2e8ff5a73794aeeebb35e97256577bc36f1dcf581c66cc23916c2f715a1b8da8f20552aab2a47fcd13daef555f88f0c3e1105e7f2bdcfbbb0efa132d96a4d539111c279fc3163b6c3baf72b0bcd70db5f2771f017dc4774e2c3e4cf78a4db1804eb8ea0a42c91a5487204570626c6bb538eedeb768a080a628a99bb09847ff4007ef4c31c8d75d58f5f17085ff82e0562465aba7a0e2a6f9f07b30a9d8feb270a50f96c73b5dc2dc69a8ef4391ae43b34e50ba869f8a164e4771ebdc6a728fa3ada05873aefba29ef6a6e146fee44f2780bb49d3272acb828a27de0b533b48c841231293d291118c7d1135fe2775326305fcfeedebb76347698d34e6d9e4391a6d6737234d0dddd4b147294043c179ff39e310b4ca789be933daf49e0df2403360d28d2fcb8afc67af5dc2f3be272a5ff9822c6f293facbb871c49915a641000b874c57d2ba79bdfc9b06bdf6ad28eb124972a070e75c2658b7c04cb236fe476111f482e4d56e42ba1c4ca8750bac8d08bb5f523dce6169ac107c9abeb4ae9d61f9146cac54eeb947c7e765f9e64341d2ce0a4bb23ecc46c7f208da6fd8d51f0a2af5421075832e51e3991b37d6644571f6cbf612921fdf8bc01eef03bdbb57bea299ffad3e27a946789d71151062574fed674d85e85d99ef9cb033ea6090d9f2ff07b1d3d3bef7f7d8e5b09cd35e81bcaa22654bee488dab227f5493f89148c9fed360663296d9f94f36fe666e4a1470e989bee6eead6fda712677eb695813f473e1d0cc81322104f0a4105fc5845a830d63e2d6f9a00251cbdf7651fab51726d8f71828e38d46545296f019f51b3c7aa99963bad34ae559cf805ff082877afc3011a764f2ba60a1955932ee4c1c6c8a0c8c0dd048fdb084ae9df174b9b4d253b168eeae76a6b51d7c689a2a535381fe4d020e87b85d76e4ed944f2fc5124f6efaad8d91ba2b0159bf3f1d9fe37643f182eefdc829ecaecda8406c5535e486b029456bea70701f531a0a9e5e5af63b732956fef5e4f418ea43b8bcddbb25ef9194d4da8c7c5f769ee82e4f48708181c13e6e1a5b54a97761bf6ff398bc5bbea1d7d77db12fcfddc22bb5c4cb69cf61e5d97b7c64ee878095344d7d40609e4cc9bb97ef2aa4c459645072b60c322361b102c88a339f94df914930c0298b710ddeb78333b76bbb29004a0cac6ed0ba66869d3e4000f03bec89c8300bcac18388a24b98590bbd4efa64ec23d2e399b0b952b85fc3ad49678db6112b7be1d5e514e0f94ca1c8189b6b06464f6590aac98022b312506324727b340d74bec35784a18cacafefb0f338a2c9a7f8d498a77534e0309c2c43b12b6dd4202cd4bd57a56d8855cba7370181e4a9f151b17c1a93599d52142a4a2e1e4c4ed1aca7197aa830b34afc7c066e9d75a289c67f6fed2514dc55086115a43623e6e3f4ffd83982c346129350951d999ab050574857a5dbbaf9972b9a4b900f24a25080c19ea25d51f3605518ea38b53456b72418e9f396c64fed44e8c44cf24c93899cfcb1b28c408ca62137856f018405887e43920c360097da55aa05824929f392a65b29b24c11e9439594b22aa86b62c9cd8499e54827a854b67b430fa02c4510669baa2cd820b858ae8a5ecd5b8072411ce0504716f0299c87539630d0733ae700d547e5f9fc988167711c1ba03e8402238d4f05ec9c843f936f82271c75b52271fdbafca081d8dad84b4fbdac0c2bb6bc922facf477fd287165f74c3c575342c5c33dd820be5989baa91dded7d1f8d4a9872f7b9a8593e7b572a9a9de59e116d9281b5442f118327bf3ff166bcd0e87214deb915a158749628f8366efecc65bbce1000ab9d186b4b27f25e0c75355cac01a5ba3758c47dde7337b6f71850299dddfdb6d153af8f60e478ef84e3eeb594da9fa9782f4b3e8dc61fa95bc62841305fcd5a99e95cd460d760b0316caf143682645c527005dd89dfd38a7fa5ab9e839a29ffa06ab7db73e7c00891bfd740cc2957b34cd645d9f31fd3d2bbe8fd969bd609f92818f97d4ef4f01e37aff8e3fdbce1bee1d44624915a8d4ef95098b7df5667ce2ff1f6616e31301e688d5c6a7c8d99ffc68ff76cfddc5e91e878c857473a7bcb41ce4aff109af5740f57ed46d3385893cfd3a816a3d8d070e96e61a2df1238ac3c7fb06f303a1254d2694eec5659f02c2c0bdf44cac997f1e55cdf878b92e2a6c95d7c0a74a3fe2a7536cdfb0cf1e1c7026e086e993505814b1c2006c3f966881c5bfcb8cf7862e7904a7f0538403c327e03d066fec5450b322658f261587109f56daada8e3af7c15fa05fd800b69ef1a2de8ee6be10ec31253b700baddddd77665cde2ab6d32db730d504e76f7577e61db7396f6af9c1ff716385aa990e358db66fc250d3eda18ccbba9fbe0fcdce435fe54b1a9f311b7dacf480afeb657e3f74f36a5c6ff88b2651d022fa40894424587ff9cb3f2f47718d7bbb64b390fdf0825f064dabd82fc096ae2ea8f84cec99ac3e7ed8c0ad5cb79a8cd29bd279432bb0317549a1da45212f254147679836a46910742c4f9205f67b50780750d452d004679c82aac2ef9d4c32a0ae8f271e9b9f569209076c90ab7c0a6e1ee2e620faaf03c6686213803d991c2f073b4f2558f513b32089e82808aceceab04ead26336acd9c91053944cc839e22a5458da83e735e850df85426e2559edae6e689e2f81861ce834108b96f71a41b765f61d0b0bf00725c9ffc5b8d74ddad4de221f77a60e2012cf21a8c4c9562724ac3cef48006a8718aedce47d4d8779e507147b764be463bf8c0262588820a9614c1af9ddbb8664eb9d254e69a96e20bff24badff10d638c4361fa7f01a09f14110a360a7ebf5a6904257d34fea83f2d1140aa09c616cddbc96bddebc05b9af47abed238af8f7afec21d56067543d91fb9ffeef0315ea8736c696ff505b7dadbc89637ae73fa84d49fcbae915d659b7bb8517a2156c7f240a4229f6a6a8794b168ed128d415db40143edf7acd7a759573e1b93e92c69335eb73a2fefafe5bda93ec03eb78a959d43159dc642a3249ebda2c772698017e1a4235c2ce6f857c394d301b1f0ba0ba7cfe50e2c8e49bc231906618f9f24b01af0ba309e571313db369e363a24b7179005ec8a590359acce59acf5fabaa48ed5bd2761a5dd3020a1223cbfb3c00f8c86c54a215e660c19e6d82dcef400ad548852352ae20260c1bd2d50902067121f0c8456d212ebc33c31f9194223ad888232c8859ce9c5515dc2545456d6c38ac7a895ea8844d63e1056218bc19dbc8a1af1b7828ff1544eeb47baeeb5c3dcec73725aaec8be23fc13e63b0587e3503c0e63e22d174dbe81a4f48677ad4e3a3cbda66a6dcd1d72f082cdcaec0a92aa1c285fc415172b065e90f61bfac74c36a9f1ca5cb42cd8f7060f8dd48d1506e9ae7ff395960bdd1586e64155482b679f482f751dd6d4e23f3bdb8ab9a47c20584df2ac8c58a2350ebab15de70763e9bf0d0c1d7f553eeed638f03e54a20a10869ffb9bc4b083e37ddc43fae5fb6b9699de522ead4eea6a664df7df0c7d11c2e8e49473e7591788f5c427b3fce49b2fc7b7d73a494fb584b36f6b59b04b960670ae15552e3eeb92708124454c9cfff09e0bc2a9bffb047e9ad31a82a658811c92c67b674683c8ceb8d38aae935d598071f53131aeb217af68e5353e4886e213bd94bbe3ba46cfc728e500f5f9f378e09d4823715dd63be170663000387c6e6274d6226f50f73c9f96b578ff2b80561a2fe95641718e09f9fa0bf81db2c2a9418a1732440d6b5dbe2984dd3339c122bf157908287db0b4b32591c088316866a08d4a6ba6116c86c3a5885952943d041feec7f30990ddf3009ec659c96862b65d7bc2e7fad0e700a562ce9267735495e9d982ffb179300681a316c171a9485c007e262f7e4f2feee1846f9ef325f8bb238d33e903d8973d9d27544c009f6bd13a73232cba9daa5158f07698441a66106bf2679625780c50afb56d1eb1ae0b9c3fc970bb4cb9fdcc2e72e56d0cbb7a77db035e34a964987051924367417d29fff0ccb8f5e339bb97562baadd641039acaf42795a891443d64f67bbb4aeaa3e48d764e5cb045d472d8889c7c738293282fda539e4380095e2d85732a4a83554ea79a534e415cdebe4e4b412e6f687edb0401acb8eb9b18fda57bb9788f66d9c45535d126ca4e7605144a9ad7aa1ffcadc1241f11f881eb952fcf3cd665b7bf8e3d50bfdc49419c2beddcabe46624a8fae20a21354ecf3d560361c246aa3e730243169413b665b0edd32dfe32a990a4f9c999032dbf2c4f43783480235e4844bc169e992bbe622ca350e151b6969c159300ac0242b0eed6baa042300537f2ad500301d9f945a4eea05143b3bbb0d23e40dce9ee04727fac4dc9f7b3b57939680c36bf04f971b78c1e6a77f91819b151ef757d7262c4f564b0cbbbc3db0ba8711844a3f2ea5d01fdeec3031af674e564cfa989e070d51cc46360257c24a8e91c6842683ffa50a40f955c1c2358748a26c896777698b7e47e57be7ba83380446d1d10e7a37753ff230b66389094d89c9268213346dfb9fa214a23651491aeef9c512082459cb8d2c5f1045b6ec0b85fad4945adc27a829082cc81d243971bfa99fc0a4a5270632819f61a4dbfe70bd50f7b44daae0f4ba5fd99cc222244c4a79404b4308ed12b5a54e18cfcf25cf7aeb9931c5aea7574f5c83555c816ea05da622ec570e93c6c5637a63a493c065856acea2c1bc5767cf14c45543aa1445f76d313f23400857a56d9e0ffc2289fc8cc0878f8f720be86cf4de8a3b1af336deb2bbd40d031a0962b65d293fa95b826be5c482d839b6c3dab0ff47b0ae7b6612be640402912def1320c28ee13675f53406b68a787c2e62e49402e85ebb7f983c023b6e0511bfe120447d2ce1b9dbdff74c637e5f3e45946860e996b0464df898610036a51c914ba8f09f9883e1b3bd8f3e1917833edf2e2c04ddc91cc2870c112b5af4ed9146a01908b602e7ce5d44fc3d571260ff4aaacf439fc27f45918e998b6008784d667d86d23908d5bcb2e0d4a53f2839edf2b9e0c2160b03732f3f0ff115344544b9d5d95953916852ae59f6004a9f9db938936a9a05601aa9560bb57745e3901a564661c2bdeb6e90b05f79be46de3478f3e5f894db764547120af3f46411017af5ff4c067c7aaa4517dd7c47ad22c0f510e797dbb756037de26284b2a5fadd0d66f84972c263798bb30ece5344662adafc8813e82c13e892a5b80679eb82fe2dc45d26d2f50cc7381527f46d3c2e2fe338bdab23bcefa0c13b94fb887208edef5b2962b3e976829f48eb225e4801e492868ee3385c0e8bd70671038b90151d3f2b3646469d84c4aee49124748cceb2ddd4ab07003e6b88682eab794cd1bc1c3fd82336c34dc111dd9d35869798a95264a97507af551d965fff461ef7a1808bd9becb7541e23ec1458d324d4686cec2da94bb2750dd3ab2e6611860284b42bf965757019f9834634b814532b03639a0ac8adb76983b23b7243ee4e46b8842624145cae4563a005f03f0800182bdec70b9ea9d7f64d9741cd4f0b4ae4ba031f3dc1947b2b68a797608a27a3b7d0ea8c77308c30f41e01864ed98d8f30022b52c6342c5497a03633d734d078304b0007de770c6d1cb8fe72faf8e85d8c50295f5c4f79081e6731c8e3737d07faea767af495fef81dabf87e16df339d61b05e4a92381cfb110c3158780eee0505bb8f17eb5c5414462202d3b3337b3a7edfa5e5d5e15d2de3dfd45a67b91f39d05cffe6b6f1fc4d5d745fd45fce6be69c72757ac33d9b84db2f48beb42a1667fa1c5b2a182e37362be8f79159fa23e5e75baf2d43f47150049a0599fc6dbaab8daaee241ecd0fea72d9f63265208f5f9641e3efb6157b4ca7562eb2df4ce31723994c88a39a63fc38289f846a74e8c0cfd2f23e776673279f1452890100f92593991bd9aedc50e48b4d81913c3bfba8c99272fb15ea44cb8970c6933e708b69338ede49bc4be54540c70774a428a48e10f3a115534c7b5d77a8ad973a6731a5df11b40f5f2c9b2c1a36dacd0fb252e2b0776a6bcb7433b13765a353c7d8095da31391d25965479ca7872e15daf1ee6dcc85c175eabd1b598a8668174f2869f70e50696054838939a3d4cc08e354c70509f95f76fffed65b651e5f68521fdcdb421e67613f4b07e1119a3403201b6f9f87c6ab28bb39c2a64369fc544190dd837471c1ce4d8def920deabc2b3c08eb4203149753f5a40c8c47dd46a819086384194769d99d3bb2573b475a0dee431d3105924ac58dc685669c33f04136ee7923a6e71f856c82600ebc58eeecca522c36f4e1fa90819f0569276daf1c1c42b042eb10174854ccd808ef61bbdde1afa59d170e363795954d77c016ab203cf2af136fc3bbd7e413e1c56d33726eeaee1d1baa94ece0b1c124973d06b0b9fd0d9115c073ce067f4697cf16ca0808b5e8f87393266622c7d785392a2c49882d979f4f960d7a84c6ae6f3abe9d967f90e60c260273085496593fb32887c7afe5118cd145e4f172a0c0ac8f37b5c830f1ce1886752bc97245e547af554ee9a4db5664a29ff7aa4edcb372c625a12e73c0b42cb96d5209d4fdbe7adf5f0ddcba9ce1cdce16c96014260ccebdce129c23edee75e35087b6cc3449c30c16600b2b6f23cd758c86f807054470bc34b13e5dff41c6e2aa2bb6ee25f932631739c98249ded205029edc20b1dfbaade899e29f7056cd38b3cdb433edebfe720ad88d9e19e597489318ee5a52468ffdb60308f247b1a7780a0247d6def40d14ddffa4612e6d5ee24a1bf3c8ff6cf7c639495e7393877444768ba60d9cc22c205bb7e8d5910ad0233542191ff74c2da76714f03984eb7de15a3639aa2e43ddae05b905b51832a7d87a63236ac9aebc315a41184dcafe248510b2b7f02aba58c1cd8834bdaa5ea0d7c9808a0d225c9c9f89c42c6cc505401565e8689cec28d13745b1195fd0d819d8be42fd92b06465a8495edf756c4e700f8686db7051982c8cc61ac9dc83a0729e2f8f41de8286b1600de3d0a859dab04948683abb812b6f081e7ed276c0f51f4b2dcbb73307d933bcb722b12c7d197aa6373d4a4d0741d886811aed7d5dd0730814b7498a196f5ad290cee8b3c87777b47d0013a677678e87129aaa011bcba4daefcb9a9efa3c957008948b6479bc222e74c3e50165cb14034272d5d228c1869150e143046e024e3207470286e79290db5304b39886d7d475f414b01ed555f74d14429ea1efe3bd970485f161c84c0010a81da1e5094fbe5783d3e1419d12b197046e7bbe163b5e774bfcfa5b41bef94948391dfea30c907c8dc9d2f04387931cfe5bb957cad163ab2513d70797332d1af2028f2cc5bd15ee78465bd468fa02d5169ed75b7da0055c40dec5c95c9c385af9c5ca34796b74b39b6b5135ed07a1dbc7e88ab0ba984467793a6653489b217ace5d1b9473b210bcc20be0a30ac2bfa6e21dbef7f3255be6d6533088435f1bd36b17e8efe9c77901265812a81eb2ed7efb8f554296d31b81402b910e19e8033308efaa8e2f8ac3fa62d45a24ed9c2055ad9ba332297a8beff9354750b815e0db3c497c8795346633c2b5156640fee1f0c9440cf36d258f7b6eefeeb77e6cfa5a70ae186f20983deefa3359137e6eb7a70199ebc24dde9aec050f5792fabc9843ca8e225e5a702f52534361fb77edaa337d2d92a931f5568f2d90baeb71fca186e34d38bfc3c545cd81bd5bd191eea703ccdece495f1d07553be859f1ca82336c69d1763e101b41fd5beaee39d2cd03bb846dbf0a050ea902e7e1b4e78ebc9939619c159cb53344c55b51fa1bd4250caf1ce382cca0b24e6c641c114bb40e791fa3b195b9e0dbeaa60d3773feb1a119640e1c30bf357ed2a6a67da261dda9872bc848c6c2ad93587e1763a821282ddf12b268b1685902ce1a8e1ccb57bcec0690a119bcbeefb8dd02784db457967279fe44c5d90787a5f8333f6530d8b6331165de3fb8a5b6833612adf893e467cde2cd3ee3bc4c179af458cdf9714796a4d951c25c0630b152953265dc8fb68c1946c9543c4640b96b3f6beec201310863da5276c60a528ad7049bb2b00c9b13bc97c18b5c4df645e1ad005f146eca05fd2cf43c3a2ae2c78eaf7effcbb4f0a8dc200197cf46b5f3ff953967bb52e71fbacca20d3be14aebf9ef83c42add306d2de0442d547642d6f03ed1c97e73e23b4195b9fba90aaa7f4c48f5d84bef07497286cbde091d0015c458effc10e72c08ac60649e65394ea7a36e9d70f04d13fdfd3925f50acd488e62af16545fdd34211b812e4de7cbcfd13bdcc7749b4c03f129e02579f353e9362ce80cd40d4db73d162f7d4e7035f02bb880c913a74c953fb011de360e5783e53bdfc0987c91eaafb02396b8c5c8cffca29b61c32574020c9b664c670cf4146f0109a99a0f52eeda17ad68d9684ed247538e3fd3c4ecb3d0d983f8c9694b2f94dd91a04ed86cbc70a96ccf5d2a4ead4a6cca05568a5e78f8ba12991e91a67d0ed3ea5d92f69ff255d3c28359d564f2922a55f0eb940f2397033947441afe53df3a6af225f7d952e8070d4e6bab57acf12596f1ca4c23bab72b2b6c93d81b60a748ef4fe4302c5becbf3d219295bc2c767762f0c2e4995e5e67e746c0865c2f6eedefc3a0fbaf5f1a3660fdf1e1189c03fe0a25985c87f5075288df90d7f61ce7f65a46ce8ee647d328c34af3fcfbd6ab5bc5a1d5a7ede81afb4c419730296dbbf0a76a306cf9870e10bd06117e96171b0722cacfa4983a4e22ce75ed915639811aa342b66fc7a200f1870b1d827a22e5cb81e5057ece562fb8ce67521104fb12be4647c549be9839f829475c6125d8b05afb3bd62f8a546f9e993db0f27963f803092507f4de2161138ba1256c7665938df4d40e9cad44f765e015355bd1e978488c9acbcd0ba8bba72e474809e99aa0d82cf8d49cb1fceb37011fde5b82ff018692b2b5af3d490a305bcc0e0452af6f9481a96d90ac9bc7995fb2b14c5c56fda614a9a79f4d9784e7b8dbab016751b646dccb8bb7df76f48d32e53358c6539420d495705cb8289d87fe926320dc1a1620a904943e6370c47eb2efc50d93a6775fc1dcfdf643eb74d6dd9d72cf23ba1deadc72a04c5e43a23bf24d457e8ca0fb03f85581f7dd7bba280675af0811eeccea9f63ea0d211f5ddef682a706bfa321416b1a4297575c6f4748b564ba551f49a8e99709862efe66a6afc1128c23817a0381c2c5d34e7414d994a208d2b7c851480203931187b908feef81ea8e99f52ec907383e0b3fb52158674ea093fbb6351036c6e4e008104475426b11c58121b84656fcb684b91c04ecabe4f9763759291cc0f643d4ecc61f1ac667646983b3370091e53e00fd1263270aea52de2625285e8fa63a4b03bd5ed1b47a91d79467d298234bc6fb055ca00296ae7d82faddcda38f2fca3941c0305d3b4a69dcfbaf6de9055c54c0bd283f9de778dcd44f0e5cf955a7b208d6667446e3b2509a17aac5f7cc7bb7e7197b00dcbd17591d838d4b7494ddef1f932092f21f4e2d6aa0e08f1146864e9ab8ca835d990da9c83510397cfb3993687f316ba56f0ffde4fe744195ec0c9d3cba10269d7165048e4d058a606d325e9aafabc2e142320133d2a7ad698042ca3f09e94dc21767f0cc7b81bb106faaae34dff2b92f627f381736ef74ef4c970d660b71daa87a1797b24db3f752ddd46199ec28cc80d884d7e3fd7026d8d986af70aa3b6218618202ade802fe7a9ca07607d3a6705fce7184ff10cfafac1ce0548e5b75b91cb68a3763441228e36d635cd141d8ff87af7659a56814909fcb9c3d1b0e712449f2ea8a45205ffd08efcd1957f2b9b4939d3e18205a07b8fe13069ec5ed37b24b66bc8495283163a6d33add3efd1d96b2eebd6fc6d8b1d4ce711abccaca585ce54d4cb5a9564181091f429c619c005995602d0bc785ed7b89e4b474457499a1bef3ad60c597512aea8a70631eeac565325b407d259557af168f38809757c6d6e49323f352a112d59429c64f34f53ad7da2abadb39c75b624280d222eef58c0bf94346b3c12795d5e2d35c38c2898847badcc605e678450b6112e313e93a450ece3bf104622a73dfe12e9410e9a00f601600ce195885f7357f6df5531823b1ea0f1a722ab6cfd0ed74160eb47aaa6690c3065877beb95d36541ba3436514cff729cdebede0cbebfc234dd88fe1f96951d17c699c929ce1ea77997c97719b5ddb13df3cf5d5889a6f4bd6c98548e1cce30fe8933699e2bb8f8ecb0e011a8abd4eccbc212bef5dd3c40cdfb1c86125e880c5bf2089a1b8e93a6bcd9c6a3e3f35597cbd2128e58849cd801c1bfc8531f79c6fb8992ab9313dad560a8b32a37be51f8364788f5275319a74af1bfc5862c255958a9a9fd0f23e87158bc93b998d22f9c87af5b2a31edea17a50ba08986199fd262d011ce981574ce49a818ff4542bc7994882af6059e503eae4b2dc6fdb8c03e4706737dea73437a727f6891dc755ff56296a8b2647ace0004b5f69794e8c06dd4fe857bb955646ced5544ec0334ff013d7d60ef8fa4ad4268bb14b572d308b51cfc5a8853be052255dc3d4823a58c9e4dda08845c925fc11f02d05f5ea3f71c4b406ca78a6174ec07cbefab5c5a4b3c31a838ea8d7eca8e910909990b01b5887c80e425a2b2d1ceb7e2fffd9fe9be096ed675b74a5f6cdf980eb489cb423f42c41f6b343d817ba20e0c927f17a43ed6f788786ab72ac6f1df932be6d0bfcd258dbf4534681a9715a96cb0158637ea20c35c98d19a4b22b79d0a2cdd7200ac4e8cd7cb9c27d695a1a1e100b1380477b19e3eaf168457cc14a18122ca5b8b7454dd16e338e437d6df146a09494cd59ab49aea827957dfaea82009e324fa62c28846b17340be44493973aa702abdae9dcc2d1fa65e758bee06658d0560a8317e39eaf2f2820cf8595385a451c2f153815bb2743e832efda40cbbcc26b89c32824f290bbec52c1d70ea10e3f09beb5a4531361a2d45b4c1a398a486cca454f3b7dcf062013b4b5264d7b7495c011c90567f6229353efb431c9aa134fc84d5d6db56758c4f3bd315c410f141e341ac89d93356d3a39c75fe44d78cc64caa692681139e0ad27623fcbeb77d1cce40a750ea9a973ab19db59381da3d343f51b3ac8ee6b5057e3b747a9e2629e620666356c677b5e8a05a27959fb90b31b2463336c8b4b821228c0adc0bbb15f7d23d3737660f0fe90f4d9d7bf233d56ed4234086043c1594e47537376452c53ea3fcd51bf911e4740e1f6eb3c34f0ad9fa1ad3e660b1053ec94351d732568b908c3421e5358335c5e2068e0963af488e7bbf93577fb4d3b7b2bb7bb6210af770d398a89785705dc25e8174b4644ab5c090da88280d3f61942ea3dabf59beb35ff68c8ca27730c8d9f846eef1c52fb009afeeb8ce9b1d236ba5c7735f17cde515a52433dce0ba2c19d28b765fdb07b9b177afa3affdc4dec41c15ac7f98c15cd3f5481f127a5825949e35a86c3684008b7f097fb0019485ca7541a1011fc97f4505342ee05a1e7bca50c9cd16180caad55c60fc9728f01baf4a2a6ce8c0cad2dd33e7834d98ca5dd83c7c4beaa7b0c90538c2a26acba3c90ae18349936182b566b4065b72210a8baabbd00d151ee0bf17ef0b3448f9f2482c1907bf1f1d24a9d45b720ca09a6717a4c6d6e1d2e59e81821b6cd77597874495fa8f125aa793ef13eb0890b300b4977fd53541dcaa1927775325abc1474e76dbaaebe1011141c3ba4576d14db3ff875e78125b10daabccbd475fac79d25008af3d8d846f256a38508ef06300f86b6c9101a5932de60f6afd36b64bad8293276cd0bf8422cd6b817c5417782a16b179dec621fb2e69aabc85dfeddab4c607b88e31ee6439a29d7b63509b9ff3e7f38c378ae1f0653b5cf88cf766a8a9e852c03e61d3bbb789d3a3c5dcbaa9a735393c3622efb84e52619d337289b8d49d4b2eff932bd38e012d8012bab468bf01bf63fd74b45ab3ce7b19d52647903922b1f846e2167a4edc39389f3e684bd9dd44795576050dced91a5c96f6e93b97b612842746a77adbc1a12bbb5d9d30c1bcddc4c2e2fbd82afb36998aff9a89732611c29e9bbe1f8f39d15962095c8e6803b51c8830b4432ebef7e96b180a7378996c9571887c069341bef1ba178ea30efe160922014e18470582ce5fa6452cdcc739017a8ae5ae86555efb1ba64189e60aa3018a1cefeefbccd5c1e95bb2c75fdaf368601d69968444ff306183525a69ba647de6ec3bd7cb844ab3dc9cbca8846cefb76d31eea3983ffad7114484d21a42f0e83a1c70f12b8033ad71ace836a90f0b37f59664ba885fcbadd398630c7d45474ee005da8da1a2905c678e039bb81251095803a9e84c01031086d7213c4a70b0766c8492e3ca0aa181adc8066a46dbfcf04c4cc2f469f228e317f612208da9277a5114aa2c71cb87749c183c5baf25ee91661f3443f1cc353581c137aeca2e7fd9db8161b9fdef2b254bfa026455e11e780714e553ca11a32e36a20103497b2813709fbd3d0419f73fbce74382ceb2dac164453b69b57dab7406867e7a4d1a0619db28b6bed1fb4f751838623272cc41954d251e0ed85d7384d6ddbb71fe9b2557f0501a0e3686f90ce3237688c0956efb2c9e64d37e40fd2c235110cc1fbce4a999420d660f64fa10335de6b8c554dfc88b0dbefe6d96de80e236cd620af50e498f6d8f2632a6572ab3e760d6e14489cdf529b2da85be21d1f857312de7350268768c1bff4f33b3328f259e78610047e556d87f6f455eac400dd46fe4303b65188a58547982f13f9aa27db837205527941ea0ac353a8db9aaf43cb4da9eef8ab6b5d0819e4f35d8b3b1dc895fb51136265c6afa5ec8692a15cd75a59165db801f647fc29ba6758f7cc42dea1b9c8bb0850e45965397b460b131cc852e0039def0b88fb4d5c40869295daa05ea00837238a30c8ca2b6c4bfb8f54eb166a2dea3f1626fae99045e3b7b4e1c639a9a63cb38cfb299ccbded238fe917e9669028b4c781816845e14d326a3eda34446b111c1e849e76617bfaf13d1bc7320b812109998d7ec9b27c398c825100aceced63d35f758cb51884379ac76344bf6a412f34c69ddc74ed61339bce2060929bced47991d18226e9525cc850a6dbf6d9395cd97e2c9b49d7786569326c54b4ae0bb1dd5b5bc1af88be5e95a4f29405b4e8a8bf12ab75b029db0fd70ee0274e1d4b13b33e9d8304d874537ee55051b189ad98efc15fb8c1419eb25f27863061e5db1327a8598ae5d4d39e2a855d8bf1d3667fc83362c6883c0346abb12c7677621f6ff7cb427c49357e17320a92ffbf8175b42b6698bc9d999a897fd76ef1ea76bdd5e5e76e19484265b7c2a7278d80b5151766f04c68bdb420d9cbf44170821dd05e4f3d90244a32851ebe017c94f3dc50f856cb11f31983dd8a6c8b5d170318131bfb4fe7ae5b9404995469610bba96a8590dcecb0040d7e53e6d0b93488fb0bd09f69a65826f4307056a76acaaf205b86ec2c21a6c6df2148f54a501ebf853d311bf513daea6ff8ae4fbd915c26c52423848b6392aab02c3017cb8571aa405b10e3651e23cc8f14946433501568ae036eaeb0f184da4faaad6f4e3088bb24c4231c41dc4c9d62f316d46835221534b332e8015e6bbfa3f693e9efdef1fb9c5f31ac21714356ce3eccfc435b0088577ba9f338bd8970f6daea604157b4a34ccc06134c6222864b02e5f2a31aa0cd8d95a8ac63a6bc8a76da7131a1130c96a5ef4588034d34a667b8c2e1044fa40dd0ffe06df16bfae0ad7f2395c3d04353051ced45a21498bb36d299601919065ef8b90e0e46fd6fc7e4c60cb4d33f77db3640644814a85fa00b423d07831995bad794a62bf07b3f4846ebfd85092df51ac1b627167885ede57a5bc5214be09376b01b407de1a733d845e866cd6f57bd43fbd564566fffcc63db7528dd17dc2620062a051656618792237ce8780f93b479ed5a13318bcae13cfc2f304effe7058b1799c990b6e5364fd071d15836f4d7e2ec913e436388409293e6982ca1b546a9a6916708db0c8466dec13ec7a14cd5863dd319cb9bf888f2366ce434e7abfd69a06209a367434b42ccac4ee225a6e5d585fee04a5cbedc3bb6a330bb5d2ede6e053413164cb1a166c6b5e25fee72722f6998954f5cce5891046faac6d1e9420a04837e798110705ea2822594502c8009f2d9444e9f256ba5735309621acfafda0c982897066bf043808c25150c3acfca692f4714ab19136063f21083c765e92d760807f0e9efbc5f3c1bc2c3fef7ab2155ebfdae5c689a2c2ffc9da5c2d7abc0a4b8c378645adf1a56ce2e2d430166c11a8e54f00e74e1ffc18751e97a292fba6fff92f74ae9f6ad73e6b56569b5bb9a3135fd8c23d485ffd93ae3f6ce65c14c59d65e33aad2703958e2dbeb4bf1093df1be358b7f662680796425b0be596ff520c8ee0728a5439b7bce4f9d9967aa15a31075a27efb92dca7b5ef7d1ec6ad731fa34f1b1b7c4d485795aa65f9c39fe09e6c5867b7994b1e1bd99916f807feff1bdbea4d9833a8122cd3fcf8fb4127a07023bcf546d74b1f3ee0c0eb7e8462f3f317c3591a8437e518a8c2a788f6d8081015095d73f090483ee3c5aa774f4cb26d7555ec22f2ff853e98620340b0bf81670c02c54bce72fcf3ddc68c48cd40d08490cf9669fa2f7b7ea8fd519a66ce43f289485237ae923ed46738796e9ea0493a2cc571869b8c4e2f77b9dc24de368569140ca826ba7fd949572ca6f941890a1de394e3648644873e4817c3fe7252b484173796ee82eb2b5a45f3771bfcc6d1b4dd1c8923cd1f17dd47c9ffa3b5498446c38a6773c5953761ead84e5f4e90a319e840e5b4d0bf15454ed97ba7b9ab635cc7421b34f41baedb742330fc0e72784d3428ed906e32e7c2822b0140ef7923af075047dbacb2ebdde67f3ce66a776d9af209af9c55e4fe3041ea0ad3b1cd991e12b56eadfab699e40052f499501fed73648d247bf1cb34db35f17ee5d79f25208426f79d39f3fcd030e6634df143b62380530ddeabab54c2f5a755dba14c088e5432892cec96d9ccf3e1bee0edd80e0365614e07d3c9955708782f50923e962ee8f552e17c6b0d4e066865017485f84edca41c2996093260abd6602a8cb935c3717185be7a06d8a3b54f0245f4d3567393b29cb002ba7efa728f035d60fc47d685505ee985141ab657473a631adc62712146f6a5195b64ac6c6cce90a7820649cbf878c1081678da973e73f5cb0d72a2e6e26af68cdf5430dbafea92f24e778448469bec7156fb94b5191f35eecb62ec6504b446e641d4330991ad1e6ae88b8bff6539e71fc1a462d3dfd9761f2332ad49746b9f79c08e1590c42ee759860021e1b4611af004e22bc053ef64fb63d33ff38cf81b03de60b59fbea64bcdcc4dc7fdb00d12ee09419d4c2a14078e7c5788c9180747629d8e8c8bd172cd9648efa521f1e3d806b8cfbc1f725f70d6ab95fb42fada57d4817e4beb631a0faa8b09f94ce1fd434c126f42dafd8d211e67b75d913555e7b22b5600618eb7720bb54c7133934d4de7a46b25ecde3d3d4f776164513196a9c6eefbf885e52f083c937f66594011d562c2cac19cc00506b65bc12a3a4a351fe1ce95099533a42fdd72cb359db2f9e7aa7eae3863e85ee7f071a62230ebb910e1bc86326e8588e2238d70748e1bd22f15c4eb18bc2ef1eb55011c063a10d9010939cfa43d1720ec54e25d0f8e4901807d76a9e69941d0cd814ae3f923a22fc1703fc5a2f9d820b2886cd15e48a85315a95bada73535fb508cfb55f0b2f520f1017abf7ec75bf3607a2ef9067d03e677d4b0dd9c3501bf6043afc75f0075c05b04f2a1e703f762e5b235b41c313b32ea8ce456a375fbb5a7e5bf329f1c3b802ce6a2533a4121b0d6f1b119719b2dae136ac2cf160e85b9c40f5f5f26b321be7d469f0de8592c96dedd3ec6e10b6bf6a95e3feec78c6d41f982e2701431b04fd97ae41447cdc25ec98ea1aa1049243cf2469af358144ae802ebf46886852f3ae19d8dacfedb219e64d62bbad9ed5936e4b6e2bc09a4086b89bc127462af5eadd07021b66f6931fc073fa8283d4db09ad1192c7f4627f43637f9c18d8d3a56345f2e78baf8925507d823f3caf4657ff16183a2f02b7a585f7dc00b2082800163466a20b7c9e2499584e17bf15a6e5d090e00908f5c505bdafc9f5fb068cb98d7c826860386b88223918b254ea363489284a33348c17419688562b7e5957026d883706fd2d4f9249fcd6370d49d7e90c662a893674cbb0126fb5a76e305149f126e8cfd2937bd0d3fa0e82a724015f577f19f89d221453f2305b161aa8cb5295806c6258491842a65bd4d229c8ac0a91b789ace5707624765f62e70839a52a8ab207dc7cc24eac6a91610f3a06b5d10735a3ebe129f0d140e44db3e034ebc93df11dd3eeccd62d41e6a6c8673deefbe9af26344e9c5bd97a2fa16035489248cf0a03ee07e54ee78a8cfce9bdc0c350f7732c2ac6069d687f110c7abb8223564b7304d2dc6aa66e41c63308f28a4f1d53767f924c1abad1e8e4f6c6d2839f632eda065f3a78879aba6f9aab453e1d5d93ddb345f05d1eb81dfdc22df04da82c5a76a97aeab4ae53f9c3cf674bdad00202a3bb1547d21f4201df7e6edac9d1ae5759b7f5be6bda5df77ce2c1850733c6d6ddabde8bfd823e1f474650824ade8076c65864749a22a9e7a4f2f4c6364e6aaa9f0f5bdd1332fd43ce36b4a4108768225aeb09b599aa76d181b73fa3bf6c0a517791f2140997d3922fa1f7126853d8c420f6f8912b2551073c1f86ddf95e4365a1aef9b528d597f228bbfdf622d64eb461387d2915c4492b6f56d905640b1b457907713dbf15613563642ede9551eefcba5578147f991b51328340cda0f4beb348825675ac431fb47d3a12185df0c8ab7e68739dec3296bf8b76b6eb80e6d0942e27c62ace25891a1f0f65f52b01fef6fffc5b7de07df77df3955e6d7931d0a0ae8bdf6aef079e994690a570339de60e90439668c53042e740ffbc59ed09282a4a84f52ad76565d60de9074de4144ca927deca555d3e88c7b79b2af0cac76a1a67092f11fef5bab60160c9438f8e488bd3ea26c9b813e766b36984f1ad3a5f193a2d917ba40ff55d2289e5463e21f827b53970d175f477e7bf4830aab7a788a6c049a25c211a67d62ce933a5449a98c2500bae8c5546f77599b44b1194d937cc4cbef367196e39574d740dc4e4e55d9c9ed08387bc8b719c87ad2e94b4dc443fadbe84a7dc346082e9f0b5c218606d444627487b102a0d625e19f51a975b75d5cc9ae0e029efc4e74320015ce621d74eacb857b429f984501cb9eb434f4e3d2c37159b35c7d4a5f8b34e1a8631b4382d434341377f0e7af4de51c77f9eba54308c112d019233ae37e4072d771ed0f40b44718085a3618357e55cc81309415650bbd550d959918147849b1815dead1e667acafb10ff711d089602e3f6d10fd1190b34dbcb6a3f78e3c22a9a1f5adc91f15d9f3dcbcdb7751d80e67d7662bfe19e13729cc3d0004df5bc139638cee4e8d46d41d10381c6305a33d9599d6d6c456ece38f8d36b240bf33422f87f154880e4c2a89553f05483e6784e8e23804ba5cee2b2203576d4b6847c0b5391e1bfa9fb658b645b57039cfdbec4a5bd253cc0721485bb7bf0211f63a9c8cd78c40b54f0a7a9fc8a50f907d27ec5917fe85a8c6cbed0767a43449aa41979d773b86365483d5186eb37f81d1f2dcdcd2144069e296e753d5210b9ad6f771dd00ac6d64894d75271663da61519e3dc264e8e192571b9ac3d0bf33f6e68a73d6683b11083c2fc72f83e887cf151bab74c87a1f227da3bcdc76f1cd13e5c75642df4ce324df1b28dcd99fd4f9f141d195e7870243b315cf48b57ca1af6a000fa538c1a42a26c205444b3dc3d468719d979291bae2f09384d43c29519eb6e06580d67c095f78b8e450c60e5ac851341f91b6d218df78577279eb0afff666c35f235e914078baa5787d9dd4192b003042fafb5b5d8f4f3f752a693d98c18407c153c39d6f673aeb163d3c55cddc1d674798b643b9f2935304b0721e76e34aa3cc32c6e8ebf0244357238bce8d825ae7dbb26cc107906e80b1563b63e19d29b7810ba0cc4337d9bdb3e3b3e8f5ba31dfd273770f79b78759d2f743ec88ea175819c55f1989d74c50cc21db1159b540a0668e5d740cf506fefdfc381bdccc7da90f8e680cbb943db090dd82098f37dd26e0858c38b4385bcecd28bffd658c2ef0d9b74e39a38c98a8f8d8baa72d6426213a2861711cd3b9388d9ff8ef7de6d62d0c3b2b9f2a24335ff9e19faadb0d0b2ae51c13b7e646cd61448b857daca65891a5f50c4b265c63d5aada4b375b0d2fd05eeca00ad453752b3f688460c4c05983353f2c9377311d1fc9db702407e74a71e6b199c15cf92f8b94011e85089222c46a37bfa1845c7005db1fda3daf1a2f9f8eb8a054feacf877490620986dd0c18a79e6176558250969babed2add4fc5b69f93bfc1bfd3e33d82ffc03d788e4983e6509c8f45efcc2ba01977e00038cad5818406e20560d9df5524078e0344a749b010c7f670a358a12ee77a506eb61d0e16ee1b7207d21ed8a27e3ad7e321946c66c7b37416de3339daa89775cdd3965897e05b3fa5b3d85e64898238fb2e4a701b84e48c7edef9ec6f8d3e0cd66692c46b3afc07e1c5b3a4b2d91d00a827b404742105f7c40da28e1c23af390da82ce62b4761fba4319dc401a3c3d28b3904c5de8a4640cfe06291e5d956c46fe90dc2e36c273aef7d5c9ed7d0ab8668dd80b527e5c570565593541d10bea2617b3e0876b0b50773db4c6e0a868502a60cc66319aeda74fa91f40d521e4d9dba12b14de9904b544331115e94c4c91cebc06c4911ea748877da62bf91a78fd7563562c50dd817386884eebfe2c74f7df2874bf71d0d776cdb4047d7e385e2c05aa39481a296eb568e22389c2afb7da8df199d3b2af7ba5b2e10ef476301be8900f2752cea3edf1625ef62f715c86b8f7b00632137881c2252e2f351ac0e92890f3395b7dbef8d5477c391a08108dbe65c123ad6281368ebc56c8bf5cdf42b0f4381fc2e60ded7b1303918404e41f9108da1872b1ef6442db34b48f83ea839bdb466728d72493aa539973a48786cc4096075d79173a4e42c8fb299b350dc206b21ba687f5140421b7fc675c9737d0e3465d3e4cd0b40baa6ad756d2129c3464d39cf33a84f690fec354f3fd0c3f946c933dbb64adfd7dc2c6efbff3316d26fba30490b72da4b81b7710de71b35a5abc4900fcbbe7c88f99156f5a5718c48ae3eb7224d381300077ebbeaddbf27d2cf41e2362409a4f8659747e476fc9fc575496f36dbfe91e376f2d8a0ca67026bc55622cf3503c77f0484392c01137fc677af8241cd8636b6478328e722fc895f278165b5b4dedda049df81bc100ffb5466b113740b5566649bf287d03f3b3d1873bd41a26630d27c78e72ac31aefadefb595a5c339aa8df7be251e61e41304ac2b932de1f3be2fc24afe19735b1157fdbf257125e5c7787b8fbaf86039aba444d9227b1e0cc532092f93a39e47bfe7c9326f9c69901832a7f7ad33cfdb97b6090e4e74ac5850b2ea40fd409df2b5fb222fb92b33ccc9e24dde2c8343400f26c189f6f9cb8ab06a7e3b807e751015cc873e94b8e9b629cb559345b13a948168318714d286ebb10a28d7bb2ccb4018b0dda44df86eaf8637aef444514c9adb4abdf29caedd43c1029f64c76960c098676cf4821354e8033f90f58783c23f6f7daa02f159001b7e13198375304575e1772831deaf4d0d7c6978db04f551a33081a266f6b78dcafbc19c5c603db3abd50a177897c17086cab52f0b6445b336a4dcfaa06266d2c13d5b7fa8f21b83eb0a736d3fe04015488cfb738d4c279a93e37e5ced3fb4c901c3779ed65b6c7c9eea645a9937e1f816c9162e75d57977ab48f0574950f7337e1294b37476f44b5776cf239b6774e4402bbff489e94e1d152235a8d70a339317091933e91387d2ed20066ecdae87160cd91895c8357d58a06b15e87ab40f1a8565ca3e6fb1684da03992cf8bb9f23999a2713da12e9e86d15862c2abb5d419f37659b015076870ca1679f3334008c041110384a6c61c75d34b720acb6318ba8cf027bc8898955a81dfe0dd1b84e1027535321787420ed1d925fec158f761e59a91f96e9be09bbadc1bb458914b10b525c24d2363159c9101dfc58df181918a2d36779d8a3ecaab8010cbd35ee1293cae59009b9f28075fb4cf7e134725c7df2f069ae767aa94889ed304953637739d818c819f963701fe7af60788a36c6537e6b351399536f46d42146559281571909aa994150793b00c6ade2a3db46c212b5985d83c9cb00bd22aa3eb0eca534684697dd705e951fe1bef5755e27e54f269a6338521b147a7abd3ba249bf9021fed66d90a6b0935c6e6288a000ea7bfe08b0c023985c6d8390d83870e70834c2fe6414959530f09924bb7df72a2c12fde8694f1bdaf4efd073f6b5c310d61687434b126af24e3f1e3528444d1004f4706cb63f399ae5ace2e38ead4223954e676a4f8ac7d01fd7b1397026cb1f6eb7f2295b186843477f2aced67bb2fee8ed2fe6d3c023d77c714ce66225f10c73e94d99175990f547fa140e81514fd79dc5508280ad953249fe7963eb4b56e80018697e05878161ed4019814d30b926f4fe3994caee053efccd82b8b1e5c285df247cc132b16ea9cafb9e6048e8b573e9357b87ebc9ddf9415d425f1e6c35c40743e0e2227c3498996a344398bf1caa4fc6bae8582fb80d6c6c000d26af74b26ce969c7237cbd535ec0080a45075f62518c6a6179c69b83c1f000bccdc6e763e37f8799a2b8b1d1a897983af29cb06daeb19e1474126c7e9ace2a8bd277a3e6889cb2958b7e074e3db9102bf4ec27787807c49bf058a7c6de2fd3769adb669645922ebbe924f2571e0acda2eb8bda3fe416b71ac9e003382b223ab083be9b719c959d2d38e4d695047a97416559f1d8339a54eef9556cea9c4b32363fae2cdf8a2b5ab309bfb28e740f38e41b9009e2b5e06f5d9462e7c39d9cbfdd577839aa29705e60e3d8c343227acd58b73171ef824e0922059be31729fc7c6372e321c54d7a2dcee6463c8b3140e5d20cf475b0bb599569c712ce4d65eaf0bc77aec168dc863f27efb2f6a9b32161312d80776ad656ad4b699fb767e5fca5f313f3d262a685bce821cf68dbc4823c51ab3018621695528277dbd1e0fa995ed643a1d3c259e292181b9e4ee0798ff46c010aec7d0a386a3dc1a810a28ec4c84342544a0ed6198cbba467f2d39f581a575e4760f47ee956082cdf1007bb05b7ceecab1c9e2ba1ed198be52edbbd1ce262e500330c1c8848ebc8a8df44cb9d58d4e605378c0590055f3407db5a1412de3d4ca0c00e10b0292d06feffc5bd6493259f4877a176ff832e095366d65a6c4cb886ef5760a015ffd6b4528063405581e8edac558495c50897b9691927d4744ba5977a27bbab77bc69c8815ffe33d38481989a35eed5c5a4a06fd5b6e746a4cb69bddef8ad547ba39fff9cb955260cc2d0c5a37101911ece3053ee07649dbdec8b6a41407ee36a52a63e7a546828afc73d44528d30fd34e83456b925c7527858a453dd10196c0b30d15038846a5034c2a4160259d61e4c0df437f7d0453e1701933ce545718f49a200f1809beddb9174dff675c9c54d79d9f9f32d7a0c392f5fef835a19dcc193f01d6769eb65f111e459cc7f204bbb9872adb8d1e3034eea49348d167d01d5a0e807e78690bc80798e82702d47bfa7f6c4acf2255293e8229e245e12d4dabf42c5010889bdca3f300f71630eaeba962b6d5211be736c0e6f1aef291412b1a158292906a5c3130c507629773c2cfd0eb14a49b9b7e50234325fededf2161f3780fa9e17728fd1cfa88131125f59864d25b0b0122aba398ce7dacbfc547964307d7e6c70ee2231961e41cf947a2e30511913f1aff3f23a1684c399b99ba741f7c1e4f77db2097f90e6652b9ff00a0d1a37e6996caba54214bd53afbd985f32f08ab3731a9a50f9e50e0c46667cb6daaa89dfa5103873d6c13a4760ce58fe80cb56839c631adae0edff24a11160ab668252cedcfc1927da0ef77fec08721fe99cfcd65db5201f5a3c33bfa9ef83aebb2689d2854febcc4bad2315ad9ae72d77f17336735047803b0c5a362b9a15c1655e47650779127e54152d0664c8213410372c56adb6e1dbe361d6411020edb3dddb47c427f1c65665558476ca52450ffd6e97626c8c90ca0d7dcc7302cb82722d135f41f150d2fe61d203c47c08e0e6875e4f85a88817a80d737595a7964341d7ccca6895001992db5de19e64c532c8b8bce76828e8bea7e030176b54e5600810f65c602d6d6e9ef4d7fa934206ca5fac221cc995d0a6d1f84069f5a4e4b7bd28db4cd31410e7da38e997cd3f0e916c0f4365ca03c74a6994731e0d977d4bed6fe5be47ca2036b3c3c50f0dc81872744aed3660295653712e7464d25d3245e8124b40189aeb84dd6adaa02de01266e596c57496c0e3434515f701f2c7814f0619807a563739d41c5630475ca224b6508ebc8b0f3eadd9b9449188c1a3d0597a438044721982f9c92b9ad41f338896b803bb9fae5881904f0bcfb1dab17b6bf9b17de2744d1dc33b9679c1547f4782ef49b41bf630057e994a7f65d29ffc363d39de2b9a4f2a43086e438c84a371f77b8474601e7b94f1f567c70a6bc1be6810c38fecd5e4a20bf8bcdcfbd38c77516ac9b9db72166b0d8448de5de7364c1e54106cf9b377ee6a02337e806059117d442ccad47e96548f581b3b1c1f6c4d84d4d41eba7bf6be9c5e504aec3fb4e5867d6fb2d55dd8f55003fea0d034c51a7e2bed76739daf36f48d5d425945cc810d60c1b46c9588a4d15e2b3f0f364ea385a512d3211d9f82ef10ffb3ea1af2b39e34896fbd3c86a43d9ce62699e73ead194fedc239f1b265218d0f298871ea8d03372efd281a369588baa136785f9597d2ca911201c36fa8116f8d7b9df80686f9287f41a55bc3cefa95b55ea60bc168c86187c2cf3566ff41ff1dd015c8dd79c9e93403d62a59dfae9eb80e68b56d15ed2e8be827ca30c86b6567a899005ea648334df7a125d2911253fbf78b26787bc5707c28a62a40f164efa6022924d10086689e520273c97a0277a3037692612e57160275d2224c6eac963567ad8ebbe3edc3ce7280c17317b43d2c557e36bcd19010f536a985b530a4a62401a623089b5ac8fc5534bd1c802a3a20c61e24c12f5bf959da7e725465311d6e430cd055e7c406715ef64d44d12c4f883b8335f4d511e110350db24381637c54fcf81cce79c3744739cca361585a0a2ae4a0cf9de9524c8d4633414e366d9106c104030ce0bb90f5e6394371a51afe0ca1dab74f895840742655cf48e5ac2076ecdf788878ca10dca12380f06660682a0b5eab3f901fb8fd1170d9bbe6c5d6d9e5cd7e90c15d86300eb2b1e72fceddc9e6e178e276db3e459efb9b7a7b347be4baaae61366061cbf55e3cb1942cf827fc26760fefc8825b718136fe709826fe3d8d290ddb157615afa573528e530186b0e0c295f96d127cbe5e0644dcca4fa13a88b3eb4e2c94febd1b1a2f6c1dc4df75250351c416d05bf8a4de11eb7507a304179b4d5d98997ee18014981d94e24594da0aced6f11016ca4838fc0b56b7c4ed387fcc0e61b28f385828ba2eca94ac0aecc76042a2c51a0eeda907a51180b537fa23d315140c4d9684c51b5410a9d43d03702f6ca7fb9b01d00701d1bb0c6ea66724a6cfb642db5f95ec26de551cdca8ade4a1b3e58aacec6e362385cfa2675ed2d2d4d985ed76283a693d901bbd7b0cf0e29c41e006d36161046465d1c940ab5e05573e01a0095d6bd1c5440ad657a0ebd9b49a61adc4b7c48fba162b92c5351cb618939d027e7f33d198e29a8475f2bc5965bf5a65a9b9d4879d8f4f174819b65b035ce8bebb9062162b4b561deb7be711c9aec3b6a6da1fce28e5c6932a9bff68b6d91de2d643c0d046785fcb8a6a4d8b1bd548918674fd367b2e120636fc577da8b2a63d89771fa14c4bbde7921c8d6f81dda4c1ac57d60b9dc833d23b0212c54da130eada659ac605baeda5f9615b54764b4d9d64c6a3c62057e06ac87fd68980917d885ed6364c87e9dcee1e3c9afe0fdc40ab023a292c26dfd44e6bc7f974d1acfc80dcc5c7050d78fc70f67ce49d9afc0254d3da216a0fdf486b56e9a3b57cbf65b12f34771e57e3c54786b508c1103e7bf5db38cbc17e8f5a7f794784bef89f006f1d2442ac6b26d3d66f62bc3c63f2cacdbe90bd40bdaa196d3fcf3bc23fae858884ee265676791ab406888d9a6a7c4356169ab0d9ad96a022bf5d925c6f1637a57649a45352349759ccea4e0730ab88925d16c9e49145d8ca8ba2f07a7f9f46d1de90e2b1423b53ab8aa11837b6821a99aad2b745b8f28a181ac5f730f11d481bcf8d9dfe82c5af20da5f22a6c4863ab9ebaaaff446cc58eb1ff5aff6f3aebbb05e09a93315362484600ec6feb641f09a4541b45c2043758f5bb01dac4f105b11d3e5560b06541716cf6ba10c617ecca595634246f0f375f692d26dd2f76ff58b8729d7ed5c3884702e98249d20958c03a5a288442089a002cd1ef9f1f7accbc83705b0f84dd2efce89be9ff480575aa043edadc7709829c9331225e420095a7c5634da14b8cfdd0fa87d8d09376b6e2d175f28c8f6a096670be08cf2baec93dfae9eea7743b70bae80a2504c0bbf2fe5b98ce5217fe47e0c8ced3f7f1ce89fa69faf8aac29a65bd29289e1ef62e94c9de0b04e6e3299d8312c2e7fe6e28895933245bc763c8aaec96b159973f67de45d9da6d4411c68477469a5b16cc39ee5ca8652957a04f39393353d3af73246864d74246a98c587aa8e61bd09f0814291108fdb511fab04659dd0ca02e147779d9ab2e8ec40b31ddbf5d75cd589ea05d2d2e222556dd5610e16321316b10efa3ff07e7890f57eadb57909358eb5a0bbbfa262782a5619e2ae8371d19c1e7063f57481e0abd13d096bc1dc4cb971edc046e786e0158054ad3af38713bcc2abcc66e92e9fdade78c022b51c53b27bcea169d1cb9967afe2fdddabf6c7445fc1a5d723e39cf5994fe30edf4f7cbd0e7521dcbdc97961d4c51cd50456c4aca3592e99bf81d710972b475ae4213c03674c47f782384e75a5a69193602948aa82b330aeb299d679777411f1914f3e21276ccf8474360a7589b2a4b6892f8ddd1a55970f620e3630b7fefc46557f36f838c4ae1ccfc14a4fe0265f100385a1f7257247b95124e53de3988a2744c79dc6ae7780ceaff5d07a47f03c234b34cfa8f12620464b3cf51081fb3802eff1c9d40bc8e3ed4d59dfbe1c1e690e51294bc4f7d41131a3949dca7c33493defbcd857ae603d97a77d6807852ff30a6413d4519ed6573e1ea0b433f5d38ba551bba54486858f3798a034cf92cb2960449197a7c093d3f780d0090a3e0340ee352b33658a85a61fe3376e9fa06f762d063f493b1d811e7cd1b76ad85e7a24e5601b141d6678396c93790df91e4bdce7689d492a4025c2d521edef5d50b8c5112c7bdba79b0ad8b8e4374c87522d79330fd2732df22e56e76aa1df629ba2ed800465808835b45783ec7229235cd21f838aa96c80eff289dab4fdc0fc80a1a8c950b64ebcaaf864e528b927f336d28e793ca0f36ae55172ccd7f5a3107c36c303b203046cc16f90bcbf8c315c6d692d80751a74e5a10de97cd1dc94a4275f4b2893054253717bc044ffa4ddcc03f023344760d29214de8ee7cb1fdc032633d2e8cb47132376182d28f8977eac86ff70f81cce1f89a51bfdfc7d8194efd6be4adae80027e24fa683880b905bb513de4b3dc2e4764207217adf35c347da72bb112980d3d9359e95d5ee998d2711ab9e3546e897a14ef906a16edd3137ffa9a28d26dd27c0401e75cf16755d0cf6284b122b6a1cc60fbdb537fe6729c40d4e419a7a1a2b0023f67744d931f14050cb22cb2feb196c1a8a0901d3661b70390f2b4ce1cd41ab1a1934f873934af362ffa4dacedfeec99188c2291e5e934f24e8d5014b1ffb399dcece2c934eaf21626f94434854080a94a1a016d3601eb8af5d2a6325757d403d19e031e9b4b8db1066d29d1d47b67f21fc12a13ea93cbbbea3f279e5a1ece0d86a9d9ef3a27c4398d64f33e6b9472b631153541765c259ed766ef3e516eb434da13e931d26ceec75b459acc61dc2de4857724185ee947f52e00e660592e3601547ae061050b1d6214cb3ebde1a275b7c382e964d7f0993750103b4c5574ff66cb5cbd2f41e3d6d96225c7a1120a5ebbe0c86b21e329f52313042bacb6bfcdaf9e7b2ea9623071b0a498ba4b0a058eb7d673702c13229e5cd6146cedfa3f1be7a2d7e9b8bb714ad5ef4e306938355ee5e58b108f38bdcbcba339780ec3dc18d67c29a226c6480f6a508642f0c0705fb12e88eab60fdf85cd02e96638960d3b9c8ba3b43b93026a931009bcc34cf66b7a37a39f9bd1cf7e0cb1aa8ee0ce507acdfe92bb0a55310996bcd330b053e8598b282868b57e390de797beb4b135df526cb7d4b5793ef24b4cb5dcf8d70a39b9e9cd8ed3133b99104a8adef4c4ec9ce8d701a59618d8ad16b79091964302df88337c52fc8b50f3993437635cf45deaff998dd1afa6b439eba30f72afd526cc1e4858f18136c8fe45f14c4f95f717b9a0fd62d4c78c612c4dec565e61a61a73fac5681a6181da096b351ec69dec7a96c1b8bb6f1146a1c5533d39a1227ecc63d800ed6435b4f98c645689030e4ed5847d6873af9dc12efe9b353107e70506c60c508b41756ef9279939ce52f272ca27991c34f7a5baa46e0bf6c37e6df6376b5040c49d8c04eb52a5daaeed51a40049c4011bb02be0341ec25b385e92fb11e0af74b4a20613dd0e40d476efe9dea2f0df7c7a7f3406fb2dd79962bd4592f95301ae037ffc82c311ab27436963a870f6e0ba300bfb79b452de55306233e2ff25b908d177995985ba673bde3e653f82c7631c63983fd6d347c7834ec6a81d2b66d399a976188f8ab491810fddb3fe51e236c1062064874d3111bdd8fcc897c8f6da347342a9e8700ab43641f81a3107e42f9261898c6deccd4ac0693c91e68bfe630f50013c2e31c937c87e161b1237a9fbf09dec3815d9fcf31ea5c61a423195423d06b7a3ebf7184c81b03c4d2495d590ff5722353ee7fea7e7c6a28e51f3b25e58419a0b9ed1f36a40b77ea51f1778f05c22052b245ed1f104115b0485f7913edb28952d98bf1ce6dbd4dde97c58f127f75b56db3b2f8a178b670ba7a28afa9ec2038d70f51dc1d8bbff756ed0813f32dcb8ef6613d4c3206102a6b0ebd150215a8d79a465db1ee65cf423759daa13787c4c1a2f8d53f94867e9f979e0c8815e1556691dfd40dc744ab021730810a06062bfc857d7bacaa664680ec6a8a927f3254d69d93fc65ce087db52986ae0479e578f5054822fbfe13e8ebc4e42204d1c5695f88fd4b68b283d22659e637f0d994144fa2efdc1ae957ba9f131626762cb67839e6d0ef04316425befffc2cb3f98ca1d0fcaff0cde5684a64d1f19dfaa2f7503345a19c95fd301e176b7a3b036806766a4dd2db6b1b8d9cad3784a948dd8e9bba61fa71412ab1da0bb88bb453600a5c0f635f8995d406d6ac0d6b7c53fd1248b3e78b225f324b52dff3a0716de34e6423097a1ebfe1bd2f8843438dded27994133a92d004cdd8c6408e414659517bc11a507a5aa2d3f9a531879d7ad05d84434c9563d9e509cc53e9ecc1c4677ec0e8b912410580981ad7e6d4bc2549a67a044f945a77a2ba2336d3ab373461b6ed014eb3868abd0234ff322d03352475d35be6ff64a1b929ec0eeff46a83c2f4b9354779d2c4c00b4153bd1e119c57513169f73ac24a87e18b199c4ae528d4230fea0fdfc3801f936cbbb806d6f4820deb7cfa0f87286334d7fd26859cb31e23a653042443f3f35eb3b13f78ced657b4907cce730ed932fae9a7a688e13b14eb72c6708bc137e66833b49e1dd27e2a9c8884dc732ca7aa7f72abefe0f146fa9958e4c136800ba1fdc4f63633c936207fcf4a7bc0fd448a1d700a05ff67fe17294d481800cd54f979cb4baed1db95275e965e9f3a64543aee9a92f355dae8f6dd2c96cb28126a40ae1697908b380b7bd64d52c7bba8f7a1347087108ec7af1a6218e1d8c83b52ec89a8f1f5922c13c42a3d4f38847e4873ca21a5a1b28c53f7e5691c0a2b7752e023619ac90d118241aaba23ac2ccba296c70ea977a420a419f987e9351107b8a2440fc05657bc77f4886a854240f78c3cc85bb43bf1c39e9cc58168b1c7c2df79df016a5090d89339d517917618139c7fb77c91db620f9243d7d1870eea2e8aa54a539fc5d2a359a867f3e739f418637fd054af5fe6a5c8106a9311e6d6a361f45268bb4681bdc6b88b66bc9f0d8492cd21da0669ab0d5b625eaeecd6768115b1149f691d2c36d987eecf91f87de7610fda607f1473b46bbddeb093f189a6dfcfaef0b4e51fc0dfb8d9752daed08b5619a4c539c24bb3e7198dbfa470327b12b07765490eb1fd8687088e8863a13a7c0cce696f7d20b8cc018e2bf99c3c009bcf8329e7021295ddc774f2df5072991081d719d36ae2bf5b68dc3dfcb432ffed687a74fdf7b50a364fe84c0a735bcba696db0977cce848fd62d0d218e20c4c81b1b9e4ce27bb9ef6b86bb53d128c6ec48fc51d97ff59d7c4bbee55bd0555580112684683836e9288f180c5b61c322aa4aca428c4034fe934f291b86a69461d6a3c085204e15ff63475e29c44fc1008919eec1e48c7ef7c8ce0250db01556fff2c037b2a969441ff434421acd7e38fc2931c64290f2fd2e3fb017b4ced6d39037aa5bc0d85c572cbd557fbc71e19f81f6e02ed07480e18d40da43b3d80ad98eef6f40041bce3f4d4001e7e659549618f8f68545282c1c8a806e396bd19f7d78aec8bdc14694847ca286d2828673e2406e215845e39f996333188acbd9ccbfa2c613baf35e0c1121c79929828fdd08f8e9724b39f2949724d7eec24117b36fccbb7c4db9d2b1098e7d7b02683de7cd4145e5e3da85d7d657ada781af5dbbf364588fef21073928f105c21a994e5f06ba769d022abfca70afb3d1ed93728086bc86f0d4a1b15c120d26b75002e9e12a70bd32bf18056ec4c6486e0ee0083b97bf731fda4e192b4171edc46b499836e2ff1b71f05460dad40fc19d15b13c909224bef438c5d880c5034210dd0052dd67d7a4852e73fd5b5b611520506882e32ffdbed43d7d811177a92d30d458703330db4617616ebbf557a5c2f84b286eb83d2058b2522b8ccc76dfaaa9229e0f0985944ee4f73ebc724d9a6531456593e1c90d5782a852b48515616d07315900e2a7cfe7ab3e3b4ebc623785fdb7ea326df725aa7e58f5db8000f19e8d4193aa06eb0e83c1d07e867a94cd2e3a3c9f46dd17d6c398454f197354271a3832ebde441209c5785dec14d41f7a44e4380fc96d0d008607ecabd130fafc3c839154ea34cfa4999270d3df0d50349b68855cb76b70000a7c4ed928dfba4584bdc1e7b4d409feb9a339dc66c709392021ad5714c10c20129d28de29d2b5a063e8f9d7d4a432e57aacf242bf7f49f87bbe06d0a7ec94ed008108ac39782e17902246ab7e60ed66d27f444869bdab2179f84f6ccfdc8f8853ee694d0fdcbffc4c8be94405e49df3d7f0b8f5bb13ebe6b6c53173b986ef125e33dda350fa7c42351ed64fc34836bc477f1dcd2b9784760b896a06e3f8672c21483924f2dbdb8ac300fc457378e615af7efaa8d43c7c57fb8ec447a2d4f4c4d5407dc70ccb72f14dae021ca6a6e442477851216f0af6a12fad26925238185b64e5f5f2c9b3362782dcbc677bca35be057e0d0f5ca835d160ae03e834cf44e5ccd4fb5ea55946085f3f5e0fa231d8f27b0ced953a85e13c28c0923434fab57c7fb379b72f4d9c2dbac830eb140dc75e9c89ae42fb6526b0c244ceb520fecfb09928bd3d5735ff72336ed8ff98e582fda702b904ec631d516353548bf286b7362a693d570f2350ce4703d8c3b273826d93b3ea65f0b7d9e77eba4695ccb3f61278416a33b7d7d3b3f480b0bedd05949182085b248d311d56361476b729837c7f5dd16c301176b778db4142c6430812220372222d18d3cc3a338ace103e9dff7b1c4c46e37b67ddcd4299fe5cda9c504247ac0ff3a0b60297041adedc24a2c57ef8061c1e57b9d052a6b288e6cb09b73ff34a44385f64fef82c91223555c7f4f7cda48d443c6721b186ae7561ef79b94ceb29e22c607c97292f1bedecb47be79885ccb53c135f131d4f52fe28eaf7d6d6e696554d79a3c18611a5c057ad0dd07840f539d607c16608a65d245c0a2a5c41df1ded57b0f7b86d2d2cd2ad736ee4c08d264589f2fc17b5e378d83112c366c03f6ee07bc5bf4bd7ff89f31d02a7858fbe15edb2832a078051c3af909a311dde0d7271e8bf308816f919a84ffe868e42d0cd834abd2283542aff842f78572e9e04453d110f21144207a3003894d91264905b3fb75eb30740211ba549b48c9cd428c1e869628a3722110619c8e87def1d27325ff5a481d456ea9ecd8b9e4aadd3a22e83d42d35294b924237cc9fe0c8c11bb05dc52571ec8e6d74ffdcd337eef21a579a9d84a8f914d04229eaa61496f985dc5a33fe85590a3917039c8012835d06015d62b53aaa64749bf64247cb71fa70fc703f04f1140bb29e560a66d44c8e543819a4d8a8641184e9b8779019f0a40d089e1104448c04504d14ffb5d4226adc76ef8ad62fdfff841b964ae4b1365549fdaf62202ccaf417f4f175c89522163dc2ee936e8e38c5d2e28f607e033515f60ce8412a8f3c997b839c11208953fa11fc521ddc410fe90bd2cb6096b2daa33ac274bd30d7223bf79569ae23ff32136dc09e78224e97471cdff092f3a2bb0b36cbc7fa7c5638e141a18ee57aa55301539f0293f4aea717f95e3af9323b753a4c309525f04d4f2e2530b264f5d2e7defafb6e42d48033074a53ab237477c34c357efc49fe91b77cbe50bc1e9092b283cf84c9e3e3269c16c62b5703d5db3f2e6f2e32bd3424c0139c974b2c3ea716f76dd76a91f4b6af3da7e4f93c278a387a30b5576e5f2a3a6be7aa03d7ad32bf22e319127c7c8ba23757e401e0a8f7878a035c0e139809e2d5976519498066dfb032356bb3d22d6c8a2f5aded1baa5a903732f0c8d8604f1c9799ec85c3642272a604e2247070b1dc6aa89cbf3997e7be4cc1ab50e2c6c91338b1ebba69b84e12f31b3b3553ee9ac81a685d328d6231b673222fec1b39649472b67aaae3cbffb3919f9bf609cf29f9f63a18293e2d224d33f8d9b4937a86fab43a82e51dc8c303a82841e618afa7455bb6f2795ac6c24f3334d0baf9ac50eb76bf8ff3194908f0fef379908f9c733e3160d60e6f598e96f15fb88a06c6d133a67fb26343bf16be757cc61298a610f37d15911743ece6942c3453cbcfac15c489b9dda95a7921c302c1daa04d42b6edae6447bdf574aeb25ff15ef05a7ef3899942622afb74ce4dc5fd5349fe5562c8502b9d08acffaece08384f90befab7ab7f67bd29fe5f3b6129ea43579c61763fb2703bf6da7eb0cf64a334951a8beb8a66fcbe0efd5532532bdcebffb8f47139fcab3c58b3628545771848c24969198d640d0b538a0be669f8c7049e1941ab34b9cd315b01565adfe3a28c73ba6411a493fb962552431503f1b52def5e05ddddbdb71ca4f62899975952bd7279b61432fe641fea9079c3b3bbc99d631cf5a4f9f7ae8dd710f810f1540f3696fb4d46e0dd541aad28ab5eb2e7fae86b76a4d997566f735fafaa6f9f43a0a2f6739b50f7e86178d31dd2ef9d695c7506a6d2a77cf85cc5e848400cd27d61b613dc8bed5582326fb0e263d3acb38f395253085ea7c240fc90656ed95398ce9d12077046f017ba8e33d961fbf044a7804a879d59c4450d44d685377a8763512523b059b239d72b1a3de7c5ed4d1409d2173bef8d129104f9a94aab182c3111d3fa1c1d919be36502c35d782e0bab34f06ce16900e31098f0a97d9771bc38cbb4dc4c4f0cecbc83a0e7077612bd445109e04ec8fe026c5f8092252c2d534813691b674c22386f2cda6a2364a6a02885a5f2b243ea294023ca447b099808cce11ae2807012c2bf2e4730d5cc75f8d1907c71f163e267c770f1f6161ad31897c191b7b267fdd1dc38a7b62631b78a479777e4b00350213d7c764505a92cb87d146e7ceb30d94d18f76fc1e6fc52bf37453776784156d0cce5f8e974fa5a72aff32f63752713b1de4b0022dbaf86f52e51e2ec0565169db9b7408a8f5292cb02410eea75db581614640a423b202eedb70d2304dcfcb1de036ba257ff8bbbb51ee72d694a1ad70476eaf1f753190ea9eb3d95ee6aabc3e0103be2edb33bf9682bf4cf1928f6f3d9f09f02b177b51feb9527366e959e8843e0f89c128b98bba6da7002780a643ce3ab71d1590a74e69e6801a73b475333dde3036bcee628592fcf8da58fb8aabc3ce02d68b9d402c70fc629815a5d78e204bfaabea4d926b382e53e4e4d57fb7c632a5dcbf47512346df3db8454cc30381f00a486d6d8d2db76c1014bd5cd25858e56680f5b5121bdcf94ee36da7f99ddc43adef4fb4e879c3ecf24c49afd6115512642719a9bd46878460f451ab2bc439b567ca394f1a2f4a2e5efcb2a3730bebfdab83f1857e43d45a907934716cdbe982cb9c9ec3683d9200077d16217e2336d370380485259653d7971a3d59b5ecf96c8d55b45539e478570ad30a650f79e3194eeb62df11bd569110b22ed8ae0cc3b920b8d11cda333b92d079a74af000dd356e9089fcb51c182adced20eba0aa811a9b56b079deef4d1ef167b46ae45faf4c6cd21c59dd98897c5902df7d273111a5002ea13f194473d4f4ef69dea89da904d3ad0673f713b55c037bbe14c9d9cd26cd9dc7de68252e23ae61a9b983725f18ed6a1f344074ef60c84ef1cdbef2205c4da75c4c8f3c924033f046d44ddf656795addae4f09f4546762214ac3cbd1b1ecbb42f3f6e63e919751282a884c3c6447056c0fa14b0d5a70fb46f004a46c62ad7c928a2b0ad7113e4942bbe8395643dcb026bd02d352d87ec6ce3864bb831797e26e8e094d237d6e8601baa265abd01abd0fce226b3ee441745fc0001447e8226cdd3e80bb8fe9420f744417066127f6d44aed69120df89377200cbdf3d05080a9cc370d80212db8a5cc1f2326b44143859068565bb316b321d6f6c12bd3f5dfe7b5948505abaf4a918e57403305ea899d99dc355b1b4c6dd741a1c9ebb1be219d081f22dbf43d5c965cdffc2b381f6242bb0648f5eeb3b15a1ed7b75b5c877cc26524df3ac0b61aca3d1bea2e77134d5fc8483fba9192a30f23ac4923ca1841ca304976aeffd5d338fccc79f045401bb4457c00b12cef276d123e46970d31ecdd276f02fd381e208f7e190644009d8d259fc2bddbc988777921bdf4e3832c39d7357c1c49c98a180cc1de1d28d2c30f3bae95dca5145bb33b40f81b8c2a35c96fe7caa2a4d8960365723cf1ef5b697427838d1e676d9d3919bcc723e307c00491aadf7781d562584138815105d74038f25614bce40634dafb896b1b7f1aff550254d6f1071dbdc605af855fcfcd6c88d125707dec2e2a2c8f7d259024a299154d46803214649110ee35f6fb2b6a39719df101e093d253a9def3f219a58a87e59360784cfacb9a8dd61f8fe6feeb37143e2def9d782c4f81431afdedf52a871bd770fdf5d087a984bfba65f2bee07b2f422cf76ae763903c610d5c97a6314a189a21bd600b1a325a09c76c99fb95a7c2326e62bb850088bfc90ae21fbab4521730e4b10f4057d472f37b0a2171ca21193e137fcdd40ad628d6ff29c7d33293600b3d0d0a77c019d95c78f59e002c4d55a0e66378f6baaafee1c9658872bd1cff905c96d001702a1620b2428b1a85b810ed7c84580e046f21cf3cb75a8765886a223f47e70613d9055736a97cc0f76c4c591cf419be63f80b818de8aa5c887c39cd628d1addcfe5cdbf2ac8bc06332abc7ac50f86baa5a9054e5f8e35ad4adb348c4b710e03d2542337255d26f49ce5123e2c257030ad64ecb257607f3a1179a8c58f07a467539c20a84ad4429b8c1e5a4efede9ad5abe645ef97c798e0e35942ceea164d9ca21ba1df6efce94cb00080a1ad74e2d2927a64649332950746319e4fadca6af2aef07c903e8b3d4cb8133ab578a6bf5717d144e4a86e320ecea62e3d042cecc59652417d35e640dfccb6b837ce5dd4569113cca3e22fcf46f5506bc5e5c0121a2c974a27fcace499dbc215b09a791755e202dc5cefc0f0b6163d4c2f0cc9b0fcc9629c84bde419cbf8f99bbc1037e491ed1862bfc8b84b7272f2c93302ddc3d7e4ebf0ddd168bf7abae3d62685055a2a5e41827eb2ca5b4eddfc47db0945522de0849de0e2feb8ea18be791541d538dc56cc480a221033dfb6778f0e5ff9780efc026057a88ac2e889ac97d49683bcad44ff10e7466aebd39a814111ed6363a5e386611739fc00a1f9b9db5afbf906d8ea40950e89aaa4c96cbbd8b16d9831e961848dabfe361a68547c1d1549e51df5cdbcee250b2f93936a9ec5a8c598edb2ff50d517c56a85176e8ad8578c6c78d3da7301042bc5269eba4c171870f34e1f6b42d075ecf2cdc1578043016b6ce0a4ff96b334ce627cdb0f38eae1f60dd709c762627bb284fcfa26206e3549911fd5207240c5f1c4260138b9fd8c7bacf8fdfaae0cbeaab7f43386a654aba279c8866fc237cbebb1fef382345c9d3f3a3b0905d3dc9fabcb41b2da12bc4492a59dac4bed4122950b10ec87e173a82bed2b113c2e70aabd500f684139ae568b9809ef5ada0ed31b77b9e60b1a941a21e469faef28f57d508032ab7cbf9c0ed35ca646a9a54d5dd84c1702d032254b78b36d84b28a8f7319b97c5b0e7938c5f63e8dab33da247529dcaa0e80c0d4ec6c9500d1c7ddd9afe4c4ad0038ccdf3a84d571e8dae1a44f3157c9d99a300be2381ada5a722bb7ef2161a7c90239804dcc6240e346cb9aeaca1f6561d3449d95f523823800f0fd82da0940836231e8d5b3be3f04e8450b9240e19f5dde34ad77631af3939a556f7fee6e817125d40a595446560e2cb1ce739a3bb9b2cc35b405cc85bdc2683fcd220b7817a8463b0b3f458f2857f471a906998e8e72bb29bed74b41a0b3c8a16f1d862a4d3a518a760f63cb2d2b2afb750a2639fb33c8be848c2e7a20b12817273ce7b6981660bbad2fb78c1e664c53ecab57de53fa92c14ec15938ae602027c46d2ba264a658787ecbb5865c3c91b66dccf663ee2f02070ea3de548d142a2ae50c54b747cde3aa1dc1fa1b9e92a01413466a872633f904a05d27d500b697b957ec84a1fa6882dbf2c9c80172cd1c2791b049404e99a95d84149675c74a106e983ebf433a24cc5fadd9f0fa19db9bf8421d4461af900b717523235df4de371dac6bb3c6e3a7fd8915d57ad0df644651949e27a756f5b8618341d227aadd2631647efdf7d220e8e3c67a65a1fa529634ba74e1d980fcfacde73e5dd926c374b631dd4bad3a9d88bcdde4707cdbe5bf06c7d332dbdeac8215afa5062b1b9bc644206aa8c015ddce2ffe769f1ab941a3717fd0928d2cf8682bb8f950954a98ced4816c746efe28ca55f09b076311a08acd6d6edf1caa7972e4935e6e726a33b896b2598e9df1875003a50576ea85f09ff96c2d42d39741196457e0ef70edd9a9b5cf5832f32dee2b529fc7bd50b850a935c97c4d04b9c608fc32da5924623bffa1924967b49b8d2dd869ada3c53c2dc7af2eaffabf3e79cdeda9f0db238fa3274b513ee108ffa52d745dab9e8df5b2e082b278c7eae937527e0ef4531a456e3803ab2e109d4666dc1d2bbe1c6067907eaaeafc3592cfb9c7bce0d3d7feddd9b7e4f7c150b7c760850e511ede4dcb0bc28cd3d1c93b9ce4571e89ddebb21badbf73445714188ba7417ccc04171a9539cf3a5ffeb1e9509a0dfac5693372bad2c6d1c0dd917dda7ee130a718251619de1b5ac1455706b05d388159cfd40b4a3cdf37a3e390aefabad4fd22ad12d3fa37478eeea5dc590795d8651d0e6c29c2c208a4b08e2d36b9f5a30ed25ca5567f5f132e13ac2ff8a187a1bb06db9b697d3215b57d7460882b58389295d911e3d79a7a4bec7d874e94c39c0b627c585b12d52e4e95626c7caece3046051baa1603f3f9e7b91ab9b63575d1bf4b9762e0b3eba3df8bc618e7f562be8ebfbb61e5fd6993f8ab1b9e9e83f94ece23aa8983d295c324ac73e84aead2a6627a38228c577ec98bca5ccc64a8af547ef4c4a159c27f33e2aa16d5cd43d50e1493bd1934604716d39486a478ee6b8c54e47ea215b1e5be81b3ef9ce4eae26f2604e059f213ab86969c9cddaab9f5b629cbbc8fc8c60db1af93dea71dfb5fdc527d89fe65d53c268e078d2b5ed608d717f91dfeef446c58a707b11a2e771cfa1d0bd5e51c9db816347f952d40c00aad218c18fa0e384e04b1a8120b9099ee0020543c5f51ef82b3a55f8f2bf6d84f7cd7613ab6d89ec21d123433726f56d84d244895adfb282cc3fe776926e5f3cbc3fdce3e2fc2abe4681a6a61b25134714add40ce486ac9bbf169535ce867861823b7c8d37a880813035f322fe797746b84b2a1922765817ea6c5d7b810c37e956f1cf780e138c2ea0c4b142ef779efc4f45cfb905193f58e76a8b195d8c3e64642908776e650b4032fd42513894a3becaf983967f4e77cc1f6034a6e71b0154af7795639e6d76960e85ab50338a9cd10b2ed56953597230a718f8b20009db7c40a58739e43d04c6f749eac3d08b7af8ab8404337e6a300c98dbef9778b190644112b25433d1b9734ed0264349cd66381b0d8cb222910a18c776b2d8b74341b74413042694b843296bfb36651e41cf70598bd149ed06c1a0e1412ffce864d9dc8785362938acf7a401a30c634f739a456d90f981b1c4fcdf54589aba73ee8c2d2e59749f2691abf91c785bf2d516207aee17d5d4c851a10fff0070c3b9a42834f68391e241ef0129d706133df9f3823bd27e32e3f2bced22f28b2773c0c549c819306579ada132cae030506cd827cd740eb3b6ba26bd2feea26c771694f624019d396658a5f22877490168984df61fc1d73cc24cf1a17edace00c71f3e19a05251980f9d44890b220c1b1010fc03d7cf29c067786ef6a3404f7ba737c53b6a949f96b54ccabbbedd7b60d8aa726f0b7c69c7577161426f8d2e5cbed710ae543f53ba1e815122cb916eca534130149ff787654babd34b2dc39ddcd0654d7da193a4616a1539bcbdb82bdfaff5e875800fe9499a731c2264193166c05ea528177c1a112c3d867b06e4afcb69a346857af74d543fd83ab3d0d1e8863d9611c6f21d271fce2999024def9c6930f3de9f9f4d0b55a431a4108e28e9d2eeec7a7ab4fce386fa8787e6afc0682671170c0d59992a5ca6ddc9436ad73ec24ca3aefc051d8ff787e931bf468215d09fe768dbc8018446eced7e6d3602291fb24adec3e2b7f2657715255463094c7c30d40f4312a43c1d14de7e8fc9802dcae5eb5b5c127252cab792716fdec9859611f12c923c351b5f4d63edc9c96539646a29db596079adc9ff1d1ccaafd2843132b189a251482ab536285c8cb77d80457902e4e49856bc5bd0c24e223186b8b26f780504c8b47e89328f15abfc6fcac3b1518baf29db7817af2a7727cb695ebb3fe190e8d27bad389c66c3739677c1356574ec9cbd6980af40db7691dbc95ced05add0bad05875f532cebb81018a737154d55d3920737e52a2b399a2b2b3725e40efeb320f30af9534889eca020a2327c56d3c0604516468258a717e7a0b21de6c8a2cfb4c1654d6392e0cf33c5c9c7a6574a2790d11f4188988c2e876620286efe0c410fbf18f6f177f69c23810d4ecab53ebf9e23ac7026c7ce67344a30e484232e66cd6703d0d728546bd8ddbf37ec8197e5bfa93e79b9f3f4b81075cb270af953acbc0d270619ab5ced12b3f1be1d76d22123e088f77f4e3c1fbb2a07f145c3b29b135f08a86397abd03d6f90c0a6f8a825ef44fd0caa48ceb507567b375c6a3c6ab40e8f10772f984fce13f508c035444574aa477205435297bbf6d13f0ed8e8591cef576daae73751be3ceb4bad0fb61e0151977c7aaf2646749c4fb4672e9664c91f8315fcead2e2bc483428c01cf2cdb18c1915c470dd108420a8e68ff105a21dab46b8038c768d4e2876a7471b2417634ce154d2d5211ec1c38e07bb11cb0c8ebd48189499ff57381b918feae54dda8bf031f3ee786b8796d3869bac0ecea23060d63327bfab65285bfa964a28924a70214863b8d7a6f5d7cd75e6cae2414a03d06c908e34f13fcd75a542969aee696ebf9a3f8c18257eba8de69263b0a93ffef52e9b7641c91f367dfe56defdea4ffbdf1c03cb5d0a541626a1514e3adf3f72a81badb7cdc366bae331b3931431dea99e61a22c25074cb8d3f0e8e0a5b03685a9f8b6d1fad24a76d1f7c34c0b685de700dee73aad150ff34883c38becf48da8d54b362e7aad7ba00e995f73ebc342b384a6624378a482dab395b36d65f3da375487ce81289790598cbca148a638631f62474201777d183eef87629fb2ebabc9b36168dcdc6c7b1c7479cf1679c56203354bc1dbb4f280f002265ec0877d2d465fc75ec614dd73a5d9e1765ad48d6abbb5931d1bf91c573f44f996852c8817a51e26bd4ef193a7388b3f6a51fdf53815589b2209c4a6f3abc1d48a332d2ae16f9e1eb2d5d0f18ac85bcf474bd52664097e8ac2e27d03a91018472261732535222a9394bd6d647818bd0dead40f536c0033951ca826ea1a54154b1d4ea53b5ce3c7cedc8118b7e4dea3bf2538db5f985a9e84513ea4e366b01523b1c8f60d462ce07707c13263e21461d32b11f5b1c041fd3d200d398fdbff02d77b2cb774b776856da2a1107424a74d76f84b9f560778ed9ce48a82767d29295ad870d9fc09b9f9d988e795c10224210592aa6f16c1ec543392b3eb6037a8c25ec1e1ef410db75312b3d43235adfa9b8a7022d6e75f88efa58df7dbf1c2ad77d7880b22d1a14262a47058635f4c85c6bf54d677e99fca8c951769dd2e89c6b6040aa60e61b99e7613770eac6ba834ddfb578590d4971e7b08cf6796ed31fd5b15260f117e8651fb2fb99f562a63a10316bdd1645a047c7fca7c1e771d2b864108056671543cb2c400d39f3549eb84841884a1107bee2b338ad6e25f1ceb56794652cdb6088d6b398b4cc472de700a12821d86d280956d15335f5ef6b0297d82e210ee631b30741c6ca1f7636b65a73a96b566979368f8258eede8a7e81bce805aa47a4f12334cd8a569aefc6f2af5e175285d424dc71f9e0a64c1831bea6a525c600e3e5b55ce4e0891aad6599dd0f079402b1c9c65c0d3c146489234efa4beb19f3d2c334afb8b151504d0c324427070f5bf7adadc29c229760f58584c5a04a53dc315142ee41d41aa0c25dbecb5ecb7d5b936605d349cf06fd52301af4b8d8b020272879b47bbd7907126aadf1a5e613304c184fc36b9cac79b80b2e7f8c5d1e7cd9a9c966c8f1af0425d6b56d0830187195f7b90d29654a8a819ba4d0214a3702d1107c514d8d8b7123c86866c65e2fb807902cbdd68ef8a56e846688144c3e247e4a554dc5ee93003181d9337d9cdb355b19f021fadc9f51969abd70942d4cd1af9d1cb1921e475e12ba5c1979ec3fbd7c61daccdb24adc30ea51ea15adca25bd9f794e97f0ec6f70880c90852d9adabec45b364eec500436de2624c28ae24be48d0a2f5948ac92ae154acf238f43a1e3eb14554c29ebd3f57a649849538ec98b9ac961f4b34ca74c1bb0379c866087a739a100b44db7207f3e8616a025902a35044f6f17cc0b55618feb25d6d479ac38a2c1757c4547e17d64b34f4b9902eafd9fedf41f367cceed1e06c081f5afa33f66267ff75d93eb8816f0daa121fdfcd03b42d058d56c39461f6e151f35f84c7a069ce706472ebe7ebffd7890fac69d6ca7a51518e93ad20657f3d6607b89d4b72cb4cbc8a6d55e51d25f698d4fbe5fdbdc2490c2dd538c606c6a5de5ec52f365887efe2581eaebbb686fef9d65788bfc56020aed8cf9983a121eb711d2410dba056bb25b89879770ab2a1b3f3bfc226b7fba7f5a06f9a111ff95d62097b461bf066d2c8a602b0afb650f640a6cf047a051244d1ccc23bed93f846d369caba51699e682550910d17b173be32329b63a406c7527ea96725e2cf95a96a6c128924a2ec41d877f21328db6b04682a2cf6ea487b7845eb4f3348f4a7f1f44f6f2296b250e75f540f8e6f0ec6e2f63236965b4a1a03b80d246a5e041bdeeb1f4bcc575419c6117ffefc4b7da97b77ff180ab7d42235dc5f0309ae72a61efd9a3f902ae4532bf7c2c85bb0382938a5ee697b5c08dd9eb2307aa1a92ffff1c7cc71974fd5078177b101eae4d002f9359c215936cc3237a041ccab7913242ef914c28f3998312df3c2b694ab1a5f7f1009c24f8ef8a0d59af0aa8ffb1d5af0e9a43ec710aa5556b159409242c2d963380ae953820a38ec2d7e2e62d7ebfd4d6d0dcaaaa367d738af15d3367fc0b813123d8ad3ee956bb3a29d4c6ada871917272b6c929ba6a590a10d61fdd7f83632d4a7630f0478460833eb833c06911f72e0bc00d16d61bd8e6368e0ff4fc039c8a9b0590381ee61ef27f7f8105b782e88971776e10b701b06f3d23bcab7bd51827573aa018c2ee3c27e7552358a5ea5addbaa49131040d6f9ff4664128efec45fb76e7778cd91e36d4522c4dbd5d65d28306c4ccff2ba724be845d51bb7f6712de463342ce020f13a276fd8f58848277855708593c33766602a2bd8218af1833ce852e895bdbf14ecf943d8feaf469828cf1236afccd4e6adbd3eabd9106536a1809b1879f34c502905d819b82c370e6905e4ddfeec4867cd133cde5f967e2c05db016d408bc9e4f725a11d383aea8e57f1653eecf8bcb3d98a91a5c196f6a4f65e891fdd2f0384471ace5c26d8da801d137ca9ebd6520690869f994d792f4db7bc48677daf9714b1b9dd1c65220e64892b564820327497094e888b1b115ab8fee73e35f006f384842de29ba7e49bafe4916f4ad17be7e7378f8f5611f027e0891d49089b2018075044ff0367946c8ed08984824cfce1b7b43c008403272dc0d93b7fa460c326c90dbb63618fd33a346eed00386737f3b534892e0345fbc4710d3ca9ddbabc73324126459014600a2392e31f1a088675a82d79fc45f789c0f0a2f140da719271a9d11a4c6b5283268264940e732786672aa8bc01b2e165038871e242f8e1bd39b8a425f64dc6692e01dd8281663bea4c0f83bc4da4037ecb0d47fcb40ae4d586d8fb7579ca387caa4098c1b6188cbf76e64a58372a8868baca4d0449094dd537bfcc6f1397d1ae6ec4d2791e4d8da0fbe11e5a541ee504b698082416dce1beb69e18ac248197271518050f4274aa03ca85916e082a17e155f5d819b13e11891431fab7d80faad4fc3ea468705d438d09404e92100cbd3a03a1513d853e4ae9dbaf23827568da81aadb0d306ab30cf11452b51c8f93d89dd4dbd7822e66148d9c8d1e35a5fba1a15fe6de80d7e740a8ac63200ce47432a74b33567548e753208caf56036bdcab2c628e4cb69c8aff24ac0b26642ac69ed2e57362cc660b2ad2b22dc025974471e8e43038640a0d4bc5f18e5147ed5f334eced672481f717f0119d486275b2069b1b570f9282503fc4fc7436a4aa1f87b9ed1bb45b7b556b703b514f75829da1c6fe78119990ec5ccb8f06ea57e3b905316bf5ea5c4d4cf10e70c3f7fc896e69bba0734485e6914ab31cb6676e981438647a600accc6407f87134dadf8ae315950104823fe0e1c91247aa9ec729d31e7b8a4c8c3703593692f85d1a3bcabdf499fe0bb033dd8f0a2d7124ba58bdc45a257c83ce130be88b8f7685f509552161c962c55f8b8cf5f40bfc445a13709c350ad3c5a68204e876af4c5b90eadbcfaa16741c2e566625cb39f45cf7b4c2bf9891d53205be2ddbed39f958b558aa9da553221c4cf110beed85037ac222fc76139ea61b4aeed28ee01db2c0d884ba99795515a83aeaa1e82fdd1dbe1656f9ff71834856b780450f4d7cb5303aaf4a2ea7b7be16f04f8465678e9ba29b95c4cc3c2d0ecd288cb0c67062374c385c3d4bc61bf4f33da078ea6375f1cf2a370412bf57597419d7fca84c60150576d2e64c9cbc26ec56484387f76b7e884c1aee729c622d7da90faf53c2c80eb4bf7cafc4b16f3efea4186a55dd59ed9039bee4cbf50c35b587c3151dacade8be7516dc89f34137e1627b3533087e8478732dba193f54b5919d4f78eaef025c80f8144e75ad5a450ac62a7c535b65e2ef868baa7a637a1e77d5174d853d4d17e661ca58562953d991f1ea19b235c5854090311c6ff9910bc177763bc05dfbb32fee0335dcb3338d4ff3ff9641caea6d6c967994101823a37de9f8094afbb868d439b9673268ddc5737776f599e6d9702e07b71c10618cec4fd533abd8fc2b60533eecf61b626c407b9e438c0d670695e0f707bf4e1ea63cf3343596519ed5659062a163b7c2d9c1d93dc0d928b212c67fe404fc3c83616629c0b4446d076b4a6e16d876326d412753c3b17b9edd05a0f75f1d8f8e9c55c6b8d2ce712187dc5764061e0eef0392a4ace21c207ba19c4ef26c28f72e6e3dac321d072e9e474fcb31bb9d559a3fc7d90444487ecfe881234315aca04108f9770314458575e9445e46486614b56fb8f606d2a76afc36cd2aba9529ffc30479077719a8aa771a3a691b2be8c3f0915b223c7aafed1e6198337bf082ec4282203683c05d7c06aeff70e57a439dfea4ea1101fa78d1d5a8c490f042b707e8f414da53a02e0798b0b725788c99d0823a4d7198e5c94630b1f90feda0dbc77ccf55fec2d406f0d6b51231233c8bb5dc420db306af3dcb598e44a1a0b3ba79dba2eab1b73771ccedf54e30d79629c8665cbb188fc6dde6fa1e0eced73a3457f85db5f0ce41968948e9586df78b0e94cce946b3269bc20a163c9305f1739d7b5dc966380113f992efc7afef3ae1ccecfa535ed81b4cdb5dd8b259bc9a97034293d43d3e7dbf3fdc9dc65415beb8d1c0cead9e9b996c2a74bd8361cb8012ffe9db5cf59e28ae3ad2de8ac3a2dc189e18a4783fb7304d1fdd6c87f69ec783082a33940eb8e8ddaeba2e9d7ad3eb8f5c335dace54aa823e86ca4ea978144c0778edd8f084fd650ea6b68190fab6e55f0db3b9c1103f2662391c342aa7eebe606b1a433c056946b9394e7c9a270207fa60703809bad23d89baa2bba29e907d59c65ae4b32ae0bd0a47a23ff1e4f21d294ead96ace0e5adb138e29b22257292ebbbcb4a29d56f12fa304acdb940300016b2e63cd4f12b40fa59c914b5f1a676f7bbbcbbfc034a99789195a958dd9d2e69a7e31163ccc3e17e951d50953b820051aa2038c45e04165e18c0a88dd288fe5b6bedd64348b6047aa49246d3952e4fd34a20045c267d0a20e0a4f456df475a576e3a2a3a103e3cd994316bb83dfe5cca851cef1712778595faf5ffb1cc627b259269dd351ec2cc22ccdb8fc83b7533be4b8634f2ddf60e1e27d515d5e831ca9dfad08db21e0f03ea35a98d2c6b8c309ba785dbc0745543bdbff994f7fc18272050de4b19c961e73d381aa064adc7b8fe094691753502be032596e97d1acf3c273968a61818a8a38d15b49f28995d1b6e17ccc9221d0d7eef985caa5924d2f96bc8742164031507a3428fafb223a767d93c436e4f0fafb72cb4c09c9f94fefbeb802f38d8555dbfa1bdf9ac71f2b0706013e8288044afd3ca24536bd394b3d4c28e9e92282c4deff241730acd076dcf32ef5065c525812d85d61de631b6dbe3599187b99c6fea5bd79f1445f2b5875c5d41fc1706910717784df5f500a9d9ac5a157ae248a0e36ad1deb1c7de5e80fb9e01630dcc8a282bd6294fcf2c09ba09a6b7e440c37d45c8d62665e603fe15fb68c969e943b859aba83861694524cac7c2641aec3944fc3d13e761c4819ba30c37d7ee8944c62fe7a091aa673024d62df430dc0925a233a175975aeb27d1fdb44cdf3f5c086c719f7d88984cd0b8d16d6b33fb119f13227815ae60fb3c3229d5983b478915429fb88aa2e78b697e4accf65c4657cf31f03548cdeff4233acc688957d7432bb6606fb735ac0db5525194eb541a4c7649f64ceb2095b7035347961cb66586ff9f5496bcc59ed7b949e6a8603ff11d676dfc4649a271d1e00093b807b7d19dc96faaeb5738d26fb5591b6389901eb6304b22426937bd7a9f59c8f2374695b0e392665b4acaa1c0d422b32b9e9418848d87c197927fb1136bf4bb2529fde789fc4863ed3e1e5421a32ed5e3a9ccc49f980dc3840631e9153b6b02379f4534c4ea055b995dfff1269fb9479362547a30b59fac7b649ad3a5bfc840b2c8b3cd2e363071d0124c5de6769e39016b0e9ebf982c8910729db4cff887eccf90c3c8a8bd2b91be211ab399c36e162cff46f0df5e849048c10da8d85e3003efb31c942471ec49b1dde5b19a748639b0138005e8ccbfc5e27bcf8ad00f731aae7ce61e37aefc21c19029dc4e3fbacd8778abe1a91c3595b7b82de3bf8f8a8102a3cdd5b38fdcc6556005edb7f53a1774d928fa6dcc0e6864b9fa04f173a8427a07dab767bdd918706a81fadd30c0f995fe8603d301972fae5fbdd8ca536a633e7b63ffcbd442d0d4e098e4edd93c33abecc0727cff77977a4c8b314c4099713cc2783ed8442f59ac984f64bb9e869d3abe42dacdd64a50ced68f71d2793ca19b223773649d3559e7e3bc206086a910a84eaa83a854cf0c8c2b060a059a487922a66f6bf1d384820d6a0697a15d92046c8bd7621d3bfd7cd18cb70ba1b083e4c33594d9d4f609094ece093b7e8c5c46f38b84faa0013b2b79c9427e86ab84102c7b2caa13586c910447b26b814f5d5a22040072703e95f85b41177dbb2217883e2566609fdfd98a2d0605eb0a74aa527ca18e98573eda15fc002cb9d47719a617e37de99f13cf1f4037cc7c595361cf4bbc35096ca34a99d8713e3c11b39a5aabf236b120b502c2d7ca887cd40011869255037a3fd1ea265d9f8e83c1058840fa48822f41508748f6da5d13d424f85ff309a80eeb6539e332c1bfa35b7b737bdc0a9a6d2d4f319af42f9fe24ca74a8d30023f69538280353a260cbef20b72b12ca778ccbbf4975d1b5a9317423d44eea1fe091b2c949acef4c614c022561d30140d4e58a37ebb3e4edad49a6d53703e3b7f20ee9b0cb8f347658d7926fe16cff3b7ee54de6ace3a27045706d8c8b931b900e5bb2202cc3b57e5dd98e7621e7a404af7846d82e57d08cee3bd3d63505a580eca003615e7fd0c4b79443f52ecce7de801f1032149299250ac1611d8d4858a8f5fc2732af3312d7af5092ecc695c56420edead99ca4697e5bf04e59a11ee25e55c7e80a286eb29088edb6e7726732ea81f2ebb13d71749cee42f47fa29131099ec75bf6e4c90d6f876bfb51d845eb9835e755887faa19bca80278171d35e76151bdbfe22f1ee59e9a2357b7c4e76d6bcac0877744288a777fa1dd1ac792d9bde7194dd78d0e4d8084877aab26d9a1fb99eee4c0fe86b6ca03ceae280ea4e3f8f9cd4c77ae0a81b3eea4125b94ec92741d54a3375cc1a1059b294d760b0f1f6bdaa0ef22eeb3d9a6105335dfe9f3753adb6a3a60935d8bc6b145bc8f3f460cd54e9e7921823f644dae766eb98226461457300572764a1f43df4d6d650df2782eeba6c3bd53309af4100bae0f456436ef8086534f7742aad3eaef7497b1c03cedf4ecb6511afaf9d543e1d4e0b94abff657116550c3086b0c6045e2d0962b60630548e36440f969d4dc4e69af4233f9fa3cc7f10df5c221ceeae3d89e8a16e4f5381d1e74971f30bde4488dba5f5e24ee1c8e0c775159e76c6a11833f9f9e1a557ba31e3179d2d4b8c7c364902955bc95bf80a71efa897fd707498badfb3e2920f428ea2bfceb157d247569d20c87c0503c230a8140522438db21112387173f37fcdba187915fd2560ab2e53aeb2d5a4701ec696808275a80845cd6a306448816449f3006fb7c626ad51850eb30236c364c16adcbea9e61c69ec51a18e4155f46496354f3f4641a61885659e863938cbeb2a2a1d68b6abf4f5bc5152a5ee5193adb0c1a83b027cabba709b7e376f8e0e3d5ea66343762c8ceb22d0ca714f82ce33e245b370576758313b57a548d7b95501fa8e69cb814c99451dff7ff22f359050a744b961323eadb939f2d8de80a954b5c55b30b5b86d85434fb7276ca721147757edfec341d0c07f04f2a4b2f98b472ff5bf11c39ce56d120080ec8e49570e3fac0bb23c0d577e04cd3c04da6a75aa75226916ec1211e1d4184d84fee5e29e7422cfe496585ede5149cfbc85ce16e7b9c7204e581dd4e5a97dead83623c13babf256f73ad031fef4e5f705b08d5a29b3ce5e2aa707c91f0c1f15add6daa63bcd0288371c0103e18df724807481f2de9a310ec2ab80707ffced646f874d72ee71c173694720020560a0229febd8978f88caa9e10b250c37776d09d08fe3c5a8553563a05ab959549afe66c9ed787da32689df21a0ee02e61edf6c77ff0d4c20486d5dd3d33e8ff611b6aed755e103669fa6c71fcf1b13b13826165806aa84dad64328a7804b0580f9d0faabc8aee64ed7b1d7a3ddc2e4f95d1c9dce7d37fe14d3386bbf5b07d5e26cb75c71c6ef36daf82b65aa79ca2c293954870d04798aecaaee3b1b5a40a041d2c052338fff4c778f2238890517db0dffdd4e60ab22aa4c48e2f55032035c64c9472a4eba4dd036c1f7b3e19ed410ec5eab9cdb480939715fb9d98b15953df5dd950554de369c54413363137867b3efdc8a3319f0fdc0f3a5e3043b5207bd32451b9e2ac62f10cc33b2f94b40c31c6472419245e7feff5ab5706339d9625da1baef3187645cf125f977ec8e836b0c789453efd0f76e36b6539eb39e3724ad45ed76033459b003c09bccbf3b11869a382d3f033e8305c4436b31e2203961128439b2ba5cf56be811590cc5846afc1b07cde4c518e8e687ecb56694f1fe97d2fe0ac1fde27f4f7f6228f6bcdd34c098f2f74ad095b78182fdacbc335f7cf21ac7bf02ae63ba8638f4e6237374ef80239d9794cb45d651c9882cdfdf9c3beead4994fcc8499959c41f6f44d26837e316c01c04004ad7571fa3556c599e3893af5ce95a2e28ff505f66f14a7ca77439bdd048cdcf1b418e92ab5045e13b06d730d71ec5df2f8ecc27f7eb5ea66448358749dc091f84d93b310c5d837bc1dc498fd1527ceab78acc5182bc4e1b1d6bba0d9506659c2cc72aa3b52db6a2a7df0bedd3913b89062dee7a3ab61955d8ec2c61644402a9e7193699c2c4f32a52c569dad2b5bb73637e5f28a3be04b8e0f1445a66c653b81af36935bb37f8799dec256e44a5da7f0af01297d59bc9f32f225c90656aa97a6d9a8e3a6aee0a38c993ebd436639cc07558c86014c0cf3f5dc44786773383096cff59d2c6abc363e166aa0648110b1c65eba21aaa59406305a417fc084015d2e8c50a61e37c5768306279d1b41e075ef7788fd0bfb5eb2282a2960f85ee5d0e5103ad8601b2cf4c5fc4daecfbc396a930d43f0e3ac922e0531a79bb37672e7619d9b6ff9e4e198739e5555145b42b0f92de1fcd36f229a00d058922997391a71f94e3244952dcf8d67cc7bcee3e0b669c8499548170ef4473170fd3df17a53e83c0cf04ad634603f7c04a343ef500599eae38195d5d810ead6c82ff305c82a475afcd2c8e8d74af723dc0d85c1a7e47fe816fcb85a6b3692594141a224610d5beeea6b1653f980f25af8a98b481dc7479718fb50e360fd6563f9f269f5a08b3e64942d70e51bdab899b4815e16855e4183067e58ed43842c853a1199d36fa9cc3fa5a90e656b8147050177bcaaba77611e3373d43afce166e8dca1e422f2281e79bd01cd1904f9c9fd55c0fa372d67bbcd29776385eca9b5624a925dfb4c9769b3d18f8cec1cc2cded4bd972049a6f82efb206d52957b2e9c8739a90f06488d3900b3123c3a610aff7178629b69fd5a3230240d110fcd08b824ff27b7cd6fe7979a8be36007fcff7382e3950bf30fc0e7e03bdf57398e11bb3f448260f2f8c00b1697d5a2b0ed35b559a28960a66ad00fc8fc5d184aa4151925b23226125bc0193d5cd334c45355a1417af224a23aa54f10011fee31ed540b30eea4dc466cbe2ad91d3dece7491b0bc23ba44442ea3f50b779f77d109d64d1bd7d9049e9f2ac4dd45be2a225f61164f77b1eeb18373716b319eb7577171f097faae3ee638c3652c6bfb006d6ce79debe95f53b87829015df2ad3f9de74eb6ca48c39cd8987e915ebf763daf37751a57e459dad2883c703bd60d2cae0ded22a942a91fab3b9f1a4403c7ca549daa49b62d256842c51f169279aa29099b7ea47a687eddf86bf2e210b1e529fa6e6c2d777d9aa1dc75d59433b59458e7084749468942d433e4fadd50959b3020401640bac58c93d04428fe63e8edf32f99de9c07150f69723d80a1e51e36bf3e4590bba3be57943c28f3c2d8a9092b046c9b916a9655f2ebad5b91c6ffcbdf0cb1d583ae14dd787a4cc476acb3c87273ff5ab7bdf654736f464be38681723d291f82b4a70588779b38814f18b37887dc45eca696abb6c2f6c512750c81ad62c8e0a5e3983589db0f817171b808fe2f379457c569e74847f126d5baf4c2686b11eacf8c9b156b2ee87db0cf2a51ad94d1c0ff019d9d064a272189f2c1d3f7789b5c2f0e6f675b32e8d585e8f26c1eca4d830e9d360873c7742ccd137cb19848127b5a7f8f8f8f05a764fa711296856f8a48e37ca3376f3a26ca3bec5eb6d2cd66b7b22caba3648442ae84e22df41d804965b555192955dc2a34d5d291e81857e2aee90cd549d346daac8c636f75aedb4318c942a59732720f38e9d3dfaa39bfed65793f31b71783170d41a491105abe0e13b8cb7cdc8b8c6548feb284979b6880b0f2e3789c24f9364d54d9a688cbf213126f056c6b139fa67ad13a421733627786f44415d6d9030db986f644ba16b9a95ca99131d31c0acda1ebf421c2f358c79f3928b994044a37fa80ddbbe2b19a38d0ac398516048e1571275d40bd9a014c7fb78cc735f40d4d94b16a3bef7e6bdee1710307fa133a75a429f7fd983adb9e50309db368ab5e334a836a3e2125152df37e63392c11385e26e7eddefe3133adccd192b586727117f6a1c248d76d1fdc6094af59a515c8f00a3b880ca215761835461ff0e4c761f68e4f5d88de1517b7a23c177120f638feaab10d0ce0f0a04f89afd7d994546fef4b5dd55bdc8b95bfae4aa343ad4f21c2027465acac257dbfaeb166e433f4ad67f3e5b25503100b2498bcc22badcb90e1c4b6854551b43172a6e604fe0a535</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>butterfly 主题</title>
    <url>/butterfly/</url>
    <content><![CDATA[<p>再次换主题，一个月前（2020/7/20）看到了 Butterfly 主题，十分心动，知道前两天才开始换从 next 换到 Butterfly。Butterfly 主题真的太美了，现在看唯一的缺点就是不支持 <code>&lt;!-- more --&gt;</code> 标签。</p>
<p>一不小心又把 blog 文件夹删了，我吐了，正好写一下重新步骤</p>
<ol>
<li>安装 Hexo 并上传到 git 上 <a href="https://blog.csdn.net/grave2015/article/details/79961843" target="_blank" rel="noopener">这里超详细</a></li>
<li>拉取源代码</li>
<li><code>npm install</code> 更新依赖（配置国内镜像：<code>npm config set registry https://registry.npm.taobao.org</code>）</li>
<li>使用<a href="https://www.dazhuanlan.com/2020/01/30/5e322259a87e5/" target="_blank" rel="noopener">方案 2</a> 修改 <code>node_modules/nunjucks</code>，并且 搜索、RSS 插件，hexo-generator-random 插件同步修改, <code>scaffolds/</code> 也要修改！。</li>
<li><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">mathjax 和 Hexo 的完美冲突解决方案</a> (目前任然不建议使用 Katex)</li>
<li>拉取自己 fork 的主题 <a href="https://github.com/chachabai/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a>，并复制 <code>_config.yml</code> 到 <code>source/_data/</code> 进行主题配置：<a href="https://demo.jerryc.me/posts/ceeb73f/" target="_blank" rel="noopener">官方配置方法</a></li>
</ol>
<p>以下内容仅需配置一次（与主题无关，最多是在主题配置文件中填写一点数值）：</p>
<ol>
<li><a href="https://tab.leancloud.cn/data.html?appid=TkSRiW6UjDGmsxqmjPiPRjHV-9Nh9j0Va#/" target="_blank" rel="noopener">LeanCloud 管理数据</a> 并配置 Valine（已关闭） 和 Utterances（也是基于 Github Issue 的，但是很好用，虽然不能在回复下回复，但是可以 <code>@</code>） <del>Gitalk 双评论系统，<a href="https://blog.csdn.net/qq_33384402/article/details/107200465" target="_blank" rel="noopener">Gitalk 配置</a>， <a href="https://www.louxiaohui.com/2018/05/15/get-file-from-git-server-automatically/" target="_blank" rel="noopener">注意事项</a>，每一篇都要初始化一次</del>。</li>
<li>添加文章加密功能，增加 <a href="https://tding.top/archives/567debe0.html" target="_blank" rel="noopener">RSS 功能</a>，<a href="https://zhuanlan.zhihu.com/p/64457116" target="_blank" rel="noopener">RSS 使用说明</a>，文章置顶功能，<a href="https://cndrew.cn/2019/10/19/plugin/" target="_blank" rel="noopener">随机文章</a></li>
<li><a href="https://blog.csdn.net/u010820857/article/details/82356974" target="_blank" rel="noopener">支持 pdf</a>，<a href="https://www.paddylin.top/post/f609.html" target="_blank" rel="noopener">支持 B 站视频</a></li>
</ol>
<h2 id="Butterfly-主题修改记录"><a href="#Butterfly-主题修改记录" class="headerlink" title="Butterfly 主题修改记录"></a>Butterfly 主题修改记录</h2><blockquote>
<p>其实直接去 <a href="https://github.com/jerryc127/hexo-theme-butterfly/compare/master...chachabai:master" target="_blank" rel="noopener">github</a> 看就行了</p>
</blockquote>
<h3 id="添加首页加载-mathjax"><a href="#添加首页加载-mathjax" class="headerlink" title="添加首页加载 mathjax"></a>添加首页加载 mathjax</h3><p>修改 <code>themes/butterfly/layout/includes/third-party/math/index.pug</code>，进去了就知道该怎么改啦。</p>
<h3 id="增加了底部小鱼游泳"><a href="#增加了底部小鱼游泳" class="headerlink" title="增加了底部小鱼游泳"></a>增加了底部小鱼游泳</h3><p>在 <code>themes/butterfly/layout/includes/footer.pug</code> 下面添加</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">style</span>.</span><br><span class="line">  <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">767px</span>)&#123;</span><br><span class="line">    <span class="selector-id">#sidebar_search_box</span> <span class="selector-tag">input</span><span class="selector-attr">[type=text]</span>&#123;<span class="attribute">width</span>:<span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">24px</span>)&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>并且在 <code>themes/butterfly/source/css/_layout/footer.styl</code> 中修改对应的 <code>footer-warp</code><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#footer-wrap</span></span><br><span class="line">  <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span></span><br><span class="line">  <span class="selector-tag">padding</span>: 1<span class="selector-class">.2rem</span> 1<span class="selector-tag">rem</span> 1<span class="selector-class">.4rem</span></span><br><span class="line">  color: $light-grey</span><br><span class="line">  <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span></span><br><span class="line">  <span class="selector-tag">left</span>: 0</span><br><span class="line">  <span class="selector-tag">right</span>: 0</span><br><span class="line">  <span class="selector-tag">top</span><span class="selector-pseudo">:0</span></span><br><span class="line">  <span class="selector-tag">bottom</span>: 0</span><br></pre></td></tr></table></figure></p>
<h3 id="添加透明度功能"><a href="#添加透明度功能" class="headerlink" title="添加透明度功能"></a>添加透明度功能</h3><ul>
<li>在 <code>source/css/_layout/post.styl</code> 的 <code>.layout_post</code> 下添加一行 <code>opacity: hexo-config(&#39;content_opacity.post&#39;)</code></li>
<li>在 <code>source/css/_layout/page.styl</code> 的 <code>.layout_page</code> 下添加一行 <code>opacity: hexo-config(&#39;content_opacity.page&#39;)</code></li>
<li>在 <code>source/css/_layout/footer.styl</code> 的 <code>footer</code> 下添加一行 <code>background-color: rgba(73,177,245,hexo-config(&#39;footer_transparent&#39;))</code></li>
<li>在 <code>source/css/_mode/darkmode.styl</code> 的 <code>#footer[data-type=color]</code> 下的内容替换为 <code>background: rgba(13,13,13,hexo-config(&#39;footer_transparent&#39;))</code></li>
</ul>
<p>然后设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 透明度</span></span><br><span class="line"><span class="attr">content_opacity:</span></span><br><span class="line">  <span class="attr">post:</span> <span class="number">0.66</span></span><br><span class="line">  <span class="attr">page:</span> <span class="number">0.77</span></span><br><span class="line"><span class="attr">footer_transparent:</span> <span class="number">0.5</span></span><br></pre></td></tr></table></figure>
<h3 id="将横幅-banner-设为透明"><a href="#将横幅-banner-设为透明" class="headerlink" title="将横幅 banner 设为透明"></a>将横幅 banner 设为透明</h3><p><code>source/css/_layout/head.styl</code> 中 <code>#page-header</code> 下的 <code>background-color:</code> 改成 <code>transparent</code></p>
<h3 id="修改-footer"><a href="#修改-footer" class="headerlink" title="修改 footer"></a>修改 footer</h3><p><code>source/css/_layout/head.styl</code> 中 <code>background-color:</code> 改成 <code>transparent</code><br>直接看<a href="https://www.paddylin.top/post/708f.html" target="_blank" rel="noopener">这里</a></p>
<blockquote>
<p>主要参考 <a href="https://yunist.cn/hexo/butterfly_modify/" target="_blank" rel="noopener">云玩家</a> 和 <a href="https://www.paddylin.top/" target="_blank" rel="noopener">Paddy</a></p>
</blockquote>
<h2 id="git-回档操作"><a href="#git-回档操作" class="headerlink" title="git 回档操作"></a>git 回档操作</h2><p>查看 github 上需要回档的版本号，三种方式</p>
<ol>
<li>直接记录下版本号，然后执行 <code>git reset --hard &lt;版本号&gt;</code></li>
<li><code>git reflog</code> 查看回档编号，<code>git reflog git reset --hard HEAD@{编号}</code></li>
<li><code>git reset –-hard HEAD ^</code> ( <code>^</code> 表示回到上一个版本，<code>^^</code> 表示回到上上个版本）</li>
</ol>
<p>最后要 <code>git push -f -u origin master</code> 提交。</p>
<p>VSCode 规范化提交插件：<a href="https://github.com/RedJue/git-commit-plugin" target="_blank" rel="noopener">git-commit-plugin</a></p>
<h2 id="部署到-github"><a href="#部署到-github" class="headerlink" title="部署到 github"></a>部署到 github</h2><p>登录 <a href="https://github.com" target="_blank" rel="noopener">github</a> ，创建 yourname/yourname.github.io 仓库， 进入该仓库 setting，下拉到 Github Page</p>
<p>设置 master branch，Custom domain（可选），Enforce HTTPS</p>
<p>git 命令行进入 blog 目录，执行下面操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C yourmail@example.com <span class="comment">#建议不设置密码，按回车</span></span><br><span class="line">clip &lt; ~/.ssh/id_rsa.pub <span class="comment"># 复制公钥到系统粘贴板</span></span><br></pre></td></tr></table></figure>
<p>去 github 账号的 setting 中添加 ssh key（复制到 key 就可以了）</p>
<p>检测是否成功： <code>ssh -T git@github.com</code></p>
<p>设置全局用户信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name yourname</span><br><span class="line">git config --<span class="keyword">global</span> user.email  yourmail@example.com</span><br></pre></td></tr></table></figure>
<p>在 <code>_config.yml</code> （最后一行）设置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yourname/yourname.github.io.git</span><br></pre></td></tr></table></figure>
<p>执行：<code>npm install hexo-deployer-git --save</code></p>
<p>然后执行： <code>hexo g -d</code> 就可以去 <code>http(s)://yourname.github.io</code> 看到自己的博客了。</p>
<h3 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置 _config.yml"></a>配置 <code>_config.yml</code></h3><p>填写 site 信息， 设置 url ， 建议 permalink 改为 ：<code>title/</code>，设置 <code># Pagination</code> 下的 <code>per_page: 0</code>。</p>
<h3 id="配置主题，配好了修改-config-yml-的-theme-为当前主题"><a href="#配置主题，配好了修改-config-yml-的-theme-为当前主题" class="headerlink" title="配置主题，配好了修改 _config.yml 的 theme 为当前主题"></a>配置主题，配好了修改 <code>_config.yml</code> 的 theme 为当前主题</h3><h2 id="以下内容被作为源代码保存"><a href="#以下内容被作为源代码保存" class="headerlink" title="以下内容被作为源代码保存"></a>以下内容被作为源代码保存</h2><ul>
<li>源码：<code>./source</code></li>
<li>环境配置文件：<code>_config.yml</code>, <code>.gitignore</code>, <code>package.json</code>, <code>package-lock.json</code>, <code>README.md</code></li>
<li>更新源码脚本：<code>updateSourceCode.py</code></li>
</ul>
<h2 id="云盘白嫖优雅解决方案"><a href="#云盘白嫖优雅解决方案" class="headerlink" title="云盘白嫖优雅解决方案"></a>云盘白嫖优雅解决方案</h2><ul>
<li>iCloud 放 pdf 和 goodnote 和一些杂七杂八但不占空间的东西</li>
<li>坚果云配分 ipad 的照片</li>
<li>各种途径的照片分类整理到 OneDrive</li>
<li>OneDrive 存照片和 Windows 默认的设置</li>
<li>用 Coding 存个人文档（2000 文件，300G）</li>
<li>百度网盘其实是最强的</li>
</ul>
<blockquote>
<p>白嫖取之有道，一定要嫖大厂的！有信誉的！<br>二级域名和虚拟主机（虚拟服务器不可能）就别想着一直白嫖了！</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>考虑代码的可迁移性，代码规范，多平台是一个好习惯。自己 fork 主题自己用，不把主题当作源码保存也是个好习惯。</p>
]]></content>
      <tags>
        <tag>Theme</tag>
      </tags>
  </entry>
  <entry>
    <title>从数列极限到点集拓扑学(from array limit to point set topology)</title>
    <url>/pointSetTopology/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">某大公司的名字(全小写)</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="968cafd8e28d0282ed8643d62431103ed9842b1303b12e309b8a50d9b379425f">eb13ed5cc53f32b13a591c515215c6c9b04495d56f4dd642ab5b3ed84f1aeb319c6599dcdaa8ab8dce6ddfbef3f8916abcc9cdec9899d142dc190201995995fbf97b77c60fbbe94b53975bdfc889f42d305dc4f121dfb1ee56e4b0361c64b063ed8b90972ad78dfec439d3eaa065c3858018214252a56fd91928e2bd81d5d4fe9ecf454b2e6088d9156bbc2c66e13b364bb3d4cd364a5ad48f9f8c75127b1073e685d0966ed8a1333d75f36a085ad6c03179503e282923eceb59b269548cf3b3c51970855a73c659a7d8c306846eb8bc7c7d3348acda417a0a37015f43fb070e60e2e112b7e91d9dd63257cfcfe5917481f580364e4e5c449e1512646878b730a13ff53b81f4bfc3f24a7966d1cee82d9ec257f9ed6f4e5e9f42da28c65868aa70af92ecafc6916889b0e858653d067a86c822350328f3f0c255cc728a7685ed12478a46bdf34ed971fab4cfac5fb6e16447701c0aa62aec93d2ea5b2e023b7ba75d68a582728ee67b9b7a88b6dd445498b8c2186a4ea0c2a01d27a2579a8c619420528f8e8a4f4ccbe79a4026db9bf39e5a8a3498d4ae233314737c543f1cede04115a73cc264757adc6a1943a60005e9b073413a04d9e86f63f29ae162dc7b5523b3269e7bad25a6394ac375ae210e8ff832f4b557b4becdf43489ebccf04553cd65568a1a4fcc1ebd5a1f201a24bf2dc8e0a1335fe893ac1509063b1a731c2ce09d82fa3950b7a09f620af787e791136bca2f25bf7fbe4dba63fd4aa00624e0a44342b5584498c902520804be3a80f2836906bd51dee0634b664c3b86cbe308a41d4a1a6cbcb86bee18a169cf4900723f2e748a5ef279adc31930c023f4508da73ad158a84539e475bf3aed92ed07304477dd61828949c50f37dba9983b3e5c1ca7ffcd5bdccc95d23857e959f71bdb22409e80fbceb04e9573a22bcdf95557a74c95aa6cdd83e5ea7d825612290c172106050b0f7ee65bc5e5ba285d7d0c70ccd938ed3674153642fed2f001e33387b8f67f03393e6a93f2b5d6fc3e2842124cfc6725f34cb1a425976d0f3fb5872d942ebebb98f462ef58d5296ccc5be5c8a9a7ce6cf40a9e78f15f7c4d80b0a02b39efcd2d85a257d29d6bd2dd6a5929e0276d314c6879c98ee3e4c1f869db8b87d779ffb4e645d12aaccaf65ba2db13b8e1a9e1077a99e047b12aff376a18a92d5caa07aa75b667588392fda017e68953138946f4f0c477b9b6e12fc7b0689d7fa4e1f0effb59dbc58803912552dc67a1c63183144bb28be262c9a8f405689b39310167130812bdf8bc69f9cded1d110d98c722f4a3eaac22e37c89ef316a023d76d029f00355d76aee618ed375be513875489b93e508ef9382abfad88492f36cbaadffece7ff5c1b31f18e8204ce9bc7f983425d90e13b55082685bf0041fc62a06f15b654e6d6bbdf0911a48ced512b0865019e8499db78bae006bc0841f56e095c99305fa21791ee8e462a53a023732f0e94bf4c0de76552b7313395d4b1e1c9325ca354c96ce55602f29ca9054d594e2597742585e8a8749e0e1a28b923458e50dbacef56d2fe1f96d8731bce8dc4afba73e5da739b07b112292cce09300fdd42471f4f1a7e96688ebeb09527fd8ddd75ac2a996f5a644b57a43c41146186e882ca5e3e8e1d9f9bff33bb5826291296e1a24f789e81919a8b1efb26f7234edcc8dfd9bdb8b4cb888eb1f051d50b759e53aaa1de37ef71998d98e00579f0a348cc11df14075e75e879ef379481f185ad5b204674f0cc869974565db8487e78b5e01c9e1457e410347b4653120d44d8f6be8048d59966362f9871efe46ab4f8506dae9c51a63437af1169a8069fee291d24a7a0fa32fdf522c17c308c8a6df2e8ad34b9be114c5232de4406f22201821af4d579855480fc5b1ee908bfd53e77a293938e05952f8dd1ca5edbe95785dc1e4d27296ce8831956adcab18952e4a570043b37383444e265e518cded8acae7beb1186bff3e190b6c6cfafa5d6d508de8a11de5b27fcc0e7622e016cb23213da360ff20bcdaa1761788d82b489b770a84a5707725e9422322e1d40fce286a137138fb497a7cfbecf874679d3ead188bd13b4a23736a6008d0e8e512ac98645206146571616c9b5dc91a1f7cee4797565f96f440d88ea903d5cb2da5e1071800bcfe2610e486d726ae21c7bf70b680736c655e8ac0cc8be756c46ea0b0f0ca00fa37fea93f30800d6e30b32de8b9fb9c1f0204365c7fb08c2d2cd2b8f22081cb4b0ff19c6ef2b611ce2f6f4cb034df8693eae726802a4a89483e534b7bb0119d874f1cd5428517cd055739b903cd418979b38b07ef97d73e386ff1407b06cd4c0eeb329e7c785beed680643b498a66cf7eca7c33d782fb6a4de3c39f1d01c4f6a37ce6829b8dee8763efc925146f64623d451010196a2e29fdd9dd5bb4dc6a92b9508ba8df46380490d446c88c3422f82d9137aa899e1c0f0306f21462a9fab0ffb99e5471ba7cac259e35535ae2c3c8ce306332a0656457054ccb0075df956bb003b5ab4b298f838ad21aa0048b2d52ba8498a2879b2f1483ce8a3f00f1589177a16d2f3a4352a24184f8a5e1f8e7f4a8ad768fcd85f6922d6977f436932b1727ded9606416b013174d133b4ccf67f8b76548f28183df066b2256dd07d6b62ae4ab57cf1afda3f814477ccb66cc184c15b6ad75a0e57bc4c28b0d0d62312978b8c3a5e75c06636cb1724d4c9a58c3df707196966f1c83716deaba4daab83ce613de4587a2263a8acb7a62472f87ca7f4935562d2d9e63ba536519a57d64c918cfde27aabe211afaa0be92b4b3e6ed9e944b316e1748567151f676286820871526e70b5e6927bf72a2e6aaea14baef2205dfb2956ead5a0dee4794ecabf24ea9ab6d7f34dfdbce03b9dd7b3f3daed26830bb5595375ad2e4387881dd666900454e6ed7e1408a41ba315b82793ac9f0f24a2797258dcd77cf6b58540703d7cad970aa68f2ffb1322e4d3f354ac20a12a3bf0f82b3dff7c8e72bc5d504b866f088f5c092c06906b16e0aa8f6f09ae239f8c03bda87d7b2d2e8bc9af0f903e4efcc07f5d92a7e659e8f44fe6ac3badfc0568ba0225e16c208f55b0c0ca035b0b0a702fdcb2df7ccaa134f64c77cf6ed7f024582d8d377663837df724cd229fbaaa853cc989bdc5bf72fe8b3d17adcc62e2547b6828337f8b075396fb8a2438d1c6fd0006f36882364d3176fc5d7ca9eb56b96d5d3018406a6e9d700964497ffc870cb445c4dce94e9069afa813ed87b09db4ffc77d5c24f32e8f461b812eaa827d343cbf582086c1283b2faf640d7b1777808e9f0db6f743bd368ab6809357810e22c473c3ebeee2d1fadacd999e96b7ab3d9b816eb57348ca12db1e5d9b4e019c01db041dc0e475b5a6c26356245c69e4ff52d42f71b5e51882e0090ff6b0a880758f83b2937cfe7a9b94a6b28a4419564d3b4198634fa11a6f5f1041f5f75df078669b39e944dac96bb754455ecfa15a160b7aa3f602c28b8331c64c7ce9b5057aa2484538ab50f172180a76945f0e5f0ed7c8f531fe4b7791a9a6810176e9196fd881c4976c43df3cb77e064bd169a22cbc21d99a4f4414bbfa68dc10c226ffd54a7e24c48c27623d7e4da5ebdf97fc33ade99ec2c8080036ede9007809178f63f46c970f3b0837dd3e43fab3e28c55f9c76dffb6f3db85feb60194769e17afaf489b3ccf0d1f080bafda704302885bb9f9c8b905080bd1ae2c5da1b90d351558ecf8ef51df5904588997679e2e3f093742589c4521969d7a173d43512f71403f1cff940ecfa37cce6950dcf270517a620731b51f605d3f3fe2d9e2404d13d1802d958645d3ee9678287538c56286a7a9bd3d15ab7928ff1d731bfb56580dd09ec65ea17e203d97dc3606d9c28c091281d3f618a75c6dff7ac37ea9e8f5102133ab56704ebb782c590711d42fbaa43e319c9fdffec30635e15e0871c800f93f666b68e1cc7b1d898f2225445bf9b1c971f13cd4f482bdc1b1d5dadc546f2d9ca599a76724af83d47ab2e16df7b01a1e9f9a86b07f9a5a6fa59d2f0ee2de7348dd8249dd1c347d2cb24d2392a9ac977eec0e14b401d844f71b8292fba43c465b6071f62c897175d0e40d42a87985af3cf305223a6eec44b5ada47707aa4626c66a5905875fd35fd241f7d3b908b08e8375f699e7d35206242888a2475b0077761130cd817b43d0cb5ffe7182e778e2f27b9aa49799f20d652565db9612682e71c973ca3e6a2e0d1a6c0d31a4868b4ff3f20fb728e2a21db635c66a7dabd51b67b854f1a967b0c947b1d3948019ce697a332017eea039d5246f6ea5b0e7600e0e52478d87933c8310612e59875d36dfb3e42035b5bc4da7f4f2dac908efde2ea9ce3267371ef90933619c02c630004c70e98a3527db32e627a86add07c7ede775b7034b7fee520d601d38581bdb0c231bbf3f82d5de01d8168fdfd81261ad9d84c27d5af71edb53fed5b73feaa8d19621a5b2046f0f94cf5dc79624e12d6fbb44122bb66fdbcbe51aace7275c0f68715afa02dbfa4123c2fca7fe46f6f8ee6f10894cffde31ae8a27d2b60b256e70aa8c22cb69b8f1c83052e046bc0e3dd9cbd0bc6f2cafe62231412103f1a06841f1d4bcb38190b18ee7902c3beeb5f93a092645537ec92b1c0bd27c68ba55acc3aad5477b88539cea60eaf43e4a15e046b648e0c622ac8a2af4e27496a0cef1394547313050c60d8a71ce35acd13c9a64c242ae4c3ca67f3ddd3105810eaeb926cabb4c2634446be804d36d9c05484d69e24d6e0a7a5aa7c71890540fee109b48e6f2df2fa17a0d5d23a04372214ae61c9c61ccd9a747dd0fd7f5505740a6da48bffef9f89f41bcb619e4e9fd26ff9865af346e70309b6cc87ee0cd055e9ebf4a4b47eaef2e4409616f4e201461b5177e1df409a3f0947a3b2d5dc83cecb010baa06bc1c2a047e1b5d1ef43416c5bc6edf1ba5bd8de58b16effb3981c4e74a3c307024faf2ac7b5ea12790795fa583785b6bd7c7cdfd5b24d641ae0ad6e535edd78a737cf600fcabe27bad89d0e259eb8e2d194fe42031dc26567d53bb0a51e59f47755bbecc81590e0da542b3d58e202c34784c2d3fad92509037d5c652fc6418cddf23e4e291e3f5076a261ddd6a9f92355ac3929e876480b1aa7fd5c8c9c28ce878a261e82a78e3d14c0e652e3facf6e4a1e46a7a430795f70aefdfb04d5117201dda87091c4e96f4cfa15bbf88336ea4a0a2da4e193dc3c728e8a06047df6230a115d9acd98e5b35d57a8618a7d72a3a1bb18fda60ed23eb743623c002d9cc460cda9d73759f3559f10f40fe61ca2266fad5086de3fb37d9c6a074c46b594b7c8c14c1ab5656155d4352c7a1a2985e6faa6bc8b2efa7b72b7a1edf9012b453837b86d8f2c5c5592024331f229d2d92cd665f1b93d2b15e26e322496fef4de4fb17b89d1b911e4d843ca2dfeac26b9a715a1b73fd834a8f0a75993611aca455ad953055a970624514581ca61e99ab76173ac67ae131997e12a43b565ea37c14dddd0e23469761e616f07731a9b7fb569a2e0173659f05f20f26b48bada8f408f3000f2c08676cf850b66bc161a39eba3c45037ffabab6ecf8b509ad21b38fca479efa2b5c3468de82fc093a1b82c1e75cc80873b01cdf6327a31f8fb53e368374290d277f253c50dfe224999a70b24ef78766529a3acbf245d22d94890048157e2c40b99a6a51db8fd4c3da0f6869a386774f84eb1038a26f2bfc805a7b0abe8648229dc9f2d41cc89d8a11fedd7364c1258f37ac5e320375442a9c7c070f48335bb3a0d43040d6e66de3ae711223a9fe8b647dd54268d3311337d29c95f7361e909577e2491a34e8678a6ec657988fdcab3382e8603496c4f946ffd3ce836908254e4514f6c8cddadc03e5b6642b9960344f00d425562f9c7adea9c36d7df970f3d2374a92945016a028cae84b5651cfee88de6266c2912b767dfc73a057373198bfa6e18288e84b35babeaa2e12065c8059ba1bd3a8954f6f075ff9c7ecfa71aa3f066d1faa7d2a2cc04d3db9d76eb15df71183ea0cd1694802d098dec81fdcacc7090579a3a724f08afcaf4fa157e5f05460cb2d42d64c91371786849cec8d1a9d066eb8ba0b2e1255ac9bbf8b1b835b18bbd9730b4997ecc70ad3d3fb86dd3ea5612caefe7a34f67495d0a7478323c934d4c491b90f046e493a77f6aeb0e91a2b9bc7742daa8f1de92a633a617f088195ae9ff54275d7f1134f055a7e81af00f3584916b0430d195707c8d130c1dedefaef7af04204e66bd996e789c9d1cd4f7f60680bc69a2c1af3adc98f46f934e370dbc3905a19f4ef3688d41c881f26116eeaf2230152d8afe1cd50065263181c5e93f06d68283e40d432142c815f3c6d87cd80e2e726946925fcd78eb04144018a64f553c1aac764b92403c13f6f8078e4ff2241d3ac1989945b81351dc15e9a00a69bce89397b7b694cfd99d42673ae90f7bacd5e2f7fc56fcbc314834bbfe0865ff40f5457755d40b479c0e4f9f36a0ebdcfe2747b9cf011a34317b100bf4910dc26386d0e10b8b877781769728bf1ed26a26234b99bc80c977a46e471b81ad9bcc4cd76da8bffec38715b9ec6d7c67996ec428f47e3abb10c79a377ea0ebcca594d1d5a8a9d75a0daca1d75e9de7d958cefae34358324f104f5ce60f4421e7cd9a45bca815bfdb7f39106ea69d2c85a30d6f3f18eed11ffc3347d0fbe9d6b1ffdf70f7e50bda005f9792e0f44cf84a7c58dc7203a851e40b339cb4fc557f14e3247656a5c5a88d91f095d7338e1fe126c02ff5716fa87f1449166c192af8eff90df515571d574a72f889b0b7a06e4fa33fe564d71531b1763085d136e2abd27980d79ae4aeaa5c2887e581dc510b1e4521cbf20e28a3947bca19d87919bd42b9848f82916388d04834c0e8a6cb3e2664b8f483e389232b0440db81f6e510ab4fa1e4770681db6217831ce64cd5e9f41e6d66902bc52348506ef5fb446b69a822cd86895d6c45f0152cc7a0816cf456cdd56c907a3e54201023b0c89823482946c353f7c4ee2f7815acd2ca81c9bba393da82111d500bb1aa12aef206124e90cf52c7e1169b5dd2a390303f4403184f4355e6989d588e3e314ac52d23e62f6c9fcb9a5daa434b5b5f19714b6b65724df22505786d386a41922eabec867694e9e4c9aa8e208070c0c9cff7739f7f44bfc3efcb452bb20eed1e207a5f4c47273edf3392f8584c1a3e26ebe631ffadfe1d08ab172537452b086e5b9d3c6c98f53372c4f9de8e07dd8e7f2e3b500d593066bd8d092bfec501efbbb2fb860e2eee1f835402fe675d690c5cd39e75215f5a2c817b844c590c761f6b154e14045a5da665de11d0d616c285d83d98bd4949a8d796537b1f97e24a4ad16e70cbafd7ca87e8a4bf0ae3671ca01200a32ae54898e32426451db389907c3238a7bb03a1ec7b1b1e97c00c65bd141d90d1bbc49c515bcc0f3d9ca22084d317ac3bbf3ebbc062fb5da1d5798f509e5182f3eac5f8880aacbf4f3998817d4c79eeb8b6b8105c37e42a1026b4fab2349555646a9c2b4c47f7b5cc2f2e34e274f08d00647662764a1418d5936b9739e4e8b9c91bb432b82d9fde3acda7aff416ef03b5f5f8267ba1134179b758f082ec8aa47a0cd2461132eff4b393caa8d201ff816aef9529b6cde8c39345a65889beba57573ad40e2fb5d841e1bd20f8e502a94511c6cf63c9e09894cf0193ecb3fb43566150f122d5b2f1eb8e0d1079fc5eea25b20594ccbe9e8eb8ed84d8884802b2fbc24644c97c32884d464151d76ecf4be8fa04815e55fc7e1a4b4e5ec1ad712e6cd026fdb52bf7d37c3f283034662d9762190aea20886fe3c2abb5d459ac1756447832f42fb992ca0f3bcc180420fceba79f4046548938aaf322ad397f12a66fa02a27af1f03520a15c27d5913e874ac7f3fcb6523e5e6904e7cb8b33898b9f9208a9f470a869805da04c9bc9e86ef2ade7ab179890eb6b291f0a78d014b9a94ebf4c3de1b3bcdf1bd4d3866b9261b19d163557c4daa75e8c60e620e9080ad618409951b5c1ae990219a1fb1392072a8fa5305ff8287db3e6205f87bb381e7f94abffafddb6fc800e3381c380a54638d98470f1e254940a524394d25599b9c8f39a9a5f2590e671eba7b3ef40d6c8aac118ab2cdf12c29a033fec2e2c91c3b4febfbb0ce293b765ed4e19304f1d015c34c081fcbe19593e1ec29c1bf27e9db4e68e2191935864299fa79d18c0cd67563ffdd2a5cbfc19481b0d55acceea6287e715b9e9b83c24a28f167db1fccf32e350f987219470819dd89d49b29e882b7b514854e7681f477bb2a677661dbcf43d2f0dd4df2dec72e1b5e1b1e1019d2e9129d061790fa9891e31da7bee190d073a1c027922c4c802cfab6fe0728314b5576e64cf9949520c246c1078845add072c877c24f8c8bec7197a16d4f568a547d7f1f9c85ec2300a6112b99cc70f507d768de52f957acc74a8c06d9161b629d0b08086104fe556b5510b39356d837b67781a408df6c285295ba8271af97373dbc42c1061c38941862c2f15ea90ff7209b22a52ed9108b9f340042e424c60f2cb697f1030695a669a1a82cdc3d9f3ad72e786de4a555636864c05537312e12452fa4cefe3d3fc082b29eb193cbe92c333970c88cefe4a3104bada4263bdce2bb7d3beef5861b5b6563e58478711d35a13fa42c8a559e441f9ced73f65ae5ffce9fe18bdb04cdcd4f1bcc809680a690534cb86ed3effbea259602236fcdb7c3a21ef39d867921108d448119ef70508d239a5b39dde302a1627db97e7233fa88d65ec5dbab58e91905b573ef882a4cb798a375848ee0fc49118c8c7e723b816d90c6673c7958a08e34506ccd99b85a0b63ce07b2c3f3c8750126f2d5f6dec2e6cb20f3347f08f37e71a6b799ada1eacbe92edf33f5cc5edc3c8227ff069f5a496735095002c1fb9cb06014d9d253882d086d1668bfa3d3bfdd3a8753fe2f75c30f9afc41d8e23c66f3181427476029c1245fe14dd55dc77c9741ec2b8334b8b18d6b65e964f125ebfe19a9f55e193dce9f7066dfb8cc25d8cd41e5c2723da3e2ad41a21ec1fd877dcab4984dc0fe15e72afe9c7204380a07258889d8b50fc2394160f67d75fcc1185a1b201ec915d5f570c174b02d5f6ada39913f9e469e3705db3472128f4aa298a915fd6f15cfd9989670020152d17526addbd53f2fe788c77226d6a8687ad94b2f11ea08424511ffc723f564450b962150513ce8cf9e9f785946e3a5a403e56ec8834eef206b9c73e785895c92250432fb04383ab2662db1173e7464f299891f4d239c25c662995363592b3c65a4488e6a2b56a4d55af0784f6dbb69e06ce9fd96be784df572407371a67f091f0fdfb0d051ab0d38131475044bb2ed9513bf768285057c040402765e28cca9228a346f2cd2f41f67d6bad4717ec12c5305756c95ca00f230d35d6047f7dd6f675aff0bc84c5c78ed919cadb54db9771208f42fdfb901a2b18258415edee6a0faf91ee6444cb745b7b4386840672af2763534e99ab147a19e094cd258b41238fb5acbff014260318be58af2caa42b7769a030470b34ba55d9d7e76fbc710923e22c141101fdaefdb68b5227b9363584763932b30526b4f10cca5c156a124b5b1d29b1f7285932cbe4623a1a7d8918facdc5985cd57c0f9c3e2426a07faa19034cf8392ca0f3611ce6c395bd27df7033ee281cc6459f648c11a2cea427079aa4441539d5906ba80c6b45d58ba7f43cae2f06ad82ac938f745e9c39623af7041ead50b35cc9c967a4df5852826d49d08203b94f79550f717ca6a9f5dde3320bee76cb818ee8fa762656b3567e6c111b45dfcca76e1c1f89bfa317aa94bcc13f052046454d3c8058ea2805791b8b1a681e563acf453f39ffd6e01bb4f9c14e9f4c24874613a571aea221b9af7da2bc431b18532fb04adab4fb87630c9d575fd60e2d0ae1b5c187300f9cad265408ace014755ecb95b61667ea8462c5fef55d3bfc0337cd750fd8b371600588b78957134c731bb0bad177c9455eca0f3e21069c98c96e473d4f0b9d2f839624d60d5363dfe0a10453f85bb87dc39f4a44c1f2f0aa11618cb9ec7e482f98af7d3d1d66495d5ff633d3f6c88db57f590766c78cfa57b7e44de3a7fb39dadb068c21e5d293bf3c90f7ae8339f1d2627fc126387c3c196be96c41545671f463ebda1216dc720b67cf2b0ffda7581bd6c375cffc2206ec6e5b92773a0ab8621f158fe0b324327b023cf8ff8bab994f5c7a63b9a869cabe87e891f0fbca5a4261759402e931faedd5f29dc36e4e40cbf22938292a4a1ad6aae7eb5525b5e143abab94cfdedc07bb3cb7e5074975ed414d7b0cd2a55c1723cf726e4e32409c5e738e1885b39e86bdd445d1b3ad58b3368364a21a77f01035afcbb6d4b396a3fcffbb10b41b3c38f82d5ed9a5da99efa4611628186373af6c88fa18204868bf9a346e134e4e4b5c82a2462e509667b861ea53c8e3459c7e3e1d01d82dbff28c1ff4572aba3cf14e54781857df31e6aa4b4e4301c6800335f815daa3add5778430966e41ac96ee1119e6cf39241186b2bc21c20317702c7819237736d5667dd8d93c26d331ba68af682b731c03bc3dc95c13cb42b2ba7898d3c2351744ccf732dd31e9fbcbbfd01903461e2e682064a5ab2bc34e00011eff1efc53ee1f85657c7b9b47126a1ffaeaf85e4b2d1baab1705e006b63bac79091415ef162cd6fc7c21291a733c2d39bcc1ef62cdd1c05b3e3ed38f779ec2a2901007d2f537bd7c2384f116f33847a46322d07a55add4e60ac15c785a2f074c11e5b843147d2dc3ca82671e1c2f5e94c1cb1490801ab27f479e59c711204cdbd6d79d3014e4f2afac93a78f54450cc46857894be8bcd3adbd25581bc3867d44125df6179bf6df2d65c688f6cc0ac0c8b4a7f9575e42627d9399d5d42a14186e3cdc7b1171b92cad3a3a348e2278dd76c3b98f434a7374d32350f4fb7391644cd5631dea35b9abb71c76de8b44d79257232573d3e51798591d5d4f6d23299c987390c42b84586846e4b56cf3907415ba3657148dd24bbe40f9b4ed74be34a1e00269ec3405117c1603be343fccf428f9366a9c1e5f0b58cf39cd2c05d7155bd414c8371bc931c56daca85d227a00d6ae99e104ac586ac7905d77995aa33dfca7e14972fe5459c7b3118d6c815d3a4215e92dffadf15706675eba5715f6a080a6b38b6a99524aaa06645516a585d1341a42995539989f015ee9b7664f39ce9efa1e116dc5ecfbb78f90228f78b0d758c67ccaef04f9757859e21ba2e07d2decccebc4958e38c103f3ebbd7ae99dee254fe5c57e583f14ae8aeeb5329f6e72df20a10f4cac366199f90785a92122b39d7c0fe8ffede448b3154b0d643458e3441b33908d988be26b98e3b543f5855841ae1615fe9cbefba2a9fdb8081f1b86a1d7b4986e6d0367470297165ff410cbabf6b869fbc350408955d13ee6d7d8b7853d9689c109449d151b7abf48be8af9e69c0aeba725cb6fc9fc8a09410813c4bbcf08474b46270ed2ad18aa62443de295dd295077cc483debf55e1ed143401fc6a31e4c8e6b1c8cf39dc6d2a14cb40e2e8099aa7b6ff905ec904d7f7d4cf7f22754ac181c4172f211a44384e716e9198e261a6475c3a63e9a455367ae3a356ae97ba96216d0075d60b3590ace0cfdeb19c34f3801b1f9a6251d453ea3a5594ce867633e670129a07726e70cc66f8872c6401a172821e577fd0aaec5bfe24673dc2859531421b75ead23dc83f943db9a3b649cfdc7be56d1c36d888e99fd0eb53f972e7fdb4f54e140e11b2effad2389dd15501ab0e9bed6097b44d53199547bc4ad48b58be4db18b4b2943015b604e1d3cf2d335f73be8aa4e769b75eed6fec69bdaf7a187b72358c80e5ed8966dbcf38e333474d8e6b8bdc6a20c0c1bf2990f518a8d4e1812efe229775099155b6dbe566846bfb815dc228b5c4fdcf4ce3bc10c11d895978f87a10ad1202645b2f2ddda21461f6104dfd9031be8a7370df49072918797ce1e8da75ff98e9dbc0583611e1c4b9a9144c158a7bdedfc19f620c815a92c85e9c0b9827ed2a8f410e8725f2fd779271a3722e27d7c941f283a9e2e473c464902caa70389d3791f4369597babbeb2b411a1e5de968abc619ec1cf102c92cf8b54041315b6ef102366c37449c6216819cee6faca0d1de99768f6b070b9da47656319414b7174b09955f14fd47b725571585d58511a1ce093146c8dcfe0e307275ee86c83eac221d964204846dbf4c4f5136f461b6ef30bf7801f9fa11e0629dab9fec508c8f705ef494441297c4f69bd10bf84b2110905cbda40fad2d79b3524f14105b71463d53ba1a954f76a430000efac7316d7e2aa4b237250fcd195eeaa4d6a51e0c69c104a1d3809ca36f453084c2803fb567488adc3622b9f8e7eb3474cc54bf31d46dd1f83d04466a90463404a9da9da5eacc874327820c6d891a1fee5e590acd847195fb1ca6f6470a2e1f3c0bb91e92eca58d6476efd048955ed911a0db96db50e012130d6a0104085946b61bb5bd5d9eff79891ff6ccf060e8f61b51654fb39427f06e8624f3ade06e2e6b6a6c69dfa96ba3eb9d7f00e13814dd842534eed054dac414d9dcb2fed75d9fe857d4faa851310815200e7c79080abee9052076fd0b51dca305b7235c0d93f24dc49bf2466858571d73e241403ad7a17f2f90f844994d32645d7cfdd65debc51c2072b0c9369e4a6f808f459e3b83987d3a477db8b615b21493b29c6a201424ebbcaae37cc792bdcd16452a63d2aad5f07799cccd50bcc6e268640fb88677c93838ad1936cb04f6c6acc289b679a6cea6eed75df623c443b009dd7c5097be18f320cefb874552da713c062f24f491635004ce5561be71b9f34489cced5156ce23de45de5088e5d9eda24f86cb0619bf55990f5a13f2ab18dbd2919f6ce85697704185da93e9a38ba1bc460122415fcfa28a9d4d4f82173cbe896308d49361eee01da633d1d7743eaf7ef32f6859256b326d34304a010fae6e8015ebe762a16fba3bd14c3dbbe52642dd9e3a1a6f6229dc22c61010e11d920a912c3dd25b89a09fc04d199004f525ded51f08e55e3abb216836fc475a0f85226ec8872ef0c40e831a3af26dc4e15e52341f247c2768b3f1b85c283e40bafcc159bf22fca5b58188be42d7fb0532e00e38cc13b483c89cdc851a6152e21f4078af26e8b25282884e4ccb60ab1b7baeae752f086b6e62a6e8e41d65b8ca78e0b6fab78ac076174ac137b3ead76b0e4e369e9a7cbefe63fa595d9355314ae3a1f777d4f2d92a8e3af1542bdbe8ef3f6ffe9bd27f1942a6537023a1104426011c840bd2c217478d08637c8d3ca3fbff35606a106c37099d947ce14c53fc03037563a56f496c00f89b12df1ab2ff9c2aa851a33b7ff4ee268feae177d6e1091f916a2f3067773c6883dd9ec2da592c47fa2fc5d18bdb848d54df47fc2bef8429240deaf503b94fab7de02e80fd4387bfa9ca91c1abe189b3a6b657bff80fc5cb50e3bbecc748a278a1dc9d82b725c130fc42c60d5af8cdb22824431dbc9540702c2ed63852aa209eaf36f4c6c86302088b104e146e103d14272643a8079a002a0a363441d694718517e34555bacd15dcb1c1cd9f12d93b47be891b701bb11bf79eb0095c996a915fce0f33876b9a3f5f846e9a8544be52eb0ec1c086c6575d35fd5371cbe6023814cebfb403d0903f1c5d33f9efbeec2f806118919ad15619963d4433e73585460392db04406d3fe3b195efe099597c47d4a14028201c611e890f5ae1854e8efdb1d15451442e60aef9c3c70c17c448e920a3ab57045425dc0d29ecf291ebca0dc32b73bf41256026209fedf3ee3700d16cb705c7f731374af8672e17fd2df0361421bf4e71b9ad9728c58d4068714e6a3b64e576a842edb9975f5858ae57702f78c8ef6a8eb8ac08280cc7029d58cdc62298021cbcd6142d89aa63a9007ef6673518a5c1658091392f1fb9b11c2c10ca2888876adb36e23093f1fe4d333e0fb49cf1aa123174be15b79611b00831a3c2d9e0aeefb5006e7539840cc078341fbb7260087c750be92dc7150554f65a9108e869748fc30b21706e42c132971e48e45ba6392b644fcf7980eb699b3de142c0bde12cbe2edd49dcbfed546e835c510777faad4f57a0854d3831ee0647cc2152853b1fbfadd8bd5393f4dcc54fab270ede4791e270c5575e8888c2704a2c22da404609370a80869466546b655b3833320c57143c7878128cff7e301baf9b06630a8330629c8a3150a0080f0de6fec1fb9598696ba81967462263c17c1eb7980a758cc1f4544292330d12b3675a2334a24d21d916b5fc55864080a5e916835bf21b882c2f80d8181c5ea3b87441727b64399cb813f3205672d2909eb7d2caba1f4282a6cd2f40c93de2e86475dc0a35c1d719cfb11ed05102523f2c17dbc4efffff9b76abd66b43c88226a42b7804cc9e1cbc7dfb0c7edcfd593478810faf3e9fe512e500080fa04d4c1878fa0489b1b477d4176ee0377417b6b068fc537982aadbdc560cd7bfafeae48c192dde21536de7f8ef81737aca2da62c5252f42c5a810acc309c729e5cdd657d4944b160098dbd907895db863ede0c65b99b53876454700b0611bf67a6b08679d8eed6753dcc90c1b626bdebe1cef23d150020785b9a338453d690cbe59b0132efa0829d48d64fde15008f048632ae860191523b621c51dddc3938deb4558c902a234ac86c419735a9549f3443981030a19d38aeeb7ee9a6f7deb150fe0caf72ec5332cdd14cbc9b17f5f45933ebd893241141cfad865dd0d0c9c2c8d703ea7fbeda92f0840a8a822bf37f0285e6d216a0167c938320afbb4d0dc23f5bf86a324e2a84458b893f33f7cdb1dc7d93a7becb33a8cc65bb02c033bb3f529734b1a42ed1ee0b802e6bed4672decd73</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 代码规范</title>
    <url>/codeStyle/</url>
    <content><![CDATA[<p>此规范参考：Codeforces 上 <a href="http://codeforces.com/profile/jiangly" target="_blank" rel="noopener">Jiangly</a> 的码风，<a href="https://oi.men.ci/code-style-oi/" target="_blank" rel="noopener">Menci</a> 代码规范，知乎 <a href="https://www.zhihu.com/question/398008181/answer/1259561408" target="_blank" rel="noopener">pansz</a> 的回答<br>VSCode 的 C_Cpp: <code>Clang_format_style</code> 和 <code>Clang_format_fallback style</code> 设置为：<code>{ BasedOnStyle: google, IndentWidth: 4,TabWidth: 4, UseTab: Always, BreakBeforeBraces: Custom, AllowShortIfStatementsOnASingleLine: true, IndentCaseLabels: false }</code></p>
<blockquote>
<p>设置可参考：<a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html" target="_blank" rel="noopener">官方代码风格配置</a></p>
</blockquote>
<h3 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h3><ul>
<li>不再使用 <code>using namespace std</code></li>
<li>不建议使用 <code>#include &lt;bits/stdc++.h&gt;</code></li>
<li>Tab 用于缩进，空格用于对齐（可不对齐）</li>
<li>左大括号不换行（左大括号前有且仅有一个空格）</li>
<li>头文件必须全部写在开头，C 的头文件必须以 c 开头而非<code>.h</code> 结尾</li>
<li><code>main</code> 函数必须在整个程序末尾</li>
<li>常用函数尽量写成类和模板形式</li>
<li>尽量使用 STL 减少代码量</li>
<li>尽量不要用 <code>C-type</code> 代码</li>
<li>善用 <code>namespace</code> 写一些通用函数（或者类似单例的东西）。不要把 <code>Class/Struct</code> 和 <code>namespace</code> 搞混淆了。</li>
</ul>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><ul>
<li>不能有两个连续空行</li>
<li>独立的代码块之间要有空行</li>
<li>头文件块、函数、成员函数、结构体、类，全局变量块之间必须用空行隔开</li>
</ul>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>空格的作用：识别族群的位置</p>
<ul>
<li>前后必须都有空格：冒号、双目运算符、三目运算符</li>
<li>前加后不加：<code>* &amp;</code></li>
<li>后加前不加：关键字，逗号</li>
<li>前后都不加：<code>. -&gt; ::</code></li>
</ul>
<h3 id="函数和变量"><a href="#函数和变量" class="headerlink" title="函数和变量"></a>函数和变量</h3><ul>
<li>传参时按照实际需要传 引用、const 引用、值</li>
<li>尽量不使用全局变量</li>
<li>局部变量在用时定义</li>
<li>在合适的时间使用 <code>static</code> 变量</li>
</ul>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul>
<li>统一使用驼峰命名法</li>
<li>常量，<code>typedef</code> 定义的类型 全部大写</li>
<li>类私有变量以 <code>_</code> 开头</li>
<li>函数和变量统一使用小驼峰</li>
<li>结构和类统一使用大驼峰</li>
<li>以 Core 结尾的核心代码是在约束条件下的高效代码，可以用 Lambda 函数写在原函数内部</li>
<li>以 S 结尾的是简单且效率较低的代码，当作对拍的测试代码</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>代码尽量自注释</li>
<li>在函数最开始注释，解释输入输出变量</li>
</ul>
<h3 id="代码优先级"><a href="#代码优先级" class="headerlink" title="代码优先级"></a>代码优先级</h3><ul>
<li>普通代码：正确，可行，可读，通用</li>
<li>Core 代码：正确，高效，通用，可读</li>
</ul>
<h3 id="STL-的使用"><a href="#STL-的使用" class="headerlink" title="STL 的使用"></a>STL 的使用</h3><ul>
<li><code>vector&lt;bool&gt;</code> 不是 <code>vector</code> 类型，谨慎使用</li>
<li>尽量用 <code>vector</code> 取代用户输入的数组，而非开足够大的数组</li>
<li>尽量使用 <code>emplace_back</code> 取代 <code>push_back</code>，有些取代不了，就不取代了</li>
<li>多使用 <code>pair, tuple, sort, stable_sort, iota, accumulate, for_each, lambda函数</code> 使得代码更加优雅</li>
</ul>
<h3 id="代码规范的说明"><a href="#代码规范的说明" class="headerlink" title="代码规范的说明"></a>代码规范的说明</h3><p>空格的作用是区分，空格缩进理论上是不合理的，<strong>强烈抵制四个空格代替 Tab</strong> </p>
<p>双目运算符两边加空格是为了 区分运算符 和 变量，虽然 <code>a+b</code>（这种代码不必加空格，但是为了养成好习惯，还是加上较好），关键字后面加空格是为了避免像 函数调用</p>
<p>工程中不推荐使用 <code>using namespace std</code> ，而且不用的时候你就会知道一些陌生的函数原来是 <code>std</code> 中的，并且以后修改起来很麻烦</p>
<p>不建议使用万能头文件，但是本人用了是因为，打 CF 等比赛的时候你一个个的敲头文件或者写一大堆头文件，还不如就写这一个，并且以后修改成不用万能头文件也很容易</p>
<p>左空格不换行完全是个人喜好，换不换都可以，固定就好</p>
<p>其它总纲的代码规范完全是为了代码通用美感，大道至简</p>
<p>尽量避免全局变量是因为防止程序不可控，降低代码耦合性，局部变量用的时候定义是为了增加代码可读性，<code>static</code> 变量也是为了避免全局变量</p>
<p>驼峰命名的好处在于 “顾名思义，望文生义”（贬义褒用）<br>遵守代码规范，养成编程好习惯~</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>dna049 的 C++ 模板</title>
    <url>/templateOfCpp/</url>
    <content><![CDATA[<p>此处只包含通用代码块，以下为其它内容：</p>
<ul>
<li><a href="/codeStyle/" title="C++ 代码规范">C++ 代码规范</a></li>
<li><a href="/allTemplate/" title="C++ 万能模板">C++ 万能模板</a></li>
<li><a href="/graph/" title="C++ 图论模板">C++ 图论模板</a>（因为图论内容实在太多）</li>
<li><a href="/string/" title="C++ 字符串模板">C++ 字符串模板</a>（内容相对独立）</li>
<li><a href="/stl/" title="STL 和 C++17 学习记录">STL 和 C++17 学习记录</a>
</li>
</ul>
<p><strong>欢迎使用或转载代码块，唯一要求添加一行注释</strong>: <code>https://dna049.com</code></p>
<blockquote>
<p>编译器比你想象中的聪明，所以尽量写 <strong>编译器好优化</strong> 并且 <strong>易读</strong> 的代码，很多位运算，除法都是可以被优化的！<br>优质的代码本身就是一种解释，添加完全不必要的注释只会让人恶心<br>以后尽量使用 <code>vector</code> 而非数组，结合 <code>C++17</code> 特征，可以简化代码且便于编译器优化！<br>以前觉得 <code>main</code> 函数 <code>return 0</code> 只是标准写法，现在(2020/5/22)才知道能返回就能提前优雅的结束，并且可以判断是否正常结束！<br>全局变量数组元素自动默认初始化为 0，局部变量要加 <code>= {}</code> 才会初始化为 0</p>
</blockquote>
<a id="more"></a>
<h2 id="通用代码块"><a href="#通用代码块" class="headerlink" title="通用代码块"></a>通用代码块</h2><h3 id="佛祖保佑，永无-bug"><a href="#佛祖保佑，永无-bug" class="headerlink" title="佛祖保佑，永无 bug"></a>佛祖保佑，永无 bug</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="comment">// #define print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl </span></span><br><span class="line"><span class="comment">// #define println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">auto</span> start = <span class="built_in">std</span>::clock();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time used: "</span> &lt;&lt; (<span class="built_in">std</span>::clock() - start) &lt;&lt; <span class="string">"ms"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">------ Welcome to my blog: http://dna049.com ------</span></span><br><span class="line"><span class="comment">                   _ooOoo_</span></span><br><span class="line"><span class="comment">                  o8888888o</span></span><br><span class="line"><span class="comment">                  88" . "88</span></span><br><span class="line"><span class="comment">                  (| -_- |)</span></span><br><span class="line"><span class="comment">                  O\  =  /O</span></span><br><span class="line"><span class="comment">               ____/`---'\____</span></span><br><span class="line"><span class="comment">             .'  \\|     |//  `.</span></span><br><span class="line"><span class="comment">            /  \\|||  :  |||//  \</span></span><br><span class="line"><span class="comment">           /  _||||| -:- |||||-  \</span></span><br><span class="line"><span class="comment">           |   | \\\  -  /// |   |</span></span><br><span class="line"><span class="comment">           | \_|  ''\---/''  |   |</span></span><br><span class="line"><span class="comment">           \  .-\__  `-`  ___/-. /</span></span><br><span class="line"><span class="comment">         ___`. .'  /--.--\  `. . __</span></span><br><span class="line"><span class="comment">      ."" '&lt;  `.___\_&lt;|&gt;_/___.'  &gt;'"".</span></span><br><span class="line"><span class="comment">     | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span></span><br><span class="line"><span class="comment">     \  \ `-.   \_ __\ /__ _/   .-` /  /</span></span><br><span class="line"><span class="comment">======`-.____`-.___\_____/___.-`____.-'======</span></span><br><span class="line"><span class="comment">                   `=---='</span></span><br><span class="line"><span class="comment">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line"><span class="comment">            佛祖保佑       永无BUG</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐</span></span><br><span class="line"><span class="comment"> * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐</span></span><br><span class="line"><span class="comment"> * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘</span></span><br><span class="line"><span class="comment"> * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐</span></span><br><span class="line"><span class="comment"> * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │</span></span><br><span class="line"><span class="comment"> * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤</span></span><br><span class="line"><span class="comment"> * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │</span></span><br><span class="line"><span class="comment"> * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │</span></span><br><span class="line"><span class="comment"> * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter  │               │ 4 │ 5 │ 6 │   │</span></span><br><span class="line"><span class="comment"> * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤</span></span><br><span class="line"><span class="comment"> * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │</span></span><br><span class="line"><span class="comment"> * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││</span></span><br><span class="line"><span class="comment"> * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│</span></span><br><span class="line"><span class="comment"> * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="VScode-下-debeg"><a href="#VScode-下-debeg" class="headerlink" title="VScode 下 debeg"></a>VScode 下 debeg</h3><p>需要在默认生成的 task.json 中在 <code>&quot;args&quot;:</code> 下添加一行 <code>&quot;-std=c++17&quot;,</code> 不然要报 warning 很烦。另外要使用绝对路径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能使用相对路径 debug，也可能是设置问题</span></span><br><span class="line">freopen(<span class="string">"C:/Users/dna049/cf/in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure>
<h3 id="递归程序防止爆栈"><a href="#递归程序防止爆栈" class="headerlink" title="递归程序防止爆栈"></a>递归程序防止爆栈</h3><p>在 Windows 上，通常的方法是在 <strong>编译选项</strong> 中加入 <code>-Wl,--stack=1000000000</code><br>命令行中可以使用：<code>g++ -static -Wl,--stack=268435456 -O2 -std=c++17 -o main main.cpp</code><br>powerShell 中可以使用：<code>g++ -static (Tab 上的那个键)-Wl,--stack=268435456 -O2 -std=c++17 -o main main.cpp</code><br>在 Linux 上，通常的方法是在运行程序前 <strong>在终端内</strong> 执行 <code>ulimit -s unlimited</code> （WSL 下无法设置可惜）</p>
<h3 id="Python-输入样例（以备不时之需，用-PyPy3-提交）"><a href="#Python-输入样例（以备不时之需，用-PyPy3-提交）" class="headerlink" title="Python 输入样例（以备不时之需，用 PyPy3 提交）"></a>Python 输入样例（以备不时之需，用 PyPy3 提交）</h3><p>用 Python 过的一次大数题：<a href="https://codeforces.com/contest/490/submission/105550245" target="_blank" rel="noopener">490C</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多 case 输入</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(int(input())):</span><br><span class="line"><span class="comment"># 单行输入</span></span><br><span class="line">    n = int(input())</span><br><span class="line"><span class="comment"># 两个元素一行输入</span></span><br><span class="line">	a, b = map(int, input().split())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提前结束	</span></span><br><span class="line">exit()</span><br></pre></td></tr></table></figure>
<h3 id="产生-log-的几个原因"><a href="#产生-log-的几个原因" class="headerlink" title="产生 log 的几个原因"></a>产生 log 的几个原因</h3><ol>
<li>二分，三分</li>
<li>$1 + \frac{1}{2} + \cdots \frac{1}{n} \sim \log n$</li>
<li>树状数组，线段树</li>
<li>重链剖分</li>
<li>倍增</li>
</ol>
<h3 id="产生根号的几个原因"><a href="#产生根号的几个原因" class="headerlink" title="产生根号的几个原因"></a>产生根号的几个原因</h3><ol>
<li>朴素判断素数</li>
<li>$\lfloor \frac{n}{i} \rfloor$ 的值域是 $O(\sqrt{n})$ 的</li>
<li>网络流中 HLPP（没读过这篇复杂度分析的论文，不懂）</li>
<li>分块处理</li>
</ol>
<h3 id="类中静态成员定义时初始化"><a href="#类中静态成员定义时初始化" class="headerlink" title="类中静态成员定义时初始化"></a>类中静态成员定义时初始化</h3><p>在前面加 inline 即可，最后都加，否则在配合 STL 的时候就会链接出错，从而无法编译通过例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Flow</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	Flow(<span class="keyword">int</span> _n) : n(_n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		d.assign(n, INF);</span><br><span class="line">		<span class="keyword">return</span> INF;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Flow <span class="title">g</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g.test() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bitset-高端压位卡常"><a href="#bitset-高端压位卡常" class="headerlink" title="bitset 高端压位卡常"></a><a href="https://www.cnblogs.com/RabbitHu/p/bitset.html" target="_blank" rel="noopener">bitset 高端压位卡常</a></h3><p>典型应用，求传递闭包。</p>
<h3 id="位运算的关系"><a href="#位运算的关系" class="headerlink" title="位运算的关系"></a>位运算的关系</h3><ul>
<li>异或 <code>1</code> 改变，异或 <code>0</code> 不变</li>
<li>某位异或位 0，表示此位相等，反之不等。</li>
<li>$a \oplus b = (a \mid b) \oplus (a \And b)$</li>
<li>$a \oplus b = (a \mid b) - (a \And b)$</li>
<li>$a + b = (a \mid b) + (a \And b)$</li>
<li>$a + b = (a \oplus b) + 2 (a \And b)$</li>
<li><code>(a &amp; b) | c = (a | b) &amp; (a | c)</code></li>
<li><code>(a | b) &amp; c = (a &amp; b) | (a &amp; c)</code></li>
<li><code>(a | b) ^ 1 = (a ^ 1) &amp; (b ^ 1)</code></li>
<li><code>(a &amp; b) ^ 1 = (a ^ 1) | (b ^ 1)</code></li>
<li><code>(a | b) ^ c</code> 和 <code>(a &amp; b) ^ c</code> 可以逐位转化，因此任何一个数 x 经过任意多次的<code>&amp;, |, ^</code> 运算最终都可以写成 <code>((x ^ a) &amp; b) | c</code>。</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a><a href="/dynamicProgramming/" title="动态规划">动态规划</a></h3><h3 id="Meet-in-Middle-拆半搜索法"><a href="#Meet-in-Middle-拆半搜索法" class="headerlink" title="Meet in Middle(拆半搜索法)"></a>Meet in Middle(拆半搜索法)</h3><blockquote>
<p>类似于动态规划，是一种思想。特别适合处理指数复杂度。</p>
</blockquote>
<p>例题：<a href="https://atcoder.jp/contests/abc184/tasks/abc184_f" target="_blank" rel="noopener">AtCoder abc184F</a>，当然针对此题可以深搜剪枝法。</p>
<h3 id="Small-to-large（把小的合并到大的里面去）"><a href="#Small-to-large（把小的合并到大的里面去）" class="headerlink" title="Small to large（把小的合并到大的里面去）"></a>Small to large（把小的合并到大的里面去）</h3><p>例子：并查集（dus），map 的合并，树上启发式合并（dus on tree)，重链剖分。</p>
<p>例题：<a href="https://codeforces.com/contest/600/problem/E" target="_blank" rel="noopener">600E</a> 的 <a href="https://codeforces.com/blog/entry/21827" target="_blank" rel="noopener">题解</a></p>
<h3 id="倍增思想"><a href="#倍增思想" class="headerlink" title="倍增思想"></a>倍增思想</h3><p>例子：RMQ，LCA。</p>
<h3 id="int128-的使用"><a href="#int128-的使用" class="headerlink" title="int128 的使用"></a>int128 的使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__int128 <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	__int128 x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">		x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printS</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) printS(x / <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">		x = -x;</span><br><span class="line">	&#125;</span><br><span class="line">	printS(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	__int128 a = <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">print</span>(a * a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交互式题目模板"><a href="#交互式题目模板" class="headerlink" title="交互式题目模板"></a><a href="https://codeforces.com/blog/entry/45307" target="_blank" rel="noopener">交互式题目模板</a></h3><p><a href="https://codeforces.com/gym/101021/problem/1" target="_blank" rel="noopener">gym101021: Guess the Number</a><br>需要 <code>fflush(stdout);</code>（对于 <code>scanf/printf</code>） 或 <code>std:::cout &lt;&lt; std::flush</code> （对于 <code>std::cin/std::cout</code>） 来刷新缓冲区，不过 <code>std::endl</code> 会自动刷新一次缓冲区，所以此时可以省略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1e6</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'&lt;'</span>) r = m - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>交互题测试例子：先假设一组答案，按照自己的程序计算出每次 query 的答案，最好用文件输入输出测试。</p>
</blockquote>
<h3 id="负数下标技巧"><a href="#负数下标技巧" class="headerlink" title="负数下标技巧"></a>负数下标技巧</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> aa[N];</span><br><span class="line"><span class="keyword">int</span> *a = (aa + N / <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可用于 $O(1)$ 首尾插入或删除元素，访问第 $i$ 个元素。<br>当然也可以用 <code>std::deque</code> 加一个标号，实现上述操作</p>
</blockquote>
<h3 id="优雅的输出技巧"><a href="#优雅的输出技巧" class="headerlink" title="优雅的输出技巧"></a>优雅的输出技巧</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" \n"</span>[i == n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模正数向下取整：-lfloor-frac-a-n-rfloor-和-模正数向下取整：-lceil-frac-a-n-rceil"><a href="#模正数向下取整：-lfloor-frac-a-n-rfloor-和-模正数向下取整：-lceil-frac-a-n-rceil" class="headerlink" title="模正数向下取整：$\lfloor \frac{a}{n} \rfloor$ 和 模正数向下取整：$\lceil \frac{a}{n} \rceil$"></a>模正数向下取整：$\lfloor \frac{a}{n} \rfloor$ 和 模正数向下取整：$\lceil \frac{a}{n} \rceil$</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">floor</span><span class="params">(LL a, LL n)</span> </span>&#123; <span class="comment">// n &gt; 0</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; <span class="number">0</span> ? (a - n + <span class="number">1</span>) / n : a / n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ceil</span><span class="params">(LL a, LL n)</span> </span>&#123; <span class="comment">// n &gt; 0</span></span><br><span class="line">	<span class="keyword">return</span> a &lt; <span class="number">0</span> ? a / n : (a + n - <span class="number">1</span>) / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到 C/C++ 中 ，整数除法 <code>/</code> 是向 <code>0</code> 取整(<code>int(x)</code>也是向 0 取整)，但是 Python（Sagemath） 整数除法 <code>//</code> 是向下取整。在 C++ 中一定不要用 <code>(x - 1) / n + 1</code> 的姿势向上取整！！！</p>
</blockquote>
<h3 id="Floor-sum-displaystyle-sum-i-0-n-1-lfloor-frac-a-cdot-i-b-m-rfloor"><a href="#Floor-sum-displaystyle-sum-i-0-n-1-lfloor-frac-a-cdot-i-b-m-rfloor" class="headerlink" title="Floor_sum : $\displaystyle \sum_{i = 0}^{n - 1} \lfloor \frac{a \cdot i + b}{m} \rfloor$"></a>Floor_sum : $\displaystyle \sum_{i = 0}^{n - 1} \lfloor \frac{a \cdot i + b}{m} \rfloor$</h3><blockquote>
<p>注意到这个求和式表示由直线 $x = 0, x = n, y = 0, y = \frac{a}{m}x + \frac{b}{m}$ 构成的梯形内部（仅包含上边界）的整点个数。</p>
</blockquote>
<p>显然我们可以先预处理，使得 $a &lt; m$ 且 $b &lt; m$，此时我们考虑 $y_{\max} = \lfloor \frac{a \cdot n + b}{m} \rfloor$，定义 $x_{\max} = y_{\max} \cdot m - b$，那么 $[\lceil \frac{x_{\max}}{a} \rceil, n)$ 的纵坐标取整值都相等为 $y_{\max}$，然后我们横纵坐标互换（在一张相对透明的纸上画图，然后在另一面看就是）由直线 $x = 0, x = y_{\max}, y = 0, y = \frac{m}{a}x + \frac{b’}{a}$ 构成的梯形内部（不包含边界）的整点个数。其中 $b’ = \lceil \frac{x_{\max}}{a} \rceil \cdot a - x_{\max}$（表示直线 $y = y_{\max}$ 与 $y = \frac{a}{m}x + \frac{b}{m}$ 以及 $x = \lceil \frac{x_{\max}}{a} \rceil$ 相交的长度）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">floorSum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (a &gt;= m) &#123;</span><br><span class="line">		r += LL(a / m) * (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">		a %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b &gt;= m) &#123;</span><br><span class="line">		r += LL(b / m) * n;</span><br><span class="line">		b %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> yMax = (LL(a) * n + b) / m;</span><br><span class="line">	<span class="keyword">if</span> (yMax == <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	LL xMax = LL(yMax) * m - b;</span><br><span class="line">	r += (n - (xMax + a - <span class="number">1</span>) / a) * yMax;</span><br><span class="line">	r += floorSum(yMax, a, m, (a - (xMax % a)) % a);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们可以考虑用长方形整点数减去上部分的整点数（要往上平移一个单位）<strong>这样搞更快</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">floorSum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (a &gt;= m) &#123;</span><br><span class="line">		r += LL(a / m) * (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">		a %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b &gt;= m) &#123;</span><br><span class="line">		r += LL(b / m) * n;</span><br><span class="line">		b %= m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> yMax = (LL(a) * n + b) / m;</span><br><span class="line">	<span class="keyword">if</span> (yMax == <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	r += LL(n - <span class="number">1</span>) * yMax;</span><br><span class="line">	r -= floorSum(yMax, a, m, m - b - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://atcoder.jp/contests/practice2/tasks/practice2_c" target="_blank" rel="noopener">模板例题</a> 和 <a href="https://atcoder.jp/contests/arc111/tasks/arc111_e" target="_blank" rel="noopener">应用例题</a></p>
<h3 id="带取整的函数取最值的技巧"><a href="#带取整的函数取最值的技巧" class="headerlink" title="带取整的函数取最值的技巧"></a>带取整的函数取最值的技巧</h3><ul>
<li>先考虑不取整的情况，然后一般这个值是可能的最小值或者最大值</li>
<li>然后通过循环看是否满足取整的情况</li>
</ul>
<h3 id="Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释"><a href="#Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释" class="headerlink" title="Barrent reduction 快速模，弃用，因为并不会变快… ：wiki 镜像解释"></a><a href="https://en.wikipedia.org/wiki/Barrett_reduction" target="_blank" rel="noopener"><del>Barrent reduction 快速模</del>，弃用，因为并不会变快…</a> ：<a href="https://en.jinzhao.wiki/wiki/Barrett_reduction" target="_blank" rel="noopener">wiki 镜像解释</a></h3><blockquote>
<p>对于给定常数 $M$ 求 <code>a % M</code>，并要求 $ 0 \leq a &lt; M^2$，并且 $a &lt; 2^k$。因此下面 $k$ 的取值还是需要注意的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> LL M  = <span class="number">1e9</span> + <span class="number">7</span>; <span class="comment">// too big, M should satisfy M * M &lt; int</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span>  k = <span class="built_in">std</span>::__lg(M) + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> LL m = (<span class="number">1L</span>L &lt;&lt; k) / M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> mod = [&amp;](<span class="keyword">int</span> a) &#123;</span><br><span class="line">	LL r = a - ((a * m) &gt;&gt; k) * M;</span><br><span class="line">	<span class="keyword">return</span> r &gt;= M ? r - M : r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="输出全排列"><a href="#输出全排列" class="headerlink" title="输出全排列"></a>输出全排列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">std</span>::for_each(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(),[](<span class="keyword">int</span> i)&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="built_in">std</span>::next_permutation(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出全排列的原理"><a href="#输出全排列的原理" class="headerlink" title="输出全排列的原理"></a>输出全排列的原理</h3><p>首先初始状态从小到大排列，然后对每一个状态考虑它的后缀，如果后缀是从大到小排列，再考虑向前一位的后缀，直到不是从大到小排列，然后找比第一个位置大的最小值放在开头，其它位置排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(n)</span>:</span></span><br><span class="line">	ans = []</span><br><span class="line">	cnt = math.factorial(n);</span><br><span class="line">	r = list(range(<span class="number">1</span>, n + <span class="number">1</span>))</span><br><span class="line">	ans.append(r.copy())</span><br><span class="line">	cnt -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">		i = n - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> r[i - <span class="number">1</span>] &gt; r[i]: i -= <span class="number">1</span></span><br><span class="line">		r[i:] = r[i:][::<span class="number">-1</span>]</span><br><span class="line">		j = i</span><br><span class="line">		<span class="keyword">while</span> r[j] &lt; r[i - <span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">		r[i - <span class="number">1</span>], r[j] = r[j], r[i - <span class="number">1</span>]</span><br><span class="line">		ans.append(r.copy())</span><br><span class="line">		cnt -= <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> ans	</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">	print(permutation(i))</span><br></pre></td></tr></table></figure>
<h2 id="初等数论"><a href="#初等数论" class="headerlink" title="初等数论"></a>初等数论</h2><h3 id="Greatest-Common-divisor"><a href="#Greatest-Common-divisor" class="headerlink" title="Greatest Common divisor"></a>Greatest Common divisor</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简洁写法，不推荐，推荐使用内建 __gcd</span></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lambda 表达式写法，开头不能是auto因为递归</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; gcd = [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 快速版本 https://cp-algorithms.com/algebra/euclid-algorithm.html</span></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!a || !b) <span class="keyword">return</span> a | b;</span><br><span class="line">	<span class="keyword">unsigned</span> shift = __builtin_ctzll(a | b);</span><br><span class="line">	a &gt;&gt;= __builtin_ctzll(a);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		b &gt;&gt;= __builtin_ctzll(b);</span><br><span class="line">		<span class="keyword">if</span> (a &gt; b) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">		b -= a;</span><br><span class="line">	&#125; <span class="keyword">while</span> (b);</span><br><span class="line">	<span class="keyword">return</span> a &lt;&lt; shift;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通版拓展GCD</span></span><br><span class="line"><span class="function">LL <span class="title">exGcd</span><span class="params">(LL a, LL b, LL&amp; x, LL&amp; y)</span></span>&#123;  <span class="comment">// ax + by = gcd(a,b)</span></span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">		x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	LL d = exgcd(b, a % b, y, x);</span><br><span class="line">	y -= a / b * x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++17版拓展GCD，优雅了不少!</span></span><br><span class="line">std::tuple&lt;LL, LL, LL&gt; exGcd(LL a, LL b) &#123;  // ax + by = gcd(a,b)</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> &#123;a, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> [d, y, x] = exGcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> &#123;d, x, y - a / b * x&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n"><a href="#Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n" class="headerlink" title="Sum of least common multiple  $s_n =  \sum_{i=1} ^n lcm(i,n)$"></a>Sum of least common multiple  $s_n =  \sum_{i=1} ^n lcm(i,n)$</h3><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1} ^n lcm(i,n) 
&= \sum_{i=1} ^n \frac{i \cdot n}{\gcd(i,n)} \\
&= n \sum_{d|n} \sum_{\gcd(i,\frac{n}{d})= 1} i \\
&= \frac{n}{2} \sum_{d|n} \frac{n}{d} \psi(\frac{n}{d}) \\
&= \frac{n}{2} \sum_{d|n} d \psi(d)
\end{aligned}</script><p>所以，我们可以在 $O(n \log n)$ 处理好 $s_n$ 的前 $n$ 项。</p>
<h3 id="Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-lcm-i-j"><a href="#Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-lcm-i-j" class="headerlink" title="Double sum of least common multiple $ds_n = \sum_{1 \leq i \leq j \leq n} lcm(i,j)$"></a>Double sum of least common multiple $ds_n = \sum_{1 \leq i \leq j \leq n} lcm(i,j)$</h3><p>本来这个也挺麻烦，但是可以借助 $s_n$ 计算：$ds_n =  \sum_{j=1} ^n s_j$，所以复杂度就一致了。当然也可以直接化简成：</p>
<script type="math/tex; mode=display">
\sum_{1 \leq i \leq j \leq n} lcm(i,j) = \sum_{i = 1} ^ n \frac{i}{4} \psi(i) \lfloor \frac{n}{i} \rfloor (\lfloor \frac{n}{i} \rfloor + 1)</script><blockquote>
<p>不借助 $s_n$ 其实也能暴力搞出来的。</p>
</blockquote>
<h3 id="模乘法逆元"><a href="#模乘法逆元" class="headerlink" title="模乘法逆元"></a>模乘法逆元</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a, LL p)</span></span>&#123; <span class="comment">// 0 &lt; a &lt; p and gcd(a,p) = 1</span></span><br><span class="line">	<span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (p - p / a) * inv(p % a, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码主要用于线性时间预处理所有$p$以内的逆元，对于较小的常数$a$, 可以直接试除 <code>b p mod a == 1</code><br>用下面快速幂也可以求逆，<code>inv</code> 的步数平均下面显著的比快速幂小，但是由于用到了递归，因此最终它们的平均效率是一致的。<br>可以通过预处理小部分值达到快速的效果。</p>
</blockquote>
<h3 id="快速模乘法"><a href="#快速模乘法" class="headerlink" title="快速模乘法"></a>快速模乘法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0 &lt;= x &lt; p &lt; INT_MAX</span></span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n, LL p)</span></span>&#123;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) r = r * x % p;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; x = x * x % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用 for 循环写的更短一点，但没必要，若 <code>p &lt; INT64_MAX</code> 就需要使用 <code>__int128</code> 了。现代计算机都是 64 位的，因此处理 int 跟 long long 基本没有时间差异，直接用 LL 避免了强制类型转化，因此效率反而更高。但是 <code>__int128</code> 就不同了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0 &lt;= x &lt; p &lt; INT64_MAX</span></span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n, LL p)</span></span>&#123;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) r = __int128(r) * x % p;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; x = __int128(x) * x % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阶乘、组合数、Lucas-定理"><a href="#阶乘、组合数、Lucas-定理" class="headerlink" title="阶乘、组合数、Lucas 定理"></a>阶乘、组合数、Lucas 定理</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">2</span>;</span><br><span class="line">LL fac[N], ifac[N];</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (M - M / a) * inv(M % a) % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">	ifac[N - <span class="number">1</span>] = inv(fac[N - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; --i) ifac[i - <span class="number">1</span>] = ifac[i] * i % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//if (n &lt; k || n &lt; 0) return 0;</span></span><br><span class="line">	<span class="keyword">return</span> fac[n] * ifac[k] % M * ifac[n - k] % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lucas</span><span class="params">(LL n, LL m, LL p)</span> </span>&#123; <span class="comment">// C(n,m)%p, 仅在p较少时发挥作用</span></span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n &amp;&amp; m) &#123;</span><br><span class="line">		LL np = n % p, mp = m % p;</span><br><span class="line">		<span class="keyword">if</span> (np &lt; mp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		r = binom(np, mp);</span><br><span class="line">		n /= p, m /= p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用组合数公式"><a href="#常用组合数公式" class="headerlink" title="常用组合数公式"></a>常用组合数公式</h3><p>对任意实数，定义：$\binom{\alpha}{k} = \frac{\alpha(\alpha - 1) \cdots (\alpha - k + 1)}{k !}$ 所以我们有：</p>
<script type="math/tex; mode=display">
\binom{-n}{k} = (-1)^{k} \binom{n + k - 1}{k}</script><script type="math/tex; mode=display">
\binom{n + 1}{k + 1} = \binom{n}{k} + \binom{n}{k + 1}</script><blockquote>
<p>最后一个数，先还是不选，这是一个问题。</p>
</blockquote>
<script type="math/tex; mode=display">
{n \choose k}{k \choose i}  = {n \choose i} {n - i \choose k - i}</script><blockquote>
<p>组合意义理解：$n$ 个人中选出 $i$ 个一流人才， $k - i$ 个二流人才。</p>
</blockquote>
<script type="math/tex; mode=display">{n + m \choose k} = \sum_{i + j = k} {n \choose i} {m \choose j}</script><blockquote>
<p>组合意义理解：$n, m$ 两个堆选出 $k$ 个人。</p>
</blockquote>
<h3 id="乞丐版素数判断"><a href="#乞丐版素数判断" class="headerlink" title="乞丐版素数判断"></a>乞丐版素数判断</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span> || n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-n-log-n-素数筛"><a href="#O-n-log-n-素数筛" class="headerlink" title="$O(n \log n)$ 素数筛"></a>$O(n \log n)$ 素数筛</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =  <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> isP[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(isP[<span class="number">2</span>]) <span class="keyword">return</span>;</span><br><span class="line">	isP[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isP[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isP[i]) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span> * i; j &lt; N; j += i * <span class="number">2</span>) &#123;</span><br><span class="line">			isP[j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性素数筛（正式使用版）"><a href="#欧拉线性素数筛（正式使用版）" class="headerlink" title="欧拉线性素数筛（正式使用版）"></a>欧拉线性素数筛（正式使用版）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initPrimeP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	p.emplace_back(<span class="number">2</span>);</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> sq = <span class="keyword">int</span>(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(N + <span class="number">0.1</span>))|<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= sq; i += <span class="number">2</span>) <span class="keyword">if</span> (isp[i]) &#123;</span><br><span class="line">		p.emplace_back(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; N; j += i &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">			isp[j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = sq + <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isp[i]) p.emplace_back(i);</span><br><span class="line">	<span class="keyword">return</span> p.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性素数筛（弃用）"><a href="#欧拉线性素数筛（弃用）" class="headerlink" title="欧拉线性素数筛（弃用）"></a>欧拉线性素数筛（弃用）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrimeP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	p.emplace_back(<span class="number">2</span>);</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) p.emplace_back(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j != p.<span class="built_in">size</span>() &amp;&amp; p[j] &lt; t; ++j) &#123; <span class="comment">// 用除号是防止溢出</span></span><br><span class="line">			isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="comment">// 不要下面的一步的话，复杂度 O(nloglogn), 但是不用除法，常数小</span></span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-1-（执行）时间复杂度判断一个数是否为素数"><a href="#O-1-（执行）时间复杂度判断一个数是否为素数" class="headerlink" title="$O(1)$ （执行）时间复杂度判断一个数是否为素数"></a>$O(1)$ （执行）时间复杂度判断一个数是否为素数</h3><blockquote>
<p>奇技淫巧来源：<a href="https://codeforces.com/blog/entry/79941#comment-659202" target="_blank" rel="noopener">https://codeforces.com/blog/entry/79941#comment-659202</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sieve</span> &#123;</span></span><br><span class="line">	<span class="keyword">bool</span> isP[N];</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">Sieve</span><span class="params">()</span>: <span class="title">isP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		isP[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isP[i] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isP[i]) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span> * i; j &lt; N; j += i * <span class="number">2</span>) &#123;</span><br><span class="line">					isP[j] = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// MAXN 默认最大值为1&lt;&lt;18=262144, 调节参数 -fconstexpr-loop-limit= 例如：</span></span><br><span class="line"><span class="comment">// g++ main.cpp -std=c++17 -fconstexpr-loop-limit=12345678 -fconstexpr-ops-limit=1234567890</span></span><br><span class="line"><span class="comment">// 使得 MAXN = 1e7+2</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fast_is_prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> Sieve&lt;MAXN&gt; s;</span><br><span class="line">	<span class="keyword">return</span> s.isP[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大素数-Miller-Rabin-概率判别法-和-大整数的最-大-小-因子分解"><a href="#大素数-Miller-Rabin-概率判别法-和-大整数的最-大-小-因子分解" class="headerlink" title="大素数 Miller-Rabin 概率判别法 和 大整数的最 大/小 因子分解"></a>大素数 Miller-Rabin 概率判别法 和 大整数的最 大/小 因子分解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> PollardRho &#123;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::mt19937 <span class="title">rnd</span><span class="params">(<span class="built_in">std</span>::chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n, LL p)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = __int128(r) * x % p;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;   x = __int128(x) * x % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 &lt; a &lt; n，若 n 是素数，那么 a^(n - 1) = 1 mod n</span></span><br><span class="line"><span class="comment">// m - 1 = m * 2 ^ t，返回 false 表示判断失败</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">witness</span><span class="params">(LL a, LL n, LL m, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	LL x = powMod(a, m, n);</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		x = __int128(x) * x %  n;</span><br><span class="line">		<span class="keyword">if</span> (x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TIMES = <span class="number">52</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LL m = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> t = __builtin_ctzll(m);</span><br><span class="line">	m &gt;&gt;= t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>; cnt &lt; TIMES; ++cnt) &#123;</span><br><span class="line">		LL a = rnd() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (witness(a, n, m, t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pollardrho</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	LL x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">1</span>, i = <span class="number">1</span>, k = <span class="number">2</span>, c = rnd() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		x = (__int128(x) * x + c) % n;</span><br><span class="line">		z = __int128(y - x + n) * z % n;</span><br><span class="line">		<span class="comment">// 累计 gcd 一次计算！太猛了啊 茶茶白</span></span><br><span class="line">		<span class="keyword">if</span> (++i == k) &#123;</span><br><span class="line">			LL d = <span class="built_in">std</span>::__gcd(z, n);</span><br><span class="line">			<span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">			y = x;</span><br><span class="line">			<span class="keyword">if</span> (k &gt; n) <span class="keyword">return</span> n;</span><br><span class="line">			k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">spf</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rabin(n) || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">	LL d = n;</span><br><span class="line">	<span class="keyword">while</span> (d == n) d = pollardrho(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">min</span>(spf(d), spf(n / d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">gpf</span><span class="params">(LL n, LL mxf = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rabin(n)) <span class="keyword">return</span> n;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= mxf) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	LL d = n;</span><br><span class="line">	<span class="keyword">while</span> (d == n) d = pollardrho(n);</span><br><span class="line">	LL res = gpf(d, mxf);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">max</span>(res, gpf(n / d, <span class="built_in">std</span>::<span class="built_in">max</span>(res, mxf)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="O-n-最小素因子预处理"><a href="#O-n-最小素因子预处理" class="headerlink" title="$O(n)$ 最小素因子预处理"></a>$O(n)$ 最小素因子预处理</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e8</span>; <span class="comment">// 再大内存吃不消了 </span></span><br><span class="line"><span class="keyword">int</span> sp[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt;= sp[i] &amp;&amp; i * p[j] &lt; N; ++j) &#123; <span class="comment">//防止乘法溢出</span></span><br><span class="line">			sp[i * p[j]] = p[j]; <span class="comment">// 注意到sp只被赋值一次</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mobius-function"><a href="#Mobius-function" class="headerlink" title="Mobius function"></a>Mobius function</h3><blockquote>
<p>另类递推公式： $ \mu(i) = - \sum_{d \mid i, d &lt; i} \mu(d) $。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 乞丐版</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line">		n /= <span class="number">2</span>;</span><br><span class="line">		r = -r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">			n /= i;</span><br><span class="line">			<span class="keyword">if</span>(n % i  == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			r = -r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n &gt; <span class="number">1</span> ? -r : r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(n log n) 预处理版本</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e6</span> +<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt; N; j += i) &#123;</span><br><span class="line">			mu[j] -= mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n) 预处理版</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e6</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="keyword">int</span> p[N], mu[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(mu[<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) mu[i] = <span class="number">-1</span>, p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j) &#123;</span><br><span class="line">			isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			mu[i * p[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">4</span>) mu[i] = -mu[i &gt;&gt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mobius-function-前缀和"><a href="#Mobius-function-前缀和" class="headerlink" title="Mobius function 前缀和"></a>Mobius function 前缀和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sumMu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSumMu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mu[<span class="number">1</span>] != <span class="number">1</span>) initmu();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) sumMu[i] = sumMu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSumMu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// M(n) = M(n-1) + mu(n)</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> sumMu[n];</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= (j - i + <span class="number">1</span>) * sumMu(n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Mobius function 绝对值前缀和</span></span><br><span class="line"><span class="function">LL <span class="title">getSumAbsMu</span><span class="params">(LL n)</span> </span>&#123; <span class="comment">// Q(n) = Q(n-1) + |mu(n)|</span></span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>, t; (t = i * i) &lt; n; ++i) &#123;</span><br><span class="line">		r += mu[i] * (n / t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Euler’s-totient-function"><a href="#Euler’s-totient-function" class="headerlink" title="Euler’s totient function"></a>Euler’s totient function</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> phi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPhi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (phi[<span class="number">2</span>] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) phi[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) phi[i] = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (phi[i] != i) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j += i) phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPhi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = (n % <span class="number">2</span> == <span class="number">0</span> ? n/<span class="number">2</span> : n);</span><br><span class="line">	<span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>) n/=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i  == <span class="number">0</span>) &#123;</span><br><span class="line">			r = r / i *(i<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">while</span> (n % i == <span class="number">0</span>) n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>) r = r / n * (n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">LL sumPhi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSumphi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (phi[<span class="number">2</span>] != <span class="number">1</span>) initPhi();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) sumPhi[i] = sumPhi[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, LL&gt; mp;</span><br><span class="line"><span class="function">LL <span class="title">getSumphi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> (LL) sumPhi[n];</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	LL r = LL(n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= (j - i + <span class="number">1</span>) * getSumphi(n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展-Euler-定理"><a href="#拓展-Euler-定理" class="headerlink" title="拓展 Euler 定理"></a>拓展 Euler 定理</h3><p>数论中欧拉定义说：若 $\gcd(a, m) = 1$ 则 $a^{\phi(m)} \equiv 1 \mod m$。</p>
<p>类似于拓展的 Fermat 小定理：$a^p \equiv a \mod p$，我们有拓展 Euler 定理：</p>
<script type="math/tex; mode=display">
a^n \equiv a^{n \mod \phi(m) + phi(m)} \mod m</script><p>证明对 m 素因子分解，再利用 Euler 函数是可乘函数，显然。</p>
<h3 id="pi-x-函数"><a href="#pi-x-函数" class="headerlink" title="$\pi(x)$ 函数"></a>$\pi(x)$ 函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span> * <span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">11</span> * <span class="number">13</span> * <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM + <span class="number">1</span>][M + <span class="number">1</span>], sz[M + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	initprime();</span><br><span class="line">	pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		pi[i] = pi[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) ++pi[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sz[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= PM; ++i) phi[i][<span class="number">0</span>] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">		sz[i] = p[i] * sz[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= PM; ++j) &#123;</span><br><span class="line">			phi[j][i] = phi[j][i - <span class="number">1</span>] - phi[j / p[i]][i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s &lt;= M) <span class="keyword">return</span> phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];</span><br><span class="line">	<span class="keyword">if</span> (x / p[s] &lt;= p[s]) <span class="keyword">return</span> primepi(x) - s + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x / p[s] / p[s] &lt;= p[s] &amp;&amp; x &lt; N) &#123;</span><br><span class="line">		<span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>))];</span><br><span class="line">		LL ans = pi[x] - (s2x + s - <span class="number">2</span>) * (s2x - s + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt;= s2x; ++i) &#123;</span><br><span class="line">			ans += pi[x / p[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> primephi(x, s - <span class="number">1</span>) - primephi(x / p[s], s - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; N) <span class="keyword">return</span> pi[x];</span><br><span class="line">	<span class="keyword">int</span> ps2x = primepi(<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>)));</span><br><span class="line">	<span class="keyword">int</span> ps3x = primepi(<span class="keyword">int</span>(cbrt(x + <span class="number">0.2</span>)));</span><br><span class="line">	LL ans = primephi(x, ps3x) + LL(ps2x + ps3x - <span class="number">2</span>) * (ps2x - ps3x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = ps3x + <span class="number">1</span>, ed = ps2x; i &lt;= ed; ++i) &#123;</span><br><span class="line">		ans -= primepi(x / p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pi-x-函数计算的另一种做法"><a href="#pi-x-函数计算的另一种做法" class="headerlink" title="$\pi(x)$ 函数计算的另一种做法"></a>$\pi(x)$ 函数计算的另一种做法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">2</span>;</span><br><span class="line">LL L[N], R[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">	LL rn = (LL) <span class="built_in">sqrt</span>(n + <span class="number">0.2</span>);</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= rn; ++i) R[i] = n / i - <span class="number">1</span>;</span><br><span class="line">	LL ln = n / (rn + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= ln; ++i) L[i] = i - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL p = <span class="number">2</span>; p &lt;= rn; ++p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L[p] == L[p - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (LL i = <span class="number">1</span>, tn = <span class="built_in">std</span>::<span class="built_in">min</span>(n / (p * p), rn); i &lt;= tn; ++i) &#123;</span><br><span class="line">			R[i] -= (i * p &lt;= rn ? R[i * p] : L[n / (i * p)]) - L[p - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (LL i = ln; i &gt;= p * p; --i) &#123;</span><br><span class="line">			L[i] -= L[i / p] - L[p - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求奇素数的一个原根"><a href="#求奇素数的一个原根" class="headerlink" title="求奇素数的一个原根"></a>求奇素数的一个原根</h3><blockquote>
<p>代码懒得贴，实际上暴力就可以了</p>
</blockquote>
<p>首先，模 $m$ 有原根的充要条件是：$m=2,4,p^a,2p^a$，其中 $p$ 为奇素数。</p>
<p>对于求模 $p$ 的原根方法：对 $p-1$ 素因子分解：$p-1 = p_1^{a_1} \cdots p_s^{a_s}$ 若恒有 </p>
<script type="math/tex; mode=display">
g^{\frac{p-1}{p_i}} \neq 1(\mod \; p)</script><p>则 $g$ 是 模 $p$ 的原根。对于 $p^a$ 可以用 $p$ 的原根简单构造，而 $2p^a$ 的原根为 $p^a$ 的原根与 $p^a$ 的原根和 $p^a$的和中奇数者。(证明见 P150《数论基础》潘承洞)</p>
<blockquote>
<p>求所有原根见 </p>
</blockquote>
<h3 id="数论函数的-Dirichlet-乘积"><a href="#数论函数的-Dirichlet-乘积" class="headerlink" title="数论函数的 Dirichlet 乘积"></a>数论函数的 Dirichlet 乘积</h3><p>以前的代码不想贴了，不优雅，下次有题做的时候补上。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/chineseRemainTheorem/" title="中国剩余定理">中国剩余定理</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;LL,LL&gt; crt2(LL a1,LL m1,LL a2,LL m2)&#123; // x = ai mod mi, m_i &gt;0</span><br><span class="line">	LL t1,t2,ans = a2-a1;</span><br><span class="line">	LL d = exgcd(m1,m2,t1,t2);</span><br><span class="line">	assert(ans%d == <span class="number">0</span>);</span><br><span class="line">	LL m = m1/d*m2;</span><br><span class="line">	ans = (a1+ans/d*t1%m2*m1)%m; <span class="comment">// %m2 是避免溢出</span></span><br><span class="line">	<span class="keyword">return</span> make_pair(ans&gt;<span class="number">0</span>?ans:ans+m,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span>;</span><br><span class="line">LL a[N],m[N];</span><br><span class="line">pair&lt;LL,LL&gt; crt(int n)&#123; // x = a[i] mod m[i], m[i] &gt;0</span><br><span class="line">	pair&lt;LL,LL&gt; ans = make_pair(a[<span class="number">0</span>]%m[<span class="number">0</span>],m[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">		ans = crt2(ans.first,ans.second,a[i],m[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a><a href="http: //blog.miskcoo.com/2015/05/discrete-logarithm-problem">离散对数</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">baby_step_giant_step</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123; <span class="comment">// a^x = b mod p</span></span><br><span class="line">	a %= p, b %= p;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b % p ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LL cnt = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (LL g = <span class="built_in">std</span>::__gcd(a, p); g != <span class="number">1</span>; g = <span class="built_in">std</span>::__gcd(a, p)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		p /= g, b /= g, t = t * (a / g) % p;</span><br><span class="line">		++cnt;</span><br><span class="line">		<span class="keyword">if</span> (b == t) <span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;LL, LL&gt; mp;</span><br><span class="line">	LL m = LL(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(p + <span class="number">0.1</span>) + <span class="number">1</span>);</span><br><span class="line">	LL base = b;</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">0</span>; i != m; ++i) &#123;</span><br><span class="line">		mp[base] = i;</span><br><span class="line">		base = base * a % p;</span><br><span class="line">	&#125;</span><br><span class="line">	base = powMod(a, m, p);</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		t = t * base % p;</span><br><span class="line">		<span class="keyword">if</span> (mp.count(t)) <span class="keyword">return</span> i * m - mp[t] + cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模素数开根号"><a href="#模素数开根号" class="headerlink" title="模素数开根号"></a>模素数开根号</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">modsqrt</span><span class="params">(LL a, LL p)</span> </span>&#123; <span class="comment">// find x s.t x*x=a mod p;</span></span><br><span class="line">	a = (p + a % p) % p;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">2</span>) <span class="keyword">return</span> (a &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	LL q = (p - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (powMod(a, q, p) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (q &amp; <span class="number">1</span>) <span class="keyword">return</span> powMod(a, (q + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line">	LL b, cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (powMod(b = rand() % p, q, p) == <span class="number">1</span>); <span class="comment">//find a non quadratic residue</span></span><br><span class="line">	<span class="keyword">while</span> (!(q &amp; <span class="number">1</span>)) ++cnt, q &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	b = powMod(b, q, p);</span><br><span class="line">	LL x = powMod(a, (q + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line">	<span class="keyword">for</span> (LL s = <span class="number">1</span>, t = powMod(a, q, p); t != <span class="number">1</span>; s = <span class="number">1</span>) &#123; <span class="comment">//keep x*x=t*a;t^&#123;2^&#123;cnt-1&#125;&#125;=1</span></span><br><span class="line">		<span class="keyword">for</span> (LL tt = t * t % p; s &lt; cnt &amp;&amp; tt != <span class="number">1</span>; ++s) tt = tt * tt % p;</span><br><span class="line">		LL d = powMod(b, <span class="number">1</span> &lt;&lt; (cnt - s - <span class="number">1</span>), p);</span><br><span class="line">		x = (x * d) % p;</span><br><span class="line">		b = d * d % p;</span><br><span class="line">		t = t * b % p;</span><br><span class="line">		cnt = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mod_sqrt</span><span class="params">(LL a, LL p, <span class="keyword">int</span> k = <span class="number">1</span>)</span> </span>&#123; <span class="comment">//find smallest x&gt;=0 s.t x*x=a mod p^k</span></span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ka = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (a % p == <span class="number">0</span>) a /= p, ++ka, --k;</span><br><span class="line">	<span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ka &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">auto</span> <span class="built_in">pow</span> = [](LL x, <span class="keyword">int</span> n) &#123;</span><br><span class="line">		LL r=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, x *= x)  <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r *= x;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	LL n = <span class="built_in">pow</span>(p, k), x;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">1</span> || k == <span class="number">2</span>) x = a == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a % <span class="number">8</span> != <span class="number">1</span>) x = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			x = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((x * x) % (<span class="number">1</span> &lt;&lt; i) == a % (<span class="number">1</span> &lt;&lt; i)) <span class="keyword">continue</span>;</span><br><span class="line">				x += <span class="number">1</span> &lt;&lt; (i - <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> x = mod_sqrt_p(a, n, p, k);</span><br><span class="line">	<span class="keyword">return</span> x == <span class="number">-1</span> ? <span class="number">-1</span> : <span class="built_in">pow</span>(p, ka &gt;&gt; <span class="number">1</span>) * (x &lt; n - x ? x : n - x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于模一般的 $n$，先素因子分解分别求出答案，然后用中国剩余定理求最终解。</p>
</blockquote>
<h3 id="自然数方幂和-O-k-算法"><a href="#自然数方幂和-O-k-算法" class="headerlink" title="自然数方幂和 $O(k)$ 算法"></a>自然数方幂和 $O(k)$ 算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> sp[N], p[N];</span><br><span class="line">LL inv[N], AP[N], AS[N], f[N];</span><br><span class="line"><span class="function">LL <span class="title">getPowSum</span><span class="params">(LL n, <span class="keyword">int</span> k, LL mod)</span> </span>&#123; <span class="comment">// mod &gt; k</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> n % mod;</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">2</span>) spf();</span><br><span class="line">	<span class="keyword">int</span> nk = k + <span class="number">1</span>;</span><br><span class="line">	LL tmp = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk; ++i) tmp = tmp * i % mod;</span><br><span class="line">	inv[nk] = powMod(tmp, mod - <span class="number">2</span>, mod);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) f[i] = powMod(i, k, mod);</span><br><span class="line">		<span class="keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]] % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (f[i] &gt;= mod) f[i] -= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= nk) <span class="keyword">return</span> f[n];</span><br><span class="line">	AP[<span class="number">0</span>] = AS[nk] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) AP[i] = AP[i - <span class="number">1</span>] * (n + <span class="number">1</span> - i) % mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) AS[i] = AS[i + <span class="number">1</span>] * (n - i - <span class="number">1</span>) % mod;</span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) &#123; <span class="comment">// because f(i)=0</span></span><br><span class="line">		LL x = f[i] * AP[i] % mod * AS[i] % mod * inv[i] % mod * inv[nk - i] % mod;</span><br><span class="line">		<span class="keyword">if</span> ((nk - i) &amp; <span class="number">1</span>) res -= x; <span class="comment">// be careful</span></span><br><span class="line">		<span class="keyword">else</span> res += x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res % mod + mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自然数方幂和精确版"><a href="#自然数方幂和精确版" class="headerlink" title="自然数方幂和精确版"></a>自然数方幂和精确版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> BINT = boost::multiprecision::cpp_int;</span><br><span class="line"></span><br><span class="line">BINT f[N];</span><br><span class="line"><span class="function">BINT <span class="title">getPowSum</span><span class="params">(LL n, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// k&lt;1000</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> BINT(n);</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="number">2</span>) spf();</span><br><span class="line">	<span class="keyword">int</span> nk = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> bPow = [](BINT x, <span class="keyword">int</span> n) -&gt; BINT &#123;</span><br><span class="line">		BINT r(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (; n; x *= x, n &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r *= x;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) f[i] = bPow(BINT(i), k);</span><br><span class="line">		<span class="keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= nk) <span class="keyword">return</span> f[n];</span><br><span class="line">	BINT res = <span class="number">0</span>, tl = <span class="number">1</span>, tr = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) tr = tr * (n - i - <span class="number">1</span>) / (nk - i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((nk - i) &amp; <span class="number">1</span>) res -= f[i] * tl * tr;</span><br><span class="line">		<span class="keyword">else</span> res += f[i] * tl * tr;</span><br><span class="line">		tl = tl * (n - i) / (i + <span class="number">1</span>);</span><br><span class="line">		tr = tr * (nk - i) / (n - i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要下载<a href="https://www.boost.org/" target="_blank" rel="noopener">boost 包</a> 类似的包还有 NTL，GMP</p>
</blockquote>
<h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><p>在 codeforces 上 <code>zscoder</code> 大佬给了一个 <a href="https://codeforces.com/blog/entry/77468" target="_blank" rel="noopener">入门教程</a> 和 <a href="https://codeforces.com/blog/entry/77551" target="_blank" rel="noopener">进阶教程</a> 还有 <code>MiFaFaOvO</code> 的 <a href="https://codeforces.com/blog/entry/76447" target="_blank" rel="noopener">终极教程</a></p>
<p>生成函数分两种：Original generating function，Expentional generating function，选择哪一种是看问题中是否牵扯组合数。无论哪一种都能保存原数列的全部信息，并且由于级数可以使用微积分和常微分方程的技术，所以会变得更好处理。然后大概率可以优化算法复杂度 $O(n^2) \to O(n \log n)$ </p>
<p>关于生成函数多项式的处理：<a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">https://cp-algorithms.com/algebra/polynomial.html</a></p>
<p>多项式高效运算模板：<a href="https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp" target="_blank" rel="noopener">https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp</a></p>
<p><strong>生成函数一般的处理思路</strong>：计算生成函数，分解成有分母不超过二次的分式之和，然后每一个二次的分母部分找一个递推数列来搞定。</p>
<p><a href="https://oi-wiki.org/math/poly/intro/" target="_blank" rel="noopener">OI-wiki 多项式运算</a></p>
<h3 id="多项式取对数和指数"><a href="#多项式取对数和指数" class="headerlink" title="多项式取对数和指数"></a>多项式取对数和指数</h3><p>$B(z) = e^{A(z)}$，即 $A(z) = \ln B(z)$ (不妨假设 $A(0) = 0$ 或等价地 $B(0) = 1$)</p>
<p>那么 $B’(z) = A’(z) \cdot B(z)$, 所以 $[z^{n - 1}] B’(z) = \sum_{k = 0}^{n - 1} [z^k] A’(z) \cdot B(z) [z^{n - 1 - k}] = \sum_{k = 1}^{n} [z^{k - 1}] A’(z) \cdot B(z) [z^{n-k}]$，从而</p>
<script type="math/tex; mode=display">
n [z^n] B(z) = \sum_{k = 1}^n k [z^k] A(z) \cdot B(z) [z^{n - k}]</script><p>上式等价于</p>
<script type="math/tex; mode=display">
n [z^n] A(z) = n [z^n] B(z) - \sum_{k = 1}^{n - 1} k [z^k] A(z) \cdot B(z) [z^{n - k}]</script><blockquote>
<p>参考：<a href="https://www.cnblogs.com/Soulist/p/13758388.html" target="_blank" rel="noopener">Soulist</a></p>
</blockquote>
<h3 id="NFT-正式可用版-last-updated-2020-7-9"><a href="#NFT-正式可用版-last-updated-2020-7-9" class="headerlink" title="NFT 正式可用版(last updated: 2020/7/9)"></a>NFT 正式可用版(last updated: 2020/7/9)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>, ROOT = <span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		x = x * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; j) <span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = a.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			(j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a, <span class="keyword">bool</span> isInverse = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">	LL g = powMod(ROOT, (M - <span class="number">1</span>) / a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span> (isInverse) &#123;</span><br><span class="line">		g = powMod(g, M - <span class="number">2</span>);</span><br><span class="line">		LL invLen = powMod(LL(a.<span class="built_in">size</span>()), M - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) x = x * invLen % M;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(a);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != w.<span class="built_in">size</span>(); ++i) w[i] = w[i - <span class="number">1</span>] * g % M;</span><br><span class="line">	<span class="keyword">auto</span> addMod = [](LL x, LL y) &#123;</span><br><span class="line">		<span class="keyword">return</span> (x += y) &gt;= M ? x -= M : x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">2</span>, half = <span class="number">1</span>; half != a.<span class="built_in">size</span>(); <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>, half &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, wstep = a.<span class="built_in">size</span>() / <span class="built_in">step</span>; i != a.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j != i + half; ++j) &#123;</span><br><span class="line">				LL t = (a[j + half] * w[wstep * (j - i)]) % M;</span><br><span class="line">				a[j + half] = addMod(a[j], M - t);</span><br><span class="line">				a[j] = addMod(a[j], t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&amp; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (sz &lt; tot) sz *= <span class="number">2</span>;</span><br><span class="line">	a.resize(sz);</span><br><span class="line">	b.resize(sz);</span><br><span class="line">	nft(a);</span><br><span class="line">	nft(b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != sz; ++i) a[i] = a[i] * b[i] % M;</span><br><span class="line">	nft(a, <span class="number">1</span>);</span><br><span class="line">	a.resize(tot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="siyuan-的-FWT-模板-（弃用）"><a href="#siyuan-的-FWT-模板-（弃用）" class="headerlink" title="siyuan 的 FWT 模板 （弃用）"></a><a href="https://blog.orzsiyuan.com/archives/Fast-Walsh-Hadamard-Transform/" target="_blank" rel="noopener">siyuan 的 FWT 模板</a> （弃用）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x += y) &gt;= P &amp;&amp; (x -= P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FWT</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; N &lt; n; N &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j + m], a[i + j]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j + m], a[i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j], a[i + j + m]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j], a[i + j + m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTxor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), inv2 = (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = a[i + j + m];</span><br><span class="line">                <span class="keyword">if</span> (!rev) &#123;</span><br><span class="line">                    a[i + j] = (x + y) % P;</span><br><span class="line">                    a[i + j + m] = (x - y + P) % P;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[i + j] = <span class="number">1L</span>L * (x + y) * inv2 % P;</span><br><span class="line">                    a[i + j + m] = <span class="number">1L</span>L * (x - y + P) * inv2 % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Or</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">And</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTand(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTand(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTand(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Xor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTxor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTxor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTxor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; fwt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    std::vector&lt;int&gt; a1(n), a2(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a2[i]);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    A = fwt.Or(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A = fwt.And(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A = fwt.Xor(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FWT 和 FMT 本质上是一致的，只是写法姿势不同。FWT 是用递归的思想写的，FMT 是用逐位计算写的。别人的总归用起来不舒服，还是用下面自己写的 FMT 模板吧！</p>
</blockquote>
<h3 id="FMT-模板"><a href="#FMT-模板" class="headerlink" title="FMT 模板"></a>FMT 模板</h3><blockquote>
<p>考虑数论函数的 <a href="/dirichletProduct/" title="Dirichlet 积">Dirichlet 积</a> 中的 Mobius 变换（本质就是带条件的求和）这里的变换也就是的各个位上的带条件求和。<br>例题：<a href="https://www.luogu.com.cn/problem/P6097" target="_blank" rel="noopener">洛谷 P6097</a>， 参考：<a href="https://www.cnblogs.com/yijan/p/12387352.html" target="_blank" rel="noopener">yijan</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FMT &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2 = (M + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">	(x += y) &gt;= M &amp;&amp; (x -= M);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> sub = [](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">	(x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += M);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> extend = [](<span class="keyword">int</span> n) &#123;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="built_in">std</span>::<span class="built_in">log</span>(n);</span><br><span class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; r) &lt; n) ++r;</span><br><span class="line">	<span class="keyword">return</span> r; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> FMTor = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> isRev) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(a.<span class="built_in">size</span>());</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRev) sub(a[j], a[j ^ (<span class="number">1</span> &lt;&lt; i)]);</span><br><span class="line">			<span class="keyword">else</span> add(a[j], a[j ^ (<span class="number">1</span> &lt;&lt; i)]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> FMTand = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> isRev) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(a.<span class="built_in">size</span>());</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRev) sub(a[j ^ (<span class="number">1</span> &lt;&lt; i)], a[j]);</span><br><span class="line">			<span class="keyword">else</span> add(a[j ^ (<span class="number">1</span> &lt;&lt; i)], a[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> FMTxor = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> isRev) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(a.<span class="built_in">size</span>());</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = a[j], v = a[j ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">			a[j] = (v - u + M) % M;</span><br><span class="line">			a[j ^ (<span class="number">1</span> &lt;&lt; i)] = (u + v) % M;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isRev) <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) x = LL(inv2) * x % M;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> fun = [](<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;, <span class="keyword">bool</span>)&gt; f, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(<span class="built_in">std</span>::<span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()));</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n); b.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	f(a, <span class="number">0</span>); f(b, <span class="number">0</span>);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) c[i] = LL(a[i]) * b[i] % M;</span><br><span class="line">	f(c, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> Or = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">return</span> fun(FMTor, a, b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> And = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">return</span> fun(FMTand, a, b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> Xor = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">return</span> fun(FMTxor, a, b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// i = j | k and j &amp; k = 0</span></span><br><span class="line"><span class="keyword">auto</span> OrAnd = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">	<span class="keyword">int</span> n = extend(<span class="built_in">std</span>::<span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()));</span><br><span class="line">	a.resize(<span class="number">1</span> &lt;&lt; n); b.resize(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">sa</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; n))</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> sb = sa, sc = sa;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) sa[__builtin_popcount(i)][i] = a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) sb[__builtin_popcount(i)][i] = b[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		FMTor(sa[i], <span class="number">0</span>);FMTor(sb[i], <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; n); ++k) &#123;</span><br><span class="line">				add(sc[i][k], LL(sa[j][k]) * sb[i - j][k] % M);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		FMTor(sc[i], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) c[i] = sc[__builtin_popcount(i)][i];</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>namespace 真香！</p>
</blockquote>
<h3 id="矩阵类"><a href="#矩阵类" class="headerlink" title="矩阵类"></a>矩阵类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LL mod;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line">	LL a[N][N];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	Matrix() &#123;&#125;</span><br><span class="line">	Matrix(<span class="keyword">int</span> _n, <span class="keyword">int</span> x = <span class="number">0</span>): n(_n) &#123; <span class="comment">// xIn</span></span><br><span class="line">		all(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			a[i][i] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">all</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				a[i][j] = x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> Matrix &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">Matrix <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				R.a[i][j] = a[i][j] + A.a[i][j];</span><br><span class="line">				<span class="keyword">if</span> (R.a[i][j] &gt;= mod) R.a[i][j] -= mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">	Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">Matrix <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">					R.a[i][j] = (R.a[i][j] + a[i][k] * A.a[k][j]) % mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function">Matrix <span class="title">R</span><span class="params">(A.n, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) R = R * A;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>; A = A * A;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到，矩阵乘法一定要写成上面的循环形式，这样利用高速缓存执行时间是原有的 $\frac{1}{4}$</p>
<p>另外有序数组的累和要比无序的快很多，也是因为高速缓存（这个不太懂原理）</p>
</blockquote>
<h3 id="Gauss-消元法浮点版"><a href="#Gauss-消元法浮点版" class="headerlink" title="Gauss 消元法浮点版"></a>Gauss 消元法浮点版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">Gauss</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; A, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-12</span>;</span><br><span class="line">	<span class="keyword">auto</span> findNonZero = [&amp;](<span class="keyword">int</span> i) &#123; <span class="comment">// 实际上找最大的比较好</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i; row &lt; n; ++row) <span class="keyword">if</span> (<span class="built_in">fabs</span>(A[row][i]) &gt; eps) <span class="keyword">return</span> row;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> triangleGauss = [&amp;](<span class="keyword">int</span> sz) &#123; <span class="comment">// A[i][i] = 1</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; x(sz);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">			x[i] = b[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; i; ++row) b[row] -= A[row][i] * x[i];</span><br><span class="line">		&#125;</span><br><span class="line">		x.resize(A[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> sz = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, row; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">			row = findNonZero(i);</span><br><span class="line">			<span class="keyword">if</span> (row != n) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) A[j][i] = A[j][m - <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">std</span>::swap(p[i], p[--m]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = m; row &lt; n; ++row) <span class="keyword">if</span> (<span class="built_in">fabs</span>(b[row])) &#123;</span><br><span class="line">				<span class="comment">// std::cout &lt;&lt; "\nNo answer\n";</span></span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			sz = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (row != i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(A[row], A[i]);</span><br><span class="line">			<span class="built_in">std</span>::swap(b[row], b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		b[i] /= A[i][i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) A[i][j] /= A[i][i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i + <span class="number">1</span>; row &lt; n; ++row) &#123;</span><br><span class="line">			b[row] -= A[row][i] * b[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">				A[row][j] -= A[row][i] * A[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if (sz != A[0].size()) std::cout &lt;&lt; "\nInfinite answer\n";</span></span><br><span class="line">	<span class="keyword">auto</span> xt = triangleGauss(sz);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); ++t) x[p[t]] = xt[t];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Gauss-消元法有限域版"><a href="#Gauss-消元法有限域版" class="headerlink" title="Gauss 消元法有限域版"></a>Gauss 消元法有限域版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// make sure 0 &lt;= A[i][j], b[i] &lt; M</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">Gauss</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;&gt; A, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;LL(LL)&gt; inv = [&amp;](LL a) -&gt; LL &#123;</span><br><span class="line">		<span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (M - M / a) * inv(M % a) % M; </span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> sub = [](LL &amp;x, LL y) &#123;</span><br><span class="line">		(x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += M);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> triangleGauss = [&amp;](<span class="keyword">int</span> sz) &#123; <span class="comment">// A[i][i] = 1</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; x(sz);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">			x[i] = (b[i] + M) % M;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; i; ++row) sub(b[row], A[row][i] * x[i] % M);</span><br><span class="line">		&#125;</span><br><span class="line">		x.resize(A[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> findNonZero = [&amp;](<span class="keyword">int</span> i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i; row &lt; n; ++row) <span class="keyword">if</span> (A[row][i]) <span class="keyword">return</span> row;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> sz = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, row; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">			row = findNonZero(i);</span><br><span class="line">			<span class="keyword">if</span> (row != n) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) A[j][i] = A[j][m - <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">std</span>::swap(p[i], p[--m]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> row = m; row &lt; n; ++row) <span class="keyword">if</span> (b[row]) &#123;</span><br><span class="line">				<span class="comment">// std::cout &lt;&lt; "\nNo answer\n";</span></span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			sz = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (row != i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(A[i], A[row]);</span><br><span class="line">			<span class="built_in">std</span>::swap(b[i], b[row]);</span><br><span class="line">		&#125;</span><br><span class="line">		LL inva = inv(A[i][i]);</span><br><span class="line">		(b[i] *= inva) %= M;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) (A[i][j] *= inva) %= M;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = i + <span class="number">1</span>; row &lt; n; ++row) &#123;</span><br><span class="line">			sub(b[row], A[row][i] * b[i] % M);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i; --j) &#123;</span><br><span class="line">				sub(A[row][j], A[row][i] * A[i][j] % M);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// if (sz != A[0].size()) std::cout &lt;&lt; "\nInfinite answer\n";</span></span><br><span class="line">	<span class="keyword">auto</span> xt = triangleGauss(sz);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); ++t) x[p[t]] = xt[t];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="：例题"><a href="#：例题" class="headerlink" title="：例题"></a><a href="/simplex/" title="线性规划单纯形法">线性规划单纯形法</a>：<a href="https://vjudge.net/problem/Kattis-cheeseifyouplease" target="_blank" rel="noopener">例题</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> VD = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1e10</span>;</span><br><span class="line"><span class="comment">// make sure that A = (I, A') and b &gt;= 0, compute max cx</span></span><br><span class="line"><span class="function">VD <span class="title">simplexCore</span><span class="params">(VD c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; A, VD b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = A.<span class="built_in">size</span>(), m = c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i].emplace_back(b[i]);</span><br><span class="line">	c.emplace_back(<span class="number">0</span>);</span><br><span class="line">	A.emplace_back(c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			A[n][j] -= A[n][i] * A[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> check = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt; m; ++j) <span class="keyword">if</span> (A[n][j] &gt; eps) &#123;</span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (A[i][j] &gt; eps) &#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> ch = <span class="built_in">std</span>::max_element(A[n].<span class="built_in">begin</span>() + n, A[n].<span class="built_in">begin</span>() + m) - A[n].<span class="built_in">begin</span>(), hc;</span><br><span class="line">		<span class="keyword">if</span> (A[n][ch] &lt; eps) <span class="keyword">break</span>;	</span><br><span class="line">		assert(check()); <span class="comment">// otherwise unbounded, no max solution</span></span><br><span class="line">		<span class="keyword">double</span> theta = DBL_MAX;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (A[i][ch] &gt; eps &amp;&amp; A[i].back() / A[i][ch] &lt; theta) &#123;</span><br><span class="line">			theta = A[i].back() / A[i][ch];</span><br><span class="line">			hc = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::swap(p[ch], p[hc]);</span><br><span class="line">		<span class="keyword">double</span> tmp = <span class="number">1</span> / A[hc][ch];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) A[hc][j] *= tmp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) <span class="keyword">if</span> (i != hc) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &lt;= m; ++j) <span class="keyword">if</span> (j != ch) &#123;</span><br><span class="line">				A[i][j] -= A[i][ch] * A[hc][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) A[i][ch] *= -tmp;</span><br><span class="line">		A[hc][ch] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">VD <span class="title">x</span><span class="params">(m)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) x[p[i]] = A[i].back();</span><br><span class="line">	<span class="comment">// watch(-A.back().back()); // max_val</span></span><br><span class="line">	<span class="keyword">return</span> x; <span class="comment">// point Corresponds to max_val</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// compute max cx, with Aqx = bq and Alq x &lt;= blq, end of 0 can be ommit in A and Aq</span></span><br><span class="line"><span class="function">VD <span class="title">simplex</span><span class="params">(VD c, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; Aq, VD bq, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; Alq, VD blq)</span> </span>&#123;</span><br><span class="line">	assert(Aq.<span class="built_in">size</span>() == bq.<span class="built_in">size</span>());</span><br><span class="line">	assert(Alq.<span class="built_in">size</span>() == blq.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">int</span> n = Aq.<span class="built_in">size</span>() + Alq.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> m = c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bq.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (bq[i] &lt; -eps) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : Aq[i]) x = -x;</span><br><span class="line">		bq[i] = -bq[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blq.<span class="built_in">size</span>(); ++i) <span class="keyword">if</span> (blq[i] &lt; -eps) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : Alq[i]) x = -x;</span><br><span class="line">		++m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VD&gt; <span class="title">A</span><span class="params">(n, VD(n + m))</span></span>;</span><br><span class="line">	VD f(n + m), b(n);</span><br><span class="line">	<span class="keyword">int</span> now = n + c.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) A[i][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Aq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Aq[i].<span class="built_in">size</span>(); ++j) A[i][n + j] = Aq[i][j];</span><br><span class="line">		b[i] = bq[i];</span><br><span class="line">		f[i] = -inf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Alq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Alq[i].<span class="built_in">size</span>(); ++j) A[i + Aq.<span class="built_in">size</span>()][n + j] = Alq[i][j];</span><br><span class="line">		<span class="keyword">if</span> (blq[i] &lt; -eps) &#123;</span><br><span class="line">			A[i + Aq.<span class="built_in">size</span>()][now++] = <span class="number">-1</span>;</span><br><span class="line">			f[i + Aq.<span class="built_in">size</span>()] = -inf;</span><br><span class="line">		&#125;</span><br><span class="line">		b[i + Aq.<span class="built_in">size</span>()] = <span class="built_in">fabs</span>(blq[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); ++i) f[n + i] = c[i];</span><br><span class="line">	<span class="keyword">auto</span> x = simplexCore(f, A, b);</span><br><span class="line">	<span class="keyword">return</span> VD(x.<span class="built_in">begin</span>() + n, x.<span class="built_in">begin</span>() + n + c.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><p>$n$ 个变量，$m$ 个约束条件，每个约束条件都形如 $x_i - x_j \leq c_k$，此时我们从节点 j 向 i 连一条长度为 $c_k$ 的有向边，（如果有等于号，我们就连两条），设 <code>dist[0] = 0</code>，然后 0 节点向所有节点连一条长度为 0 的有向边。跑单源最短路，如果环中有负环，那么无解，否则 $x_i = dist[i]$ 为一组解。</p>
<p>可用图论中 Bellman-Ford 算法，或 spfa（随笔图跑的快），例题：<a href="https://www.luogu.com.cn/problem/P1993" target="_blank" rel="noopener">LOJ P1993</a>，<a href="https://www.luogu.com.cn/record/46227278" target="_blank" rel="noopener">spfa 做法</a>，<a href="https://www.luogu.com.cn/record/46228308" target="_blank" rel="noopener">Bellman-Ford 做法</a></p>
<blockquote>
<p>变式：$\frac{x_i}{x_j} \leq c_k$（取 log 即可）</p>
</blockquote>
<h3 id="求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法"><a href="#求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法" class="headerlink" title="求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法"></a>求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1003</span>;</span><br><span class="line">LL c[M], ans[<span class="number">2</span> * M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecSeq</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LL a[<span class="number">2</span> * M];</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	RecSeq(<span class="keyword">int</span> _m, LL x = <span class="number">0</span>): m(_m) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> (a));</span><br><span class="line">		a[<span class="number">0</span>] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	RecSeq <span class="keyword">operator</span> * (<span class="keyword">const</span> RecSeq &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">RecSeq <span class="title">R</span><span class="params">(m)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">				R.a[i + j] = (R.a[i + j] + a[i] * A.a[j]) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * m - <span class="number">2</span>; i &gt;= m; --i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">				R.a[i - m + j] += (R.a[i] * c[j]) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">			R.a[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			R.a[i] %= mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">	<span class="function">T <span class="title">tPow</span><span class="params">(T &amp; A, LL n)</span> </span>&#123;</span><br><span class="line">		<span class="function">T <span class="title">R</span><span class="params">(A.m, <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n &amp; <span class="number">1</span>) R = R * A;</span><br><span class="line">			n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			A = A * A;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initC</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> (c));</span><br><span class="line">	c[<span class="number">0</span>] = c[m - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		ans[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[m] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt; <span class="number">2</span> * m; ++i) &#123;</span><br><span class="line">		ans[i] = ans[i - <span class="number">1</span>] + ans[i - m];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(LL n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	initC(m);</span><br><span class="line">	<span class="function">RecSeq <span class="title">A</span><span class="params">(m)</span></span>;</span><br><span class="line">	A.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	RecSeq R = tPow(A, n - m);</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		r += (R.a[i] * ans[i + m]) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用<a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">多项式带模除法：Division with remainder</a>的 $O(m \log m)$ 算法，可优化到 $O(m \log m \log n)$，</p>
<p>但是如果递推关系中仅有常数个不为 0，比如通常是两个，也可以不用多项式带模除法来搞，只需 NFT 就可以优化到 $O(m \log m \log n + m^2)$ （暂时不知道如何去掉 $m^2$）</p>
</blockquote>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="/nimSgFunction/" title="博弈">博弈</a></h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="并查集（Disjoint-Set-Union）"><a href="#并查集（Disjoint-Set-Union）" class="headerlink" title="并查集（Disjoint Set Union）"></a>并查集（Disjoint Set Union）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始情形: p[i] = i</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// p[find(j)] = p[find(i)];</span></span><br><span class="line">	<span class="comment">// In general we should write below, and merge small to big</span></span><br><span class="line">	<span class="comment">// int fi = find(i), fj = find(j);</span></span><br><span class="line">	<span class="comment">// if (fi != fj) p[fi] = fj;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回的是离散化之后的数组值对应的原始值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">discrete</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> b = a;</span><br><span class="line">	<span class="built_in">std</span>::sort(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">	b.erase(<span class="built_in">std</span>::unique(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">r</span><span class="params">(b.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x : a) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="built_in">std</span>::lower_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), x) - b.<span class="built_in">begin</span>();</span><br><span class="line">		r[id] = x;</span><br><span class="line">		x = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h3><ol>
<li>直接求 $O(n^2)$ 没啥好写的。</li>
<li>把原数组每个位置进行编号，排序，然后每次把最大的数的编号丢进树状数组中，丢进去先看这个编号前面有多少个数，累加一下就可以了，$O(n^2)$，结合下面树状数组的知识还是很简单的。</li>
<li>带离散化的树状数组（就是如果元素的数值特别大，树状数组内存就不够了，所以需要离散化一下）</li>
<li>归并的求（不会也不想搞 0.0）</li>
<li>逐位处理（代码如下）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all number in a are nonegetive</span></span><br><span class="line"><span class="function">LL <span class="title">inverseNumber</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> dn = <span class="built_in">std</span>::<span class="built_in">log</span>(*<span class="built_in">std</span>::max_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>())) + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= dn; ++d) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="built_in">std</span>::iota(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(),[&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">			<span class="keyword">return</span> (a[i] &gt;&gt; d) &lt; (a[j] &gt;&gt; d) || ((a[i] &gt;&gt; d) == (a[j] &gt;&gt; d) &amp;&amp; i &lt; j);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i = j) &#123;</span><br><span class="line">			<span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (j &lt; n &amp;&amp; (a[p[i]] &gt;&gt; d) == (a[p[j]] &gt;&gt; d)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[p[j]] &gt;&gt; (d - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">					++x1;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					r += x1;</span><br><span class="line">				&#125;</span><br><span class="line">				++j;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组（单点更新，从-1-到某个位置的最小值）"><a href="#树状数组（单点更新，从-1-到某个位置的最小值）" class="headerlink" title="树状数组（单点更新，从 1 到某个位置的最小值）"></a>树状数组（单点更新，从 1 到某个位置的最小值）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArrayMin</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	TreeArrayMin() &#123;&#125;</span><br><span class="line">	TreeArrayMin(<span class="keyword">int</span> n) : s(n + <span class="number">1</span>, INT_MAX) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			s[id] = <span class="built_in">std</span>::<span class="built_in">min</span>(s[id], p);</span><br><span class="line">			id += lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 计算区间 [1, id] 的最小值</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> r = INT_MAX;</span><br><span class="line">		<span class="keyword">while</span> (id) &#123;</span><br><span class="line">			r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, s[id]);</span><br><span class="line">			id -= lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组（单点更新，区间求和，编号从-1-开始）"><a href="#树状数组（单点更新，区间求和，编号从-1-开始）" class="headerlink" title="树状数组（单点更新，区间求和，编号从 1 开始）"></a>树状数组（单点更新，区间求和，编号从 1 开始）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; s;</span><br><span class="line">	TreeArray() &#123;&#125;</span><br><span class="line">	TreeArray(<span class="keyword">int</span> n) : s(n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			s[id] += p;</span><br><span class="line">			id += lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (id) &#123;</span><br><span class="line">			r += s[id];</span><br><span class="line">			id -= lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find minimal index s.t. sum(id) &gt;= x, sum must be increased</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(LL val)</span> </span>&#123;</span><br><span class="line">		LL sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">std</span>::__lg(s.<span class="built_in">size</span>()); ~i; --i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (id + (<span class="number">1</span> &lt;&lt; i) &lt; s.<span class="built_in">size</span>() &amp;&amp; sum + s[id + (<span class="number">1</span> &lt;&lt; i)] &lt; val) &#123;</span><br><span class="line">				id += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">				sum += s[id];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ++id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组（区间更新，区间求和，编号从-1-开始）"><a href="#树状数组（区间更新，区间求和，编号从-1-开始）" class="headerlink" title="树状数组（区间更新，区间求和，编号从 1 开始）"></a>树状数组（区间更新，区间求和，编号从 1 开始）</h3><p>有了单点更新的树状数组，只需简单利用差分就可以变成区间的更新了。<br>设原始数组为 <code>a[1 ~ n]</code>， 定义 <code>c[i] = a[i] - a[i - 1], (a[0] = 0)</code> 显然</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^m a_i = \sum_{i = 1}^m (m - i + 1) c_i = m \sum_{i = 1}^m c_i - \sum_{i = 1}^m (i - 1) c_i</script><p>比如对区间 <code>[l, r]</code> 做更新，那么就只需更新两点：<code>r + 1, l</code> ，套用之前的类就行了。</p>
<blockquote>
<p>注意在树状数组中搜索本来应该是 $O(\log ^2 n)$，但是因为在 $2^i$ 的位置搜索时，一步到位。所以复杂度会降到 $O(\log n)$：<a href="https://codeforces.com/blog/entry/61364" target="_blank" rel="noopener">理论依据</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeArrayPlus</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// c[i] = a[i] - a[i - 1], b_i = (i - 1) * c_i</span></span><br><span class="line">	TreeArray B, C;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		C.add(id, p);</span><br><span class="line">		B.add(id, (id - <span class="number">1</span>) * p);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	TreeArrayPlus() &#123;&#125;</span><br><span class="line">	TreeArrayPlus(<span class="keyword">int</span> _n) : n(_n), B(n), C(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		add(l, p);</span><br><span class="line">		add(r + <span class="number">1</span>, -p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id * C.sum(id) - B.sum(id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sum(r) - sum(l - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find minimal index s.t. sum(id) &gt;= x, sum must be increased</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(LL val)</span> </span>&#123;</span><br><span class="line">		LL sumB = <span class="number">0</span>, sumC = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">std</span>::__lg(n); ~i; --i) <span class="keyword">if</span> (<span class="keyword">int</span> idi = id + (<span class="number">1</span> &lt;&lt; i); idi &lt;= n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (idi * (sumC +  C.s[idi]) - B.s[idi] - sumB &lt; val) &#123;</span><br><span class="line">				id = idi;</span><br><span class="line">				sumB += B.s[id];</span><br><span class="line">				sumC += C.s[id];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ++id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="线段树（正式版）"><a href="#线段树（正式版）" class="headerlink" title="线段树（正式版）"></a>线段树（正式版）</h3><p>首先显然总节点 $m$ 上界为 $4n$，并且可以证明 $\frac{m}{n}$ 的上确界为 $4$，下确界为 $2$ 注意到如果 $n = 2^k + 2^{j + 1}$ 时，则 $m = 2 ^{k + 1} + 2^k + \cdots 2^{k - j} + 1$，所以 $\frac{m}{n} = \frac{4 - 2^{-j} + 2^{-k}}{1 + 2^{j + 1 - k}}$，对任意 $\epsilon &gt; 0$ 存在 $j$ 使得 $4 - 2 ^{-j} &gt; 4 - \epsilon$， 然后让 $k$ 趋于无穷，那么显然 $\frac{m}{n}$ 上极限为 $4$.（$n = 40$ 时， $\frac{m}{n} &gt; 3$，$n = 2^20 + 2^10 = 1049600$ 时，$\frac{m}{n} &gt; 3.99$）</p>
<blockquote>
<p>和与最大值的线段树模板（如果单纯求和，可以用树状数组）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mn, tag;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; sm;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lson l, m, 2 * p</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, 2 * p + 1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mn.resize(<span class="number">4</span> * n);</span><br><span class="line">		tag.resize(<span class="number">4</span> * n);</span><br><span class="line">		sm.resize(<span class="number">4</span> * n);</span><br><span class="line">	&#125;</span><br><span class="line">	SegmentTree(<span class="keyword">int</span> _n) : n(_n) &#123;</span><br><span class="line">		resize();</span><br><span class="line">	&#125;</span><br><span class="line">	SegmentTree(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a) &#123;</span><br><span class="line">		n = a.<span class="built_in">size</span>();</span><br><span class="line">		resize();</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; build = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p) &#123;</span><br><span class="line">			<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">				mn[p] = sm[p] = a[l - <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">			build(lson);</span><br><span class="line">			build(rson);</span><br><span class="line">			pull(p);</span><br><span class="line">		&#125;;</span><br><span class="line">		build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		mn[p] = <span class="built_in">std</span>::<span class="built_in">min</span>(mn[<span class="number">2</span> * p], mn[<span class="number">2</span> * p + <span class="number">1</span>]);</span><br><span class="line">		sm[p] = sm[<span class="number">2</span> * p] + sm[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (tag[p]) &#123;</span><br><span class="line">			<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">			<span class="built_in">set</span>(lson, tag[p]);</span><br><span class="line">			<span class="built_in">set</span>(rson, tag[p]);</span><br><span class="line">			tag[p] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		tag[p] = mn[p] = v;</span><br><span class="line">		sm[p] = LL(r - l + <span class="number">1</span>) * v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rangeSet</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;</span><br><span class="line">			<span class="built_in">set</span>(l, r, p, v);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		push(l, r, p);</span><br><span class="line">		<span class="keyword">if</span> (L &lt;= m) rangeSet(L, R, v, lson);</span><br><span class="line">		<span class="keyword">if</span> (R &gt; m) rangeSet(L, R, v, rson);</span><br><span class="line">		pull(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以下内容根据需要修改</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>&amp; y, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mn[p] &gt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= l &amp;&amp; sm[p] &lt;= y) &#123;</span><br><span class="line">			y -= sm[p];</span><br><span class="line">			<span class="keyword">return</span> r - l + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		push(l, r, p);</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= m) ans += query(x, y, lson); </span><br><span class="line">		ans += query(x, y, rson);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">bounded</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mn[p] &gt;= v) <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (mn[<span class="number">2</span> * p] &gt;= v) <span class="keyword">return</span> bounded(v, rson);</span><br><span class="line">		<span class="keyword">return</span> bounded(v, lson);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = bounded(y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (l &lt;= x) rangeSet(l, x, y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> query(x, y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码参考了 Jiangly 的模板，他的是左闭右开的。</p>
</blockquote>
<h3 id="线段树-（弃用版）"><a href="#线段树-（弃用版）" class="headerlink" title="线段树 （弃用版）"></a>线段树 （弃用版）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, lrt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rrt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">LL sum[N * <span class="number">3</span>], col[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	sum[rt] = sum[lrt] + sum[rrt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (col[rt]) &#123;</span><br><span class="line">		col[lrt] += col[rt];</span><br><span class="line">		col[rrt] += col[rt];</span><br><span class="line">		sum[lrt] += (m - (m &gt;&gt; <span class="number">1</span>)) * col[rt];</span><br><span class="line">		sum[rrt] += (m &gt;&gt; <span class="number">1</span>) * col[rt];</span><br><span class="line">		col[rt] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp; sum[rt]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	col[rt] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(lson);</span><br><span class="line">	build(rson);</span><br><span class="line">	pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;</span><br><span class="line">		sum[rt] += p * (r - l + <span class="number">1</span>);</span><br><span class="line">		col[rt] += p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= m) update(L, R, p, lson);</span><br><span class="line">	<span class="keyword">if</span> (R &gt; m) update(L, R, p, rson);</span><br><span class="line">	pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> sum[rt];</span><br><span class="line">	pushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= m) ans += query(L, R, lson);</span><br><span class="line">	<span class="keyword">if</span> (R &gt; m) ans += query(L, R, rson);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>吊打线段树的 <a href="https://blog.csdn.net/CC_dsm/article/details/98166835" target="_blank" rel="noopener">珂朵莉树（Chtholly Tree）</a></p>
</blockquote>
<h3 id="RMQ-求区间最大值（弃用，RMQ-和-spfa-已经死了）"><a href="#RMQ-求区间最大值（弃用，RMQ-和-spfa-已经死了）" class="headerlink" title="RMQ 求区间最大值（弃用，RMQ 和 spfa 已经死了）"></a>RMQ 求区间最大值（弃用，RMQ 和 spfa 已经死了）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMQ</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> a[N][<span class="number">20</span>]; <span class="comment">//a[i][j]=max(s[i]---s[i+2^j-1])</span></span><br><span class="line">	RMQ(<span class="keyword">int</span> * s, <span class="keyword">int</span> _n): n(_n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) a[i][<span class="number">0</span>] = s[i];</span><br><span class="line">		<span class="keyword">int</span> len = (<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(n)) / <span class="built_in">log</span>(<span class="number">2.0</span>)) + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != len; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - (<span class="number">1</span> &lt;&lt; i); ++j) &#123;</span><br><span class="line">				a[j][i] = <span class="built_in">max</span>(a[j][i - <span class="number">1</span>], a[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 0 &lt;= l &lt;= r &lt; n</span></span><br><span class="line">		<span class="keyword">int</span> len = (<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(r - l + <span class="number">1</span>)) / <span class="built_in">log</span>(<span class="number">2.0</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(a[l][len], a[r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们经常用二分答案的思想， 但是其实二分答案是仅仅知道其单调的情况下的策略，实际上，对于具体的问题， 我们完全可以对 $m$ 的值进行不同的处理， 而非单纯的 $m = (l + r) &gt;&gt; 1 $。</p>
</blockquote>
<h3 id="三分法简单版"><a href="#三分法简单版" class="headerlink" title="三分法简单版"></a><a href="https://codeforces.com/contest/439/problem/D" target="_blank" rel="noopener">三分法简单版</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for a given covex function f: (f(a) + f(b)) / 2 &gt;= f((a + b) / 2)</span></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span> (l + <span class="number">2</span> &lt; r) &#123;</span><br><span class="line">	<span class="keyword">int</span> lm = (<span class="number">2l</span>l * l + r) / <span class="number">3</span>, rm = (l + <span class="number">2l</span>l * r + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (f(lm) &lt; f(rm)) r = rm;</span><br><span class="line">	<span class="keyword">else</span> l = lm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">	<span class="keyword">if</span> (f(l) &lt; f(r)) --r;</span><br><span class="line">	<span class="keyword">else</span> ++l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标准三分法用黄金分割的原因"><a href="#标准三分法用黄金分割的原因" class="headerlink" title="标准三分法用黄金分割的原因"></a>标准三分法用黄金分割的原因</h3><p>我们不妨设原始区间为 <code>[0, 1]</code>，我们在其中选两个点 <code>0 &lt; a &lt; b &lt; 1</code>，然后比较 <code>f(a)</code> 和 <code>f(b)</code>，然后再相应改变区间。然后重复上述过程。如果我们能充分利用计算过的值，也就是说假设更新后的区间为 <code>[0, b]</code> 那么我们自然想让 <code>a</code> 的计算值充分被利用，所以我们想再选的两个点的其中一个是 <code>a</code>，如果更新后区间为 <code>[a, 1]</code> 同理。也就是说我们有策略</p>
<script type="math/tex; mode=display">
\frac{a}{b} = b, \frac{b - a}{1 - a} = a</script><p>化简可得 $b(1 + b) = 1$，即 $b = \frac{\sqrt{5} - 1}{2}, a = b ^ 2 = \frac{3 - \sqrt{5}}{2} = 1 - b$。</p>
<blockquote>
<p>注意到上述 $b$ 的值正好是黄金分割 0.618…</p>
</blockquote>
<h3 id="三分法黄金分割版（可用版）"><a href="#三分法黄金分割版（可用版）" class="headerlink" title="三分法黄金分割版（可用版）)"></a><a href="(https://codeforces.com/contest/439/problem/D">三分法黄金分割版（可用版）</a>)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for a given covex function f: (f(a) + f(b)) / 2 &gt;= f((a + b) / 2)</span></span><br><span class="line"><span class="keyword">auto</span> tupleCut = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> phiL = (<span class="number">3</span> - <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">5</span>)) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> phiR = (<span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">5</span>) - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">auto</span> getLeft = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l + (r - l) * phiL;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> getRight = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l + (r - l) * phiR;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> lm = getLeft(l, r), rm = getRight(l, r);</span><br><span class="line">	LL fl = f(lm), fr = f(rm);</span><br><span class="line">	<span class="keyword">while</span> (r - l &gt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fl &lt; fr) &#123;</span><br><span class="line">			r = rm;</span><br><span class="line">			rm = lm;</span><br><span class="line">			fr = fl;</span><br><span class="line">			fl = f(lm = getRight(l, rm));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			l = lm;</span><br><span class="line">			lm = rm;</span><br><span class="line">			fl = fr;</span><br><span class="line">			fr = f(rm = getLeft(lm, r));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fl = f(l), fr = f(r);</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fl &lt; fr) fr = f(--r);</span><br><span class="line">		<span class="keyword">else</span> fl = f(++l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意返回的是最值而不是最值点</p>
<p>注意到一定要用上述写法，由于取整带来的误差，所以必须充分利用“左分点”是“右分点”的“右分点”，“右分点”是“左分点”的“左分点”（用来保证 $l \leq lm \leq rm \leq r$），然后如果单次求 $f$ 的复杂度特别高，两段各自最后一步也是可以优化一下，少算一次 $f$，但是会很不优雅，所以还是算了。</p>
</blockquote>
<h3 id="subarray（连续部分）-VS-subsequence（不要求连续部分）"><a href="#subarray（连续部分）-VS-subsequence（不要求连续部分）" class="headerlink" title="subarray（连续部分） VS subsequence（不要求连续部分）"></a>subarray（连续部分） VS subsequence（不要求连续部分）</h3><h3 id="最长（严格）递增子序列"><a href="#最长（严格）递增子序列" class="headerlink" title="最长（严格）递增子序列"></a>最长（严格）递增子序列</h3><blockquote>
<p>下面数组 <code>b</code> 的意义：<code>b[i]</code> 表示当前长为 <code>i</code> 的子列的末位的最小值。<br>这个子序列还能给附加限制（比如都要大于某个值）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123; <span class="comment">// length of longest increasing subsquence</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::lower_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), x); it == b.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			b.emplace_back(x);</span><br><span class="line">		&#125; <span class="keyword">else</span> *it = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LNDS</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123; <span class="comment">// length of longest increasing subsquence</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::upper_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), x); it == b.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			b.emplace_back(x);</span><br><span class="line">		&#125; <span class="keyword">else</span> *it = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LISP</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123; <span class="comment">// longest increasing subsquence</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b, pb, pa(a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">std</span>::iota(pa.<span class="built_in">begin</span>(), pa.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">auto</span> it = <span class="built_in">std</span>::upper_bound(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), a[i]); it == b.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!pb.empty()) pa[i] = pb.back();</span><br><span class="line">			b.emplace_back(a[i]);</span><br><span class="line">			pb.emplace_back(i);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			*it = a[i];</span><br><span class="line">			<span class="keyword">int</span> t = it - b.<span class="built_in">begin</span>();</span><br><span class="line">			pb[t] = i;</span><br><span class="line">			<span class="keyword">if</span> (t &gt; <span class="number">0</span>) pa[i] = pb[t - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">	<span class="keyword">int</span> now = pb.back();</span><br><span class="line">	c.push(a[now]);</span><br><span class="line">	<span class="keyword">while</span> (now != pa[now]) &#123;</span><br><span class="line">		now = pa[now];</span><br><span class="line">		c.push(a[now]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lower_bound(first,end,val) 表示在单增 [frist,end) 中首次大于等于 val 的位置</span></span><br><span class="line"><span class="comment">// upper_bound(first,end,val) 表示在单增 [frist,end) 中首次大于 val 的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> r[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pack</span><span class="params">(<span class="keyword">int</span> cash, <span class="keyword">int</span> num, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">0</span> || w == <span class="number">0</span> || v == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">1</span>) &#123; <span class="comment">//  0-1背包</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = cash; i &gt;= v; --i)</span><br><span class="line">			r[i] = <span class="built_in">max</span>(r[i], r[i - v] + w);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num * v &gt;= cash - v + <span class="number">1</span>) &#123; <span class="comment">//完全背包</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = v; i &lt;= cash; ++i)</span><br><span class="line">			r[i] = <span class="built_in">max</span>(r[i], r[i - v] + w);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> q[MAX], s[MAX], head, tail;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123; <span class="comment">//多重背包</span></span><br><span class="line">		q[<span class="number">0</span>] = r[j];</span><br><span class="line">		s[<span class="number">0</span>] = head = tail = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = j + v; k &lt;= cash; ++i, k += v) &#123;</span><br><span class="line">			q[i] = r[k] - i * w;</span><br><span class="line">			<span class="keyword">while</span> (s[head] &lt; i - num) ++head;</span><br><span class="line">			<span class="keyword">while</span> (head &lt;= tail &amp;&amp; q[tail] &lt; q[i]) --tail;</span><br><span class="line">			s[++tail] = i;</span><br><span class="line">			q[tail] = q[i];</span><br><span class="line">			r[k] = q[head] + i * w;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆与-STL-优先队列"><a href="#堆与-STL-优先队列" class="headerlink" title="堆与 STL 优先队列"></a>堆与 STL 优先队列</h3><p>可以使用 <a href="http: //www.cplusplus.com/reference/">C++STL</a> 的 priority_queue，查找可用 lower_bound 和 upper_bound。C++ STL 中优先队列是用堆来实现的。用途十分广泛，例如加速最小生成树，拓扑排序，等等。<br>堆的实现一般是用数组。 我们可以用 1 作为树的根， 对每一个节点 $x$， 它的两个节点分别就是 $2x$ 和 $2x + 1$ 平时都用 <code>x &lt;&lt; 1, x &lt;&lt; 1 | 1</code> 表示。 堆只支持三个操作:</p>
<ol>
<li>插入一个节点(我们实现时是插入最尾部， 这样保证了是一个完全二叉树) $O(\log n)$ </li>
<li>删除最大键值节点（ 删除根元素的值） $O(\log n)$ </li>
<li>输出最大键值节点（ 查看根元素的值） $O(1)$</li>
</ol>
<blockquote>
<p>我掌握的也很喜欢的几个数据结构：<code>单调队列，单调栈，树状数组，堆，线段树，红黑树</code></p>
</blockquote>
<h3 id="单调队列：解决滑动窗口问题（固定长度内的最值问题）"><a href="#单调队列：解决滑动窗口问题（固定长度内的最值问题）" class="headerlink" title="单调队列：解决滑动窗口问题（固定长度内的最值问题）"></a>单调队列：解决滑动窗口问题（固定长度内的最值问题）</h3><p><a href="https://zhuanlan.zhihu.com/p/346354943" target="_blank" rel="noopener">知乎 Pecco</a> 讲的很好（建议直接去看它的讲解）：</p>
<blockquote>
<p>如果一个选手比你小还比你强，你就可以退役了。——单调队列的原理</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求每个长度为 m 的区间的区间最大值的编号</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">monicDequeMax</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!Q.empty() &amp;&amp; i - Q.front() &gt;= m) Q.pop_front();</span><br><span class="line">		<span class="comment">// 如果求最小值，大于号改成小于号即可</span></span><br><span class="line">		<span class="keyword">while</span> (!Q.empty() &amp;&amp; a[i] &gt; a[Q.back()]) Q.pop_back();</span><br><span class="line">		Q.push_back(i);</span><br><span class="line">		<span class="comment">// 如果需要返回值，就在下面加入 a[Q.front()]</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt;= m - <span class="number">1</span>) r.emplace_back(Q.front());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题：<a href="https://www.luogu.com.cn/problem/P2216" target="_blank" rel="noopener">LOJ P2216</a>：这个是二维的，我们可以一维一维的处理</p>
<h3 id="单调队列优化-DP"><a href="#单调队列优化-DP" class="headerlink" title="单调队列优化 DP"></a>单调队列优化 DP</h3><p>例题：<a href="https://www.luogu.com.cn/problem/P2034" target="_blank" rel="noopener">LOJ P2034</a>：取数字使得和最大，但是不能取连续 k 个数</p>
<p>肯定是 dp 问题，如果把 dp[i] 定义成取第 i 个，前 i 个结果的最值，会发现很搞。<br>因此我们反过来考虑。考虑删除若干个数，且删除的间隔不超过 k，求删除的最小和。最终答案就是总和减去最小和。设 <code>dp[i]</code> 表示删除 i，且满足性质的前 i 个数的答案。那么显然     $dp[i] = a[i] i \leq k$，$dp[i] = a[i] + \min_{i - k \leq j \leq i - 1} dp[j]$。注意最终答案不是总和减去 dp 的 最小值，而是 $dp[n - k - 2, \cdots, n - 1]$ 的最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, k;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	std::vector&lt;int&gt; a(n), dp(n);</span><br><span class="line">	LL s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		s += x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		dp[i] = a[i];</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k + <span class="number">1</span>) dp[i] += dp[Q.front()];</span><br><span class="line">		<span class="keyword">if</span> (!Q.empty() &amp;&amp; i - Q.front() &gt;= k + <span class="number">1</span>) Q.pop_front();</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty() &amp;&amp; dp[i] &lt;= dp[Q.back()]) Q.pop_back();</span><br><span class="line">		Q.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s - *<span class="built_in">std</span>::min_element(dp.<span class="built_in">end</span>() - k - <span class="number">1</span>, dp.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调栈：形式更简单应用更广"><a href="#单调栈：形式更简单应用更广" class="headerlink" title="单调栈：形式更简单应用更广"></a>单调栈：形式更简单应用更广</h3><p><a href="https://zhuanlan.zhihu.com/p/346536592" target="_blank" rel="noopener">知乎 Pecco</a> 的精彩讲解：维护一个栈，当我们碰上一个新元素，我们知道，越靠近栈顶的元素离新元素位置越近。所以不断比较新元素与栈顶，如果新元素比栈顶大，则可断定新元素就是栈顶的下一个更大元素，于是弹出栈顶并继续比较。直到新元素不比栈顶大，再将新元素压入栈。显然，这样形成的栈是单调递减的。</p>
<p>应用一：求下一个比自身大的元素位置（下可以改成上，大可以改成小）</p>
<p>洛谷模板题：<a href="https://www.luogu.com.cn/problem/P5788" target="_blank" rel="noopener">LOJ P5788</a></p>
<p>应用二：两个元素间所有元素均（不）大/小于这二者。</p>
<p>洛谷进阶题：<a href="https://www.luogu.com.cn/problem/P1823" target="_blank" rel="noopener">LOJ P1823</a>，问有多少对元素，它们之间没有比它们都大的元素。<br>代码放在 <a href="/codeforces/" title="这里了">这里了</a></p>
<h3 id="单调栈优化-DP"><a href="#单调栈优化-DP" class="headerlink" title="单调栈优化 DP"></a>单调栈优化 DP</h3><p>应用一优化 DP 例题：<a href="https://codeforces.com/contest/1313/problem/C2" target="_blank" rel="noopener">1313C2</a>，首先最优答案肯定时先递增后递减的。相当于有一个制高点，枚举制高点，自然有 $O(n^2)$ 的算法。但是可以优化到 $O(n)$<br>代码放在 <a href="/codeforces/" title="这里了">这里了</a></p>
<p>应用二优化 DP 例题：<a href="https://codeforces.com/contest/1407/problem/D" target="_blank" rel="noopener">1407D</a>，每次跳跃，它们之间的元素都严格大于它们或者严格小于它们。首先设 <code>dp[i]</code> 为到达 i 最小跳跃数，那么显然 $\displaystyle dp[i] = \min{j \to i} dp[j] + 1$。我们可以用两个单调栈来看那些 j 能跳到 i。 <a href="/codeforces/" title="这里了">这里了</a></p>
<h3 id="红黑树-red-black-tree"><a href="#红黑树-red-black-tree" class="headerlink" title="红黑树 red-black tree"></a>红黑树 red-black tree</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBT</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span> elemType;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> RED = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> BLACK = <span class="number">1</span>;</span><br><span class="line">		Node * ch[<span class="number">2</span>], * fa; <span class="comment">// x-&gt;fa-&gt;ch[x-&gt;rs] = x</span></span><br><span class="line">		<span class="keyword">int</span> sz;</span><br><span class="line">		elemType key;</span><br><span class="line">		<span class="keyword">bool</span> color, rs; <span class="comment">// is rightson</span></span><br><span class="line">	&#125;;</span><br><span class="line">	Node * root; <span class="comment">// root has no father</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">faSon</span><span class="params">(Node * x, Node * y, <span class="keyword">bool</span> rs)</span> </span>&#123;</span><br><span class="line">		y-&gt;fa = x;</span><br><span class="line">		y-&gt;rs = rs;</span><br><span class="line">		x-&gt;ch[rs] = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">newNode</span><span class="params">(Node * x, elemType val, <span class="keyword">bool</span> rs)</span> </span>&#123; <span class="comment">// x-&gt;ch[rs]=null</span></span><br><span class="line">		Node * p = <span class="keyword">new</span> Node;</span><br><span class="line">		p-&gt;ch[<span class="number">0</span>] = p-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">		p-&gt;sz = <span class="number">1</span>;</span><br><span class="line">		p-&gt;key = val;</span><br><span class="line">		p-&gt;color = Node::RED;</span><br><span class="line">		faSon(x, p, rs);</span><br><span class="line">		++x-&gt;sz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node * x, <span class="keyword">bool</span> rs)</span> </span>&#123; <span class="comment">// x must not null</span></span><br><span class="line">		Node * y = x-&gt;ch[!rs];</span><br><span class="line">		<span class="keyword">if</span> (y == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x == root) root = y;</span><br><span class="line">		<span class="keyword">else</span> faSon(x-&gt;fa, y, x-&gt;rs);</span><br><span class="line">		faSon(x, y-&gt;ch[rs], !rs);</span><br><span class="line">		faSon(y, x, rs);</span><br><span class="line">		y-&gt;sz = x-&gt;sz;</span><br><span class="line">		x-&gt;sz = x-&gt;ch[<span class="number">0</span>]-&gt;sz + x-&gt;ch[<span class="number">1</span>]-&gt;sz + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insMaintain</span><span class="params">(Node * x)</span> </span>&#123; <span class="comment">// x-&gt;color is RED</span></span><br><span class="line">		<span class="keyword">if</span> (x == root || x-&gt;fa-&gt;color == Node::BLACK) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;fa-&gt;fa-&gt;ch[!x-&gt;fa-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;rs ^ x-&gt;fa-&gt;rs) rotate(x-&gt;fa, x-&gt;fa-&gt;rs);</span><br><span class="line">			<span class="keyword">else</span> x = x-&gt;fa;</span><br><span class="line">			x-&gt;color = Node::BLACK;</span><br><span class="line">			x-&gt;fa-&gt;color = Node::RED;</span><br><span class="line">			rotate(x-&gt;fa, !x-&gt;rs);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			x = x-&gt;fa-&gt;fa;</span><br><span class="line">			x-&gt;color = Node::RED;</span><br><span class="line">			x-&gt;ch[<span class="number">0</span>]-&gt;color = x-&gt;ch[<span class="number">1</span>]-&gt;color = Node::BLACK;</span><br><span class="line">			insMaintain(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase1</span><span class="params">(Node * x, Node * y)</span> </span>&#123;</span><br><span class="line">		y-&gt;color = Node::BLACK;</span><br><span class="line">		y-&gt;fa-&gt;color = Node::RED;</span><br><span class="line">		y = y-&gt;ch[!y-&gt;rs];</span><br><span class="line">		rotate(x-&gt;fa, x-&gt;rs);</span><br><span class="line">		delCase2(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase2</span><span class="params">(Node * x, Node * y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;ch[y-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (y-&gt;ch[!y-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">				y-&gt;color = Node::RED;</span><br><span class="line">				delMaintain(y-&gt;fa);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				y-&gt;color = Node::RED;</span><br><span class="line">				y-&gt;ch[!y-&gt;rs]-&gt;color = Node::BLACK;</span><br><span class="line">				rotate(y, y-&gt;rs);</span><br><span class="line">				delCase3(y-&gt;fa);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> delCase3(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delCase3</span><span class="params">(Node * y)</span> </span>&#123;</span><br><span class="line">		y-&gt;color = y-&gt;fa-&gt;color;</span><br><span class="line">		y-&gt;ch[y-&gt;rs]-&gt;color = y-&gt;fa-&gt;color = Node::BLACK;</span><br><span class="line">		rotate(y-&gt;fa, !y-&gt;rs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delMaintain</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == root || x == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;color == Node::RED) &#123;</span><br><span class="line">			x-&gt;color = Node::BLACK;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node * y = x-&gt;fa-&gt;ch[!x-&gt;rs];</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;color == Node::RED) delCase1(x, y);</span><br><span class="line">		<span class="keyword">else</span> delCase2(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">pred</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// max elem &lt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &gt; val) <span class="keyword">return</span> pred(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] == null) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">return</span> pred(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">succ</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// min elem &gt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &lt; val) <span class="keyword">return</span> succ(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] == null) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">return</span> succ(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// count elem &lt;= val</span></span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;key &gt; val) <span class="keyword">return</span> rank(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">		<span class="keyword">return</span> x-&gt;ch[<span class="number">0</span>]-&gt;sz + <span class="number">1</span> + rank(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">select</span><span class="params">(Node * x, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// k-th smallest elem</span></span><br><span class="line">		<span class="keyword">if</span> (x == null || x-&gt;sz &lt; k) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">int</span> sz = x-&gt;ch[<span class="number">0</span>]-&gt;sz + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (sz == k) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">if</span> (sz &lt; k) <span class="keyword">return</span> select(x-&gt;ch[<span class="number">1</span>], k - sz);</span><br><span class="line">		<span class="keyword">return</span> select(x-&gt;ch[<span class="number">0</span>], k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) <span class="built_in">clear</span>(x-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) <span class="built_in">clear</span>(x-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x != null) <span class="keyword">delete</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"key = %d, sz = %d "</span>, x-&gt;key, x-&gt;sz);</span><br><span class="line">		<span class="built_in">puts</span>(x-&gt;color == Node::RED ? <span class="string">"RED"</span> : <span class="string">"BLACK"</span>);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) <span class="built_in">print</span>(x-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) <span class="built_in">print</span>(x-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	Node * null;</span><br><span class="line">	RBT() &#123;</span><br><span class="line">		null = <span class="keyword">new</span> Node; <span class="comment">// no key, rs, father</span></span><br><span class="line">		null-&gt;ch[<span class="number">0</span>] = null-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">		null-&gt;sz = <span class="number">0</span>;</span><br><span class="line">		null-&gt;color = Node::BLACK;</span><br><span class="line">		root = null;</span><br><span class="line">		null-&gt;key = INF; <span class="comment">// for convenient</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node * <span class="title">search</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		Node * x = root;</span><br><span class="line">		<span class="keyword">while</span> (x != null) &#123;</span><br><span class="line">			<span class="keyword">if</span> (val == x-&gt;key) <span class="keyword">return</span> x;</span><br><span class="line">			x = x-&gt;ch[val &gt;= x-&gt;key];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> null;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">			root = <span class="keyword">new</span> Node; <span class="comment">// no father, rs</span></span><br><span class="line">			root-&gt;ch[<span class="number">0</span>] = root-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">			root-&gt;sz = <span class="number">1</span>;</span><br><span class="line">			root-&gt;color = Node::BLACK;</span><br><span class="line">			root-&gt;key = val;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Node * x = root;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;ch[val &gt;= x-&gt;key] != null) &#123;</span><br><span class="line">			++x-&gt;sz;</span><br><span class="line">			x = x-&gt;ch[val &gt;= x-&gt;key];</span><br><span class="line">		&#125;</span><br><span class="line">		newNode(x, val, val &gt;= x-&gt;key);</span><br><span class="line">		insMaintain(x-&gt;ch[val &gt;= x-&gt;key]);</span><br><span class="line">		root-&gt;color = Node::BLACK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		Node * x = search(val), * y;</span><br><span class="line">		<span class="keyword">if</span> (x == null) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">while</span> (x-&gt;ch[<span class="number">0</span>] != null || x-&gt;ch[<span class="number">1</span>] != null) &#123;</span><br><span class="line">			<span class="keyword">bool</span> rs = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;ch[rs] == null) rs = !rs;</span><br><span class="line">			y = x-&gt;ch[rs];</span><br><span class="line">			<span class="keyword">while</span> (y-&gt;ch[!rs] != null) y = y-&gt;ch[!rs];</span><br><span class="line">			<span class="built_in">std</span>::swap(x-&gt;key, y-&gt;key);</span><br><span class="line">			x = y;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;color == Node::RED) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		delMaintain(x);</span><br><span class="line">		root-&gt;color = Node::BLACK;</span><br><span class="line">		y = x;</span><br><span class="line">		<span class="keyword">while</span> (y != root) &#123;</span><br><span class="line">			y = y-&gt;fa;</span><br><span class="line">			--y-&gt;sz;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x == root) root = null;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) faSon(x-&gt;fa, x-&gt;ch[<span class="number">0</span>], x-&gt;rs);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) faSon(x-&gt;fa, x-&gt;ch[<span class="number">1</span>], x-&gt;rs);</span><br><span class="line">		<span class="keyword">else</span> x-&gt;fa-&gt;ch[x-&gt;rs] = null;</span><br><span class="line">		<span class="keyword">delete</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">pred</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pred(root, val)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">succ</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> succ(root, val)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rank(root, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">elemType <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> select(root, k)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">clear</span>(root);</span><br><span class="line">		root = null;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> root-&gt;sz;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root != null) <span class="built_in">print</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// for particular use</span></span><br><span class="line">		<span class="keyword">return</span> select(root, rank(root, a) + k)-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><h3 id="二维凸包正式版"><a href="#二维凸包正式版" class="headerlink" title="二维凸包正式版"></a>二维凸包正式版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Point = <span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLeft</span><span class="params">(<span class="keyword">const</span> Point &amp;op, <span class="keyword">const</span> Point &amp;sp, <span class="keyword">const</span> Point &amp;ep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (sp.first - op.first) * (ep.second - op.second) </span><br><span class="line">	&lt;= (sp.second - op.second) * (ep.first - op.first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; <span class="title">convexHull</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">	p.erase(<span class="built_in">std</span>::unique(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()), p.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; <span class="title">q</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; crossLeft(q[top - <span class="number">1</span>], p[i], q[top - <span class="number">2</span>])) --top;</span><br><span class="line">		q[top++] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = top;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (top &gt; len &amp;&amp; crossLeft(q[top - <span class="number">1</span>], p[i], q[top - <span class="number">2</span>])) --top;</span><br><span class="line">		q[top++] = p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	top -= n &gt; <span class="number">1</span>;</span><br><span class="line">	q.resize(top);</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三维凸包模板可以参考 上交模板</p>
</blockquote>
<h3 id="旋转卡壳求凸包直径（即平面上点的最远欧式距离）"><a href="#旋转卡壳求凸包直径（即平面上点的最远欧式距离）" class="headerlink" title="旋转卡壳求凸包直径（即平面上点的最远欧式距离）"></a>旋转卡壳求凸包直径（即平面上点的最远欧式距离）</h3><ul>
<li>整数版模板例题：<a href="https://www.luogu.com.cn/problem/P1452" target="_blank" rel="noopener">LOJ P1452</a></li>
<li>实数版模板例题：<a href="https://www.luogu.com.cn/problem/P6247" target="_blank" rel="noopener">LOJ P6247</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Point = <span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point &amp;op, <span class="keyword">const</span> Point &amp;sp, <span class="keyword">const</span> Point &amp;ep)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (sp.first - op.first) * (ep.second - op.second) </span><br><span class="line">	- (sp.second - op.second) * (ep.first - op.first);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist2</span><span class="params">(<span class="keyword">const</span> Point &amp;p, <span class="keyword">const</span> Point &amp;q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x = q.first - p.first, y = q.second - p.second;</span><br><span class="line">	<span class="keyword">return</span> x * x + y * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">diameter</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> q = convexHull(p);</span><br><span class="line">	<span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (q.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> dist2(q[<span class="number">0</span>], q[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">	q.emplace_back(q[<span class="number">0</span>]);</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (cross(q[i], q[i + <span class="number">1</span>], q[j]) &lt; cross(q[i], q[i + <span class="number">1</span>], q[j + <span class="number">1</span>])) j = (j + <span class="number">1</span>) % n;</span><br><span class="line">		ans = <span class="built_in">std</span>::<span class="built_in">max</span>(&#123;ans, dist2(q[i], q[j]), dist2(q[i + <span class="number">1</span>], q[j])&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Manhattan 距离的话仅需考虑 $x_i + y_i$ 的最大最小值之差 与 $x_i - y_i$ 的最大最小值之差的最大值即可。</p>
</blockquote>
<h3 id="分治法求平面最短距离（任何距离都适用）"><a href="#分治法求平面最短距离（任何距离都适用）" class="headerlink" title="分治法求平面最短距离（任何距离都适用）"></a>分治法求平面最短距离（任何距离都适用）</h3><p>首先根据横坐标排序，然后取中位数假设处理好了左右两边的值，然后合并中间的值，首先距离中心点的横坐标不能超过已知的最小值，然后把筛出来的点按照纵坐标排序，然后 $O(n)$ 更新答案。总题复杂度 $O(n \log^2 n)$，如果使用归并排序理论复杂度为 $O(n \log n)$，但是实际效果并不如直接排序。</p>
<p>例题：[<a href="https://www.luogu.com.cn/problem/P1429" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1429</a>] 和 <a href="https://www.luogu.com.cn/problem/P6247" target="_blank" rel="noopener">LOJ P6247</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Point = <span class="built_in">std</span>::pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="comment">// 这里不要用 dist2，否则很多比较的地方都要平方，反而不优雅了。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span> <span class="params">(<span class="keyword">const</span> Point&amp; p, <span class="keyword">const</span> Point &amp;q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> x = q.first - p.first, y = q.second - p.second;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">minDist</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> d = DBL_MAX;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">	<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; merge = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (r - l == <span class="number">2</span>) &#123;</span><br><span class="line">			d = <span class="built_in">std</span>::<span class="built_in">min</span>(d, dist(a[l], a[l + <span class="number">1</span>]));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		merge(l, m);</span><br><span class="line">		merge(m + <span class="number">1</span>, r);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; p;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= l &amp;&amp; a[m].first - a[i].first &lt; d; --i) &#123;</span><br><span class="line">			p.emplace_back(a[i].second, a[i].first);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; r &amp;&amp; a[i].first - a[m].first &lt; d; ++i) &#123;</span><br><span class="line">			p.emplace_back(a[i].second, a[i].first);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; p.<span class="built_in">size</span>() &amp;&amp; p[j].first - p[i].first &lt; d; ++j) &#123;</span><br><span class="line">				d = <span class="built_in">std</span>::<span class="built_in">min</span>(d, dist(p[i], p[j]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	merge(<span class="number">0</span>, n);</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分治法还能求两个点作为对交的矩阵的最大面积（详见 <a href="/dynamicProgramming/" title="动态规划之分治算法">动态规划之分治算法</a>）</p>
</blockquote>
<h3 id="三维偏序之陈丹琪分治（仅支持离线查询，还是直接暴力好用-）"><a href="#三维偏序之陈丹琪分治（仅支持离线查询，还是直接暴力好用-）" class="headerlink" title="三维偏序之陈丹琪分治（仅支持离线查询，还是直接暴力好用~）"></a>三维偏序之陈丹琪分治（仅支持离线查询，还是直接暴力好用~）</h3><blockquote>
<p>如果带更新怎么处理呢？先预处理求出，之后更新一个计算一个更新？（那也不太行呀）</p>
</blockquote>
<p>一般地，我们考虑可以考虑 $k$ 维偏序，设有 $n$ 个 $k$ 维向量，$a_j \leq a_i$ 当且仅当所有的下标都满足小于等于关系，想知道对任意 $i$ 有多少个 $j \neq i$ 使得 $a_j \leq a_i$。</p>
<p>有复杂度 $O(n \log^k n)$ 的算法，因此在 $k &gt; 3$ 时，我们会选择直接 $O(n^2)$ 暴力解决问题（见下小节）。</p>
<ul>
<li>$k = 1$ 时，我们直接排序，假设没有相同元素，那么它们排完序之后的位置就是答案，有相同的数字的话可以先合并，也可以用 <code>upper_bound</code> 查找出结果。复杂度 $O(n \log n)$</li>
<li>$k = 2$ 时，我们先对第一个坐标偏序，再来一个树状数组，一个个的加入元素，加入之前可以查询结果。这也是求逆序数的操作(如果数据值域范围很大，可以离散化处理一下，仅需对要加入树状数组的那一维离散化，排序可以使用下标排序，就可以避免使用 tuple）。</li>
</ul>
<p>因此三维偏序是一个空缺的问题，就有大名鼎鼎的 cdq 分治。</p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/P3810" target="_blank" rel="noopener">LOJ P3810</a>，这个题的<a href="https://www.luogu.com.cn/problem/solution/P3810" target="_blank" rel="noopener">题解</a>中，有人讲的很好，echo6342：</p>
<blockquote>
<p>cdq 分治每次计算前一半对后一半的影响。具体地，假设三维分别是 $x, y, z$，先按 $x$ 排序。分治时每次将前半边、后半边分别按 $y$ 排序。虽然现在 $x$ 的顺序被打乱了，但是前半边还是都小于后半边的，所以要是只计算前半边对后半边的偏序关系，是不会受到 $x$ 的影响的。维护后一半的指针 i，前一半的指针 j，每次将 i 后移一位时，若 $y[j] \leq y[i]$ 则不断后移 j，并不断将 z[j] 加入树状数组。然后再查询树状数组中有多少数小于等于 z[i]。 最后要清空树状数组（注意清空的时候不能直接清空，而是根据更新的命令，反向一次命令来清空，否则一直开树状数组耗时的），还有就是要去重贼麻烦，还是弃用吧。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y, z, id, w;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (x == A.x) <span class="keyword">return</span> y == A.y ? z &lt; A.z : y &lt; A.y;</span><br><span class="line">		<span class="keyword">return</span> x &lt; A.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ans[i] 表示 小于或等于 a[i] 的元素个数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cdq</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; &amp;a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先按照 y 排序，免得后面代码写的太麻烦</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(a.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// 去重操作</span></span><br><span class="line">	<span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i].x != a[i - <span class="number">1</span>].x || a[i].y != a[i - <span class="number">1</span>].y || a[i].z != a[i - <span class="number">1</span>].z) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = i - last - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = last; j &lt; i; ++j) &#123;</span><br><span class="line">				ans[a[j].id] = t;</span><br><span class="line">				a[j].w = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			a[i - <span class="number">1</span>].w = i - last;</span><br><span class="line">			last = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> t = a.<span class="built_in">size</span>() - last - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		ans[a[i].id] = t;</span><br><span class="line">		a[i].w = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a.back().w = a.<span class="built_in">size</span>() - last;</span><br><span class="line">	<span class="function">TreeArray <span class="title">A</span><span class="params">(k)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> cmpy = [](<span class="keyword">const</span> Node &amp;lhs, <span class="keyword">const</span> Node &amp;rhs) &#123;</span><br><span class="line">		<span class="keyword">return</span> lhs.y &lt; rhs.y;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; divide = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">		divide(l, m);</span><br><span class="line">		divide(m, r);</span><br><span class="line">		<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>() + l, a.<span class="built_in">begin</span>() + m, cmpy);</span><br><span class="line">		<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>() + m, a.<span class="built_in">begin</span>() + r, cmpy);</span><br><span class="line">		<span class="keyword">int</span> t = l;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; r; ++i) &#123;</span><br><span class="line">			<span class="keyword">while</span> (t &lt; m &amp;&amp; a[t].y &lt;= a[i].y) &#123;</span><br><span class="line">				A.add(a[t].z, a[t].w);</span><br><span class="line">				++t;</span><br><span class="line">			&#125;</span><br><span class="line">			ans[a[i].id] += A.sum(a[i].z);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; t; ++i) A.add(a[i].z, -a[i].w);</span><br><span class="line">	&#125;;</span><br><span class="line">	divide(<span class="number">0</span>, a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="k-维偏序（暴力-bitset-优化，分块时间换空间）-O-frac-k-n-2-w"><a href="#k-维偏序（暴力-bitset-优化，分块时间换空间）-O-frac-k-n-2-w" class="headerlink" title="k 维偏序（暴力 bitset 优化，分块时间换空间） $O(\frac{k n^2}{w})$"></a>k 维偏序（暴力 bitset 优化，分块时间换空间） $O(\frac{k n^2}{w})$</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e4</span> + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// a 是 k * n 矩阵表示 n 个 k 维向量，输出每个小于自身的向量个数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partialOrder</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;a)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 直接暴力不太行，所以需要时间换空间，具体说就是分块。</span></span><br><span class="line">	<span class="keyword">int</span> k = a.<span class="built_in">size</span>(), n = a[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">using</span> Node = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; <span class="title">f</span><span class="params">(k, Node(n))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) f[i][j] = &#123;a[i][j], j&#125;;</span><br><span class="line">		<span class="built_in">std</span>::sort(f[i].<span class="built_in">begin</span>(), f[i].<span class="built_in">end</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> sn = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">using</span> Data = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt;&gt;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Data&gt; <span class="title">bs</span><span class="params">(k, Data(n / sn + <span class="number">1</span>))</span></span>;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt; now;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j % sn == <span class="number">0</span>) bs[i][j / sn] = now;</span><br><span class="line">			now.<span class="built_in">set</span>(f[i][j].second);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n % sn == <span class="number">0</span>) bs[i][n / sn] = now;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> getbst = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> val) -&gt; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt; &#123;</span><br><span class="line">		<span class="comment">// 如果求小于或等于的个数，这里要改成 upper_bound 并且要用 INT_MAX，还有最终答案减 1（去掉自身）</span></span><br><span class="line">		<span class="keyword">int</span> j = <span class="built_in">std</span>::lower_bound(f[i].<span class="built_in">begin</span>(), f[i].<span class="built_in">end</span>(), <span class="built_in">std</span>::make_pair(val, INT_MIN)) - f[i].<span class="built_in">begin</span>();</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt; r = bs[i][j / sn];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t = j / sn * sn; t &lt; j; ++t) r.<span class="built_in">set</span>(f[i][t].second);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;N&gt; now; now.<span class="built_in">set</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">			now &amp;= getbst(i, a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		r[j] = now.count();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/U66865" target="_blank" rel="noopener">LOJ U66865</a>，可参考 <a href="https://www.cnblogs.com/cjyyb/p/8196312.html" target="_blank" rel="noopener">小蒟蒻 yyb 的博客</a> 中的 ppt 实现。其它例题：<a href="http://cogs.pro:8081/cogs/problem/problem.php?pid=vSJzQVejP" target="_blank" rel="noopener">偏序++</a></p>
<blockquote>
<p>虽然三维偏序问题用 cdq 分治更好，但是用 bitset 暴力过题还是没啥问题的，例如 <a href="https://www.luogu.com.cn/problem/P3810" target="_blank" rel="noopener">LOJ P3810</a></p>
</blockquote>
<h2 id="几类根号算法"><a href="#几类根号算法" class="headerlink" title="几类根号算法"></a>几类根号算法</h2><p>首先注意到 $\max \{x \mid \lfloor \frac{n}{x} \rfloor =  \lfloor \frac{n}{i} \rfloor \} =  \lfloor \frac{ n }{ \lfloor \frac{n}{i} \rfloor } \rfloor$</p>
<p><strong>Proof</strong>：由于 $x \cdot  \lfloor \frac{n}{x} \rfloor \leq n$ 所以 $x \leq \frac{n}{\lfloor \frac{n}{x} \rfloor}$，所以 $x \leq \lfloor \frac{n}{\lfloor \frac{n}{x} \rfloor} \rfloor$，所以取 $x = i$ 和 $x = \lfloor \frac{n}{i} \rfloor$，则 $\lfloor \frac{n}{\lfloor \frac{ n }{ \lfloor \frac{n}{i} \rfloor } \rfloor} \rfloor = \lfloor \frac{n}{i} \rfloor$，另一方面，若 $\lfloor \frac{n}{x} \rfloor =  \lfloor \frac{n}{i} \rfloor$, 则 $x \leq \lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor} \rfloor$，证毕。</p>
<h3 id="s-n-sum-i-1-n-lfloor-frac-n-i-rfloor"><a href="#s-n-sum-i-1-n-lfloor-frac-n-i-rfloor" class="headerlink" title="$ s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $"></a>$ s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	LL sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		sum += LL(j - i + <span class="number">1</span>) * (n / i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i"><a href="#sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i" class="headerlink" title="$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$"></a>$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// g[i]=f[i]+g[i-1]</span></span><br><span class="line">	LL sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= <span class="built_in">min</span>(n, m); i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = <span class="built_in">min</span>(n / (n / i), m / (m / i);</span><br><span class="line">		sum += LL(n / i) * (m / i) * (g[j] - g[i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题：<a href="https://ac.nowcoder.com/acm/contest/9005/C" target="_blank" rel="noopener">牛客</a>，大致题意是：$n=p \times k + m, 0 \leq m &lt; k$，求 $\sum_{p = 1}^n km$，注意到 $m = n - pk$，所以用上述公式计算即可。</p>
<h3 id="h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor"><a href="#h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor" class="headerlink" title="$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$"></a>$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	<span class="keyword">int</span> r = LL(n) * (n - <span class="number">1</span>) % M * (n - <span class="number">2</span>) % M * inv3 % M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">		j = n / (n / i);</span><br><span class="line">		r -= LL(j - i + <span class="number">1</span>) * getans(n / i) % M;</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>) r += M;</span><br><span class="line">	&#125;</span><br><span class="line">	mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归算法复杂度分析"><a href="#递归算法复杂度分析" class="headerlink" title="递归算法复杂度分析"></a>递归算法复杂度分析</h2><p>下图取自算法导论</p>
<p><img src= "/img/loading.gif" data-lazy-src="complexAnalysis.png" alt="complexAnalysis"></p>
<h2 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h2><h2 id="日常表白-zly"><a href="#日常表白-zly" class="headerlink" title="日常表白 zly"></a>日常表白 zly</h2>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>万能通用模板</title>
    <url>/allTemplate/</url>
    <content><![CDATA[<h2 id="比赛版"><a href="#比赛版" class="headerlink" title="比赛版"></a>比赛版</h2><h3 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 <code>std::endl</code> 和 <code>\n</code> 的区别是前一个刷新缓冲区，后一个不刷新。</p>
</blockquote>
<h3 id="no-Case"><a href="#no-Case" class="headerlink" title="no Case"></a>no Case</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试版"><a href="#面试版" class="headerlink" title="面试版"></a>面试版</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>良好的码风，不乱 define，代码通用性高，不用 using namespace std</p>
</blockquote>
<h2 id="时间自测版本"><a href="#时间自测版本" class="headerlink" title="时间自测版本"></a>时间自测版本</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">auto</span> start = <span class="built_in">std</span>::clock();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time used: "</span> &lt;&lt; (<span class="built_in">std</span>::clock() - start) &lt;&lt; <span class="string">"ms"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>STL 和 C++17 学习记录</title>
    <url>/stl/</url>
    <content><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>为了更加 <strong>优雅</strong> 的写 C++，在学了一点 C++17 皮毛之后，重新探索了一下 C++ STL，总结一些好用的特征。</p>
<p><code>static_cast&lt;T&gt;, optional&lt;T&gt;</code> 是两个好东西。</p>
<p>等到 Codeforces 支持 <code>C++20</code> 后开始学习 <code>C++2x</code></p>
<blockquote>
<p>没有必要关心你自己不用的特征！用的就一定要搞清楚。</p>
</blockquote>
<p>以下示例中，凡是 vector 类型的 <code>a.begin(),a.end()</code> 对应的数组类型都可以改成 <code>a,a+n</code>。</p>
<p>避免使用 <code>vector&lt;bool&gt;</code>，推荐使用 <code>bitset&lt;N&gt;</code><br>简单的说就是它并未实际保存一个 <code>bool</code>, 而是用位域的概念进行了封装.<br>所以你在实际应用的时候可能会发生一些你意料之外的问题.</p>
<h3 id="INT-MAX-DBL-MAX"><a href="#INT-MAX-DBL-MAX" class="headerlink" title="INT_MAX, DBL_MAX"></a><code>INT_MAX</code>, <code>DBL_MAX</code></h3><p>注意一般只用来比较大小的初始变量，做运算会有溢出问题。<code>int</code> 溢出本质就是对 $2^31$ 取模，<code>double</code> 会出现大数吃小数（这个涉及 double 的二进制表达，加减的时候要向大的数对齐），一旦超过了 <code>DBL_MAX</code>，那就变成 <code>inf</code>，<code>inf</code> 的运算规则跟数学的一致。<code>inf - inf = nan</code> 跟 <code>1/0 = nan</code> 一致都是未定义数。</p>
<h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p><code>min,max,minmax</code> 都是参数个数为 2，返回的是值。所以不举例了，注意到 <code>minmax</code> 返回的是 <code>pair</code></p>
<p><code>min_element,max_element,minmax_element</code> 参数都是 <code>vector</code>，且返回的是索引。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *max_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span> lr = minmax_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//不能取*,因为返回的是pair类型</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *lr.first &lt;&lt; <span class="string">" "</span> &lt;&lt; *lr.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span>[l, r] = minmax_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//自动解析也行</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *l &lt; <span class="string">" "</span> &lt;&lt; *r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="累积运算-accumulate-（长没关系，有代码补全）"><a href="#累积运算-accumulate-（长没关系，有代码补全）" class="headerlink" title="累积运算  accumulate （长没关系，有代码补全）"></a>累积运算  accumulate （长没关系，有代码补全）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//默认累和</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//可选加减乘除</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="built_in">std</span>::minus&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>, <span class="built_in">std</span>::multiplies&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>, <span class="built_in">std</span>::divides&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>, [](<span class="keyword">auto</span> &amp; x, <span class="keyword">auto</span> &amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span> * x + y;</span><br><span class="line">&#125;) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>用 <code>stable_sort</code> 是稳定排序，即不改变原有相互不小于的元素的相对位置</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 默认从小到大排序</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 手动从小到大排序（不一定是int，具体问题具体修改）</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.rbegin(), a.<span class="built_in">end</span>()); <span class="comment">// 从大到小排序</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 从大到小排序</span></span><br><span class="line"><span class="comment">//对于 tuple 和 pair 大小关系都是从按照字典序比较的</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> (x ^ <span class="number">4</span>) &lt; (y ^ <span class="number">4</span>); <span class="comment">// 位运算的优先级好低呀</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>std::tuple_size&lt;decltype(tupleExample)&gt;::value;</code> 可以获得 tuple 是多少维的。其中 <code>decltype</code> 代表 <code>declare type</code> 即声明类型。</p>
</blockquote>
<h3 id="集合交并运算"><a href="#集合交并运算" class="headerlink" title="集合交并运算"></a>集合交并运算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; x&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; y&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line"><span class="built_in">std</span>::set_intersection(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>(), y.<span class="built_in">end</span>(), <span class="built_in">std</span>::inserter(t, t.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// 若x,y,t是vector等有push_back 的容器，就可以使用</span></span><br><span class="line"><span class="comment">// set_intersection(x.begin(),x.end(),y.begin(),y.end(),back_inserter(t));</span></span><br><span class="line"><span class="comment">// set_union,set_difference,set_symmetric_difference 等同理</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>优先使用 <code>unorder_set</code></p>
</blockquote>
<h3 id="lambda-表达式递归写法"><a href="#lambda-表达式递归写法" class="headerlink" title="lambda 表达式递归写法"></a>lambda 表达式递归写法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; gcd = [ &amp; ](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="comment">// 注意最前面不能用auto</span></span><br><span class="line">	<span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; gcd(<span class="number">102</span>, <span class="number">210</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::__gcd(<span class="number">102</span>, <span class="number">210</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="C-STL-内建的一些好用的函数"><a href="#C-STL-内建的一些好用的函数" class="headerlink" title="C++ STL 内建的一些好用的函数"></a>C++ STL 内建的一些好用的函数</h3><blockquote>
<p>下面函数后加 <code>ll</code> 就可以得到 <code>unsigned long long</code> 对应的版本。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line">__builtin_parity(uint n):   返回n的二进制<span class="number">1</span>的个数奇偶性</span><br><span class="line">__builtin_clz(uint n)：     返回n的二进制前置<span class="number">0</span>的个数</span><br><span class="line">__builtin_ctz(uint n):      返回n的二进制后置<span class="number">0</span>的个数</span><br><span class="line">__builtin_ffs(<span class="keyword">int</span> n)：      返回n的二进制从后往前第一次出现<span class="number">1</span>的位置</span><br><span class="line">__lg(<span class="keyword">int</span> n):                返回log2(n)的整数部分</span><br><span class="line">= __builtin_ctz(uint n)+<span class="number">1</span></span><br><span class="line">__builtin_popcount(uint n): 返回n的二进制<span class="number">1</span>的个数，以上函数仅在GCC中有</span><br><span class="line">lowbit(uint n): n&amp;(-n)      返回使得最大的<span class="number">2</span>^i|n <span class="comment">// 这个不是内建的</span></span><br><span class="line"><span class="comment">//产生大的随机数</span></span><br><span class="line"><span class="built_in">std</span>::mt19937 rnd(<span class="built_in">std</span>::chrono::steady_clock::now().time_since_epoch().count());</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="容器简介"><a href="#容器简介" class="headerlink" title="容器简介"></a>容器简介</h2><ul>
<li>array, vector, deque, list（双向链表），forward_list（单向链表） 都是顺序容器。</li>
<li>set, map 是关联容器。</li>
<li>unordered_map 和 unordered_set 是无序关联容器</li>
<li>stack，queue，priority_queue 严格说不是容器，而是容器适配器（默认使用 deque，可以自己换成 vector）</li>
</ul>
<h3 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列 priority_queue"></a>优先队列 priority_queue</h3><ul>
<li><code>std::priority_queue&lt;int&gt;</code> 是默认最大堆，即头部是最大值。</li>
<li>最小堆可以用 <code>std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;&gt;&gt;</code>。</li>
<li>如果一般化地情况，<code>std::priority_queue&lt;Node&gt;</code> 其中 Node 中要定义小于号，然后也是最大堆。例如 Node 可以是 <code>std::pair&lt;int, int&gt;</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	Node(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x * A.y &lt; y * A.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>另一种方式（cmp 中出现的 lambda 函数必须是全局变量），例如对 <code>pii = std::pair&lt;int, int&gt;</code> 的<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> pii &amp;lhs, <span class="keyword">const</span> pii &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lhs.first * rhs.second &lt; rhs.second * rhs.first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<blockquote>
<p>注意优先队列不能随机访问和自然遍历 0.0</p>
</blockquote>
<h3 id="注意-map-和-unordered-map-的数据污染问题"><a href="#注意-map-和-unordered-map-的数据污染问题" class="headerlink" title="注意 map 和 unordered_map 的数据污染问题"></a>注意 map 和 unordered_map 的数据污染问题</h3><p>map 中支持 <code>mp[i]</code> 的直接调用（即使没有数据 i，此时默认返回 0），但是次调用会污染了数据，即此时无论 mp 中是否有元素 i, i 都被添加到 mp 中。此时调用迭代器，i 就会出现了，这里需要特别注意。</p>
<p>unordered_map 同理。</p>
<h2 id="大数库"><a href="#大数库" class="headerlink" title="大数库"></a>大数库</h2><h3 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h3><blockquote>
<p>谁说 GMP 好用的，出来挨打！已经抛弃</p>
</blockquote>
<p>Ubuntu 20.04 好像内置安装了 GMP，如果没安装可以使用 <code>sudo apt install libgmp-dev</code> 安装（可能需要安装 m4)<br>使用的时候 <code>#include &lt;gmpxx.h&gt;</code> 就好了（带 xx 表示 C++ 使用，不带表示 C 使用），不过它真的难用</p>
<h3 id="NTL：专攻数论，以后再学吧"><a href="#NTL：专攻数论，以后再学吧" class="headerlink" title="NTL：专攻数论，以后再学吧"></a><a href="https://www.shoup.net/ntl/doc/tour.html" target="_blank" rel="noopener">NTL</a>：专攻数论，以后再学吧</h3><blockquote>
<p>NTL 才是正确的选择，但是它的高效是需要借助 GMP 的</p>
</blockquote>
<h3 id="Boost：最终选择"><a href="#Boost：最终选择" class="headerlink" title="Boost：最终选择"></a><a href="https://www.boost.org/" target="_blank" rel="noopener">Boost</a>：最终选择</h3><blockquote>
<p>Boost 是激进的 STL，STL 是保守的 Boost</p>
</blockquote>
<p>一键安装：<code>sudo apt install libboost-all-dev</code>，正确用法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> BINT = boost::multiprecision::cpp_int;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>win10 下 WSL ubuntu20.04 真香。全所未有的方便！<br>win10 下 还可以用 <a href="https://packages.msys2.org/package/mingw-w64-x86_64-boost?repo=mingw64" target="_blank" rel="noopener">MSYS2 安装</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> BINT = boost::multiprecision::cpp_int;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = <span class="built_in">std</span>::pair&lt;LL, LL&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> sp[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt;= sp[i] &amp;&amp; i * p[j] &lt; N; ++j) &#123; <span class="comment">//防止乘法溢出</span></span><br><span class="line">			sp[i * p[j]] = p[j]; <span class="comment">// 注意到sp只被赋值一次</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">BINT f[N];</span><br><span class="line"><span class="function">BINT <span class="title">getPowSum</span><span class="params">(LL n, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// k&lt;1000</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> BINT(n);</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="number">2</span>) spf();</span><br><span class="line">	<span class="keyword">int</span> nk = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> bPow = [](BINT x, <span class="keyword">int</span> n) -&gt; BINT &#123;</span><br><span class="line">		BINT r(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (; n; x *= x, n &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r *= x;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp[i] == i) f[i] = bPow(BINT(i), k);</span><br><span class="line">		<span class="keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= nk) <span class="keyword">return</span> f[n];</span><br><span class="line">	BINT res = <span class="number">0</span>, tl = <span class="number">1</span>, tr = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) tr = tr * (n - i - <span class="number">1</span>) / (nk - i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((nk - i) &amp; <span class="number">1</span>) res -= f[i] * tl * tr;</span><br><span class="line">		<span class="keyword">else</span> res += f[i] * tl * tr;</span><br><span class="line">		tl = tl * (n - i) / (i + <span class="number">1</span>);</span><br><span class="line">		tr = tr * (nk - i) / (n - i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; getPowSum(<span class="number">100</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="2021-1-11-更新"><a href="#2021-1-11-更新" class="headerlink" title="2021/1/11 更新"></a>2021/1/11 更新</h2><h3 id="指向-const-的指针-p-const-指针-q-和-指向-const-的-const-指针-pq"><a href="#指向-const-的指针-p-const-指针-q-和-指向-const-的-const-指针-pq" class="headerlink" title="指向 const 的指针 p, const 指针 q 和 指向 const 的 const 指针 pq"></a>指向 const 的指针 p, const 指针 q 和 指向 const 的 const 指针 pq</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> *p &#123;&amp;i&#125;;</span><br><span class="line">*p = &amp;j;</span><br><span class="line"><span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> * <span class="keyword">const</span> q &#123;&amp;k&#125;;</span><br><span class="line">*q = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> * <span class="keyword">const</span> pq&#123;&amp;j&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="mutable-成员"><a href="#mutable-成员" class="headerlink" title="mutable 成员"></a>mutable 成员</h3><p>multable 成员指出，即使是 const 对象，它的 mutable 成员也是可以被修改的（例如计数的）<br>。</p>
<h3 id="虚函数-virtual-重载-overide，不再允许子类重载-final"><a href="#虚函数-virtual-重载-overide，不再允许子类重载-final" class="headerlink" title="虚函数 virtual, 重载 overide，不再允许子类重载 final"></a>虚函数 virtual, 重载 overide，不再允许子类重载 final</h3><p>假设基类 的 A 函数需要调用 B 函数，而子类有对 B 进行覆盖。那么子类在调用（从基类继承的） A 函数时，并不会调用子类的 B 函数，而是调用基类的 B 函数。如果像 A 函数调用的是子类中的 B 函数，那么只需在 A 函数前加 virtual 关键字即可，此时最好在子类的函数中添加一个 overide 关键字，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Box.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOX_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOX_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">double</span> length &#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">	<span class="keyword">double</span> <span class="built_in">width</span> &#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">	<span class="keyword">double</span> <span class="built_in">height</span> &#123;<span class="number">1.0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Box() = <span class="keyword">default</span>;</span><br><span class="line">	Box(<span class="keyword">double</span> lv, <span class="keyword">double</span> wv, <span class="keyword">double</span> hv) : length &#123;lv&#125;, <span class="built_in">width</span> &#123;wv&#125;, <span class="built_in">height</span> &#123;hv&#125; &#123;&#125;</span><br><span class="line">	<span class="comment">// Function to show the volume of an object</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showVolume</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Box usable volume is "</span> &lt;&lt; volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">	<span class="comment">// Function to calculate the volume of a Box object</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">volume</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> length * <span class="built_in">width</span> * <span class="built_in">height</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PACKAGE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKAGE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Box.hpp"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Package</span> :</span> <span class="keyword">public</span> Box &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Constructor</span></span><br><span class="line">	Package(<span class="keyword">double</span> lv, <span class="keyword">double</span> wv, <span class="keyword">double</span> hv) : Box &#123;lv, wv, hv&#125; &#123;&#125;</span><br><span class="line">	<span class="comment">// Function to calculate volume of a ToughPack allowing 15% for packing</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">volume</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.85</span> * length * <span class="built_in">width</span> * <span class="built_in">height</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Box.hpp"</span> <span class="comment">// For the Box class</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Package.hpp"</span> <span class="comment">// For the ToughPack class</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Box box &#123;<span class="number">20.0</span>, <span class="number">30.0</span>, <span class="number">40.0</span>&#125;; <span class="comment">// Define a box</span></span><br><span class="line">	Package hardcase &#123;<span class="number">20.0</span>, <span class="number">30.0</span>, <span class="number">40.0</span>&#125;; <span class="comment">// Declare tough box - same size</span></span><br><span class="line">	box.showVolume(); <span class="comment">// Display volume of base box</span></span><br><span class="line">	hardcase.showVolume(); <span class="comment">// Display volume of derived box</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lambda-函数做计数器"><a href="#lambda-函数做计数器" class="headerlink" title="lambda 函数做计数器"></a><a href="https://github.com/shuai132/blog_code/tree/master/src/1.closure" target="_blank" rel="noopener">lambda 函数做计数器</a></h3>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>快速数论变换</title>
    <url>/nft/</url>
    <content><![CDATA[<p>快速 Fourier 变换，被称为 20 世纪最伟大的十大算法之一。所以很多软件都有对应的 FFT，例如 Python 的 <code>scipy.fftpack</code> 中就有关于 FFT 的包。所以个人写 FFT 就没有那么必要了。但是 NFT 的包一般都没多少，而且会写 NFT 必然就会写 FFT 了。大约在 5 年前就写过 NFT 的 C++ 代码，现在一看依然不记得蝶式映射到底是咋想的，<del>所以想独立思考出整个过程</del>(失败）。</p>
<blockquote>
<p>此博文特别划水，建议直接阅读 <a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform" target="_blank" rel="noopener">miskcoo 博文：从多项式乘法到快速傅里叶变换</a></p>
</blockquote>
<p>发现 NFT 一个很大的限制就是你只能在 <code>NFT-friendly</code> 的域（例如 $\mod 998244353 = 119 \cdot2^{23}$，原根为 $3$ ）或者模很小的数的环中处理。即环中所有运算放在整数环中都不会超过选择的大基底。</p>
<p>选择 $n$ 个 <code>NFT-friendly</code> 的大基底 $p_1,\cdots, p_n$ 使得 $p_1\cdots p_n$ 大于 ans 的上界，然后再用 <a href="/chineseRemainTheorem/" title="中国剩余定理">中国剩余定理</a> 就可以把 ans 搞出来了。</p>
<a id="more"></a>
<h2 id="基底的选择"><a href="#基底的选择" class="headerlink" title="基底的选择"></a>基底的选择</h2><p>我们考虑 $\mod p$  构成的域。即运算默认是 $\mod p$ 的（除了指数上的幂次数），因为原根定理，此形式必有原根 $g$，即存在 $\mod p$ 中所有元素都可以写成 $g^n$ 的形式（所以 $g^{p-1}=1,g^{n}\neq 1, 0&lt;n&lt;p-1$）。而我们做 NFT 是需要找一个元素 $w$，使得 $w^{2^k} = 1$，因此我们需要找素数 $p$，使得 $p-1=c \cdot 2^k$，其中 $c$ 是个小奇数。</p>
<h3 id="查找基底的-SageMath-代码"><a href="#查找基底的-SageMath-代码" class="headerlink" title="查找基底的 SageMath 代码"></a>查找基底的 SageMath 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>,<span class="number">32</span>): <span class="comment"># 调节这个数值范围来找自己想要的 p</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">25</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span>(is_prime(j*<span class="number">2</span>^i+<span class="number">1</span>)):</span><br><span class="line">            ans.append(j*<span class="number">2</span>^i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ans: </span><br><span class="line">    print(<span class="string">"1 + "</span>,factor(i<span class="number">-1</span>),<span class="string">"\t=\t"</span>,i)</span><br></pre></td></tr></table></figure>
<p>我们会发现有很多可供选择的例子，其中的娇楚（$c$ 较小，$k$ 较大，$p^2 &lt; 2^{63}$）</p>
<ul>
<li><code>x_1 = 1 + 2^27 * 15</code> 十分推荐！$x_2$ 刚好不超过 <code>INT_MAX</code>，所以在乘积取模之前还多一次加法运算，就很方便！</li>
<li><code>x_2 = 1 + 2^27 * 17</code> 是平方不超过 <code>LL(long long)</code> 中最大的一个，但是不推荐，因为 $2*x_1^2$ 超了 <code>LL</code>。</li>
<li><code>x_3 = 1 + 2^21 * 479</code> 是网上常见的一个，但并不推荐。$c$ 太大了！</li>
<li><code>x_4 = 1 + 2^12 * 3</code> 是最小不超过<code>INT16</code>，并且 $c$ 特别小的一个！如果不用<code>LL</code>就很推荐</li>
<li><code>x_5 = 1 +  2^57 * 29</code> 是不超过 <code>INT64</code> 中最推荐的一个！然后基础运算需要用 GCC 内建的 <code>__int128</code></li>
</ul>
<p>总之，$x_1$ 是最为推荐的，$x_2,x_3$ 很常见主要是因为国内第一篇比较完整的介绍 NFT 的是 <a href="http://blog.miskcoo.com/" target="_blank" rel="noopener">大佬 miskcoo</a>，他当时给的常数是 $x_2,x_3$，然后就人云亦云了！$x_5$ 很有意思，它敲好比 $2^{62}$ 小一点，然后它又大于 $1e9+9$，而 $1e9+7,1e9+9$ 这两个孪生素数又经常的出现在 <code>ICPC/IO</code> 中！<strong>但是，貌似也没啥用，见 NFT 模板代码的注释</strong></p>
<p>用 SageMath 自带的 <code>primtive_root</code> 函数分别求对应的原根 $g_1=31,g_2=g_3=g_5=3,g_4=11$。</p>
<p>所以，在 <code>LL</code> 的数据范围内，我们可以使用 $x_1$，可以处理最长长度为 $2^{27}$ 的 NFT，最长为 $2^{26} \sim 6 \times 10^7$ 项的 NFT 多项式乘法。 </p>
<blockquote>
<p>我们现在存在 $w$，有 $w^N = 1,\; w^n \neq 1, 0&lt; n &lt; N$，其中 $N = 2^k, k&lt;27$，有时我们用 $w_N$ 表明 $w$ 和 $N$ 的关系。</p>
</blockquote>
<h2 id="离散-Fourier-变换-DFT"><a href="#离散-Fourier-变换-DFT" class="headerlink" title="离散 Fourier 变换 DFT"></a>离散 Fourier 变换 DFT</h2><p>对长度为 $N$ 的数列 $a_0,\cdots a_{N-1}$ 做离散 Fourier 变换得到数列 $\hat{a}_0 \cdots \hat{a}_{N-1}$：</p>
<script type="math/tex; mode=display">
\hat{a}_k = \sum_{n=0} ^{N-1} w^{kn}a_n</script><p>写成矩阵形式：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
\hat{a}_0 \\
\hat{a}_1 \\
\vdots \\
\hat{a}_{N-1} 
\end{pmatrix} 
= 
\begin{pmatrix}
1 & 1   & \cdots &1 \\
1 & w & \cdots &w^{N-1} \\
\vdots& & \ddots & \\
1 & w^{N-1}& \cdots & w^{(N-1)(N-1)}
\end{pmatrix} 
\begin{pmatrix}
a_0 \\
a_1 \\
\vdots \\
a_{N-1} 
\end{pmatrix}</script><p>即上述矩阵为 $A$，则 $a_{ij} = w^{ij}$, 即 $b_{ij}= w^{-ij}$，则 $AB = NI$，即 $A^{-1} = \frac{1}{N}(w^{-ij})_{N \times N}$。即我们得到了 Fourier 逆变换公式：</p>
<script type="math/tex; mode=display">
a_k = \frac{1}{N} \sum_{n=0} ^{N-1} w^{-kn} \hat{a}_n</script><h2 id="快速-Fourier-数论变换-NFT"><a href="#快速-Fourier-数论变换-NFT" class="headerlink" title="快速 Fourier 数论变换 NFT"></a>快速 Fourier 数论变换 NFT</h2><p>记 $H = \frac{N}{2}$，</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat{a}_{k} &= \sum_{n=0} ^{N-1} w^{kn}a_n \\
&= (a_0+w^{2k}a_2+\cdots+ w^{2k(H-1)}a_{N-2})+w^k(a_1+w_{2k}a_3+\cdots+w^{2k(H-1)}a_{N-1}) \\
&= \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n} + w^k  \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n+1} \\
\hat{a}_{k+H} &= \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n} - w^k  \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n+1} \\
\end{aligned}</script><p>即长度为 $N$ 的 Fourier 变换可以其奇数项和偶数项的长度为 $\frac{N}{2}$ 的 Fourier 变换表出。于是递归的我们可以在 $O(n\log n)$ 时间复杂度求出。</p>
<blockquote>
<p>递归太消耗计算时间了。因此我们需要给出非递归的版本</p>
</blockquote>
<h3 id="快速-NFT-图"><a href="#快速-NFT-图" class="headerlink" title="快速 NFT 图"></a>快速 NFT 图</h3><p>下图出自 <a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform" target="_blank" rel="noopener">miskcoo 从多项式乘法到快速傅里叶变换</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="bit-reverse-miskcoo.png" alt="bit-reverse-miskcoo"></p>
<p>从这个图发现，最终的计算顺序，是每个数的位倒序。处理的细节 miskcoo 博客写的特别清楚了！</p>
<blockquote>
<p>当我想要修改 Miskcoo 的代码形式时，发现怎么修改都没他的好！</p>
</blockquote>
<p>还有 NFT 可以用于求多项式的逆！也可见 <a href="http://blog.miskcoo.com/2015/05/polynomial-inverse" target="_blank" rel="noopener">Miskcoo 的博文</a></p>
<h2 id="NFT-和卷积的关系"><a href="#NFT-和卷积的关系" class="headerlink" title="NFT 和卷积的关系"></a>NFT 和卷积的关系</h2><p>设 $a,b$ 是长度为 $N$（不必 2 的幂次，之前这个限制只是为了快速计算）的数列，则</p>
<script type="math/tex; mode=display">
\hat{ab} = \hat{a} \star \hat{b}</script><p><strong>Proof</strong>：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat{a} \star \hat{b}(k) &=  \sum_{n=0} ^k  \hat{a}(n) \hat{b}(k-n) \\ 
&=  \sum_{n=0} ^k (\sum_{i=0} ^{N-1}  w^{ni} a_i ) (\sum_{j=0} ^{N-1}w^{(k-n)j}b_j) \\ 
&= \hat{ab}(k)
\end{aligned}</script><blockquote>
<p>最后一个式子成立是因为若 $i \neq j$，则 $\sum_{n=0} ^k w^{ni} a_i w^{(k-n)j}b_j=0$</p>
</blockquote>
<p>所以我们有 $a \star b= \hat{\hat{a} \hat{b}}$，而多项式乘法只是卷积的一个例子。有些时候 <strong>计算式</strong> 一开始不是卷积形式，但是可以转换成卷积形式，再利用 FFT 或者 NFT 加速。</p>
<h2 id="NFT-模板"><a href="#NFT-模板" class="headerlink" title="NFT 模板"></a>NFT 模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> BI = __int128;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(BI *x,<span class="keyword">int</span> len)</span></span>&#123; <span class="comment">// note that bitreverse(i)=j</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;j) swap(x[i],x[j]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l=len&gt;&gt;<span class="number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the mod must NFT-friendly or (len+1)*mod^2 &lt; FM</span></span><br><span class="line"><span class="keyword">const</span> BI FM = BI(<span class="number">29</span>)&lt;&lt;<span class="number">57</span>|<span class="number">1</span>, gg=<span class="number">3</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(BI *x,<span class="keyword">int</span> len,<span class="keyword">bool</span> isInverse=<span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">	g = powmod(gg,(FM<span class="number">-1</span>)/len,FM);</span><br><span class="line">	<span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">		g = powmod(g,FM<span class="number">-2</span>,FM);</span><br><span class="line">		BI invlen = powmod(BI(len),FM<span class="number">-2</span>,FM);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">			x[i]=x[i]*invlen%FM;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(x,len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> half=<span class="number">1</span>,<span class="built_in">step</span>=<span class="number">2</span>;half!=len;half&lt;&lt;=<span class="number">1</span>,<span class="built_in">step</span>&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		BI wn = powmod(g,len/<span class="built_in">step</span>,FM),w=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="built_in">step</span>,w=<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;i+half;++j)&#123;</span><br><span class="line">				BI t=(w*x[j+half])%FM;</span><br><span class="line">				x[j+half]=(FM-t+x[j])%FM;</span><br><span class="line">				x[j]=(x[j]+t)%FM;</span><br><span class="line">				w = w*wn%FM;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">square</span><span class="params">(BI *a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(<span class="number">2</span>*n+<span class="number">1</span>));</span><br><span class="line">	nft(a,len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">		a[i]=a[i]*a[i]%FM;</span><br><span class="line">	&#125;</span><br><span class="line">	nft(a,len,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(BI *a,BI *b,<span class="keyword">int</span> na,<span class="keyword">int</span> nb)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(na+nb+<span class="number">1</span>));</span><br><span class="line">	nft(a,len);nft(b,len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">		a[i] = a[i]*b[i]%FM;</span><br><span class="line">	&#125;</span><br><span class="line">	nft(b,len,<span class="number">1</span>);nft(a,len,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NFT-模板更新（2020-7-9"><a href="#NFT-模板更新（2020-7-9" class="headerlink" title="NFT 模板更新（2020/7/9)"></a>NFT 模板更新（2020/7/9)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> LL M = <span class="number">998244353</span>,ROOT=<span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powmod</span><span class="params">(LL x,LL n)</span></span>&#123;</span><br><span class="line">	<span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%M;</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>; x=x*x%M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i!=a.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;j) swap(a[i],a[j]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l=a.<span class="built_in">size</span>()&gt;&gt;<span class="number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; &amp;a,<span class="keyword">bool</span> isInverse=<span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">	LL g = powmod(ROOT,(M<span class="number">-1</span>)/a.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">		g = powmod(g,M<span class="number">-2</span>);</span><br><span class="line">		LL invLen = powmod(LL(a.<span class="built_in">size</span>()),M<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) x=x*invLen%M;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(a);</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(),<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=w.<span class="built_in">size</span>();++i) w[i] = w[i<span class="number">-1</span>]*g%M;</span><br><span class="line">	<span class="keyword">auto</span> addMod = [](LL x,LL y)&#123;<span class="keyword">return</span> (x+=y)&gt;=M?x-=M:x;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">2</span>,half = <span class="number">1</span>;half!=a.<span class="built_in">size</span>();<span class="built_in">step</span>&lt;&lt;=<span class="number">1</span>,half&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,wstep=a.<span class="built_in">size</span>()/<span class="built_in">step</span>;i!=a.<span class="built_in">size</span>();i+=<span class="built_in">step</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j!=i+half;++j)&#123;</span><br><span class="line">				LL t = (a[j+half]*w[wstep*(j-i)])%M;</span><br><span class="line">				a[j+half]=addMod(a[j],M-t);</span><br><span class="line">				a[j]=addMod(a[j],t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;LL&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; a,<span class="built_in">vector</span>&lt;LL&gt; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz=<span class="number">1</span>,tot = a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(sz&lt;tot) sz*=<span class="number">2</span>;</span><br><span class="line">	a.resize(sz);b.resize(sz);</span><br><span class="line">	nft(a);nft(b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=sz;++i) a[i] = a[i]*b[i]%M;</span><br><span class="line">	nft(a,<span class="number">1</span>);</span><br><span class="line">	a.resize(tot);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于多项式乘法，求逆，带余除法的理论基础见下图，取自 <a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">cp-algorithm</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="mulInv.png" alt="mulInv"></p>
<p><img src= "/img/loading.gif" data-lazy-src="divRem.png" alt="divRem"></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
        <tag>SageMath</tag>
      </tags>
  </entry>
  <entry>
    <title>$x^2 \equiv a \mod n$ 何时有解</title>
    <url>/quadraticModEquation/</url>
    <content><![CDATA[<p>显然，我们只需考虑 $0 \leq a &lt; n$ 的情形。这个问题应该很早就被人考虑好了，不过无所谓吧（反正只是个博文而已）。以下内容都是独立完成的。并可看作 <a href="/quadraticResidueAndGaussReciprocity/" title="二次剩余和 Gauss 互反律">二次剩余和 Gauss 互反律</a> 这篇博文的延续。最后再给出方程的一个解（如果存在的话）。</p>
<a id="more"></a>
<p>记 $A_n =  \{0 &lt; x &lt; n \mid \gcd(x,n) = 1\}$，则 $A_n$ 关于 $\mod n$ 的乘法构成一个群（根据 Euler 定理 $|A_n| = \psi(n)$）</p>
<p>所以若 $\gcd(a,n)= 1$，则任意 $x \in A_n$，存在唯一 $y \in A_n$ 使得 $xy \equiv a \mod n$ </p>
<p>若 $x^2 \equiv a \mod n$ 无解，则 $\prod_{x \in A_n} x = a^{\frac{\psi(n)}{2}} \mod n$</p>
<p>若 $x^2 \equiv a \mod n$ 有解，设 $0 &lt; a_1 &lt; a_2 &lt; \cdots &lt; a_r &lt; n$ 是全部解。则 $\prod_{x \in A_n} x = a^{\frac{\psi(n)-r}{2}} a_1 \cdots a_r  \mod n$，注意到 $r$ 只与 $n$ 有关，与 $a$ 无关。</p>
<blockquote>
<p>用 $[\frac{a}{n}] = 1$ 表示有解，用 $[\frac{a}{n}] = 0$ 表示无解。</p>
</blockquote>
<p>为了考虑这个问题，我们分情况讨论</p>
<h2 id="x-2-equiv-a-mod-2-m-gcd-a-p-m-1-何时有解"><a href="#x-2-equiv-a-mod-2-m-gcd-a-p-m-1-何时有解" class="headerlink" title="$x^2 \equiv a \mod 2^m,  \gcd(a,p^m) = 1$ 何时有解"></a>$x^2 \equiv a \mod 2^m,  \gcd(a,p^m) = 1$ 何时有解</h2><p>当 $m=1,2$ 时，有解当且仅当 $a=1$</p>
<p>当 $m \geq 3$ 时，$2^m | (a_2 -a_1)(a_2+a_1)$, 若 $(a_2-a_1)$ 和 $a_2+a_1$ 都是 <code>4</code> 的倍数，则 $a_1,a_2$ 也是 <code>2</code> 的倍数矛盾于 $\gcd(a,2^m) = 1$。所以 $2^{m-1} \mid a_2+a_1)$ 或者 $2^{m-1} \mid (a_2-a_1)$。所以 $0 &lt; a_1 &lt; 2^{m-2}$，$a_2 = 2^{m-1} - a_1, a_3 = 2^{m-1}+a_1, a_4 = 2^m-a_1$。</p>
<p>但是，若 $x$ 是奇数，则 $x^2 \equiv 1\mod 8$ ，令一方面 $\gcd(a,2^m) = 1$ 当且仅当 $a \equiv \mod 2$，而且每一个解对应 4 个 $x$。</p>
<p>即 $1^2,2^2,\cdots,(2^m-1)^2 \mod 2^m$，只有 $2^{m-3}$ 个数，但是小于 $2^m$ 且模 8 为 1 的数也只有，$2^{m-3}$ 个。因此，</p>
<p>有解 <strong>当且仅当</strong> $a \equiv 1 \mod 8$</p>
<h2 id="x-2-equiv-a-mod-p-m-p-gt-2-gcd-a-p-m-1-何时有解"><a href="#x-2-equiv-a-mod-p-m-p-gt-2-gcd-a-p-m-1-何时有解" class="headerlink" title="$x^2 \equiv a \mod p^m,\;p&gt;2, \gcd(a,p^m) = 1$ 何时有解"></a>$x^2 \equiv a \mod p^m,\;p&gt;2, \gcd(a,p^m) = 1$ 何时有解</h2><p>因为 $p^m \mid (a_2-a_1)(a_2+a_1)$，若$(a_2-a_1)$ 和 $a_2+a_1$ 都是 $p$ 的倍数，则 $a_1, a_2$ 也是 $p$ 的倍数矛盾于 $\gcd(a,p^m) = 1$，所以 $a_2 = p^m - a_1$。从而 $r=2, \; a_1a_2 \equiv -a \mod p^m$，所以</p>
<ul>
<li><p>若 $x^2 \equiv a \mod p^m$ 无解，则 $\prod_{x \in A_n} x = a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m$</p>
</li>
<li><p>若 $x^2 \equiv a \mod p^m$ 有解，则 $\prod_{x \in A_n} x = -a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m$</p>
</li>
</ul>
<p>取 $a=1$，则 $\prod_{x \in A_n} x = -1 \mod p^m$，即 </p>
<script type="math/tex; mode=display">
[\frac{a}{p^m}] =  (1 \equiv a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m)?</script><h2 id="x-2-equiv-a-p-i-mod-p-m-i-lt-m-gcd-a-p-m-1-何时有解"><a href="#x-2-equiv-a-p-i-mod-p-m-i-lt-m-gcd-a-p-m-1-何时有解" class="headerlink" title="$x^2 \equiv a p^i \mod p^m, \; i&lt;m, \; \gcd(a,p^m) = 1$ 何时有解"></a>$x^2 \equiv a p^i \mod p^m, \; i&lt;m, \; \gcd(a,p^m) = 1$ 何时有解</h2><p>若 $i=2k-1$ 为奇数，则 $p^k \mid x$，从而 $p^{i+1} \mid ap^i$，矛盾于 $\gcd(a,p^m) = 1$</p>
<p>所以 $i$ 为偶数，显然此时上式有解当且仅当 $x^2 \equiv a \mod p^{m-i},\gcd(a,p^{m-i}) = 1$ 有解</p>
<p>综上 </p>
<script type="math/tex; mode=display">
[ \frac{a}{p^m} ] = \left\{ \begin{array}{cc} 
1 & a=0 \\
1 & p=2,\; a \equiv 1 \mod 8 \\
-1 & p=2,\; a \not \equiv 1 \mod 8 \\
(1 \equiv a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m)? & p>2,\; \gcd(a,p^m) = 1\\
-1 & \gcd(a,p^m) = p^i, i \equiv 1 \mod 2 \\
[\frac{ap^{-i}}{p^{m-i}}] & \gcd(a,p^m) = p^i, i \equiv 0 \mod 2 \\
\end{array} \right.</script><h2 id="x-2-equiv-a-mod-m-1m-2-gcd-m-1-m-2-1-何时有解"><a href="#x-2-equiv-a-mod-m-1m-2-gcd-m-1-m-2-1-何时有解" class="headerlink" title="$x^2 \equiv a \mod m_1m_2, \gcd(m_1,m_2)=1$ 何时有解"></a>$x^2 \equiv a \mod m_1m_2, \gcd(m_1,m_2)=1$ 何时有解</h2><p>考虑</p>
<script type="math/tex; mode=display">
\begin{aligned}
x \equiv a_1^2 \mod m_1 \\
x \equiv a_2^2 \mod m_2
\end{aligned}</script><p>则，存在 $t_1,t_2$ 使得，$t_1m_1 + t_2m_2 = 1$，所以 $t_1^2 m_1^2 + t_2^2 m_2^2 + 2 t_1 m_1 t_2 m_2=1$, 所以 $x \equiv (t_2m_2 a_1)^2$ 且 $x \equiv (t_1 m_1 a_2)^2$，所以 </p>
<script type="math/tex; mode=display">
x \equiv (t_2 m_2 a_1)^2 + (t_1 m_1 a_2)^2 \equiv (t_2 m_2 a_1 + t_1 m_1 a_2)^2 \mod m_1 m_2</script><p>令一方面若 $x \equiv a^2 \mod m_1 m_2$，则 $x \equiv (a \mod m_i)^2 \mod m_i$</p>
<p>即 $x^2 = a \mod m_1 m_2$ <strong>有解当且仅当</strong> $[\frac{a}{m_1}] = [\frac{a}{m_2}] = 1$</p>
<blockquote>
<p>最终方案：$n = p_1^{m_1} \cdots p_r^{m_r}, \; p_1&lt; \cdots &lt;p_r$, $[\frac{a}{m}] = \prod [\frac{a}{p_i^{m_i}}]$ </p>
</blockquote>
<h2 id="判断是否有解的-sagemath-代码"><a href="#判断是否有解的-sagemath-代码" class="headerlink" title="判断是否有解的 sagemath 代码"></a>判断是否有解的 sagemath 代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modSqrtSymbol.ipynb</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modSqrtSymbol</span><span class="params">(an,n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> p,m <span class="keyword">in</span> factor(n):</span><br><span class="line">        a = an%p^m</span><br><span class="line">        <span class="keyword">if</span> a == <span class="number">0</span>:  <span class="keyword">continue</span></span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> a%p == <span class="number">0</span>:</span><br><span class="line">            a//=p</span><br><span class="line">            m-=<span class="number">1</span></span><br><span class="line">            flag = <span class="keyword">not</span> flag</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:  <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> a%<span class="number">8</span> != <span class="number">1</span>:  <span class="keyword">return</span>  <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> power_mod(a,p^(m<span class="number">-1</span>)*(p<span class="number">-1</span>)//<span class="number">2</span>,p^m) != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 <code>factor</code> 复杂度是 $O(\sqrt{n})$， 所以整体复杂度 $O(\sqrt{n})$</p>
</blockquote>
<h2 id="求出-x-2-equiv-a-mod-n-的一个解"><a href="#求出-x-2-equiv-a-mod-n-的一个解" class="headerlink" title="求出 $x^2 \equiv a \mod n$ 的一个解"></a>求出 $x^2 \equiv a \mod n$ 的一个解</h2><blockquote>
<p>本来是想求全部解的，但是考虑到如果 $\gcd(a,n) \neq 1$ 则解的个数实在太多，就不想求全部解了，当然如果真的有这个需要，求全部解也不难。</p>
<p>另外，无论是是否有解还是求全部解都可以直接暴力做，只是复杂度为 $O(n)$ ，效率太低。</p>
</blockquote>
<h3 id="求-x-2-equiv-a-mod-2-m-的全部解，不妨设-a-equiv-1-mod-8"><a href="#求-x-2-equiv-a-mod-2-m-的全部解，不妨设-a-equiv-1-mod-8" class="headerlink" title="求 $x^2 \equiv a \mod 2^m$ 的全部解，不妨设 $a \equiv 1 \mod 8$"></a>求 $x^2 \equiv a \mod 2^m$ 的全部解，不妨设 $a \equiv 1 \mod 8$</h3><p>若 $m=1$，则 $x=1$，若 $m=2$，则 $x = 1, 3$，若 $m=3$，则 $x=1,3,5,7$，若 $m \geq 4$，不妨设 $x_{m-1}$ 是满足方程 $x^2 \equiv a \mod 2^{m-1}$的最小正整数解，即 $x_{m-1}^2 = a + 2^{m-1}k$</p>
<ul>
<li><p>若 $k$ 是偶数，则必然是 $x_{m-1}^2 \equiv a \mod 2^m$ 的解，最小的解就是 $\min(x_{m-1},2^{m-2}-x_{m-1})$，但由于 $x_{m-1} \leq 2^{m-3}$，所以 $x_m=x_{m-1}$</p>
</li>
<li><p>若 $k$ 为奇数，则 $(2^{m-2} - x_{m-1})^2 = 2^{2m-4} - 2^{m-1} + x_{m-1}^2 \equiv a \mod 2^m$，且 $0&lt;2^{m-2}-x_{m-1}&lt;2^{m-2}$，所以 $x_m =2^{m-2} - x_{m-1}$</p>
</li>
</ul>
<p>所以经过 $m$ 步就可找到所有解就是 $x_m, 2^{m-1} - x_m,2^{m-1} + x_m, 2^m - x_m$</p>
<h3 id="求-x-2-equiv-a-mod-p-m-p-gt-2-的全部解，其中-gcd-a-p-m-1"><a href="#求-x-2-equiv-a-mod-p-m-p-gt-2-的全部解，其中-gcd-a-p-m-1" class="headerlink" title="求 $x^2 \equiv a \mod p^m, \; p&gt;2$ 的全部解，其中 $\gcd(a,p^m) = 1$"></a>求 $x^2 \equiv a \mod p^m, \; p&gt;2$ 的全部解，其中 $\gcd(a,p^m) = 1$</h3><p>令 $q = \frac{\psi(p^m)}{2} = p^{m-1}\frac{p-1}{2}$，若 $q$ 是奇数，则 $(a^{\frac{q+1}{2}})^2 = a^q a \equiv a\mod p^m$，从而解就是 $a^{\frac{q+1}{2}},p^m-a^{\frac{q+1}{2}}$</p>
<p>否则，记 $q = 2^{i}q’$（想模仿上面 $q$ 是奇数的情况），我们找一个非二次剩余 $b$，即 $b^q \equiv -1 \mod p^m$。我们记 $x = a^{\frac{q’+1}{2}},\;y = b^{q’}, \; t= a^{q’}$。则</p>
<p>$x^2 = ta, t^{2^i} = 1, y^{2^i}=-1$。我们想保持 $x^2 = ta$，让 $t$ 变成 1。就打到了我们的目的。</p>
<p>若 $t^{2^{s}} = -1, t^{2^{s+1}} = 1$, 则 $s&lt;i$，那么 $(y^{2^{i-s}}t)^{2^{s}} = y^{2^i}t^{2^{s}} = 1$，并且 $(y^{2^{i-s-1}}x)^2 = (y^{2^{i-s}}t)a$，我们更新 $t = y^{2^{i-s}}t$，更新 $x=y^{2^{i-s-1}}x$。重复上述过程直到 $t=1$。</p>
<p>我们也可以类似 $p=2$ 的情况，经过 $m$ 步得到全部解，只是 $m=1$ 的时候是困难的，并且和上述分析一致，所以就没用 $p=2$ 时的方法。若 $x_{m-1}$ 满足 $x_{m-1}^2 = a + p^{m-1}k$</p>
<ul>
<li><p>若 $k$ 是偶数，$(x_{m-1} - \frac{k}{2}p^{m-1})^2 \equiv a \mod p^m$</p>
</li>
<li><p>若 $k$ 是奇数，$(x_{m-1} + \frac{p-k}{2}p^{m-1})^2 \equiv a \mod p^m$</p>
</li>
</ul>
<p>对一般的 $n = p_1^{m_1} \cdots p_r ^{m_r}$，我们对每个 $(a, p_i ^m)$ 给出一个解，再用 <a href="/chineseRemainTheorem/" title="中国剩余定理">中国剩余定理</a> 拼出最终解。</p>
<h3 id="x-2-equiv-a-mod-n-的一个解的-Sagemath-代码"><a href="#x-2-equiv-a-mod-n-的一个解的-Sagemath-代码" class="headerlink" title="$x^2 \equiv a \mod n$ 的一个解的 Sagemath 代码"></a>$x^2 \equiv a \mod n$ 的一个解的 Sagemath 代码</h3><blockquote>
<p>需要用到上面的 <code>modSqrtSymbol</code> 函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modSqrt.ipynb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find one x s.t. x^2 = a mod 2^m, gcd(a,2) = 1 and 0 &lt; a &lt; 2^m and must have an answer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modSqrt2Core</span><span class="params">(a,m)</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (x*x-a)%(<span class="number">1</span>&lt;&lt;i) != <span class="number">0</span>:</span><br><span class="line">            x = (<span class="number">1</span>&lt;&lt;i<span class="number">-2</span>)-x</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># find one x s.t. x^2 = a mod p^m, gcd(a,p)=1, p&gt;2 and  0 &lt; a &lt; p^m and must have an answer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modSqrtPCore</span><span class="params">(a,p,m)</span>:</span></span><br><span class="line">    n = p^m</span><br><span class="line">    q = p^(m<span class="number">-1</span>)*(p<span class="number">-1</span>)&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> q%<span class="number">2</span> == <span class="number">1</span>:  <span class="keyword">return</span> power_mod(a,(q+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,n)</span><br><span class="line">    b=randint(<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">while</span>(power_mod(b,q,n)==<span class="number">1</span>):  b=randint(<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    ni = q&amp;(-q)</span><br><span class="line">    q //= ni</span><br><span class="line">    x = power_mod(a,(q+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,n)</span><br><span class="line">    y = power_mod(b,q,n)</span><br><span class="line">    t = power_mod(a,q,n)</span><br><span class="line">    <span class="comment"># x^2 = ta mod n, y^ni = -1 mod n</span></span><br><span class="line">    <span class="keyword">while</span> t != <span class="number">1</span>:</span><br><span class="line">        ns = <span class="number">1</span>;tt=t*t;</span><br><span class="line">        <span class="keyword">while</span> tt!=<span class="number">1</span>:</span><br><span class="line">            tt=(tt*tt)%n</span><br><span class="line">            ns&lt;&lt;=<span class="number">1</span></span><br><span class="line">        <span class="comment"># t^ns = -1 mod n</span></span><br><span class="line">        t = power_mod(y,ni//ns,n)*t%n</span><br><span class="line">        x = power_mod(y,ni//(ns*<span class="number">2</span>),n)*x%n</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># find one x s.t. x^2 = a mod p^m and must have an answer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modPowerSqrt</span><span class="params">(a,p,m)</span>:</span></span><br><span class="line">    n = p^m</span><br><span class="line">    a %= n</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> a%p==<span class="number">0</span>:</span><br><span class="line">        a//=p</span><br><span class="line">        m-=<span class="number">1</span></span><br><span class="line">        time+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>**(time//<span class="number">2</span>)*(modSqrt2Core(a,m) <span class="keyword">if</span> p==<span class="number">2</span> <span class="keyword">else</span> modSqrtPCore(a,p,m))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modSqrt</span><span class="params">(a,n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> modSqrtSymbol(a,n):  <span class="keyword">return</span> []</span><br><span class="line">    fact = list(factor(n))</span><br><span class="line">    x = [modPowerSqrt(a,p,m) <span class="keyword">for</span> p,m <span class="keyword">in</span> fact]</span><br><span class="line">    m = [p^m <span class="keyword">for</span> p,m <span class="keyword">in</span> fact]</span><br><span class="line">    <span class="keyword">return</span> crt(x,m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试几个样例</span></span><br><span class="line">a,m = <span class="number">17</span>,<span class="number">2</span>**<span class="number">8</span></span><br><span class="line">x =  modSqrt(a,m)</span><br><span class="line">print(x,x*x%m,a,m)</span><br><span class="line"></span><br><span class="line">a,m = <span class="number">15</span>,<span class="number">7</span>**<span class="number">8</span></span><br><span class="line">x =  modSqrt(a,m)</span><br><span class="line">print(x,x*x%m,a,m)</span><br><span class="line"></span><br><span class="line">a,m = <span class="number">16</span>,<span class="number">3</span>*<span class="number">5</span>*<span class="number">5</span>*<span class="number">7</span>*<span class="number">7</span>*<span class="number">7</span></span><br><span class="line">x =  modSqrt(a,m)</span><br><span class="line">print(x,x*x%m,a,m)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>SageMath</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/dynamicProgramming/</url>
    <content><![CDATA[<p>动态规划是研究一大类问题（特别是最值问题）的一种思路。从大二刚开始 ICPC 竞赛的时候第一次遇到，到大三学运筹学系统的了解，再到后来一直成为解决问题的一种思考方式。可以说动态规划真的是万金油的方法。</p>
<p>计算机领域（或者说博弈论）中的动态规划，就如同数学中的数学归纳法，一样重要。</p>
<blockquote>
<p>运用动态规划的能力，就好比武侠小说中的内功，是随着时间慢慢累积的。<br>进阶可看 <a href="https://codeforces.com/blog/entry/47764" target="_blank" rel="noopener">zscoder 的博文</a></p>
</blockquote>
<a id="more"></a>
<h2 id="动态规划应用举例"><a href="#动态规划应用举例" class="headerlink" title="动态规划应用举例"></a>动态规划应用举例</h2><ul>
<li>数列的递推关系</li>
<li>背包问题</li>
<li>图论中 <a href="/templateOfCpp/" title="Floyd 算法">Floyd 算法</a>，Dijkstra 算法</li>
<li>流水线问题，旅行商问题</li>
<li>其它杂类问题</li>
</ul>
<h2 id="动态规划原理"><a href="#动态规划原理" class="headerlink" title="动态规划原理"></a>动态规划原理</h2><p>动态规划（dynamic programming）于 1950s 被 Richard Bellman 发现。<a href="https://www.zhihu.com/question/23995189/answer/35324479" target="_blank" rel="noopener">引用这里的话</a>，动态规划本质就是：</p>
<ul>
<li>定义问题的状态（必须满足”无后效性”：这个就很玄学了）</li>
<li>写出状态间的转移方程</li>
</ul>
<p>从而递推（分治）的解决问题。</p>
<blockquote>
<p>难点就在于定义问题的状态</p>
<p>很多时候一个变量的问题，我们需要强行加一个（甚至两个）变量来定义状态</p>
<p>然后给出状态转移方程，再做时间空间的优化。</p>
</blockquote>
<h2 id="常规动态规划的状态定义"><a href="#常规动态规划的状态定义" class="headerlink" title="常规动态规划的状态定义"></a>常规动态规划的状态定义</h2><ul>
<li>以该位置结尾的最优策略</li>
<li>多设一个变量的最优策略</li>
</ul>
<h2 id="动态规划举例（长期更新）"><a href="#动态规划举例（长期更新）" class="headerlink" title="动态规划举例（长期更新）"></a>动态规划举例（长期更新）</h2><h3 id="codeforces1354F"><a href="#codeforces1354F" class="headerlink" title="codeforces1354F"></a><a href="https://codeforces.ml/problemset/problem/1354/F" target="_blank" rel="noopener">codeforces1354F</a></h3><p>有 $n$ 张牌，$i$ 号牌的数值是 $a_i$，当 $i$ 号牌放入桌上，之前在桌上的牌，每张数值增加 $b_i$，桌上的牌可以销毁（每张牌最多销毁一次），但是桌上牌的数量不能超过 $k$。 问使桌上牌数值总和最大的放法。其中数据满足</p>
<script type="math/tex; mode=display">
1 \leq k \leq n,\; 1 \leq a_i \leq N,\; 0 \leq b_i \leq N = 10^5, \; a_i,b_i,n,k \in \mathbb{N}</script><blockquote>
<p>由于牌的编号于问题无关，所以不妨设 $b_i$ 单调递增。</p>
</blockquote>
<p>状态定义：<code>dp[i][j]</code> 表示：场上前 $j$ 张牌数（编号都不超过 $i$ ）的桌面牌总和最大值（其实还要减去后 $k-j$ 张牌的原始面值）。如果不减去就有后效性了！！！</p>
<p>状态转移：我们考虑第 $i$ 张牌，</p>
<ul>
<li>如果将它最终留在桌面上，那么它一定是最后一张放在桌面上的，因为 $b_i$ 单调递增。此时 $dp[i][j] = dp[i-1][j-1]+(j-1)b[i] + a[i]$</li>
<li>如果它没留在桌面，那么它一定会在后来第 $k$ 张牌加过 buff，$dp[i][j] = dp[i-1][j] + (k-1)b[i]$</li>
</ul>
<p>所以</p>
<script type="math/tex; mode=display">
dp[i][j] = \max(dp[i-1][j-1]+(j-1)b[i]+a[i],\; dp[i-1][j]+(k-1)b[i])</script><p>我们可以用 <code>isin[i][j]</code> 来标记桌上第 $j$ 张牌是否是 $i$ 号牌。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">bool</span> isin[N][N],chose[N];</span><br><span class="line"><span class="keyword">using</span> node = tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line">node q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+(k<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;i &amp;&amp; j&lt;=k;++j)&#123;</span><br><span class="line">			<span class="keyword">int</span> x = dp[i<span class="number">-1</span>][j]+(k<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i]);</span><br><span class="line">			<span class="keyword">int</span> y = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(j<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i])+<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(q[i]);</span><br><span class="line">			<span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">				dp[i][j] = x;</span><br><span class="line">				isin[i][j] = <span class="literal">false</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[i][j] = y;</span><br><span class="line">				isin[i][j] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=k)&#123;</span><br><span class="line">			dp[i][i] = dp[i<span class="number">-1</span>][i<span class="number">-1</span>]+(i<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i])+<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(q[i]);</span><br><span class="line">			isin[i][i] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n,j=k;i;--i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isin[i][j])&#123;</span><br><span class="line">			chose[i]=<span class="literal">true</span>;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			chose[i]=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas,n,k,a,b;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">	<span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			q[i] = &#123;i,a,b&#125;;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		sort(q+<span class="number">1</span>,q+n+<span class="number">1</span>,[](<span class="keyword">const</span> node &amp; x, <span class="keyword">const</span> node &amp; y)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(x)&lt;<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(y);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(<span class="number">2</span>*n-k)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		getans(n,k);</span><br><span class="line">		<span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(chose[i])&#123;</span><br><span class="line">				<span class="keyword">if</span>(++last == k)&#123;</span><br><span class="line">					last = i;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!chose[i])  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>&lt;&lt;-<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[last])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hdu-5691"><a href="#hdu-5691" class="headerlink" title="hdu 5691"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5691" target="_blank" rel="noopener">hdu 5691</a></h3><p>这题大意：给你一些数，数值固定，部分数的位置随意调节，问你如何调解使得下式取值最大</p>
<script type="math/tex; mode=display">
a_0 a_1 + a_1 a_2 + \cdots + a_{n-1} a_n</script><p>这确实是经典的状态转移问题：</p>
<p>设 $i$ 的 2 进制表示是 $0 \cdots 0 i_1 0 \cdots 0 i_x 0\cdots 0$ 有 $x$ 位。<br><code>dp[i][j]</code> 表示前 $x$ 个空 分别填了 $a[i_1],a[i_2],\cdots,a[i_x]$ 的一个排列 且 $i_x = j$ 使目标最大的最大值。<br>那么，自然地有 <code>dp[i|(1&lt;&lt;k)][k] = max(dp[i][j]+a[j]*a[k])</code></p>
<p>详细转移见代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; <span class="keyword">if</span> (a&lt;b) a=b;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF =  <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],p[N];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, Case = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++Case);</span><br><span class="line">        <span class="keyword">int</span> n, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)    p[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,a+i, &amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x != <span class="number">-1</span>) p[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                dp[i][j] = -INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">0</span>]!=<span class="number">-1</span>)    dp[<span class="number">1</span>&lt;&lt;p[<span class="number">0</span>]][p[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)   dp[<span class="number">1</span>&lt;&lt;i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(i&amp;(<span class="number">1</span>&lt;&lt;j)))   <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;k))    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> x = __builtin_popcount(i);</span><br><span class="line">                    <span class="keyword">if</span>(p[x] == <span class="number">-1</span> || p[x] == k)&#123;</span><br><span class="line">                        upmax(dp[i|(<span class="number">1</span>&lt;&lt;k)][k], dp[i][j]+a[j]*a[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) upmax(res, dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Codeforces-1312E"><a href="#Codeforces-1312E" class="headerlink" title="Codeforces 1312E"></a><a href="https://codeforces.com/contest/1312/problem/E" target="_blank" rel="noopener">Codeforces 1312E</a></h3><p>我们用 <code>ans[i][j]</code> 表示前 <code>i</code> 个数中以 <code>j</code> 结尾的最短数列长度，并用 <code>b[i][j]</code> 保存导致它以 <code>j</code> 结尾的前缀首项的位置。那么状态转移就显然，可从代码中读取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1022</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">502</span>][N],b[<span class="number">502</span>][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,x;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(ans,inf,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		ans[<span class="number">0</span>][x] = <span class="number">1</span>;</span><br><span class="line">		b[<span class="number">0</span>][x]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;N;++j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(ans[i<span class="number">-1</span>][j]!=inf)&#123;</span><br><span class="line">					ans[i][x] = <span class="built_in">min</span>(ans[i][x],ans[i<span class="number">-1</span>][j]+<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				b[i][x]=i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> s = i<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">while</span>(s&gt;=<span class="number">0</span>&amp;&amp;ans[s][x]!=inf)&#123;</span><br><span class="line">				ans[i][x+<span class="number">1</span>] = ans[s][x];</span><br><span class="line">				b[i][x+<span class="number">1</span>] = b[s][x];</span><br><span class="line">				s = b[s][x]<span class="number">-1</span>;</span><br><span class="line">				++x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> r = inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">			r = <span class="built_in">min</span>(r,ans[n<span class="number">-1</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷-P1005-矩阵取数游戏"><a href="#洛谷-P1005-矩阵取数游戏" class="headerlink" title="洛谷 P1005 矩阵取数游戏"></a><a href="https://www.luogu.com.cn/problem/P1005" target="_blank" rel="noopener">洛谷 P1005 矩阵取数游戏</a></h3><blockquote>
<p>每一行单独考虑，然后因为数据范围，所以用 Python 交题</p>
<p>按照规模做 <code>dp</code>，最近做的很少，记录一哈 2020/7/4</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a)</span>:</span></span><br><span class="line">	b = a.copy()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(a)):</span><br><span class="line">		c = []</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,len(b)<span class="number">-1</span>):</span><br><span class="line">			c.append(max(<span class="number">2</span>*b[j]+a[i+j],<span class="number">2</span>*b[j+<span class="number">1</span>]+a[j]))</span><br><span class="line">		b=c</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>*b[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">n = int(input().split()[<span class="number">0</span>])</span><br><span class="line">r=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">	r += f([int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> input().split()])</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure>
<h3 id="洛谷-T135246-「SWTR-05」Grid"><a href="#洛谷-T135246-「SWTR-05」Grid" class="headerlink" title="洛谷 T135246 「SWTR-05」Grid"></a><a href="https://www.luogu.com.cn/problem/T135246?contestId=28195" target="_blank" rel="noopener">洛谷 T135246 「SWTR-05」Grid</a></h3><p><code>dp[i][j]</code> ：第 <code>i</code> 行，以第 <code>j</code> 个数结尾的最小和， <code>s[i][j]</code> ：第 <code>i</code> 行，前 <code>j</code> 个数之和</p>
<p><code>rr[i][j]</code> ：到达 <code>i,j</code> 位置经过的数字和。 </p>
<p><code>r[i][j]</code> ：首次到达 <code>i,j</code> 位置经过格子的数字和(不包括 <code>i,j</code> 的值）初值为 <code>rr[i+1][j]</code></p>
<p><code>dp[i][j]</code> 和 <code>s[i][j]</code> 的状态转移是显然的，<code>rr[i][j]</code> 和 <code>r[i][j]</code> 状态转移：</p>
<script type="math/tex; mode=display">
\begin{aligned}
r[i][j] = \min_{j \leq k<m} r[i][k] + s[i][k] - s[i][j] \\
rr[i][j] = r[i][j] + dp[i][j]
\end{aligned}</script><p>由于 <code>r[i][j]</code> 转移式的对称性，我们考虑记录 <code>s[i][j] + r[i][j]</code> 的最小值，（直接优化了一个 $O(m)$），这也是此题的经典之处。最后 <code>rr</code> 数组可被优化掉。当然也可以对 <code>r</code> 进行空间优化，<del>但是没必要</del>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	LL a[n][m],dp[n][m],s[n][m],r[n+<span class="number">1</span>][m];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">			<span class="keyword">if</span>(j==<span class="number">0</span>) s[i][j] = a[i][j];</span><br><span class="line">			<span class="keyword">else</span> s[i][j] = s[i][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">			cur += a[i][j];</span><br><span class="line">			dp[i][j] = cur;</span><br><span class="line">			cur = <span class="built_in">min</span>(cur,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">		LL mi = <span class="number">1e9</span>+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">			r[i][j] = (i==n<span class="number">-1</span>?<span class="number">0</span>:r[i+<span class="number">1</span>][j]);</span><br><span class="line">			<span class="keyword">if</span>(r[i][j]&lt;mi-s[i][j])&#123;</span><br><span class="line">				mi = r[i][j]+s[i][j]; </span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				r[i][j] = mi-s[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">			r[i][j] += dp[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	LL ret = r[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;++j)&#123;</span><br><span class="line">		ret = <span class="built_in">min</span>(ret,r[<span class="number">0</span>][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面上题的 <strong>空间优化版本（优雅的不行，需要考虑从上向下走）</strong>：</p>
<p><code>rr[j]</code> 表示上一行的答案， <code>r[j]</code> 表示当前行的答案。那么 <code>r[j]</code> 的初始值应该为 <code>rr[j]+dp[j]</code>，状态转移</p>
<script type="math/tex; mode=display">
r[j] = \min_{0 \leq k \leq j} r[k] - s[k] + s[j]</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	LL a[m],s[m],dp[m],r[m],rr[m]=&#123;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		LL cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[j];</span><br><span class="line">			cur += a[j];</span><br><span class="line">			dp[j] = cur;</span><br><span class="line">			cur = <span class="built_in">min</span>(cur,<span class="number">0L</span>L);</span><br><span class="line">			s[j] = a[j]+(j==<span class="number">0</span>?<span class="number">0</span>:s[j<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		cur = rr[<span class="number">0</span>]+dp[<span class="number">0</span>]-s[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">			r[j] = <span class="built_in">min</span>(rr[j]+dp[j],cur+s[j]);</span><br><span class="line">			cur = <span class="built_in">min</span>(cur,r[j]-s[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j) rr[j] = r[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;*min_element(rr,rr+m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T134867-YsOI2020-归零"><a href="#T134867-YsOI2020-归零" class="headerlink" title="T134867 [YsOI2020]归零"></a><a href="https://www.luogu.com.cn/problem/T134867?contestId=31074" target="_blank" rel="noopener">T134867 [YsOI2020]归零</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">132</span>;</span><br><span class="line">LL f[N],invf[N];</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,LL n)</span></span>&#123;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%M;</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>; x=x*x%M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) f[i]=f[i<span class="number">-1</span>]*i%M;</span><br><span class="line">	invf[N<span class="number">-1</span>] = pow_mod(f[N<span class="number">-1</span>],M<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i) invf[i] = invf[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> f[n]*invf[n-k]%M*invf[k]%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	init();</span><br><span class="line">	<span class="built_in">string</span> ss;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;ss;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:ss) s.emplace_back(c-<span class="string">'0'</span>);</span><br><span class="line">	<span class="keyword">auto</span> plusOne = [&amp;](<span class="keyword">int</span> l,<span class="keyword">int</span> r)&#123;</span><br><span class="line">		<span class="keyword">int</span> id = r<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(s[id]==<span class="number">9</span>) --id;</span><br><span class="line">		++s[id];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=id+<span class="number">1</span>;i&lt;r;++i) s[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> minusOne = [&amp;](<span class="keyword">int</span> l,<span class="keyword">int</span> r)&#123;</span><br><span class="line">		<span class="keyword">int</span> id = r<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(s[id]==<span class="number">0</span>) --id;</span><br><span class="line">		--s[id];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=id+<span class="number">1</span>;i&lt;r;++i) s[i] = <span class="number">9</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	function&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>,LL&gt;(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; f = [&amp;](<span class="keyword">int</span> l,<span class="keyword">int</span> r) -&gt; <span class="built_in">map</span>&lt;<span class="keyword">int</span>,LL&gt;&#123;</span><br><span class="line">		<span class="keyword">if</span>(all_of(s.<span class="built_in">begin</span>()+l,s.<span class="built_in">begin</span>()+r,[](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x == <span class="number">0</span>;&#125;))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>,LL&gt;&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">map</span>&lt;<span class="keyword">int</span>,LL&gt; ret;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;r;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i])&#123;</span><br><span class="line">				<span class="keyword">int</span> x = s[i];</span><br><span class="line">				s[i]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(x&gt;<span class="number">4</span>) plusOne(l,i);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ia:f(l,i))&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ib:f(i,r))&#123;</span><br><span class="line">						<span class="keyword">int</span> t1 = <span class="number">1</span>+ia.first+ib.first;</span><br><span class="line">						LL t2 = ia.second*ib.second%M*C(ia.first+ib.first,ia.first)%M;</span><br><span class="line">						<span class="keyword">if</span>(ret.<span class="built_in">find</span>(t1)==ret.<span class="built_in">end</span>())&#123;</span><br><span class="line">							ret[t1] = t2;</span><br><span class="line">						&#125;<span class="keyword">else</span> ret[t1] = (ret[t1]+t2)%M;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(x&gt;<span class="number">4</span>) minusOne(l,i);</span><br><span class="line">				s[i]=x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;;</span><br><span class="line">	LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:f(<span class="number">0</span>,s.<span class="built_in">size</span>()))&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;x.first&lt;&lt;" "&lt;&lt;x.second&lt;&lt;endl;</span></span><br><span class="line">		res+=x.second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res%M&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态压缩-DP（mask-dp）"><a href="#状态压缩-DP（mask-dp）" class="headerlink" title="状态压缩 DP（mask dp）"></a>状态压缩 DP（mask dp）</h2><h3 id="给定-2n-个非负整数，求两两配对的最大公约数的和的最大值"><a href="#给定-2n-个非负整数，求两两配对的最大公约数的和的最大值" class="headerlink" title="给定 $2n$ 个非负整数，求两两配对的最大公约数的和的最大值"></a>给定 $2n$ 个非负整数，求两两配对的最大公约数的和的最大值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// input n and 2n non-negetive integers(less than 1e9)</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	n *= <span class="number">2</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="comment">// initial all gcd which will be used for effectiveness</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">gcd</span><span class="params">(n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			gcd[i][j] = <span class="built_in">std</span>::__gcd(a[i], a[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> cmax = [](LL &amp;a, LL b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a &lt; b) a = b;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// total complex O(2^n * n^3) and we can remove the "if" part of following code</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">mask</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>; <span class="built_in">step</span> &lt; n; ++<span class="built_in">step</span>) &#123; <span class="comment">// every step choose two integers</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> msk = <span class="number">0</span>; msk &lt; (<span class="number">1</span> &lt;&lt; n); ++msk) <span class="keyword">if</span> (__builtin_popcount(msk) == <span class="number">2</span> * <span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">if</span> (!(msk &amp; (<span class="number">1</span> &lt;&lt; i))) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) <span class="keyword">if</span> (!(msk &amp; (<span class="number">1</span> &lt;&lt; j))) &#123;</span><br><span class="line">					cmax(mask[msk|(<span class="number">1</span> &lt;&lt; i)|(<span class="number">1</span> &lt;&lt; j)], mask[msk] + gcd[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(mask.back());</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本问题可以在多项式时间用<a href="https://oi-wiki.org/topic/graph-matching/general-match/" target="_blank" rel="noopener">一般图匹配</a> 解决。</p>
</blockquote>
<h3 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a><a href="https://atcoder.jp/contests/abc180/tasks/abc180_e" target="_blank" rel="noopener">旅行商问题</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; a(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y, z] : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">	<span class="keyword">auto</span> dist = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [aix, aiy, aiz] = a[i];</span><br><span class="line">		<span class="keyword">auto</span> [ajx, ajy, ajz] = a[j];</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">abs</span>(aix - ajx) + <span class="built_in">abs</span>(aiy - ajy) + <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, ajz - aiz);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">d</span><span class="params">(n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			d[i][j] = dist(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> cmin = [](<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a &gt; b) a = b;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">mask</span><span class="params">(<span class="number">1</span> &lt;&lt; n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1e8</span>))</span></span>;</span><br><span class="line">	mask[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">1</span>; <span class="built_in">step</span> &lt; n; ++<span class="built_in">step</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> msk = <span class="number">1</span>; msk &lt; (<span class="number">1</span> &lt;&lt; n); msk += <span class="number">2</span>) <span class="keyword">if</span> (__builtin_popcount(msk) == <span class="built_in">step</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (msk &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) <span class="keyword">if</span> (!(msk &amp; (<span class="number">1</span> &lt;&lt; j))) &#123;</span><br><span class="line">					cmin(mask[msk|(<span class="number">1</span> &lt;&lt; j)][j], mask[msk][i] + d[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">1e8</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, mask[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i] + d[i][<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">print</span>(r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="453B：状态压缩-DP"><a href="#453B：状态压缩-DP" class="headerlink" title="453B：状态压缩 DP"></a><a href="https://codeforces.com/contest/453/problem/B" target="_blank" rel="noopener">453B</a>：状态压缩 DP</h3><p>给定数列 $a$，求满足元素两两互素的数列 $b$ 使得 $\sum |a_i - b_i|$ 最小</p>
<blockquote>
<p>注意到 $b_i &lt; 2 a_i$，因为否则取 $b_i = 1$ 即可。</p>
</blockquote>
<p>由于 $60$ 内的素数个数为 17, 因此可以状态压缩 DP。设 <code>dp[i][j]</code> 表示使得 $\sum_{k = 1} ^ i |a_k - b_k|$ 最小，且$b_1 \cdots b_i$ 中所有出现的素因子的状态为 $j$。因此状态转移就是 <code>dp[i][j | factor[k]] = min(dp[i - 1][j] + |a_i - k|)</code>，其中 <code>factor[k]</code> 与 $j$ 没有交集。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">int</span> ma = *<span class="built_in">std</span>::max_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) * <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; ma; ++i) &#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i; ++j) <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) p.emplace_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">factor</span><span class="params">(ma)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; ma; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.<span class="built_in">size</span>(); ++j) <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">			factor[i] |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; p.<span class="built_in">size</span>(), <span class="number">1e9</span>))</span></span>;</span><br><span class="line">	ans[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * a[i - <span class="number">1</span>]; ++j) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; p.<span class="built_in">size</span>()); ++k) <span class="keyword">if</span> ((k &amp; factor[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">				ans[i][k | factor[j]] = <span class="built_in">std</span>::<span class="built_in">min</span>(ans[i][k | factor[j]], ans[i - <span class="number">1</span>][k] + <span class="built_in">abs</span>(a[i - <span class="number">1</span>] - j));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="built_in">std</span>::min_element(ans[n].<span class="built_in">begin</span>(), ans[n].<span class="built_in">end</span>()) - ans[n].<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * a[i]; ++j) <span class="keyword">if</span> ((now | factor[j]) == now) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ans[i][now ^ factor[j]] + <span class="built_in">abs</span>(a[i] - j) == ans[i + <span class="number">1</span>][now]) &#123;</span><br><span class="line">				r[i] = j;</span><br><span class="line">				now ^= factor[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : r) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">println</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="662C：状态压缩-DP-FWT-模板"><a href="#662C：状态压缩-DP-FWT-模板" class="headerlink" title="662C：状态压缩 DP + FWT 模板"></a><a href="https://codeforces.com/contest/662/problem/C" target="_blank" rel="noopener">662C</a>：状态压缩 DP + FWT 模板</h3><p>给定 $n \times m$ 的 0-1 方阵，可以取反一些行和列使得最后 0 的数列最小。</p>
<blockquote>
<p>首先注意到 $n &lt; 20$，我们可以把每一列看作一个状态 <code>i</code> ，并且结果跟列的顺序无关。我们可以记录下初始情况每种状态数 C[i] 量。<br>并且每一种状态 <code>i</code> 对答案的贡献显然就是它的 0, 1 个数的最小值记作 <code>g[i]</code>。<br>对于每一个行取反 S, 其实就是将一个状态 i 变成 状态 <code>i ^ S</code><br>所以每一种行取反 S，最终的答案 $\displaystyle F(S) = \sum_{i} C[i] \cdot g[i \wedge S] = \sum_{i \wedge j = S} C[i] \cdot g[j]$ </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x += y) &gt;= P &amp;&amp; (x -= P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FWT</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; N &lt; n; N &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j + m], a[i + j]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j + m], a[i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j], a[i + j + m]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j], a[i + j + m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTxor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), inv2 = (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = a[i + j + m];</span><br><span class="line">                <span class="keyword">if</span> (!rev) &#123;</span><br><span class="line">                    a[i + j] = (x + y) % P;</span><br><span class="line">                    a[i + j + m] = (x - y + P) % P;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[i + j] = <span class="number">1L</span>L * (x + y) * inv2 % P;</span><br><span class="line">                    a[i + j + m] = <span class="number">1L</span>L * (x - y + P) * inv2 % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Or</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">And</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTand(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTand(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTand(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Xor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTxor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTxor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTxor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; fwt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	std::vector&lt;int&gt; c(1 &lt;&lt; n), g(1 &lt;&lt; n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			r |= (a[j][i] - <span class="string">'0'</span>) &lt;&lt; j;</span><br><span class="line">		&#125;</span><br><span class="line">		++c[r];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j &amp; (<span class="number">1</span> &lt;&lt; i)) ++g[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i) &#123;</span><br><span class="line">		g[i] = <span class="built_in">std</span>::<span class="built_in">min</span>(g[i], n - g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> f = fwt.Xor(c, g);</span><br><span class="line">	<span class="built_in">print</span>(*<span class="built_in">std</span>::min_element(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>()));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树形-DP"><a href="#树形-DP" class="headerlink" title="树形 DP"></a>树形 DP</h2><blockquote>
<p>树形 DP 本质上就是，树结构可以给出各种不同的偏序关系，针对不同的问题，给出偏序关系，再来 DP</p>
</blockquote>
<h2 id="换根-DP"><a href="#换根-DP" class="headerlink" title="换根 DP"></a>换根 DP</h2><p>树形 DP 的进阶：<a href="https://zhuanlan.zhihu.com/p/348349531" target="_blank" rel="noopener">朝夕 ACM 笔记</a></p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/P3478" target="_blank" rel="noopener">LOJ P3478</a></p>
<p>题意：求以树的某个节点为根，各个节点的深度之和</p>
<p>做法：先以 1 为根预处理出所有子树的深度之和，然后 DP，例如 v 的父节点为 u，那么 <code>ans[v] = ans[u] - sz[v] + sz[1] - sz[v]</code> (以 v 的根的子树的深度都要降低 1， v 的父节点和兄弟节点深度都要加 1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	std::vector&lt;int&gt; dep(n + 1), sz(n + 1);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		sz[u] = <span class="number">1</span>;</span><br><span class="line">		ans[u] = dep[u];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			pdfs(v, u);</span><br><span class="line">			sz[u] += sz[v];</span><br><span class="line">			ans[u] += ans[v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	dep[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	pdfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 预处理出 1 为根的结果，然后进行换根 DP</span></span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			ans[v] = ans[u] + sz[<span class="number">1</span>] - <span class="number">2</span> * sz[v];</span><br><span class="line">			dfs(v, u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::max_element(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()) - ans.<span class="built_in">begin</span>() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换根 DP 套路：</p>
<ul>
<li>dfs 预处理以 1 为根的结果，预处理时其实也计算了子树的结果</li>
<li>第二次 dfs 进行 DP。</li>
</ul>
<p>其它例题：<a href="https://codeforces.com/problemset/problem/1324/F" target="_blank" rel="noopener">1324F</a> 和 <a href="https://codeforces.com/problemset/problem/708/C" target="_blank" rel="noopener">708C</a></p>
<h2 id="斜率优化-DP"><a href="#斜率优化-DP" class="headerlink" title="斜率优化 DP"></a>斜率优化 DP</h2><p>形如 $dp[i] = c_i + \min_{j &lt; i} a_j x_i + b_j$ 的都可以用斜率优化 DP（要求 $x_i, a_j$ 单调，最大值同理也是一样的）</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P2120" target="_blank" rel="noopener">LOJ P2120</a> </p>
<p>就此题具体说明斜率优化 DP</p>
<p>首先设 <code>dp[i]</code> 为在第 i 个工厂建设仓库，前 i 个工厂的费用之和的最小值。显然 $dp[0] = 0$</p>
<script type="math/tex; mode=display">
dp[i] = c_i + \min_{j < i} dp[j] + \sum_{k = j + 1}^i (x_i - x_k) p_k</script><p>设 $a_i = \sum_{j = 1}^i p_j$，$b_i = \sum_{j = 1}^i x_j p_j$，则</p>
<script type="math/tex; mode=display">
dp[i] = c_i + a_i x_i - b_i + \min_{j < i} -a_j x_i + (b_j + dp[j])</script><p>不妨设 $i &gt; j &gt; k$，那么若决策 j 优于 k 当且仅当 $-a_j x_i + b_j + dp[j] &lt; -a_k x_i + b_k + dp[k]$ 当且仅当 $x_i &gt; \frac{(b_j + dp[j]) - (b_k + dp[k])}{a_j - a_k}$（记作 solpe(j, k)），显然若 <code>solpe(i, j) &lt; solpe(j, k)</code> 则 <code>j</code> 必不可能成为最优点。因此相邻的节点斜率必然是递增的，因此合法队首对应的就是答案。用一个双向队列即可。（实现的时候变量有一些混用为了代码的简洁）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("C:\\Users\\dna049\\cf\\in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	std::vector&lt;LL&gt; x(n + 1), a(n + 1), c(n + 1), b(n + 1), dp(n + 1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; a[i] &gt;&gt; c[i];</span><br><span class="line">		++x[i]; <span class="comment">// 为了避免 x[0] = x[1]</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		b[i] = b[i - <span class="number">1</span>] + x[i] * a[i];</span><br><span class="line">		a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// j &gt; k, </span></span><br><span class="line">	<span class="keyword">auto</span> solpe = [&amp;](<span class="keyword">int</span> j, <span class="keyword">int</span> k) -&gt; <span class="keyword">double</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">double</span>(b[j] - b[k]) / (a[j] - a[k]); </span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 这里手写双向队列要更为方便，队列中相邻两点斜率是单调递增的，且队首最优</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Q</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r &amp;&amp; solpe(Q[l + <span class="number">1</span>], Q[l]) &lt;= x[i]) ++l;</span><br><span class="line">		dp[i] = c[i] + (a[i] - a[Q[l]]) * x[i] - b[i] + b[Q[l]];</span><br><span class="line">		b[i] += dp[i];</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r &amp;&amp; solpe(Q[r], Q[r - <span class="number">1</span>]) &gt;= solpe(i, Q[r])) --r;</span><br><span class="line">		Q[++r] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dp.back() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四边形优化-DP"><a href="#四边形优化-DP" class="headerlink" title="四边形优化 DP"></a><a href="https://oi-wiki.org/dp/opt/quadrangle/" target="_blank" rel="noopener">四边形优化 DP</a></h2><h3 id="区间-2D1D-动态规划，将-O-n-3-复杂度优化成-O-n-2"><a href="#区间-2D1D-动态规划，将-O-n-3-复杂度优化成-O-n-2" class="headerlink" title="区间 2D1D 动态规划，将 $O(n^3)$ 复杂度优化成 $O(n^2)$"></a>区间 2D1D 动态规划，将 $O(n^3)$ 复杂度优化成 $O(n^2)$</h3><script type="math/tex; mode=display">
f_{l, r} = \min_{l \leq k < r} f_{l, k} + f_{k + 1, r} + w(l, r) \qquad (1 \leq l < r \leq n)</script><p>其中 $w(l, r)$ 满足</p>
<ul>
<li>区间单调性：$w(l’, r’) \leq w(l, r)$ 对任意 $l \leq l’ \leq r’ \leq r$ 成立</li>
<li>四边形不等式：$w(l_1, r_1) + w(l_2, r_2) \leq w(l_2, r_1) +  w(l_1, r_2)$ 对任意 $l_1 \leq l_2 \leq r_1 \leq r_2$ 成立。</li>
<li>四边形不等式（等价形式）：$w(i, j) + w(i + 1, j + 1) \geq w(i + 1, j) + w(i, j + 1)$ 对任意 $i &lt; j$ 成立。</li>
</ul>
<p>若 $w(l, r)$ 满足上述关系，那么 $f_{l, r}$ 满足四边形不等式。首先注意到 $l_1 = l_2$ 或 $r_1 = r_2$ 时是平凡的。我们分 $l_1 &lt; l_2 = r_1 &lt; r_2$ 和 $l_1 &lt; l_2 &lt; r_1 &lt; r_2$ 两种情况讨论，都用数学归纳法证明。第一种情形只需 $w(l, r)$ 的区间单调性，第二种情形的证明只需四边形不等式。</p>
<p><a href="https://github.com/OI-wiki/OI-wiki/pull/2958/commits/172c5b18aa3b3b63fd4df4978341a1743818ef05" target="_blank" rel="noopener">完整证明</a></p>
<p>此时记 $m_{l, r} = \min \{k: f_{l, r} = f_{l, k} + f_{k + 1, r} + w(l, r)\} \quad (1 \leq l &lt; r \leq n)$ 即最小最优决策点。则有（反证法证明）</p>
<script type="math/tex; mode=display">
m_{l, r - 1} \leq m_{l, r} \leq m_{l + 1, r} \quad (l + 1 < r)</script><p>因此如果我们在计算 $f_{l, r}$ 的同时记录下最小最优决策点 $m_{l, r}$ 那么我们对 决策点 $k$ 的总枚举次数为</p>
<script type="math/tex; mode=display">
\sum_{1 \leq l \leq r} m_{l, r} = n - 1 +
\sum_{1 \leq l + 1 \leq r} m_{l + 1, r} - m_{l, r -1} = n - 1 \sum_{1 < i < n} m_{i, n} - m_{1, i} \leq n^2</script><blockquote>
<p>若 $w$ 仅满足区间单调性，我们取最大值，那么做法完全不同，此时</p>
</blockquote>
<script type="math/tex; mode=display">
g_{l, r} = \max_{l \leq k < r} g_{l, k} + g_{k + 1, r} + w(l, r) \qquad (1 \leq l < r \leq n)</script><p>我们可以证明：$g_{l, r} = \max \left(g_{l, l} + g_{l + 1, r}, g_{l, r - 1} + g(r, r) \right) + w(l, r)$。</p>
<p>设 $k$ 是 $g_{l, r}$ 的最小最优决策点。不妨假设 $l &lt; k &lt; r - 1$，设 $u$ 是 $g_{l, k}$ 的最优决策点，$v$ 是 $g_{k + 1, r}$ 的最优决策点。那么我们先决策 $u$ 再决策 $k$ 可知 $w(u + 1, r) &lt; w(l, k)$。先决策 $v$ 再决策 $k$ 知 $w(l, v) \leq w(k + 1, r)$，然而 $w(l, v) + w(u + 1,r) \geq w(l, k) + w(k + 1, r)$ 矛盾。（画图看就能看得很清晰）</p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/P1880" target="_blank" rel="noopener">LOJ P1880</a></p>
<p>题意：在一个圆圈上，有 n 堆石子，可以合并相邻的石子获得合并后的石子数的得分。问最后合并成一堆时最大得分和最小得分。</p>
<p>做法：首先我们可以搞 2n 堆石子，破圈为链。然后设 $f_{i, j}, g_{i, j}$ 为分别为第 i 堆到第 j 堆合并成一堆的最小和最大得分。记 $w(i, j)$ 为第 i 堆到第 j 堆石子数之和，则</p>
<script type="math/tex; mode=display">
f_{i, j} = \min_{i \leq k < j} g(i, k) + g(k + 1, j) + w(i, j) \\
g_{i, j} = \max_{i \leq k < j} g(i, k) + g(k + 1, j) + w(i, j) \\</script><p>显然 $w(i, j)$ 满足区间单调性和四边形恒等式，因此对于最小都可以用平行四边形优化。</p>
<p>对于最大值，用上述优化做法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("C:\\Users\\dna049\\cf\\in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">a</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 破圈为链</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		a[i + n] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++i) a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">auto</span> w = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">		<span class="keyword">return</span> a[r] - a[l - <span class="number">1</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">	std::vector&lt;std::vector&lt;LL&gt;&gt; f(2 * n + 1, std::vector&lt;LL&gt;(2 * n + 1)), mf(2 * n + 1, std::vector&lt;LL&gt;(2 * n + 1));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">		f[i][i + <span class="number">1</span>] = w(i, i + <span class="number">1</span>);</span><br><span class="line">		mf[i][i + <span class="number">1</span>] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> g = f;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = len + <span class="number">1</span>; r &lt;= <span class="number">2</span> * n; ++l, ++r) &#123;</span><br><span class="line">			f[l][r] = INT64_MAX;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = mf[l][r - <span class="number">1</span>]; k &lt;= mf[l + <span class="number">1</span>][r]; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> (f[l][r] &gt; f[l][k] + f[k + <span class="number">1</span>][r]) &#123;</span><br><span class="line">					f[l][r] = f[l][k] + f[k + <span class="number">1</span>][r];</span><br><span class="line">					mf[l][r] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			f[l][r] += w(l, r);</span><br><span class="line">			g[l][r] = <span class="built_in">std</span>::<span class="built_in">max</span>(g[l + <span class="number">1</span>][r], g[l][r - <span class="number">1</span>]) + w(l, r);			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	LL ff = INT64_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ff = <span class="built_in">std</span>::<span class="built_in">min</span>(ff, f[i][i + n - <span class="number">1</span>]);</span><br><span class="line">	LL gg = INT64_MIN;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) gg = <span class="built_in">std</span>::<span class="built_in">max</span>(gg, g[i][i + n - <span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ff &lt;&lt; <span class="string">"\n"</span> &lt;&lt; gg &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>石子合并问题的最优解法是 GarsiaWachs 算法，复杂度 $O(n \log n)$。例题：<a href="https://www.luogu.com.cn/problem/P5569" target="_blank" rel="noopener">LOJ 5569</a>，以后有时间再学论文：<a href="https://sci-hub.do/10.1016/0196-6774%2888%2990009-0#" target="_blank" rel="noopener">A New Proof of the Garsia-Wachs Algorithm</a>，本质是决策树问题。</p>
</blockquote>
<h3 id="二维滚动-DP-分治-DP-将-O-n-m-2-复杂度优化成-O-n-m"><a href="#二维滚动-DP-分治-DP-将-O-n-m-2-复杂度优化成-O-n-m" class="headerlink" title="二维滚动 DP 分治 DP 将 $O(n m^2)$ 复杂度优化成 $O(n m)$"></a>二维滚动 DP 分治 DP 将 $O(n m^2)$ 复杂度优化成 $O(n m)$</h3><script type="math/tex; mode=display">
f_{i, j} = \min_{k < j} f_{i - 1, k} + w(k + 1, j) \quad (1 \leq i \leq n, 1 \leq j \leq m)</script><p>其中 $f(0, 0) = 0$，$f_0, i = \infty, f_{i, j} = 0 \quad i &gt; j$。$w$ 满足区间单调和四边形不等式。</p>
<p>不难看出 $f_{1, j} = w(1, j)$。</p>
<p>我们对 $i$ 数学归纳法证明：$f_{i, j + 1} + f_{i + 1, j} \geq f_{i, j} + f_{i + 1, j + 1}$ 对任意 $i &lt; j$ 成立。即证明四边形不等式。</p>
<p>当 $i = 1$ 时，$f_{2, j} = f_{1, p} + w(p + 1, j) = w(1, p) + w(p + 1, j)$，并且 $f_{2, j + 1} \leq w(1, p) + w(p + 1, j + 1)$</p>
<p>从而</p>
<script type="math/tex; mode=display">
f_{1, j + 1} + f_{2, j} = w(1, j + 1) + w(1, p) + w(p + 1, j) \geq w(1, j) + w(p + 1, j + 1) + w(1, p) \geq f_{1, j} + f_{2, j + 1}</script><p>假设 $f_{i - 1, j} + f_{i, j - 1} \geq f_{i - 1, j - 1} + f_{i, j}$ 对任意 $i &lt; j$ 成立，那么显然 $f_{i - 1, k} + f_{i, j - 1} \geq f_{i - 1, j - 1} + f_{i, k}$ 对任意 $i &lt; j \leq k$ 成立。</p>
<p>分情况讨论，记  $u, v$ 分别为 $f_{i, j + 1}, f_{i+ 1, j}$ 的最优决策点（$i - 1 \leq u \leq j, i \leq v &lt; j$）。那么</p>
<p>假设 $i &lt; i + 1 &lt; j &lt; j +1$</p>
<ul>
<li><p>$u \geq v$，则 $i \leq u \leq j$，$f_{i + 1, j + 1} \leq f_{i, u} + w(u + 1, j +1)$，$f_{i, j} \leq f_{i - 1, v} + w(v + 1, j)$ 从而 </p>
<script type="math/tex; mode=display">
  f_{i, j + 1} + f_{i + 1, j} = f_{i - 1, u} + w(u + 1, j +1) + f_{i, v} + w(v + 1, j)</script><p>  由归纳法知道 $f_{i - 1, u} + f_{i, v} \geq  f_{i - 1, v} + f_{i, u} \quad (i - 1 &lt; i &lt; v \leq u)$。两式相加得到我们要证的目标。</p>
</li>
<li><p>$u &lt; v$ 则 $i - 1 \leq u &lt; j$，$f_{i + 1, j + 1} \leq f_{i, v} + w(v + 1, j + 1), f_{i, j} \leq f_{i - 1, u} + w(u + 1, j)$，从而 $u + 1 \leq v + 1 \leq j \leq j + 1$</p>
<script type="math/tex; mode=display">
  f_{i, j + 1} + f_{i + 1, j} - f_{i +1, j + 1} - f_{i, j} \geq w(u + 1, j +1) + w(v + 1, j) - w(v + 1, j + 1) - w(u + 1, j) \geq 0</script></li>
</ul>
<p>假设 $i &lt; i + 1 = j &lt; j + 1$</p>
<ul>
<li><p>若 $u &lt; j$，则 $f_{i, j} \leq f_{i - 1, u} + w(u + 1, j)$，</p>
<script type="math/tex; mode=display">
  f_{i, j} + f_{i + 1, j + 1} \leq f_{i - 1, u} + w(u + 1, j) + f_{i, i} + w(i + 1, j + 1) \leq f_{i - 1, u} + w(u + 1, j + 1) + f_{i, i} + w(i + 1, j) = f_{i, j + 1} + f_{i + 1, j}</script></li>
<li><p>若 $u = j$ ，注意到 $i - 1 &lt; i = j - 1 &lt; j$，归纳法有 $f_{i - 1, j} + f_{i, j - 1} \geq f_{i - 1, j - 1} + f_{i, j}$。所以 $f_{i, j + 1} + f_{i + 1, j} = f_{i - 1, j} + w(j + 1, j + 1) + f_{i, j - 1} + w(j, j) \geq f_{i - 1, j - 1} + w(j, j) f_{i, j} + w(j + 1, j + 1) \geq f_{i, j} + f_{i + 1, j + 1}$，证毕。</p>
</li>
</ul>
<p>记 $k[i][j]$ 为 $f_{i, j}$ 的最小最优策略。</p>
<p>决策优化不等式：$k[i -1][j] \leq k[i][j] \leq k[i][j + 1]$（注意这与之前的不同）。</p>
<p>证明：记 $u = k[i][j], x = k[i - 1][j], y = k[i][j + 1]$，反证法：若 $u &lt; x$。首先由定义 </p>
<script type="math/tex; mode=display">
f_{i - 1, u} + w(u + 1, j) \leq f_{i - 1, x} + w(x + 1, j)</script><p>又 $i - 2 &lt; i - 1 \leq u &lt; k$，因此 </p>
<script type="math/tex; mode=display">
f_{i - 2, u} + f_{i - 1, x} \leq f_{i - 2, x} + f_{i - 1, u}</script><p>两式相加得到</p>
<script type="math/tex; mode=display">
f_{i - 2, u} + w(u + 1, j) \leq f_{i - 2, x} + w(x + 1, j)</script><p>矛盾与 $x$ 是 $f_{i - 1, j}$ 的最小最优策略。</p>
<p>同理，假设 $u &gt; y$。由定义</p>
<script type="math/tex; mode=display">
f_{i - 1, y} + w(y + 1, j + 1) \leq f_{i - 1, u} + w(u + 1, j + 1)</script><p>又 $y + 1 &lt; u + 1 \leq j &lt; j + 1$。</p>
<script type="math/tex; mode=display">
w(y + 1, j) + w(u + 1, j + 1) \leq w(y + 1, j + 1) + w(u + 1, j)</script><p>两式相加得到</p>
<script type="math/tex; mode=display">
f_{i - 1, y} + w(y + 1, j) \leq f_{i - 1, u} + w(u + 1, j)</script><p>复杂度：</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^{n} \sum_{j = 1}^m k_{i, j + 1} - k_{i - 1, j} = \sum_{i = 1}^n k_{i, m + 1} + \sum_{j = 1}^m  k_{n, j} < 2 n m</script><p>例题：<a href="https://www.luogu.com.cn/problem/P4767" target="_blank" rel="noopener">LOJ P4767</a></p>
<p>不难看出 $w(k, j)$ 表示在 $k$ 到 $j$ 个村庄建一个邮局使得总距离之和最小（那肯定是建在中位数位置）不难证明它满足四边形不等式（分奇偶很好证明）。首先把 w 给预处理出来。然后再转移。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("C:\\Users\\dna049\\cf\\in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	std::vector&lt;std::vector&lt;int&gt;&gt; w(n + 1, std::vector&lt;int&gt;(n + 1)), f(m + 1, std::vector&lt;int&gt;(n + 2));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) w[i][i + <span class="number">1</span>] = a[i + <span class="number">1</span>] - a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = len + <span class="number">1</span>; j &lt;= n; ++j, ++i) &#123;</span><br><span class="line">			w[i][j] = w[i + <span class="number">1</span>][j - <span class="number">1</span>] + a[j] - a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> mf = f;</span><br><span class="line">	<span class="comment">// mf[i - 1][j] \leq mf[i][j] \leq m[i][j + 1]</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) f[<span class="number">0</span>][i] = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		mf[i][n + <span class="number">1</span>] = n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">			f[i][j] = INT_MAX;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="built_in">std</span>::<span class="built_in">max</span>(i - <span class="number">1</span>, mf[i - <span class="number">1</span>][j]); k &lt; j &amp;&amp; k &lt;= mf[i][j + <span class="number">1</span>]; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> (f[i][j] &gt; f[i - <span class="number">1</span>][k] + w[k + <span class="number">1</span>][j]) &#123;</span><br><span class="line">					f[i][j] = f[i - <span class="number">1</span>][k] + w[k + <span class="number">1</span>][j];</span><br><span class="line">					mf[i][j] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f[m][n] &lt;&lt; <span class="string">"\n"</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它例题：<a href="https://codeforces.com/contest/321/problem/E" target="_blank" rel="noopener">321E</a>。</p>
<h3 id="1D1D-四边形-分治-DP-将-O-n-2-复杂度优化成-O-n-log-n"><a href="#1D1D-四边形-分治-DP-将-O-n-2-复杂度优化成-O-n-log-n" class="headerlink" title="1D1D 四边形 + 分治 DP 将 $O(n^2)$ 复杂度优化成 $O(n \log n)$"></a>1D1D 四边形 + 分治 DP 将 $O(n^2)$ 复杂度优化成 $O(n \log n)$</h3><script type="math/tex; mode=display">
f_r = \min_{l = 1}^{r - 1} f_l + w(l, r) \quad (1 \ r \leq n)</script><p>若 $w(l, r)$ 满足四边形不等式，记 $k_r$ 为 $f_r$ 的最小最优决策点，则（反证法可证明）</p>
<script type="math/tex; mode=display">
\forall r_1 \leq r_2: \quad k_{r_1} \leq k_{r_2}</script><p>使用分治法优化 DP（递归实现）可以给出 $O(n \log n)$ 的做法。</p>
<blockquote>
<p>如果上述 $w(l, r) = f(r) - g(l)$，并且 $f, g$ 单调递增，则我们可以使用斜率优化 DP，$O(n)$ 解决。</p>
</blockquote>
<h3 id="四边形不等式函数类"><a href="#四边形不等式函数类" class="headerlink" title="四边形不等式函数类"></a>四边形不等式函数类</h3><ul>
<li>$w_1(l, r), w_2(l, r)$ 均满足四边形不等式（或区间包含单调性），则 $\forall c_1, c_2 \geq 0$，$c_1 w_1 + c_2 w_2$ 对应的也满足。</li>
<li>若存在函数 $f, g$ 使得 $w(l, r) = f(r) - g(l)$ 则函数 $w$ 满足四边形恒等式。若 $f, g$ 单调递增，则 $w$ 满足区间包含单调性。</li>
<li>若 $h(x), h’(x)$ 都是单调递增的，若 $w$ 满足区间包含单调性和四边形不等式，则 $h(w)$ 也满足。</li>
<li>$h’(x)$ 单调递增，若 $w$ 满足区间包含单调性和四边形恒等式，则 $h(w)$ 满足四边形不等式。</li>
</ul>
<h3 id="决策单调性分治优化-DP"><a href="#决策单调性分治优化-DP" class="headerlink" title="决策单调性分治优化 DP"></a>决策单调性分治优化 DP</h3><p>例题：<a href="https://codeforces.com/gym/101471/" target="_blank" rel="noopener">2017 ACM-ICPC Word Final D: Money for Nothing</a></p>
<p>$L_i = (x_i, y_i) x_i &lt; x_{i + 1}, y_i &gt; y_{i + 1}$<br>$R_i = (p_i, q_i) p_i &lt; p_{i + 1}, q_i &gt; q_{i + 1}$</p>
<p>$L_iR_j = (q_j - y_i)(p_j - x_i), \quad (x_i &lt; p_i, y_j &lt; p_j)$ 即围成的面积。<br>即 $u_i$ 为 使得 $L_iR_j$ 最大的 $j$（多个取下标最大的）。若 $i &lt; j, k &lt; l$，画个图显然就有（有点四边形内味）</p>
<script type="math/tex; mode=display">
L_iR_l + L_jR_k \leq L_iR_k + L_jR_l</script><p>因此 $u_i$ 是单调递增的（因此这样就可以调整最优策略了，这也就给出了决策单调性）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("C:\\Users\\dna049\\cf\\in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	std::vector&lt;std::pair&lt;int, int&gt;&gt; a(n), b(m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y] : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y] : b) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i].second &lt; a[cnt - <span class="number">1</span>].second) a[cnt++] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a.resize(cnt);</span><br><span class="line">	<span class="built_in">std</span>::sort(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">	cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (cnt &gt; <span class="number">0</span> &amp;&amp; b[i].second &gt;= b[cnt - <span class="number">1</span>].second) --cnt;</span><br><span class="line">		b[cnt++] = b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	b.resize(cnt);</span><br><span class="line">	<span class="comment">// 确保了始终能找到最优策略</span></span><br><span class="line">	b.insert(b.<span class="built_in">begin</span>(), &#123;<span class="number">0</span>, INT_MAX&#125;);</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; divideConquer = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> opl, <span class="keyword">int</span> opr) &#123;</span><br><span class="line">		<span class="comment">// 区间都是左闭右开的</span></span><br><span class="line">		<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		LL rm = INT64_MIN;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">		<span class="comment">// 一开始必然满足 b[opl].second &gt; a[mid].second，因此 k 必然满足</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = opl; i &lt; opr &amp;&amp; b[i].second &gt; a[mid].second; ++i) &#123;</span><br><span class="line">			LL tmp = LL(b[i].second - a[mid].second) * (b[i].first - a[mid].first);</span><br><span class="line">			<span class="keyword">if</span> (tmp &gt; rm) &#123;</span><br><span class="line">				rm = tmp;</span><br><span class="line">				k = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, rm);</span><br><span class="line">		divideConquer(l, mid, opl, k + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// b[k].second &gt; a[mid].second &gt; ... &gt; a[r - 1].second，从而没有 k = -1 出现的可能</span></span><br><span class="line">		divideConquer(mid + <span class="number">1</span>, r, k, opr);</span><br><span class="line">	&#125;;</span><br><span class="line">	divideConquer(<span class="number">0</span>, a.<span class="built_in">size</span>(), <span class="number">0</span>, b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这题不指定左下角节点和右上角节点。那么我们可以让所有节点成为左下角，所有节点成为右上角，就又变成此问题了。如果更进一步，不要求左下角和右上角，只要是斜对角线即可。那么我们可以让所有横坐标取相反数，再算一遍即可（妙啊）。</p>
<p>如果求最小值我目前还不知道有什么好方法。</p>
<h3 id="仅有一个特殊元素分治优化"><a href="#仅有一个特殊元素分治优化" class="headerlink" title="仅有一个特殊元素分治优化"></a>仅有一个特殊元素分治优化</h3><p>例题：<a href="https://codeforces.com/contest/1442/problem/D" target="_blank" rel="noopener">1442D</a>，详见<a href="https://codeforces.com/blog/entry/84298" target="_blank" rel="noopener">官方题解</a>，或者我的 <a href="/codeforces/" title="做题记录">做题记录</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
        <tag>运筹学</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Grossman 常数</title>
    <url>/grossmanConstant/</url>
    <content><![CDATA[<p>考虑由如下递推关系确定的实数数列 $\lbrace A_n \rbrace$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_{n+2} = \frac{A_n}{1+A_{n+1}} \\
A_0=1,\; A_1=x
\end{aligned}</script><p>可以证明，有且仅有一个 $x=x_0$ 使得 $\lbrace A_n \rbrace$ 收敛。这个 $x_0 = 0.7373383…$  被称为 Grossman 常数。</p>
<p><a href="https://mathworld.wolfram.com/GrossmansConstant.html" target="_blank" rel="noopener">Grossman 常数</a> 在 Wolfram 百科里面有讲，也在 Finch, S. R.《 Mathematical Constants》又讲，但是都依赖于核心论文 <a href="1987_Article_MathematicalEntertainments.pdf">Janssen, A. J. E. M. and Tjaden, D. L. A. Solution to Problem 86-2. <em>Math. Intel.</em> <strong>9</strong>, 40-43, 1987.</a> 折腾终于下下来了。</p>
<blockquote>
<p>吐槽一下 Wolfram 百科提供的所有 Reference 链接没法访问。。。</p>
</blockquote>
<a id="more"></a>
<p>为了方便起见，我们记：</p>
<script type="math/tex; mode=display">
\begin{aligned}
A_0(x) = \alpha >0 ,\; A_1(x) = x \\
A_{n+2}(x) = \frac{A_{n}(x)}{1+A_{n+1}(x)}
\end{aligned}</script><p>首先罗列一些显而易见的结果：</p>
<ul>
<li><p>如果 $x&gt;0$，则 $A_n(x)&gt;0$，且 $A_{2n}(0)=\alpha,A_{2n+1}(0)=0$</p>
</li>
<li><p>$a(x) = \lim A_{2n}(x),\; b(x)= \lim A_{2n+1}(x)$ 均存在，且 $a(x)b(x)=0$</p>
</li>
<li><p>如果 $\lim A_n(x)$ 存在，则为 $0$</p>
</li>
<li><p>如果 $x \leq 0$，则 $\lim A_n(x)$ 不存在 （反证，奇偶项写出两个递推关系分析）</p>
<p><strong>以下仅考虑 $x\geq 0$ 的情形</strong></p>
</li>
<li><p>$A_{2n}(x)$ 是连续单调递减的函数 （数学归纳）</p>
</li>
<li><p>$A_{2n+1}(x)$ 是连续单调递增的函数 （数学归纳）</p>
</li>
<li><p>$a(x) \geq 0$ 单调递减，$b(x) \geq 0$ 单调递增</p>
</li>
<li><p>$A_{2n}(x),\;A_{2n+1}(x)$ 都关于 $n$ 单调递减</p>
</li>
<li><p>重要公式（累和相加）： </p>
<script type="math/tex; mode=display">
\alpha - A_{2N+2}(x) =  \sum_{n=0} ^N A_{2n+1}(x) A_{2n+2}(x) \\
x - A_{2N+3}(x) = \sum_{n=0} ^N A_{2n+3}(x) A_{2n+2}(x)</script></li>
</ul>
<blockquote>
<p>以上罗列的结果按顺序证明是容易的！</p>
</blockquote>
<h2 id="lim-A-n-x-0-当且仅当-A-n-x-关于-n-单调递减"><a href="#lim-A-n-x-0-当且仅当-A-n-x-关于-n-单调递减" class="headerlink" title="$\lim A_n(x) =0$  当且仅当 $A_n(x)$ 关于 $n$ 单调递减"></a>$\lim A_n(x) =0$  当且仅当 $A_n(x)$ 关于 $n$ 单调递减</h2><p><strong>Proof</strong>： 若 $\lim A_n(x) =0$ ，再由上面的 “重要公式” 易知：</p>
<script type="math/tex; mode=display">
A_{2N+2}(x) =  \sum_{n=N+1} ^ \infty A_{2n+1}(x) A_{2n+2}(x) \\
A_{2N+3}(x) = \sum_{n=N+1} ^ \infty A_{2n+3}(x) A_{2n+2}(x)</script><p>所以 $A_{2N+2}&gt;A_{2N+3}$ ，紧接着 $A_{2N+1} = \sum_{n=N+1} ^ \infty A_{2n+1}A_{2n} &gt; A_{2N+2}$，所以 $A_n(x)$ 关于 $n$ 单调递减</p>
<blockquote>
<p>这也提供了一个求解 Grossman 常数的数值依据。</p>
</blockquote>
<h2 id="最多只有一个-x-使得-lim-A-n-x-0"><a href="#最多只有一个-x-使得-lim-A-n-x-0" class="headerlink" title="最多只有一个 $x$ 使得 $\lim A_n(x) =0$"></a>最多只有一个 $x$ 使得 $\lim A_n(x) =0$</h2><p><strong>Proof</strong>：若 $\lim A_n(y) = \lim A_n(x) = 0,\; y&gt;x$，则：</p>
<script type="math/tex; mode=display">
\frac{A_{n+2}(y)}{A_{n+2}(x)} = \frac{A_{n}(y)}{A_{n}(x)} \frac{1+A_{n+1}(x)}{1+A_{n+1}(y)}</script><p>从而</p>
<script type="math/tex; mode=display">
\frac{A_{2n+2}(y)}{A_{2n+2}(x)} = \prod _{k=1} ^n \frac{1+A_{2k+1}(y)}{1+A_{2k+1}(x)} \\
\frac{A_{2n+1}(y)}{A_{2n+1}(x)} = \frac{y}{x} \prod _{k=1} ^n \frac{1+A_{2k}(y)}{1+A_{2k}(x)}</script><p>从而  $\frac{A_{2n+2}(y)}{A_{2n+2}(x)}$ 单调递减收敛于 $L_1 \leq 1$，$\frac{A_{2n+1}(y)}{A_{2n+1}(x)}$  单调递增收敛于 $L_2&gt;1$。所以</p>
<script type="math/tex; mode=display">
\lim \frac{A_{2n+2}(y)}{A_{2n+2}(x)} \frac{A_{2n+1}(x)}{A_{2n+1}(y)} = \frac{L_1}{L_2} <1</script><p>但是另一方面</p>
<script type="math/tex; mode=display">
1 \geq \frac{A_{2n+2}(y)}{A_{2n+1}(y)} \geq \frac{A_{2n+3}(y)}{A_{2n+1}(y)} = \frac{1}{1+A_{2n+2}(y)} \to 1 \\
1 \leq \frac{A_{2n+1}(x)}{A_{2n+2}(x)} \geq \frac{A_{2n+1}(x)}{A_{2n+3}(x)} = 1+A_{2n+2}(x) \to 1</script><p>矛盾！</p>
<h2 id="Dini-定理"><a href="#Dini-定理" class="headerlink" title="Dini 定理"></a>Dini 定理</h2><p>为了证明的连贯性，先给出下面需要引用 <strong>Dini 定理</strong>（证明见陈纪修《数学分析》下册定理 10.2.7）</p>
<p>设函数序列 $\{S_n(x)\}$ 在闭区间 $[a,b]$ 上（点态）收敛于 $S(x)$，且满足：</p>
<ul>
<li>$S_n(x)$ 在 $[a,b]$ 上连续</li>
<li>$\{S_n(x)\}$ 关于 $n$ 单调</li>
</ul>
<p>则 $\{S_n(x)\}$ 在 $[a,b]$ 一致收敛于 $S(x)$ 当且仅当 $S(x)$ 在 $[a,b]$ 上连续 （”$\Rightarrow$”易证，”$\Leftarrow$” 称作 Dini <strong>定理</strong>）</p>
<h2 id="存在唯一的-x-使得-lim-A-n-x-0"><a href="#存在唯一的-x-使得-lim-A-n-x-0" class="headerlink" title="存在唯一的 $x$ 使得 $\lim A_{n}(x) = 0$"></a>存在唯一的 $x$ 使得 $\lim A_{n}(x) = 0$</h2><p>由“重要公式”知：</p>
<script type="math/tex; mode=display">
\alpha - a(x) = \sum_{n=0} ^{\infty} A_{2n+1}(x) A_{2n+2}(x) \\
x - b(x) = \sum_{n=0} ^{\infty} A_{2n+3}(x) A_{2n+2}(x) \\</script><p>从而 $\alpha -  a(x) &gt; x - b(x)$，所以 $b(\alpha) &gt; 0$，从而 $a(\alpha) = 0$，并且 $a(0) = \alpha,\; b(0) = 0$。令</p>
<script type="math/tex; mode=display">
x_0 = \sup \{ x \in [0, \alpha] \mid a(x) >0 \} \\
x_1 = \inf \{ x \in [0,\alpha] \mid b(x)>0 \}</script><p>显然 $x_0 \leq x_1$， 若 $x_0 &lt; x_1$，则 对任意 $x_0 &lt; x &lt; x_1$ 有，$a(x) = b(x) = 0$，矛盾于收敛于 0 的 $x$ 最多只有一个，从而 $x_0 = x_1$。</p>
<p>注意到 $\frac{1}{1+\alpha} A_{2n+1}(x) A_{2n+2}(x) \leq  A_{2n+3}(x) A_{2n+2}(x) \leq  A_{2n+1}(x) A_{2n+2}(x)$，所以 $a(x),b(x)$ 在闭区间 $D$ 上有共同的一致收敛性，从而由 <strong>Dini 定理</strong> 知，$a(x)$ 在闭区间 $D$ 上连续当且仅当 $b(x)$ 在闭区间 $D$ 上连续。</p>
<blockquote>
<p>我们想要证明 $a(x),b(x) $ 在区间 $[0,\alpha]$ 上连续，从而 $a(x_0) = b(x_0) = 0$。</p>
</blockquote>
<p>当 $x &lt; x_0$ 时，$b(x)=0$，当 $x &gt; x_0$ 时，$a(x)=0$，所以 $a(x),b(x)$ 在 $[0,x_0) \cup (x_0, \alpha]$ 上连续。</p>
<p>若 $a(x_0) &gt;0$，则 $b(x_0) = 0$，记 $b_0 = \lim_{x \to x_0 ^{+}} b(x)$，若 $b_0&gt;0$， 则</p>
<script type="math/tex; mode=display">
A_{2k+2}(x) = \prod_{j=1} ^k \frac{1}{1+A_{2j-1}(x)} < \frac{1}{(1+b_0)^k} \quad x \in (x_0, \alpha ] \\
A_{2k+1}(x) = \prod_{j=1}^k \frac{1}{1+A_{2j}(x)} < \frac{1}{(1+a(x_0))^k} \quad x \in [0,x_0]</script><p>从而 $a(x),b(x)$ 在 $[0,\alpha]$ 上一致收敛，矛盾，从而 $b_0 = 0$，从而 $b(x)$ 连续，从而 $a(x)$ 连续，矛盾，从而 $a(x_0) = 0$。同理 $b(x_0) = 0$。所以 $\lim A_n(x) = 0$。</p>
<h2 id="Grossman-常数的推广"><a href="#Grossman-常数的推广" class="headerlink" title="Grossman 常数的推广"></a>Grossman 常数的推广</h2><p>由上述过程可知，本质上，对每个给定的 $A_0 \geq 0$, 都存在唯一的 $0 \leq A_1 \leq A_0$ ，使得 $\lim A_n$ 存在（且等于 0）。我们不妨 $A_1 = F(A_0)$，其中 $F: [0, +\infty] \to [0, \infty]$，满足 $F(0)= 0$，若$x&gt;0$ 则，$0&lt;F(x)&lt;x$ ，假设 $A_0 = \alpha$，则 $A_1 = F(\alpha),\;A_2 = \frac{\alpha}{1+F(\alpha)}$，而 $(A_0, A_1) = (F(\alpha),\frac{\alpha}{1+F(\alpha)})$ 必然能使得 $\lim A_n = 0$， 所以 $F(F(\alpha)) = \frac{\alpha}{1+F(\alpha)}$，写成</p>
<script type="math/tex; mode=display">
x = (1+F(x))F(F(x))</script><p>由于 $a(x)$ 关于 $\alpha$ 连续，所以 $x_0(\alpha) = \sup \{ x \in [0, \alpha] \mid a(x) &gt;0 \}$ 关于 $\alpha$ 连续，即上述 $F(x)$ 连续，若可导​，则 $F(x)$ 单调递增。</p>
<blockquote>
<p>上述形式最早由 Gabor Nyerges 给出（由于找不到文献，所以就自己推导了一下）</p>
</blockquote>
<p>按照上述观点，从而 Grossman 常数就是 $F(1)$。</p>
<h2 id="Grossman-常数的数值计算"><a href="#Grossman-常数的数值计算" class="headerlink" title="Grossman 常数的数值计算"></a>Grossman 常数的数值计算</h2><p>由于 $\lim A_n(x) =0$  当且仅当 $A_n(x)$ 关于 $n$ 单调递减 。令 $n_0$ 是最小的 $n$ 使得 $A_{n+1}(x) &gt; A_n(x)$，则</p>
<script type="math/tex; mode=display">
A_{n+3}(x) - A_{n+2}(x) = \frac{(A_{n+1} - A_n) + (A_{n+1}^2 - A_n A_{n+2}) }{(1+A_{n+2})(1+A_{n-1})} > 0</script><p>从而对任意 $k \geq 0$，$A_{n+2k+1} &gt; A_{n+2k}$。</p>
<p>若 $n$ 为偶数，则 $b(x)&gt;a(x)$，从而 $b(x) &gt; 0 = a(x)$，即 $x&gt;x_0$。反之，若 $n$ 为奇数，则 $x &lt; x_0$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bigercheck</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> m,<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">10000</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ans=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(--<span class="built_in">step</span>&amp;&amp;x&gt;m)&#123;</span><br><span class="line">        ans = !ans;</span><br><span class="line">        <span class="keyword">double</span> t=x/(<span class="number">1</span>+m);</span><br><span class="line">        x = m;</span><br><span class="line">        m = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x&gt;m||ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> eps = <span class="number">1e-12</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l =x/(<span class="number">1</span>+x),r = x;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;eps)&#123;</span><br><span class="line">        <span class="keyword">double</span> m = (l+r)*<span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">if</span>(bigercheck(x,m))  r=m;</span><br><span class="line">        <span class="keyword">else</span> l=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;x)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;F(x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;F(F(x))*(F(x)+<span class="number">1</span>)-x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>高精度太耗时了！参考 <a href="https://oeis.org/A085835" target="_blank" rel="noopener">A085835</a> </p>
</blockquote>
<h2 id="后来的故事"><a href="#后来的故事" class="headerlink" title="后来的故事"></a>后来的故事</h2><p>Gabor Nyerges 在 2014 年的论文 《On the convergence of $x_n = f(x_{n–2}, x_{n–1})$ when $f (x, y) &lt; x$. Advances in Difference Equations2014, 2014:8》中证明，只需 $f: (0,\infty)^2 \to (0,\infty)$，$f (x, y) &lt; x$，且$f(x,y)$ 关于 $y$ 递减，则对任意 $x_0 &gt; 0$，存在 $f(x_0,x_0)&lt;x_1&lt;x_0$ 使得 $x_n$ 单调递减趋于 0 。但是没法保证唯一性，毕竟条件这么弱。证明过程巧妙的应用了闭区间套定理。</p>
<h3 id="明显的推论：若-x-n-frac-x-n-2-1-f-x-n-1-，其中-f-0-infty-to-0-infty-为单调递增的连续函数，-则，对任意-x-geq-0-，存在唯一的-frac-x-0-1-f-x-0-leq-x-1-leq-x-0"><a href="#明显的推论：若-x-n-frac-x-n-2-1-f-x-n-1-，其中-f-0-infty-to-0-infty-为单调递增的连续函数，-则，对任意-x-geq-0-，存在唯一的-frac-x-0-1-f-x-0-leq-x-1-leq-x-0" class="headerlink" title="明显的推论：若 $x_n = \frac{x_{n-2}}{1+f(x_{n-1})}$，其中 $f: (0,\infty) \to (0, \infty)$为单调递增的连续函数， 则，对任意 $x \geq 0$，存在唯一的 $\frac{x_0}{1+f(x_0)} \leq x_1 \leq x_0$"></a>明显的推论：若 $x_n = \frac{x_{n-2}}{1+f(x_{n-1})}$，其中 $f: (0,\infty) \to (0, \infty)$为单调递增的连续函数， 则，对任意 $x \geq 0$，存在唯一的 $\frac{x_0}{1+f(x_0)} \leq x_1 \leq x_0$</h3><p><strong>Proof</strong> ：存在性由 Gabor Nyerges 的证明显然，唯一性模仿之前的过程显然。</p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 和 Linux Shell</title>
    <url>/vimWithLinuxShell/</url>
    <content><![CDATA[<p>Windows10 + WSL(Ubuntu 20.04LTS) 用的越来越多，就想系统的入门一下： vim 和 Linux Shell</p>
<a id="more"></a>
<h2 id="Vi-m-入门"><a href="#Vi-m-入门" class="headerlink" title="Vi(m) 入门"></a>Vi(m) 入门</h2><p>所有类 Unix 系统都自带 vi，所以学习 vi 收益满满！</p>
<blockquote>
<p>参考：<a href="https://codeshellme.github.io/2020/04/vim-use/" target="_blank" rel="noopener">如何高效使用Vim</a>，<a href="https://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">Linux vi/vim | 菜鸟教程</a></p>
</blockquote>
<h3 id="vi-m-工作模式图解"><a href="#vi-m-工作模式图解" class="headerlink" title="vi(m) 工作模式图解"></a>vi(m) 工作模式图解</h3><p><img src= "/img/loading.gif" data-lazy-src="vim-vi-workmodel.png" alt="vimWorkMod"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常见命令（区分大小写)</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gg</code></td>
<td>移动到当前文件的第一行</td>
</tr>
<tr>
<td><code>G</code></td>
<td>移动到当前文件的最后一行</td>
</tr>
<tr>
<td><code>M</code></td>
<td>移动到当前文件的中间一行</td>
</tr>
<tr>
<td><code>Ctrl + o</code></td>
<td>移动到上一次编辑的地方</td>
</tr>
<tr>
<td><code>:n</code> ， 其中 n 为数字</td>
<td>输入一个 <code>:</code>，再输入一个 <code>数字</code>，按回车，快速跳到某一行</td>
</tr>
<tr>
<td><code>ndd</code>，其中 n 为数字（不写默认为 1）</td>
<td>删除光标所在的行，并且内容在剪切板</td>
</tr>
<tr>
<td><code>nyy</code>，其中 n 为数字（不写默认为 1）</td>
<td>复制光标所在的行，并且内容在剪切板</td>
</tr>
<tr>
<td><code>D</code></td>
<td>删除 <code>光标</code> 到行 <code>末尾</code> 所有的内容，并且内容在剪切板</td>
</tr>
<tr>
<td><code>p</code></td>
<td>粘贴剪切板的内容到光标处</td>
</tr>
<tr>
<td><code>/word</code></td>
<td>向光标之下寻找一个名称为 word 的字符串</td>
</tr>
<tr>
<td><code>?word</code></td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td><code>n</code></td>
<td>这个 n 是英文按键。继续搜索下一个目标</td>
</tr>
<tr>
<td><code>N</code></td>
<td>这个 N 是英文按键。与 n 刚好相反</td>
</tr>
<tr>
<td><code>Ctrl + v</code></td>
<td>进入列选择模式</td>
</tr>
<tr>
<td><code>Shift + v</code></td>
<td>进入行选择模式</td>
</tr>
<tr>
<td><code>u</code></td>
<td>复原前一个动作</td>
</tr>
<tr>
<td><code>Ctrl+r</code></td>
<td>重做上一个动作</td>
</tr>
<tr>
<td><code>Ctrl+n</code></td>
<td>常规（Normal）补全</td>
</tr>
<tr>
<td><code>Ctrl+o</code></td>
<td>全能（Omni）补全</td>
</tr>
</tbody>
</table>
</div>
<h3 id="vimrc-超简洁设置："><a href="#vimrc-超简洁设置：" class="headerlink" title=".vimrc 超简洁设置："></a><code>.vimrc</code> 超简洁设置：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">syntax on    " 语法高亮</span><br><span class="line">set nu       " 行数显示</span><br><span class="line">set ts=4     " tab 宽度</span><br><span class="line">set spell    " 语法拼写检测</span><br><span class="line">set noexpandtab       " 不将 tab 转换成空格</span><br><span class="line">colorscheme darkblue  " 颜色主题： /usr/share/vim/vimxx/colors (xx: 版本号)</span><br></pre></td></tr></table></figure>
<h3 id="vi-m-键盘图"><a href="#vi-m-键盘图" class="headerlink" title="vi(m)键盘图"></a>vi(m)键盘图</h3><p><img src= "/img/loading.gif" data-lazy-src="vi-vim.png" alt="vim-vim"></p>
<h3 id="vi-m-命令思维导图"><a href="#vi-m-命令思维导图" class="headerlink" title="vi(m) 命令思维导图"></a>vi(m) 命令思维导图</h3><p><img src= "/img/loading.gif" data-lazy-src="vim.png" alt="vim"></p>
<h2 id="Linux-Shell-入门"><a href="#Linux-Shell-入门" class="headerlink" title="Linux Shell 入门"></a>Linux Shell 入门</h2><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <code>#!/bin/sh</code>，它同样也可以改为 <code>#!/bin/bash</code>。</p>
<blockquote>
<p>参考：<a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">Shell 教程 | 菜鸟教程</a>，<a href="https://zhuanlan.zhihu.com/p/65106362" target="_blank" rel="noopener">这些Shell编程必备知识你都掌握了吗？</a></p>
</blockquote>
<h3 id="Hello-Shell"><a href="#Hello-Shell" class="headerlink" title="Hello Shell"></a>Hello Shell</h3><p><code>vim test.sh</code> 编辑下面内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Hello Shell "</span><br></pre></td></tr></table></figure>
<p><code>esc</code> + <code>:wq</code> 保存，执行下面命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使脚本具有执行权限</span></span><br><span class="line">$ chmod +x test.sh</span><br><span class="line"><span class="comment">#执行脚本，若报错则输入 chmod u+x test.sh</span></span><br><span class="line">$ ./test.sh</span><br><span class="line"><span class="comment">#无执行权限时</span></span><br><span class="line">$ sh ./test.sh</span><br></pre></td></tr></table></figure>
<h3 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello=123 # 变量定义</span><br><span class="line">readonly my_blog="dna049.com" #只读变量（常量）定义</span><br><span class="line">echo $my_blog   #变量引用方式一，不推荐</span><br><span class="line">echo $&#123;my_blog&#125; #变量引用方式二，推荐</span><br><span class="line">for skill in C++ Python SageMath; do</span><br><span class="line">    echo "I am good at $&#123;skill&#125;Script"</span><br><span class="line">done</span><br><span class="line">unset my_blog   #删除变量</span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量定义 <code>=</code> 两边不能有空格！</p>
</blockquote>
<h3 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a>Shell 字符串</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myBlog='dna049.com' #单引号里的任何字符都会原样输出, 不支持转义</span><br><span class="line">str="My Blog is \"$myBlog\"! \n"</span><br><span class="line">echo -e $str # -e 开启转义</span><br><span class="line">echo 'hello, ' $&#123;myBlog&#125; " Welcome!" #单引号双引号都可以做字符拼接</span><br><span class="line">echo $&#123;#myBlog&#125; #获取字符串长度</span><br><span class="line">echo $&#123;myBlog:0:6&#125; # 输出dna049</span><br></pre></td></tr></table></figure>
<h3 id="Shell-传递参数"><a href="#Shell-传递参数" class="headerlink" title="Shell 传递参数"></a>Shell 传递参数</h3><ul>
<li><code>$n</code>：传入参数，例如：<code>$0 $1 $2</code> 分别表示，脚本名，第一个参数，第二个参数</li>
<li><code>$#</code>：脚本后面跟的参数个数（不包含脚本名)</li>
<li><code>$@</code>：所有参数，并且可以被遍历</li>
<li><code>$*</code>：所有参数</li>
<li><code>\$$</code>：当前脚本的进程 ID (没有 <code>\</code>)</li>
<li><code>$?</code>：上一条命令的退出状态</li>
</ul>
<h3 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array=(A B "cpp" D)</span><br><span class="line">echo $&#123;array[2]&#125;</span><br><span class="line">echo "数组元素个数为: $&#123;#array[*]&#125;" # @* 都对应着全部内容</span><br><span class="line">echo "数组元素为: $&#123;array[@]&#125;" </span><br><span class="line">echo $&#123;array[@]:1:4&#125; </span><br><span class="line">echo $&#123;array[@]::3&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Shell-运算符"><a href="#Shell-运算符" class="headerlink" title="Shell 运算符"></a>Shell 运算符</h3><ul>
<li>算数运算符： <code>+ - * / % = == !=</code></li>
<li>关系运算符：<code>-eq -ne -ge -lt -gt -le</code></li>
<li>布尔运算符：<code>! -o -a</code> （取否，or，and）</li>
<li>逻辑运算符：<code>&amp;&amp; ||</code> ，需要： <code>[[ expr ]]</code></li>
<li>字符串运算符：<code>= != -z -n $</code></li>
<li>文件测试运算符：<code>-b -c -d -f -g -k -p -u -r -w -x -s -e</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=11;b=22</span><br><span class="line">val=`expr $a + $b`</span><br><span class="line">echo "a + b : $val"</span><br><span class="line"></span><br><span class="line">if [ $a == $b ];then</span><br><span class="line">   echo "a 等于 b"</span><br><span class="line">elif [ $a -gt $b ];then</span><br><span class="line">   echo "a 大于 b"</span><br><span class="line">elif [ $a -lt $b ];then</span><br><span class="line">   echo "a 小于 b"</span><br><span class="line">else</span><br><span class="line">   echo "没有符合的条件"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]];then</span><br><span class="line">   echo "返回 true"</span><br><span class="line">else</span><br><span class="line">   echo "返回 false"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">a="abc"</span><br><span class="line">if [ -n $a ];then</span><br><span class="line">   echo "-n $a : 字符串长度不为 0"</span><br><span class="line">else</span><br><span class="line">   echo "-n $a : 字符串长度为 0"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<blockquote>
<p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作</p>
<p>条件表达式要放在方括号之间，并且要有空格，例如L：<code>[$a==$b]</code> 是错误的，必须写成 <code>[ $a == $b ]</code></p>
</blockquote>
<h3 id="Shell-printf-命令"><a href="#Shell-printf-命令" class="headerlink" title="Shell printf 命令"></a>Shell printf 命令</h3><p><code>printf  format-string  [arguments...]</code></p>
<p>例如： <code>printf &quot;%-8s = %10.4f\n&quot; pi 3.141592653</code></p>
<blockquote>
<p><code>%s %c %d %f</code> 都是格式替代符</p>
<p><code>%-8s</code> 指一个宽度为 8 个字符（<code>-</code> 表示左对齐，没有则表示右对齐），如果不足则自动以空格填充，超过也会将内容全部显示出来。</p>
</blockquote>
<h3 id="Shell-流程控制"><a href="#Shell-流程控制" class="headerlink" title="Shell 流程控制"></a>Shell 流程控制</h3><h4 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h4><ul>
<li><p><code>if else-if else</code> 已经在上面例子中提过了。</p>
</li>
<li><p><code>case esac</code> 的奇葩写法，吐了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo '输入 1 到 4 之间的数字:'</span><br><span class="line">echo '你输入的数字为:'</span><br><span class="line">read aNum       </span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo '你选择了 1'</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo '你选择了 2'</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo '你选择了 3'</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo '你选择了 4'</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo '你没有输入 1 到 4 之间的数字'</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>read</code> 输入快乐啊！</p>
</blockquote>
</li>
</ul>
<h4 id="循环控制：for-while-until-break-continue"><a href="#循环控制：for-while-until-break-continue" class="headerlink" title="循环控制：for while until break continue"></a>循环控制：<code>for while until break continue</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 例子来自 https://www.runoob.com/linux/linux-shell-process-control.html</span></span><br><span class="line">for str in 'This is a string'</span><br><span class="line">do</span><br><span class="line">    echo $str</span><br><span class="line">done</span><br><span class="line">for((i=1;i&lt;=5;i++));do</span><br><span class="line">    echo "这是第 $i 次调用";</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo '按下 &lt;CTRL-D&gt; 退出'</span><br><span class="line">echo -n '输入你最喜欢的网站名: '</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo "是的！$FILM 是一个好网站"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="Shell-函数"><a href="#Shell-函数" class="headerlink" title="Shell 函数"></a>Shell 函数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">funWithParam()&#123;</span><br><span class="line">    echo "第一个参数为 $1 !"</span><br><span class="line">    echo "第二个参数为 $2 !"</span><br><span class="line">    echo "参数总数有 $# 个!"</span><br><span class="line">    echo "作为一个字符串输出所有参数 $* !"</span><br><span class="line">&#125;</span><br><span class="line">echo "-----函数开始执行-----"</span><br><span class="line">funWithParam 3 . 1 4 1 5 9 2 </span><br><span class="line">echo "-----函数执行完毕-----"</span><br></pre></td></tr></table></figure>
<h3 id="Shell-输入-输出重定向和文件包含-特别好用！"><a href="#Shell-输入-输出重定向和文件包含-特别好用！" class="headerlink" title="Shell 输入/输出重定向和文件包含(特别好用！)"></a>Shell 输入/输出重定向和文件包含(特别好用！)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ echo <span class="string">"菜鸟教程：www.runoob.com"</span> &gt; users</span><br><span class="line">$ cat users</span><br><span class="line">$ echo <span class="string">"菜鸟教程：www.runoob.com"</span> &gt;&gt; users</span><br><span class="line">$ cat users</span><br></pre></td></tr></table></figure>
<ul>
<li><p>test2.sh 中调用 test.sh：<code>source ./test.sh</code></p>
</li>
<li><p>管道运算符 <code>|</code>，是 unix 一个很强大的功能。</p>
<p>command 1 | command 2</p>
<p>把第一个命令 command 1 执行的结果作为 command 2 的输入，例如:</p>
<p><code>$ ls -s|sort -nr</code> </p>
</li>
</ul>
<h3 id="Linux-工具："><a href="#Linux-工具：" class="headerlink" title="Linux 工具："></a>Linux 工具：</h3><ul>
<li><a href="https://www.runoob.com/linux/linux-remote-login.html" target="_blank" rel="noopener">Linux 远程登录</a></li>
<li><a href="https://www.runoob.com/linux/linux-forget-password.html" target="_blank" rel="noopener">Linux 忘记密码解决方法</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>中国剩余定理</title>
    <url>/chineseRemainTheorem/</url>
    <content><![CDATA[<p>仅以此博文，感谢知乎好友 <a href="https://www.zhihu.com/people/li-yong-xiang-38" target="_blank" rel="noopener">Vivr0</a> </p>
<p>中国剩余定理也称孙子定理，是中国古代求解一次同余方程组的方法。</p>
<a id="more"></a>
<p>用现代的语言来说就是：</p>
<script type="math/tex; mode=display">
x \equiv
\left\{ 
\begin{array}{cc}
a_1 \mod m_1 \\
a_2 \mod m_2 \\
\vdots \\
a_n \mod m_n
\end{array}
\right.</script><p>且正整数组 $m_i$ 两两互素，则对任意整数组 $a_i$，上述方程有解，解可以写成 $x \equiv a \mod m$</p>
<p>我们不要求 $m_i$ 两两互素也能求解，只是不一定有解，下面详细给出做法。</p>
<p>我们先考虑 $n=2$ 的情形。即 </p>
<script type="math/tex; mode=display">
x \equiv
\left\{
\begin{array}{cc}
a_1 \mod m_1 \\
a_2 \mod m_2
\end{array}
\right.</script><p>我们可以把方程写成</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{lll}
x - a_1 & \equiv \; 0  & \mod m_1 \\
x - a_1 & \equiv \; a_2-a_1 & \mod m_2
\end{array}
\right.</script><p>我们设 $d = \gcd(m_1,m_2)$，则 $d| x-a_1$ 又 $d|m_2$，所以  $d|a_2-a_1$。</p>
<blockquote>
<p>我们知道对任意正整数 $a,b$,  存在整数 $x, y$ 使得 $xa + yb = \gcd(a,b)$。</p>
<p>(最后 Python 代码注释中有给出 $x, y$ 的详细操作)</p>
</blockquote>
<p>存在 $t_1, t_2$ 使得 $m_1 t_1 + m_2 t_2 = gcd(m_1, m_2) = d$，所以</p>
<script type="math/tex; mode=display">
x-a_1 \equiv \frac{a_2-a_1}{d} (m_1t_1 + m_2t_2) \equiv \frac{a_2-a_1}{d} t_1 m_1 \mod m_2</script><p>即 $x \equiv a \mod m$，其中 $a=  a_1 + \frac{a_2-a_1}{d} t_1m_1 = \frac{t_2m_2a_1+t_1m_1a_2}{d}$，$m = lcm(m_1,m_2) = \frac{m_1m_2}{d}$ </p>
<blockquote>
<p>$n-1$ 次上述操作，就处理了一般情况</p>
</blockquote>
<h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL&amp; x,LL&amp; y)</span></span>&#123;  <span class="comment">// ax + by = gcd(a,b)</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL d=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;LL,LL&gt; crt2(LL a1,LL m1,LL a2,LL m2)&#123; // x = ai mod mi, m_i &gt;0</span><br><span class="line">    LL t1,t2,ans = a2-a1;</span><br><span class="line">    LL d = exgcd(m1,m2,t1,t2);</span><br><span class="line">    assert(ans%d == <span class="number">0</span>);</span><br><span class="line">    LL m = m1/d*m2;</span><br><span class="line">    ans = (a1+ans/d*t1%m2*m1)%m; <span class="comment">// %m2 是避免溢出</span></span><br><span class="line">    <span class="keyword">return</span> make_pair(ans&gt;<span class="number">0</span>?ans:ans+m,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span>;</span><br><span class="line">LL a[N],m[N];</span><br><span class="line">pair&lt;LL,LL&gt; crt(int n)&#123; // x = a[i] mod m[i], m[i] &gt;0</span><br><span class="line">    pair&lt;LL,LL&gt; ans = make_pair(a[<span class="number">0</span>]%m[<span class="number">0</span>],m[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        ans = crt2(ans.first,ans.second,a[i],m[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL a1,m1,a2,m2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a1&gt;&gt;m1&gt;&gt;a2&gt;&gt;m2)&#123;</span><br><span class="line">        LL ans = crt2(a1,m1,a2,m2).first;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>((ans-a1)%m1 || (ans-a2)%m2)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"something wrong"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># input : a,b natural number</span></span><br><span class="line"><span class="comment"># output: [gcd(a,b), x, y]</span></span><br><span class="line"><span class="comment"># ax + by = gcd(a,b)</span></span><br><span class="line"><span class="comment"># Algorithm: b(a//bx+y) + a%bx = gcd(b,a%b) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exgcd</span><span class="params">(a,b)</span>:</span></span><br><span class="line">	<span class="keyword">if</span>(b == <span class="number">0</span>): <span class="keyword">return</span> [a,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">	[d,y,x] = exgcd(b,a%b)</span><br><span class="line">	<span class="keyword">return</span> [d,x,y-a//b*x]</span><br><span class="line"></span><br><span class="line"><span class="comment"># input:  x = ai mod m_i, mi&gt;0, i=1,2</span></span><br><span class="line"><span class="comment"># output: x = a mod m</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crt2</span><span class="params">(a1,m1,a2,m2)</span>:</span></span><br><span class="line">	[d,t1,t2] = exgcd(m1,m2)</span><br><span class="line">	a,m = a2-a1,m1//d*m2</span><br><span class="line">	<span class="keyword">if</span>(a%d):  <span class="keyword">raise</span> ValueError(<span class="string">'No solution to crt problem'</span>)</span><br><span class="line">	<span class="keyword">return</span> [(a1+a//d*t1*m1)%m,m]</span><br><span class="line"></span><br><span class="line"><span class="comment"># input:  x = ai mod m_i, mi&gt;0</span></span><br><span class="line"><span class="comment"># output: x = a mod m</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crt</span><span class="params">(a,m)</span>:</span></span><br><span class="line">	n = len(a)</span><br><span class="line">	<span class="keyword">if</span>(len(m)!=n):  <span class="keyword">raise</span> ValueError(<span class="string">'a and m must have equal length'</span>)</span><br><span class="line">	aa,mm = a[<span class="number">0</span>],m[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">		[aa,mm] = crt2(aa,mm,a[i],m[i])</span><br><span class="line">	<span class="keyword">return</span> [aa,mm]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">	[a,m]=crt([<span class="number">2</span>,<span class="number">-4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>])</span><br><span class="line">	print(a,m)</span><br><span class="line">	[a,m]=crt([<span class="number">2</span>,<span class="number">-4</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>])</span><br><span class="line">	print(a,m)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>上流开源免费数学软件之 SageMath</title>
    <url>/sageMath/</url>
    <content><![CDATA[<p>Sage 的是“ 圣”的意思，所以 <a href="http://www.sagemath.org/" target="_blank" rel="noopener">SageMath</a> 懂啥意思了吧，上流！哈哈。SageMath 整合了当前开源的所有高效包，用来取代 MATLAB（20G)，Mathematics(5G）等商业软件。 而 SageMath 安装包仅 1G 不到，而且语言基于 Python，就很快乐。而且你还能免费注册账号用基于 Jupyter Notebook 的 <a href="https://cocalc.com/" target="_blank" rel="noopener">SageMath 在线版: Cocalc</a> </p>
<blockquote>
<p>感谢知乎好友<a href="https://www.zhihu.com/people/li-yong-xiang-38" target="_blank" rel="noopener">Vivr0</a> 的推荐</p>
</blockquote>
<a id="more"></a>
<p>SageMath 的安装，入门教程在 <a href="http://www.sagemath.org/" target="_blank" rel="noopener">官网</a> 很容易就找到了，而且下载提供国内镜像下载地址，特别友好。除了入门教程，还有专题教程。语言和 Python 几乎一致。不用一致 import，内建的特别好。文件格式：<code>.sage</code></p>
<blockquote>
<p>Macos or Linux 上用 sage 会更加快乐！WSL 就没法用 Jupyter 了，不过也还行！</p>
</blockquote>
<h2 id="SageMath-特征"><a href="#SageMath-特征" class="headerlink" title="SageMath 特征"></a>SageMath 特征</h2><ul>
<li>交互界面下，有赋值就不输出，表达式会输出(调用 <code>__repr__</code> 方法)</li>
<li><code>ZZ,QQ,RR,CC</code> 分别表示整数，有理数，实数，复数</li>
<li>Tab 补全，vim 姿势退出，git 姿势复制粘贴，很上流</li>
<li><code>^</code> 等同 <code>**</code>，<code>^^</code> 表示 <code>xor</code>, <code>/</code> 表示分数的除。其它和 Python 一致</li>
<li>（Python）函数和 SageMath 符号表达式是有本质区别的。</li>
<li>自带抽象代数：群，多项式环，$\mathbb{Z}_n$ ，$p$-adic 数等等。上流</li>
<li><code>latex(expr)</code> ：表达式的 latex 形式</li>
<li>可以直接使用 <code>oeis</code></li>
<li>sage.arith.misc 各种杂类函数，sage.games 有几个有意思的。</li>
<li><code>%time</code>： 测时间，<code>?</code> 帮助文章并且可以定位到源码位置查看源码！</li>
<li><a href="https://github.com/sagemath/sage/blob/develop/src/sage" target="_blank" rel="noopener">github 上查看 SageMath 模块源码</a></li>
<li>线性规划有包 MixIntegerLinearProgram</li>
<li>To be Continue</li>
</ul>
<h2 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h2><p><a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">jupyter 主题</a></p>
<p><code>Esc</code> 进入命令模式，<code>Enter</code> 进入编辑模式。<a href="https://www.cnblogs.com/locke-hu/p/9236540.html" target="_blank" rel="noopener">快捷键</a>友好(工具栏最右边有快捷键查询)</p>
<h4 id="命令模式常用快捷键（按-Esc-键开启）"><a href="#命令模式常用快捷键（按-Esc-键开启）" class="headerlink" title="命令模式常用快捷键（按 Esc 键开启）"></a>命令模式常用快捷键（按 Esc 键开启）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>S</code></td>
<td>保存当前 NoteBook</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><code>Shift-Enter</code></td>
<td>运行本单元，选中下个单元</td>
<td>新单元默认为命令模式</td>
</tr>
<tr>
<td style="text-align:left"><code>Ctrl-Enter</code></td>
<td>运行本单元</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><code>Alt-Enter</code></td>
<td>运行本单元，在其下插入新单元</td>
<td>新单元默认为编辑模式</td>
</tr>
<tr>
<td style="text-align:left"><code>D,D</code></td>
<td>删除选中的单元</td>
<td>连续按两个 D 键</td>
</tr>
<tr>
<td style="text-align:left"><code>Y</code></td>
<td>单元转入代码状态</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><code>M</code></td>
<td>单元转入 markdown 状态</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><code>R</code></td>
<td>单元转入 raw 状态</td>
<td>保持原始格式</td>
</tr>
<tr>
<td style="text-align:left"><code>B</code></td>
<td>当前行下方插入一行，并进入该行</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><code>Shift-H</code></td>
<td>清空所有输出</td>
<td>个人定制哈哈</td>
</tr>
</tbody>
</table>
</div>
<h4 id="编辑模式常用快捷键（-按-Enter-键启动）"><a href="#编辑模式常用快捷键（-按-Enter-键启动）" class="headerlink" title="编辑模式常用快捷键（ 按 Enter 键启动）"></a>编辑模式常用快捷键（ 按 Enter 键启动）</h4><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Tab</code></td>
<td>代码补全或缩进</td>
<td></td>
</tr>
<tr>
<td><code>Shift-Tab</code></td>
<td>提示</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-]</code></td>
<td>缩进</td>
<td>向右缩进</td>
</tr>
<tr>
<td><code>Ctrl-[</code></td>
<td>解除缩进</td>
<td>向左缩进</td>
</tr>
<tr>
<td><code>Ctrl-/</code></td>
<td>注释整行/撤销注释</td>
<td>仅代码状态有效</td>
</tr>
<tr>
<td><code>Ctrl-Z</code></td>
<td>撤销</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-ShiftZ</code></td>
<td>重做</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-Y</code></td>
<td>重做</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-Home</code></td>
<td>跳到单元开头</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-Up</code></td>
<td>跳到单元开头</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-End</code></td>
<td>跳到单元末尾</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-Down</code></td>
<td>跳到单元末尾</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Jupyter Notebook 在绘图方面特别方便，而且可以将代码和 Markdown 很清楚的写在一起</p>
<p>Jupyter 卡顿时候一定要强制中断！有数字的说明运行好了的！</p>
</blockquote>
<h2 id="SageMath-文档"><a href="#SageMath-文档" class="headerlink" title="SageMath 文档"></a>SageMath 文档</h2><p><a href="https://doc.sagemath.org/html/en/tutorial/index.html" target="_blank" rel="noopener">入门教程</a>，<a href="https://doc.sagemath.org/html/en/reference/index.html" target="_blank" rel="noopener">用户手册</a>，<a href="https://doc.sagemath.org/html/en/reference/py-modindex.html" target="_blank" rel="noopener">所有模块</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模块索引(首字母)</th>
<th>模块全名（<code>sage.</code>）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a</code></td>
<td>algebra, arith</td>
</tr>
<tr>
<td><code>c</code></td>
<td>calculus, categories, coding, combinat, cPython , crypto</td>
</tr>
<tr>
<td><code>d</code></td>
<td>date_structures, databases, docs, doctest, dynaimics</td>
</tr>
<tr>
<td><code>e, f</code></td>
<td>ext, features, finance, functions</td>
</tr>
<tr>
<td><code>g</code></td>
<td>game_theory, games, geometry, graphs, groups</td>
</tr>
<tr>
<td><code>h, i</code></td>
<td>knots, lfuntions libs, logic</td>
</tr>
<tr>
<td><code>m</code></td>
<td>manifolds, matrix, matroids media, misc, modular, modules, monoids</td>
</tr>
<tr>
<td><code>n, p, q, r</code></td>
<td>numerical, parallel, plot probability, quadratic_forms, quivers, repl, rings</td>
</tr>
<tr>
<td><code>s, t</code></td>
<td>sandpiles, sat, schemes, sets, stats, structure, symbolic, tensor, typeset</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>记不清名字的时候多用代码补全！</p>
</blockquote>
<p>先找对应名字，再找对应模块中的函数，最后看手册用的例子。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Math</tag>
        <tag>SageMath</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 调用 C/C++ 之 ctypes</title>
    <url>/ctypes/</url>
    <content><![CDATA[<p>放弃 Julia 之后，我开始想要用 Python + ctypes 满足自己的需求。由于 Windows 搞这个很麻烦，就在 Ubuntu 上搞了，不过我是在 WSL 上做的哈哈。</p>
<a id="more"></a>
<h2 id="Python-调用-C-示例"><a href="#Python-调用-C-示例" class="headerlink" title="Python 调用 C 示例"></a>Python 调用 C 示例</h2><p><a href="https://docs.Python.org/zh-cn/3.8/library/ctypes.html" target="_blank" rel="noopener">ctypes 官方中文文档</a>中选择自己 Python 对应版本的文档。有很清晰的描述，然后在 <a href="https://docs.Pythontab.com/interpy/c_extensions/ctypes/" target="_blank" rel="noopener">Pythonlab.com</a> 中很直观的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>; <span class="comment">// 这样就不用改之前的代码了！</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于 C++ 支持函数重载功能，在编译时会更改函数名。</p>
<p>所以在函数声明时，前缀 <code>extern &quot;C&quot;</code> 则确保按 C 的方式编译。</p>
</blockquote>
<p>然后把上面 <code>add.c/add.cpp</code> 编译成 <code>.so</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#For Linux</span></span><br><span class="line">$ gcc -fPIC -shared -o libadder.so add.c</span><br><span class="line">$ g++ -fPIC -shared -o libadder.so add.cpp</span><br></pre></td></tr></table></figure>
<p>再调用就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#load the shared object file</span></span><br><span class="line">adder = CDLL(<span class="string">'./libadder.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find sum of integers</span></span><br><span class="line">res_int = adder.add_int(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">print(<span class="string">"Sum of 4 and 5 = "</span>, res_int)</span><br></pre></td></tr></table></figure>
<h2 id="Python-调用自己写的-primepi-C-函数"><a href="#Python-调用自己写的-primepi-C-函数" class="headerlink" title="Python 调用自己写的 primepi C++ 函数"></a>Python 调用自己写的 primepi C++ 函数</h2><blockquote>
<p>Python 调用自己写的 PrimePI 岂不美哉</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">// 仅对要用的做extern操作</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j) &#123;</span><br><span class="line">			isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span> * <span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">11</span> * <span class="number">13</span> * <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM + <span class="number">1</span>][M + <span class="number">1</span>], sz[M + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	initprime();</span><br><span class="line">	pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isp[i]) pi[i] = pi[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> pi[i] = pi[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	sz[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= PM; ++i) phi[i][<span class="number">0</span>] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">		sz[i] = p[i] * sz[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= PM; ++j) &#123;</span><br><span class="line">			phi[j][i] = phi[j][i - <span class="number">1</span>] - phi[j / p[i]][i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s &lt;= M) <span class="keyword">return</span> phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];</span><br><span class="line">	<span class="keyword">if</span> (x / p[s] &lt;= p[s]) <span class="keyword">return</span> primepi(x) - s + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; N &amp;&amp; x / p[s] / p[s] &lt;= p[s]) &#123;</span><br><span class="line">		<span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>))];</span><br><span class="line">		LL ans = pi[x] - LL(s2x + s - <span class="number">2</span>) * (s2x - s + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt;= s2x; ++i) &#123;</span><br><span class="line">			ans += pi[x / p[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> primephi(x, s - <span class="number">1</span>) - primephi(x / p[s], s - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; N) <span class="keyword">return</span> pi[x];</span><br><span class="line">	<span class="keyword">int</span> ps2x = pi[<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>))];</span><br><span class="line">	<span class="keyword">int</span> ps3x = pi[<span class="keyword">int</span>(cbrt(x + <span class="number">0.2</span>))];</span><br><span class="line">	LL ans = primephi(x, ps3x) + LL(ps2x + ps3x - <span class="number">2</span>) * (ps2x - ps3x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = ps3x + <span class="number">1</span>, ed = ps2x; i &lt;= ed; ++i) &#123;</span><br><span class="line">		ans -= primepi(x / p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行 <code>g++ -fPIC -shared -o libprimepi.so primepi.cpp</code> 后运行下面 Python 程序</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">c = CDLL(<span class="string">'./libprimepi.so'</span>)</span><br><span class="line">c.init()</span><br><span class="line"><span class="comment"># 再大就崩了，Segmentation fault (core dumped)</span></span><br><span class="line">print(c.primepi(<span class="number">9876543210</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C 中用 Python 老是提醒没有 <code>Python.h</code>，试了网上的方法，各种系统都不行服了。不过无所谓最在 C 中用 Python 啊</p>
</blockquote>
<h2 id="SageMath-调用-C-的方法"><a href="#SageMath-调用-C-的方法" class="headerlink" title="SageMath 调用 C 的方法"></a><a href="https://doc.sagemath.org/html/en/thematic_tutorials/cython_interface.html#cython-interface" target="_blank" rel="noopener">SageMath 调用 C 的方法</a></h2><h2 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a><a href="https://www.cnblogs.com/skynet/p/3372855.html" target="_blank" rel="noopener">动态库和静态库</a></h2><h2 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h2><p>既然要混合编程了，哪必然要涉及到 makefile 了，于是我去 <a href="https://www.zhihu.com/question/23792247/answer/600773044" target="_blank" rel="noopener">知乎</a></p>
<p>示例源代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">	fun1();</span><br><span class="line">	fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"this is fun1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun2.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"this is fun2\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 Makefile（注意 Makefile 一定要 Tab 缩进)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># makefile1</span></span><br><span class="line"><span class="section">app: main.c fun1.c fun2.c  </span></span><br><span class="line">	gcc main.c fun1.c fun2.c -o app</span><br><span class="line"></span><br><span class="line"><span class="comment"># makefile2</span></span><br><span class="line"><span class="section">app: main.o fun1.o fun2.o  </span></span><br><span class="line">	gcc main.o fun1.o fun2.o -o app</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">	gcc -c main.c -o main.o</span><br><span class="line"><span class="section">fun1.o: fun1.c</span></span><br><span class="line">	gcc -c fun1.c -o fun1.o</span><br><span class="line"><span class="section">fun2.o: fun2.c</span></span><br><span class="line">	gcc -c fun2.c -o fun2.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># makefile3</span></span><br><span class="line">obj = main.o fun1.o fun2.o  </span><br><span class="line">target = app  </span><br><span class="line">CC = gcc</span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(obj)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># makefile</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span>  </span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span> <span class="comment"># obj = $(src:%.c=%.o)  </span></span><br><span class="line">target = app  </span><br><span class="line">CC = gcc</span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(obj)</span>  </span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o: %.c  </span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean  </span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(obj)</span> <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 <code>$</code> 自然是取值操作 <code>%</code> 是未定元的感觉，然后 <code>wildcard, patsubst</code> 从版本中就能看出。</p>
<p><code>$&lt;</code>：第一个依赖文件；<code>$@</code>：目标文件；<code>$^</code>：所有不重复的依赖文件，以空格分开。</p>
</blockquote>
<p>依次执行 <code>make -f makefilei</code> 即可，最后 <code>make (-f makefile 可省略), make clean</code> 是最终版本</p>
<h2 id="Make-规则"><a href="#Make-规则" class="headerlink" title="Make 规则"></a><a href="https://zhuanlan.zhihu.com/p/44267123" target="_blank" rel="noopener">Make 规则</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">目标: 预置条件</span></span><br><span class="line">&lt;TAB&gt; 步骤</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/127335903" target="_blank" rel="noopener">这里写的很详细</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>Make</tag>
      </tags>
  </entry>
  <entry>
    <title>Julia 入门到放弃</title>
    <url>/juliaLearning/</url>
    <content><![CDATA[<blockquote>
<p>和 Julia 的一夜情结束了 0.0 ，渣男 dna049 拥抱 SageMath 咯</p>
</blockquote>
<p>学完 Python 之后，觉得 Python 更像一个工具箱，啥都能干，但是我真的需要一个（轻量级）科学计算的工具，而不是像 Matlab 一样的付费巨无霸（我不想再用盗版软件了，学校正版 Matlab 2020 20G 吃不消！）而 C/C++ 在科学计算中因为原生精度问题，又没有特别权威的高精度包，所以也不太行。我甚至有自己学着去开发一种新型语言来打破当前尴尬的局面，直到我知道了 <a href="https://docs.juliacn.com/latest/" target="_blank" rel="noopener">Julia</a> ，已分手，理由：</p>
<blockquote>
<p>有 C 快吗？没有！有 Python 方便吗？没有！安装个包就跟求它借 100w 一样（国内源安装不了）</p>
<p>免费是取代 MATLAB，Mathematics 的理由吗？不是，收费是一件好事！！！</p>
<p>学术界的高性能计算的人员，它们学校至少买了 MATLAB 或者 Mathematics 好吧！</p>
<p>非上述人员，真的需要高性能计算吗？？？再说了真的性能高吗？向量化计算竟然还没有循环快，我吐了好吧</p>
</blockquote>
<a id="more"></a>
<h2 id="我会的语言"><a href="#我会的语言" class="headerlink" title="我会的语言"></a>我会的语言</h2><p>我已经会写，C/C++，Matlab，Python 了，接触过 Java, Swift, Lua(现在全忘了)。又要新学一门语言其实我是抵触的，并且 Julia 的语法简直就像 <code>没有分号的Matlab</code> ，我是很不喜欢的，依然想着某天我也能设计一个仅用于科学计算和 OI/ICPC 的语言! </p>
<ul>
<li>用 C/C++ 写高效小巧的功能</li>
<li>用 Python 处理日常小功能，计算器，模拟鼠标键盘控制，图片处理，视频处理，小游戏开发。</li>
<li>用 ~~Julia ~~ SageMath 写复杂的科学计算用以取代 Matlab。VSCode 一定要选择一个工作区文件夹</li>
<li>用 Matlab（学校版）做演示和交互，Wolfram Mathematics（网页版）做验算。</li>
</ul>
<h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>Julia 设计理念竟然是传承各种语言的优势，丢弃各个语言的不足的一种动态编程语言，可是这不是既要马儿跑，又要马儿不吃草吗？它借助 LLVM 和 JIT 技术。</p>
<p>Julia 有交互界面，现在语言感觉都能像 Python，Matlab 一样支持交互界面，<em>REPL</em> <em>REPL</em> : Read Eval Print Loop : 交互式解释器。</p>
<blockquote>
<p>高精度，支持向量，矩阵，传值而非传引用，速度快是我向往的</p>
</blockquote>
<h2 id="Julia-入门"><a href="#Julia-入门" class="headerlink" title="Julia 入门"></a>Julia 入门</h2><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><blockquote>
<p>太接近数学符号了！不亏是 MIT 出来的。</p>
</blockquote>
<ul>
<li><p>支持非 ASCII 码当运算符我是接受不了的</p>
</li>
<li><p>typeof 查看类型</p>
</li>
<li><p>Bool 类型： <code>true, false</code></p>
</li>
<li><p>整数有 Int8,16,32,64,128, 和 U 版本（越界取模），还有高精度 BigInt（都会自动向这个转化）</p>
</li>
<li><p>浮点数有 Int16，Int32，Int64，有 Inf，-Inf，NaN，eps，还有高精度 BigFloat（当然了不可能是精确值）</p>
</li>
<li><p>有理数和复数自带（<code>//</code> 表示有理数，im 表示虚数 i）</p>
</li>
<li><p>从 1 开头索引，我有点接受不了</p>
</li>
<li><p>整除: <code>÷</code> (或者用 div)  异或：<code>⊻</code>(或者用 xor)</p>
<blockquote>
<p>div 向 0 近似，fld 向 -inf 近似，cld 向 +inf 近似</p>
</blockquote>
</li>
<li><p>Base.operator_precedence 看运算符优先级，Base.operator_associativity 看是左结合还是右结合</p>
</li>
<li><p>math 包内建</p>
</li>
<li><p>养成运算符之间加空格的好习惯</p>
</li>
<li><p>短路求值是个好东西</p>
</li>
<li><p>dot 运算，竟然比 for 循环慢？？？搞笑？这玩什么</p>
</li>
<li><p>好像要 Python 一样有 Yield 目前没找到</p>
</li>
<li><p>!放在函数名后面表示输入参数会被改变（但是不一定要这么做）</p>
</li>
<li><p>Copy 跟 Python 一样是浅 Copy</p>
</li>
</ul>
<h3 id="包的国内镜像"><a href="#包的国内镜像" class="headerlink" title="包的国内镜像"></a>包的国内镜像</h3><p>装个包，人装傻了！</p>
<p>USTC 的用不了，所以用 ZJU 的了</p>
<blockquote>
<p>先把<a href="https://mirrors.zju.edu.cn/julia/registries/General/Registry.toml" target="_blank" rel="noopener">Registry.toml</a> 文件下载下来，放在 <code>C:\\Users\\Administrator\\.julia\\registries\\General\\</code></p>
</blockquote>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">(v1<span class="number">.4</span>) pkg&gt; registry add https://mirrors.zju.edu.cn/julia/registries/General.git/</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Julia</tag>
      </tags>
  </entry>
  <entry>
    <title>$GL_n(\mathbb{Z}_m)$ 的阶数</title>
    <url>/orderOfGLnZm/</url>
    <content><![CDATA[<p>由线性无关性，我们不难知道 $|GL_n(\mathbb{Z}_p)| = \prod_{i=0} ^{n-1} (p^n-p^i)$，但是 $|GL_n(\mathbb{Z}_m)|$ 却是一个相对复杂的问题，它本质上是在考虑有限 Abel 群的自同构群的阶数问题。它又跟递推数列模 $m$ 的周期密切相关。</p>
<a id="more"></a> 
<p>2007 年 CHRISTOPHER J. HILLAR AND DARREN L. RHEA 发表一篇论文<a href="automorphismsOfFiniteAblianGroup.pdf">《AUTOMORPHISMS OF FINITE Abelian GROUPS》</a> 完美的解决了这个问题。</p>
<h2 id="有限生成-Abel-群结构定理"><a href="#有限生成-Abel-群结构定理" class="headerlink" title="有限生成 Abel 群结构定理"></a>有限生成 Abel 群结构定理</h2><p>设 $G$ 是一个有限 Abel 群，那么 $G$ 同构于一些</p>
<script type="math/tex; mode=display">
H_p = \mathbb{Z}_{p^{e_1}} \times \cdots  \mathbb{Z}_{p^{e_n}}</script><p>的乘积。其中 $p$ 是素数（$p$ 一般默认为素数），$1 \leq e_1 \leq \cdots \leq e_n$ 是正整数。</p>
<blockquote>
<p>证明可见任意一般抽象代数（或近世代数）书。</p>
</blockquote>
<h2 id="乘积的自同构"><a href="#乘积的自同构" class="headerlink" title="乘积的自同构"></a>乘积的自同构</h2><p>若 $H$ 和 $K$ 是有限群，且它们的阶数互素。那么我们就有同构：</p>
<script type="math/tex; mode=display">
Aut(H) \times Aut(K) \simeq Aut(H \times K)</script><p><strong>Proof</strong> ：我们构造很自然的映射：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\phi: Aut(H) \times Aut(K) \to Aut(H \times K) \\
\phi(\alpha,\beta)(h,k) = (\alpha(h),\beta(k))
\end{aligned}</script><p>容易验证 $\phi$  是合理的映射，并且是单射，然后我们同构构造它的逆映射来说明它是满射。</p>
<p>我们记 $n = |H|,m = |K|$，$\pi_H,\pi_K$ 是标准投影映射： $\pi_H: H \times K \to H$，$\pi_K: H \times K \to K$ 。对于给定的 $\omega \in Aut(H \times K)$，我们定义同态 $\gamma: K \to H$， $\gamma(k) = \pi_H(\omega(1_H,k))$，注意到 $\lbrace k^n: k \in K \rbrace \subseteq \ker \gamma$。又 $m,n$是互素的，所以 $\gamma$ 是平凡的映射。同理，我们定义 $\delta: H \to K$，$\delta(h) = \pi_K(\omega(h,1_K))$ 也是平凡映射。最后我们定义$H$和$K$的自同态：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\omega_H(h) = \pi_H(w(h,1_K)) ,\quad \omega(k) = \pi_K(w(1_H,k)) \\
\omega(h,k) = \omega(h,1_K) \omega(1_H,k) = (\omega_H(h),  \omega_K(k)) = \phi(w_H,w_k)(h,k)
\end{aligned}</script><p>由于 $\omega_H,\omega_K$ 都是单射，并且 $H,K$ 是有限群，所以它们是自同构，证毕。</p>
<blockquote>
<p>所以我们考虑 $Aut(G)$，只需考虑 $Aut(H_p)$ 即可</p>
</blockquote>
<h2 id="H-p-的自同态"><a href="#H-p-的自同态" class="headerlink" title="$H_p$ 的自同态"></a>$H_p$ 的自同态</h2><p>我们定义，环 $E_p = End(H_p)$（加法就是映射的加法，乘法就是映射的复合）</p>
<p>由于循环群 $C_{p^{e_i}}$ 对应的是 模 $p^{e_i}$ 的加法群。所以 $H_p$ 中的元素可以表示成列向量 $(\overline{h_1},\cdots \overline{h_n})^T$，其中 $\overline{h_i} \in \mathbb{Z}_{p^{e_i}}, \; h_i \in \mathbb{Z}$</p>
<p>我们定义（<strong>精华所在</strong>)</p>
<script type="math/tex; mode=display">
R_p \doteq \lbrace (a_{ij} \in \mathbb{Z}^{n \times n}: p^{e_i - e_j}|a_{ij} \quad \forall 1 \leq j < i \leq n)</script><p>注意到 $\forall A \in R_p$，$A = P A’ P^{-1}$，其中 $P = diag(p^{e_1},\cdots,p^{e_n}), A’ \in \mathbb{Z}^{n \times n}$。从而 $R_p$ 根据加法和矩阵乘法，构成了一个环。</p>
<p>我们定义 $\pi_i: \mathbb{Z} \to \mathbb{Z}_{p^{e_i}}$ 为标准商映射。$\pi: \mathbb{Z}^n \to H_p$ 为：</p>
<script type="math/tex; mode=display">
\pi(h_1,\cdots h_n)^T = (\pi_1(h_1),\cdots,\pi_n(h_n))^T = (\overline{h_1},\cdots \overline{h_n})^T</script><p>我们不难验证 $\psi: R_p \to E_p$</p>
<script type="math/tex; mode=display">
\psi(A)(\overline{h_1},\cdots \overline{h_n})^T = \pi(A(h_1,\cdots,h_n)^T)</script><p>是环满同态（需要验证映射合理性，环同态，满射）且 $\ker \psi = \lbrace A = (a_{ij}) \in R_p: p^{e_i} | a_{ij}$ </p>
<h2 id="H-p-的自同构-Aut-H-p"><a href="#H-p-的自同构-Aut-H-p" class="headerlink" title="$H_p$ 的自同构 $Aut(H_p)$"></a>$H_p$ 的自同构 $Aut(H_p)$</h2><p>$M = \psi(A) \in Aut(H_p)$ 当且仅当 $A \mod p \in GL_n(\mathbb{F}_p)$，即 $\det(A) \in U(H_p)$ 是 $H_p$ 中可逆元。</p>
<p><strong>Proof</strong>：利用 $A$ 的逆矩阵推出 $M$ 是自同构，利用 $M$ 的逆映射给出 $A$ 的逆矩阵。</p>
<h2 id="Aut-H-p"><a href="#Aut-H-p" class="headerlink" title="$| Aut(H_p)|$"></a>$| Aut(H_p)|$</h2><p>定义：$d_k = \max \lbrace l: e_l  = e_k \rbrace, c_k = \min \lbrace l: e_l  = e_k \rbrace$，显然 $c_k \leq k \leq d_k$。我们需要计算</p>
<ul>
<li>所有 $GL_n(\mathbb{F}_p)$ 中可以拓展成 $A \in R_p$ 的元素</li>
<li>每个元素拓展方式</li>
</ul>
<p>我们找到所有 $M \in  GL_n(\mathbb{F}_p)$ 形如：</p>
<script type="math/tex; mode=display">
M = 
\begin{pmatrix} 
m_{11} & & & \star \\
\vdots \\
m_{d_1 1} \\
& m_{d_2 2} \\
& & \ddots \\
0 & & & m_{d_n n} 
\end{pmatrix}</script><blockquote>
<p>注意到 $\sum_{j=1} ^n \sum_{i=1} ^{d_j} m_{ij} = \sum_{e_i \leq e_j} m_{ij} = \sum_{i=1} ^n \sum_{j = c_i}^n m_{ij}$</p>
</blockquote>
<p>因为我们只考虑线性无关的，所以这种 $M$ 的数量是</p>
<script type="math/tex; mode=display">
\prod_{k=1} ^n (p^{d_k} - p^{k-1})</script><p>将 $m_{ij}$ 从 $\overline{m_{ij}} \in \mathbb{Z}_p$ 到 $\overline{a_{ij}} \in p^{e_i-e_j} \mathbb{Z}/p^{e_i} \mathbb{Z}$ 使得 $a_{ij} \equiv m_{ij} \mod p$ 的方案数分两种情况</p>
<ul>
<li>$e_i &gt; e_j$ 时， $p^{e_j}$ 种</li>
<li>$e_i \leq e_j$ 时， $p^{e_i-1}$ 种</li>
</ul>
<p>从而</p>
<script type="math/tex; mode=display">
|Aut(H_p)| = \prod_{k=1} ^n (p^{d_k} - p^{k-1}) \prod _{j=1} ^n (p^{e_j})^{n-d_j} \prod_{i=1} ^n (p^{e_i -1})^{n-c_i+1}</script><h2 id="GL-n-mathbb-Z-m"><a href="#GL-n-mathbb-Z-m" class="headerlink" title="$|GL_n(\mathbb{Z}_m)|$"></a>$|GL_n(\mathbb{Z}_m)|$</h2><p>由 $|Aut(H_p)|$ 的公式的特殊形式，我们知道 $|GL_n(Z_{p^s})| = p^{n^2 (s-1)} \prod_{k=1} ^n (p^n - p^{k-1})$。</p>
<p>将 $m$ 质因数分解 $m = p_1^{s_1} \cdots p_r ^{s_r}, \quad p_1 &lt; \cdots &lt; p_r$ </p>
<script type="math/tex; mode=display">
|GL_n(\mathbb{Z}_m)| =  \prod_{i=1} ^r |GL_n(Z_{p_i^{s_i}})|</script><h2 id="mathbb-Z-m-上-n-阶给定可逆矩阵-A-的周期"><a href="#mathbb-Z-m-上-n-阶给定可逆矩阵-A-的周期" class="headerlink" title="$\mathbb{Z}_m$ 上$n$ 阶给定可逆矩阵 $A$ 的周期"></a>$\mathbb{Z}_m$ 上$n$ 阶给定可逆矩阵 $A$ 的周期</h2><p>设 $f(\lambda) = | \lambda I -A|$，$A$ 可逆等价于 $\gcd(f(\lambda),\lambda) = 1$，由于 $A^k$ 都可以由 $I,A,\cdots A^{n-1}$，线性表出，但是由于是在 $\mod m$ 的意义下，所以根据容斥原理，对任意 $k \geq m^n$ 时，必然存在 $l &lt; k$，使得 $A^k = A^l$。即 $A$ 的周期上限是 $m^n$，并且周期是 $|GL_n(\mathbb{Z}_m)|$ 的一个真因子（$n&gt;1$）。</p>
<p>显然若 $A$ 可对角化，那么 $A$ 的周期必然是 $\phi(m)$ 的一个因子！但是注意这里 $A$ 对称并不能推出 $A$ 可对角化。</p>
<h2 id="常系数递推数列模意义下的周期"><a href="#常系数递推数列模意义下的周期" class="headerlink" title="常系数递推数列模意义下的周期"></a>常系数递推数列模意义下的周期</h2><p>给定初值，$x_1,\cdots x_s$, 和递推关系：$x_{n+s} = a_1 x_{n+s-1} + \cdots + a_s x_n, a_s \neq 0$ 的数列 ${x_n}$可以表示成：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
x_n \\
x_{n-1} \\
\vdots  \\
x_{n-s+1}
\end{pmatrix} =
\begin{pmatrix}
a_1 & a_2 &\cdots & a_s \\
1 & 0 \\
\vdots  & & & 0\\
0 &\cdots & 1& 0
\end{pmatrix} 

\begin{pmatrix}
x_{n-1} \\
x_{n-2} \\
\vdots  \\
x_{n-s}
\end{pmatrix}</script><p>可以通过矩阵幂在 $O(s^3 \log n)$ 复杂度求出。</p>
<blockquote>
<p>当 $s$ 相对较大时，根据特征多项式将系数矩阵 $A^n$ 写成 $I,A,\cdots A^{s-1}$ 的线性组合，然后只考虑仅乘以第一行，就可以在 $O(s^2\log n)$ 复杂度求出</p>
</blockquote>
<p>我们考虑 数列 $\lbrace x_n  \mod m \rbrace$ ，由容斥原理知，数列 $\lbrace x_n  \mod m \rbrace$ 是周期数列，记它的最小正周期为 $f(m)$ ，则 </p>
<script type="math/tex; mode=display">
f(m) = lcm(f(p_1^{s_1}),\cdots f(p_r^{s_r}))</script><p>只要 $p_i \not| \; a_s$，则 $f(p_i ^{s_i})$  是 $|GL_n(\mathbb{Z}_{p_i^{s_i}})|$ 的一个真因子（当 $n&gt;1$ 时，$GL_n(\mathbb{Z}_{p_i^{s_i}})$ 不是循环群）。</p>
<blockquote>
<p>精确的周期要具体问题具体分析。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>不超过 $x$ 的素数之和</title>
    <url>/primePowSum/</url>
    <content><![CDATA[<p>我们可以在不求出 <strong>不超过 $x$ 的所有素数</strong> 的情况下，求出最终结果。</p>
<script type="math/tex; mode=display">
f_k(x) \doteq \sum_{p \leq x} p^k</script><ul>
<li>$f_0(x) = \pi(x)$ 这个在 <a href="/computationOfPiX/" title="$\pi(x)$ 的计算">$\pi(x)$ 的计算</a></li>
<li>$f_1(x) = \sum_{p \leq x} p$ 这是我们关心的结果</li>
<li>对于一般的 $k$ 借助 <a href="/fastPowSumOfNaturalNumber/" title="自然数方幂和快速算法">自然数方幂和快速算法</a> 也可以求</li>
</ul>
<a id="more"></a>
<h2 id="f-k-x-s-：-最小素因子大于-p-s-且不超过-x-的数的-k-次方和"><a href="#f-k-x-s-：-最小素因子大于-p-s-且不超过-x-的数的-k-次方和" class="headerlink" title="$f_k(x,s)$： 最小素因子大于 $p_s$ 且不超过 $x$ 的数的 $k$ 次方和"></a>$f_k(x,s)$： 最小素因子大于 $p_s$ 且不超过 $x$ 的数的 $k$ 次方和</h2><script type="math/tex; mode=display">
f_k(x,s) = \sum_{m \leq x, \delta(m)>p_s} m^k</script><p>其中，$\delta(m)$ 表示 $m$ 的最小素因子（约定 $\delta(1) = + \infty$）。</p>
<h3 id="f-k-x-s-的递推公式"><a href="#f-k-x-s-的递推公式" class="headerlink" title="$f_k(x,s)$ 的递推公式"></a>$f_k(x,s)$ 的递推公式</h3><script type="math/tex; mode=display">
\begin{aligned}
f_k(x,s) &= \sum_{m \leq x, \delta(m)>p_s} m^k \\
&= f(x,s-1) - \sum_{m \leq x, \delta(m) = p_s} m^k \\
&= f(x,s-1) - p_s ^k f(\frac{x}{p_s},s-1)
\end{aligned}</script><blockquote>
<p>$\displaystyle f_k(x,0) = \sum_{i=1} ^ {\lfloor x \rfloor} i^k$</p>
</blockquote>
<h3 id="f-k-x-s-和-f-k-x-的关系"><a href="#f-k-x-s-和-f-k-x-的关系" class="headerlink" title="$f_k(x,s)$  和 $f_k(x)$ 的关系"></a>$f_k(x,s)$  和 $f_k(x)$ 的关系</h3><p>若 $s &gt;= \pi(\sqrt{x})$，则</p>
<script type="math/tex; mode=display">
f_k(x) = f_k(x,s) - 1  + f_k(p_s)</script><h3 id="只对-k-1-写代码（一般的-k-同理）"><a href="#只对-k-1-写代码（一般的-k-同理）" class="headerlink" title="只对 $k=1$ 写代码（一般的 $k$ 同理）"></a>只对 $k=1$ 写代码（一般的 $k$ 同理）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;p[<span class="number">1</span>]=<span class="number">2</span>;isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)   isp[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])  p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>,t=(N<span class="number">-1</span>)/i + <span class="number">1</span>;j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j)&#123;</span><br><span class="line">            isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">LL spi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    initprime();</span><br><span class="line">    pi[<span class="number">2</span>] = <span class="number">1</span>;spi[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])&#123;</span><br><span class="line">            pi[i]=pi[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            spi[i] = spi[i<span class="number">-1</span>]+i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pi[i]=pi[i<span class="number">-1</span>];</span><br><span class="line">            spi[i] = spi[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sump</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">sumphi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)  <span class="keyword">return</span> (x+<span class="number">1</span>)*x/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x/p[s] &lt;= p[s])  <span class="keyword">return</span> sump(x)+<span class="number">1</span>-sump(p[s]);</span><br><span class="line">    <span class="keyword">return</span> sumphi(x,s<span class="number">-1</span>)-p[s]*sumphi(x/p[s],s<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sump</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> spi[x];</span><br><span class="line">    <span class="keyword">int</span> s = pi[<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">    <span class="keyword">return</span> sumphi(x,s) <span class="number">-1</span>+ sump(p[s]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n = 10^10 就超过int64了,此时用Int128 n &lt; N*N</span></span><br><span class="line">        <span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sump(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是其实我们还可以，类似于 $\pi(x)$ 的计算一样, 取 $\pi(\sqrt[3]{x}) \leq s \leq \pi(\sqrt{x})$</p>
<script type="math/tex; mode=display">
f_k(x) = f_k(x,s) - 1  + f_k(p_s) - \sum_{i=s+1} ^ {\pi(\sqrt{x})} (f(\frac{x}{p_i})-f(p_{i-1})) p_i ^k</script><h3 id="只对-k-1-写代码（一般的-k-同理）-1"><a href="#只对-k-1-写代码（一般的-k-同理）-1" class="headerlink" title="只对 $k=1$ 写代码（一般的 $k$ 同理）"></a>只对 $k=1$ 写代码（一般的 $k$ 同理）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;p[<span class="number">1</span>]=<span class="number">2</span>;isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)   isp[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])  p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>,t=(N<span class="number">-1</span>)/i + <span class="number">1</span>;j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j)&#123;</span><br><span class="line">            isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">LL spi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    initprime();</span><br><span class="line">    pi[<span class="number">2</span>] = <span class="number">1</span>;spi[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])&#123;</span><br><span class="line">            pi[i]=pi[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            spi[i] = spi[i<span class="number">-1</span>]+i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pi[i]=pi[i<span class="number">-1</span>];</span><br><span class="line">            spi[i] = spi[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sump</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">sumphi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)  <span class="keyword">return</span> (x+<span class="number">1</span>)*x/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x/p[s] &lt;= p[s])  <span class="keyword">return</span> sump(x)+<span class="number">1</span>-sump(p[s]);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N &amp;&amp; x/p[s]/p[s] &lt;= p[s])&#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">        LL ans = spi[x]+<span class="number">1</span>-spi[p[s]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=s2x;++i)&#123;</span><br><span class="line">            ans+=p[i]*(spi[x/p[i]]-spi[p[i<span class="number">-1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumphi(x,s<span class="number">-1</span>)-p[s]*sumphi(x/p[s],s<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sump</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> spi[x];</span><br><span class="line">    <span class="keyword">int</span> ps2x = pi[<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">    <span class="keyword">int</span> ps3x = pi[<span class="keyword">int</span>(cbrt(x+<span class="number">0.2</span>))];</span><br><span class="line">    LL ans = sumphi(x,ps3x) <span class="number">-1</span> + spi[p[ps3x]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =ps3x+<span class="number">1</span>;i&lt;=ps2x;++i)&#123;</span><br><span class="line">        ans -= p[i]*(sump(x/p[i])-sump(p[i<span class="number">-1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n = 10^10 就超过int64了,此时用Int128 n &lt; N*N</span></span><br><span class="line">        <span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sump(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊数列</title>
    <url>/SpecialNumberSequences/</url>
    <content><![CDATA[<p>在知乎上看到一个有趣的问题: <a href="https://www.zhihu.com/question/383254359" target="_blank" rel="noopener">如何证明这个数列无界？</a> 在此记录一下简单的做法，然后把这篇博客记录以后遇到的一些特殊数列。</p>
<p>证明：当 $x$ 是无理数时，$f_n(x) = \sum_{i=1}^n (-1)^{\lfloor ix \rfloor}$  无界</p>
<blockquote>
<p>$\lfloor x \rfloor$ 表示 $x$ 的整数部分， $0 \leq \lbrace x \rbrace \doteq x- \lfloor x \rfloor&lt;1$ 表示 $x$ 的小数部分</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>为了更顺畅的介绍这个数列，我们先来点前戏，不然插入的时候就不那么顺滑了 0.0 不要笑，我没有开车 0.0</p>
</blockquote>
<h2 id="连分数"><a href="#连分数" class="headerlink" title="连分数"></a><a href="ContinuedFractions.pdf">连分数</a></h2><blockquote>
<p>它和 Farey 序列，无理数的有理逼近，密切相关</p>
</blockquote>
<p>我们将一个整数序列 $a_0,a_1, \cdots, a_n$ 构成的分数叫做连分数，记作</p>
<script type="math/tex; mode=display">
[a_0,a_1,\cdots, a_n] = a_0 + \frac{1}{a_1 + \frac{1}{a_2 + \cdots}}</script><p>其中 $a_0$ 是整数， $a_i (i&gt;0)$ 是正整数。</p>
<p>我们定义:</p>
<p>$p_0 = a_0,p_1 = a_1a_0 +1,p_n = a_np_{n-1} + p_{n-2} (n&gt;1)$</p>
<p>$q_0 = 1,q_1 = a_1,q_n=a_nq_{n-1}+q_{n-2} (n&gt;1)$</p>
<p>那么数学归纳法易证：</p>
<script type="math/tex; mode=display">
[a_0,a_1,\cdots, a_n] = \frac{p_n}{q_n} = x_0</script><p>并且还有</p>
<ul>
<li>$[a_0,a_1,\cdots, a_n] = [a_0,a_1,\cdots, a_{n-1} + \frac{1}{a_n}]$</li>
<li>$p_{n+1}q_n - q_{n+1}p_n = (-1)^n$</li>
<li>从而 $(p_n,p_{n+1}) = (q_n,q_{n+1}) = (p_n,q_n) = 1$</li>
<li>$x_{n+2} - x_n = \frac{(-1)^n a_{n+2}}{q_n q_{n+2}}$</li>
<li>从而 $x_0 &lt; x_2&lt; x_4 &lt; \cdots &lt; x_5 &lt; x_3 &lt; x_1$</li>
</ul>
<h3 id="对任意一个数-x-构造连分数"><a href="#对任意一个数-x-构造连分数" class="headerlink" title="对任意一个数 $x$ 构造连分数"></a>对任意一个数 $x$ 构造连分数</h3><ol>
<li>初始 $i = 0$</li>
<li>$a_i = \lfloor x \rfloor$ 取 $x$ 的整数部分。</li>
<li>$x - a_i == 0$ 结束</li>
<li>取 $x = \frac{1}{x-a_i}$ </li>
<li>++$i$ 回到步骤 1</li>
</ol>
<p>从构造中，我们看出：<strong>连分数长度有限当且仅当 $x$ 是有理数</strong>，此时，最后一项得到的连分数就是 $x$。</p>
<p>当 $x$ 是无理数时， $x_{2n} &lt; x &lt; x_{2n+1}$ ，又因为</p>
<script type="math/tex; mode=display">
x_{2n+1} - x_{2n} = \frac{1}{q_{2n}q_{2n+1}} \leq  \frac{1}{2n(2n+1)}</script><p>且  $x_{2n}$  单调递增，$x_{2n+1}$ 单调递减。所以 $\lim _{n \to \infty} x_n = x$。并且</p>
<script type="math/tex; mode=display">
|x - \frac{p_n}{q_n} | < \frac{1}{q_n ^2}</script><h3 id="补充定义"><a href="#补充定义" class="headerlink" title="补充定义"></a>补充定义</h3><script type="math/tex; mode=display">
a_n' \doteq a_n'(x) \doteq [a_n, a_{n+1}, a_{n+2},\cdots]</script><script type="math/tex; mode=display">
p_{n+1}' \doteq a_{n+1}' p_n + p_{n-1} = \frac{p_{n+2}'}{a_{n+2}'} \\ 
q_{n+1}' \doteq a_{n+1}' q_n + q_{n-1} = \frac{q_{n+2}'}{a_{n+2}'}</script><p>显然，$x = \frac{p_n’}{q_n’} =  \frac{p_n}{q_n} + \frac{(-1)^n}{q_n q_{n+1}’}$</p>
<h3 id="唯一分解"><a href="#唯一分解" class="headerlink" title="唯一分解"></a>唯一分解</h3><p>对于任意给定 $x = [a_0,a_1,\cdots,a_n,\cdots]$，对任意 $N$，有如下唯一分解：</p>
<script type="math/tex; mode=display">
N = \sum c_i q_i  = \sum_{i=0} ^{m(N,x)} c_i(N,x)q_i(x)</script><p>其中 $0 \leq c_i \leq a_{i+1}, c_m(N,x) &gt;0$ 且对任意 $0 \leq j \leq m(N,x)$，$\sum_{i=0} ^ j c_i q_i &lt; q_{j+1}$ 。</p>
<h2 id="f-n-x-sum-i-1-n-1-lfloor-ix-rfloor-何时有界"><a href="#f-n-x-sum-i-1-n-1-lfloor-ix-rfloor-何时有界" class="headerlink" title="$ f_n(x) = \sum_{i=1}^n (-1)^{\lfloor ix \rfloor} $ 何时有界"></a>$ f_n(x) = \sum_{i=1}^n (-1)^{\lfloor ix \rfloor} $ 何时有界</h2><p>由于 $f_n(x+2) = f_n(x) $， 所以我们仅考虑 $x \in [0,2) $ ， 在不引起混淆时，简记成 $f_n $</p>
<h3 id="当-x-是有理数时，记-x-frac-p-q-quad-p-q-1"><a href="#当-x-是有理数时，记-x-frac-p-q-quad-p-q-1" class="headerlink" title="当 $x$ 是有理数时，记 $ x = \frac{p}{q},\quad (p,q)=1$"></a>当 $x$ 是有理数时，记 $ x = \frac{p}{q},\quad (p,q)=1$</h3><p>则 $f_{2q+n} = f_{2q} + f_n$， 从而 $a_n$ 有界当且仅当 $f_{2q} \neq 0 $</p>
<script type="math/tex; mode=display">
f_{2q} = \sum_{i=1}^{2q} (-1)^{\lfloor \frac{ip}{q} \rfloor } =\sum_{i=1}^{q} (-1)^{\lfloor \frac{ip}{q} \rfloor } + \sum_{i=1}^{q} (-1)^{\lfloor  \frac{(i+q)p}{q} \rfloor  } = (1+(-1)^p) f_q</script><ul>
<li><p>当 $q$ 为奇数， $f_{2q} = 0$，即 $f_n$ 有界</p>
</li>
<li><p>当 $p$ 为偶数时，此时 $q$ 为奇数，且 $(\frac{p}{2},q)=1$，所以当 $i$ 跑遍 $[1, q]$ 时，$i\frac{p}{2} \mod q$ 跑遍 $[0,q-1]$，即</p>
<script type="math/tex; mode=display">
f_q = \sum_{i=1}^q (-1)^{ \lfloor \frac{2( i\frac{p}{2} \mod q)}{q} \rfloor} =\sum_{i=0} ^{q-1} (-1)^{\lfloor \frac{2i}{q} \rfloor} = \frac{q+1}{2} - \frac{q-1}{2} = 1</script><p>从而 $f_{2q} = 2f_q = 2$ 推出 $f_n$ 无界。</p>
</li>
</ul>
<h2 id="对任意无理数-x-，我们证明-g-n-x-f-n-2x-无界，从而-f-n-x-无界"><a href="#对任意无理数-x-，我们证明-g-n-x-f-n-2x-无界，从而-f-n-x-无界" class="headerlink" title="对任意无理数 $x$，我们证明 $g_n(x) = f_n(2x)$ 无界，从而 $f_n(x)$ 无界"></a>对任意无理数 $x$，我们证明 $g_n(x) = f_n(2x)$ 无界，从而 $f_n(x)$ 无界</h2><blockquote>
<p>目前没理解论文中的做法，太繁琐了</p>
</blockquote>
<p>显然，我们只需考虑 $0&lt; x &lt;1$</p>
<p>我们考虑 $x$ 的连分数 $[0,a_1,a_2,\cdots,a_n,\cdots]$，由于 $(p_n,q_n)=(q_n,q_{n+1})=1$ (目前不知道有什么简单的操作)</p>
<p>这个问题可以推广到更一般的情形：<a href="1.pdf">单栏阅读</a> <a href="2.pdf">双栏阅读</a></p>
<blockquote>
<p>里面定理一挺有意思的，虽然长但是很清晰。</p>
</blockquote>
<h2 id="另一个相关问题：https-www-zhihu-com-question-392014769"><a href="#另一个相关问题：https-www-zhihu-com-question-392014769" class="headerlink" title="另一个相关问题：https://www.zhihu.com/question/392014769"></a>另一个相关问题：<a href="https://www.zhihu.com/question/392014769" target="_blank" rel="noopener">https://www.zhihu.com/question/392014769</a></h2><p>是否存在 $N$ 使得， $|\sin n|&gt;\frac{1}{n}$ 对所有 $n&gt;N$ 成立。(<a href="https://www.zhihu.com/people/dna049" target="_blank" rel="noopener">dna049</a> 和 <a href="https://www.zhihu.com/people/zhai-sen-8" target="_blank" rel="noopener">寨森 Lambda-CDM</a> 建议修改)</p>
<h3 id="存在无穷多个正整数-x-n-使得-sin-x-n-lt-frac-2-pi-x-n"><a href="#存在无穷多个正整数-x-n-使得-sin-x-n-lt-frac-2-pi-x-n" class="headerlink" title="存在无穷多个正整数 $x_n$ 使得 $|\sin x_n| &lt; \frac{2 \pi}{x_n}$"></a>存在无穷多个正整数 $x_n$ 使得 $|\sin x_n| &lt; \frac{2 \pi}{x_n}$</h3><p>引理： 对任意无理数 $a$ , 存在无穷多个 $x_n$，使得 $\min(\{a x_n\},\{-a x_n\}) &lt; \frac{2}{x_n}$</p>
<p>我们考虑 $a$ 的连分数 $[a_0,a_1,\cdots,a_n,\cdots]$, 我们知道 $|a - \frac{p_n}{q_n} | &lt; \frac{1}{q_n ^2}$，由于 $(p_n,q_n) = 1$,  所以存在 $u_n,v_n$ 使得 $p_n u_n + q_n v_n = 1$, 此时 $p_n(u_n+tq_n) + q_n(v_n - tp_n) = 1$，所以我们不妨假设 $q_n &lt; u_n &lt; 2q_n$。所以 </p>
<script type="math/tex; mode=display">
\{ a u_n \} = \{ (a-\frac{p_n}{q_n})u_n + \frac{p_n}{q_n}u_n \}  = \{ (a-\frac{p_n}{q_n})u_n + \frac{1}{q_n} \}</script><p>我们仅考虑 $n$ 为奇数数的情况，此时 $-\frac{1}{q_n^2} &lt; a - \frac{p_n}{q_n} &lt; 0$，所以 $-\frac{1}{q_n} &lt;(a-\frac{p_n}{q_n})u_n + \frac{1}{q_n} &lt;\frac{1}{q_n}$。而 $x_n = u_{2n+1} &gt; q_{2n+1}$  即为所求。</p>
<blockquote>
<p>实际上 $n$ 为偶数时，也可以取做，只是此时 $u_n$ 要换成 $3q_n - u_n$</p>
</blockquote>
<p>取引理中 $a = \frac{1}{\pi}$，由于 $|\sin(x)|$ 是周期为 $\pi$ 的偶函数。所以 $|\sin(x_n)| = |\sin(\{ax_n\}\pi)| = |\sin(\{-ax_n\}\pi)| &lt; \frac{2\pi}{x_n}$</p>
<p>受 <a href="https://www.zhihu.com/people/zhai-sen-8" target="_blank" rel="noopener">寨森 Lambda-CDM</a>  启发，可以不用引理直接证明：</p>
<h3 id="存在无穷多个正整数-m-，使得-sin-m-lt-frac-pi-m"><a href="#存在无穷多个正整数-m-，使得-sin-m-lt-frac-pi-m" class="headerlink" title="存在无穷多个正整数 $m$，使得 $|\sin m| &lt; \frac{\pi}{m}$"></a>存在无穷多个正整数 $m$，使得 $|\sin m| &lt; \frac{\pi}{m}$</h3><p>Proof：考虑 $\frac{1}{\pi}$ 的连分数 $[a_0,a_1,\cdots,a_n,\cdots]$，我们有 $|\frac{1}{\pi} - \frac{p_n}{q_n} | &lt; \frac{1}{q_n ^2}$，所以</p>
<script type="math/tex; mode=display">
|\sin q_n| = |\sin[(\frac{q_n}{\pi} -p_n) \pi + p_n\pi ]|  =  |\sin[(|\frac{q_n}{\pi} -p_n|) \pi]| < \frac{\pi}{q_n}</script><p>这个问题还关联这 <a href="https://mathworld.wolfram.com/IrrationalityMeasure.html" target="_blank" rel="noopener">Irrationality Measure</a>，菲尔兹奖级别的工作！</p>
<h3 id="Irrationality-Measure"><a href="#Irrationality-Measure" class="headerlink" title="Irrationality Measure"></a><a href="https://mathworld.wolfram.com/IrrationalityMeasure.html" target="_blank" rel="noopener">Irrationality Measure</a></h3><p>对于给定是实数 $x$, 定义</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mu(x) \doteq \inf_{u \in R} u \\
R = \{ u\mid \exists \text{ infty } (p,q)\; s.t.\quad 0< |x -\frac{p}{q}| < \frac{1}{q^u} \}
\end{aligned}</script><p>显然考虑连分数，我们知道 当 $x$ 是有理数时，$u(x) = 1$，无理数时，$\mu(x) \geq 2$。</p>
<p>Roth 证明，当 $x$ 是代数数时 $\mu(x) = 2$，因此获得 Field 奖。</p>
<p>$\mu(L) = \infty$，其中 $L = \sum_{n=1} ^{\infty} 10^{-n!}$ 为刘维尔（Joseph Liouville）数</p>
<p>我们下面证明：当 $u&gt;2$ 时，$A = \{ x \mid 0&lt; |x -\frac{p}{q}| &lt; \frac{1}{q^u}\}$，则 $A$ 的外（lebesgue）测度 $m^{\star}(A) = 0$，从而（lebesgue）测度 $m(A)=0$</p>
<p>由于 当$1\leq p \leq q$时， $(\frac{p}{q}-\frac{1}{q^u},\frac{p}{q} + \frac{1}{q^u})$ 只有可数个，记作$I_1, I_2,\cdots I_n,\cdots$ ，按照定义，$A \cap (0,1) \subseteq \overline\lim I_n$, 另一方面 $\sum_{i=1}^{\infty} I_n = \sum_{q=1}^{\infty} \frac{q+1}{q^u} &lt; +\infty$，从而 $m^{\star}(A \cup (0,1)) = 0$，同理可证了$m^{\star}(A \cup (n,n+1))=0, n \in \mathbb{Z}$，从而 </p>
<script type="math/tex; mode=display">
0 \leq m^{\star}(A) \leq \sum_{n \in \mathbb{Z}} m^{\star}(A \cup (n,n+1)) =0</script><p>从而$m^{\star}(A) = m(A) = 0$。其中 $m^{\star}(I) = \inf \{u|u=\sum_{k=1}^{\infty} |I_k|,\; \cup_{k=1}^ {\infty} I_k \supset m ,I_k \text{ 是开矩形 } \}$</p>
<h2 id="sagemath-数值测试-Jupyter-Notebook-上运行"><a href="#sagemath-数值测试-Jupyter-Notebook-上运行" class="headerlink" title="sagemath 数值测试(Jupyter Notebook 上运行)"></a>sagemath 数值测试(Jupyter Notebook 上运行)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = continued_fraction(<span class="number">1</span>/pi).convergents()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">32</span>):</span><br><span class="line">    n = x[i].denominator()</span><br><span class="line">    print(N(abs(sin(n))-pi/n),<span class="string">"\t= "</span>,abs(sin(n))-pi/n ) <span class="comment"># 后来精度就崩了</span></span><br><span class="line">    </span><br><span class="line">x = continued_fraction(<span class="number">1</span>/pi).convergents()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">32</span>):</span><br><span class="line">    n = x[i].denominator()</span><br><span class="line">    print(i,N(abs(sin(n))*n),<span class="string">"\t= "</span>,abs(sin(n))*n) <span class="comment"># 后来精度就崩了</span></span><br></pre></td></tr></table></figure>
<h3 id="1-sum-s-in-S-frac-1-s-2-1-其中-S-a-m-a-gt-1-m-gt-1-a-m-in-mathbb-N"><a href="#1-sum-s-in-S-frac-1-s-2-1-其中-S-a-m-a-gt-1-m-gt-1-a-m-in-mathbb-N" class="headerlink" title="$1 = \sum_{s \in S} \frac{1}{s^2-1}$, 其中 $S = \{a^m | a &gt; 1, m&gt;1, a,m \in \mathbb{N} \}$"></a>$1 = \sum_{s \in S} \frac{1}{s^2-1}$, 其中 $S = \{a^m | a &gt; 1, m&gt;1, a,m \in \mathbb{N} \}$</h3><blockquote>
<p>方法：<a href="https://link.zhihu.com/?target=https%3A//www.maa.org/sites/default/files/pdf/upload_library/22/Ford/bibiloni206.pdf">On a Series of Goldbach and Euler</a></p>
</blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
\lim S(n) &= \sum_{a \in A} \sum_{m\geq 2} \frac{1}{a^m -1} \\ 
&=  \sum_{a \in A} \sum_{m\geq 2} \frac{1}{a^m} + \sum_{a \in A} \sum_{m\geq 2} \frac{1}{a^m(a^m -1)} \\ 
& =  \sum_{a \in A} \frac{1}{a(a-1)} +   \sum_{b \in B} \frac{1}{b(b -1)} \\ 
& = \sum_{i=2}^n \frac{1}{n(n-1)} = 1
\end{aligned}</script><p>其中 $B = \{n \in \mathbb{N} \mid n = k^m , k&gt;1 \}$，$A= \{n \in \mathbb{N} \mid n &gt;1 \} - B$</p>
<h2 id="f-n-m-sum-i-0-i-leq-n-im-C-n-im-i"><a href="#f-n-m-sum-i-0-i-leq-n-im-C-n-im-i" class="headerlink" title="$f(n,m) = \sum_{i=0}^{i \leq n-im} C_{n-im}^i$"></a>$f(n,m) = \sum_{i=0}^{i \leq n-im} C_{n-im}^i$</h2><blockquote>
<p>洛谷题目，具体题号就不便说了。</p>
</blockquote>
<p>数据范围 $1 \leq n \leq 10^{18} , m \leq 100$ 。我们注意考察 $f(n,m)$ 的意义！假设我们要上楼梯，每次只能上 1 步或者 $m+1$ 步，那么 $f(n,m)$ 就是方案数，因此，我们显然有</p>
<script type="math/tex; mode=display">
f(n,m) = f(n-1,m)+f(n-m-1,m)</script><p>当然了我们不考虑意义直接用 $f(n,m)-f(n-1,m)$ 也可以得到这个公式。</p>
<h3 id="无法过题的-O-m-log-m-log-n-代码，原因是没法找一个合适的基底"><a href="#无法过题的-O-m-log-m-log-n-代码，原因是没法找一个合适的基底" class="headerlink" title="无法过题的 $O(m \log m \log n)$ 代码，原因是没法找一个合适的基底"></a>无法过题的 $O(m \log m \log n)$ 代码，原因是没法找一个合适的基底</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> BI=__int128;</span><br><span class="line"><span class="keyword">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M =<span class="number">10004</span>;</span><br><span class="line">BI a[<span class="number">4</span>*M],r[<span class="number">4</span>*M],ans[<span class="number">2</span>*M];</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">powmod</span><span class="params">(T x,U n,T p)</span></span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;  x=x*x%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(BI *x,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;j) swap(x[i],x[j]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> l=len&gt;&gt;<span class="number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> BI FM = BI(<span class="number">29</span>)&lt;&lt;<span class="number">57</span>|<span class="number">1</span>,gg=<span class="number">3</span>;</span><br><span class="line"><span class="comment">// the mod must NFT-friendly or (len+1)*mod^2 &lt; FM</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(BI *x,<span class="keyword">int</span> len,<span class="keyword">bool</span> isInverse=<span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">	g = powmod(gg,(FM<span class="number">-1</span>)/len,FM);</span><br><span class="line">	<span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">		g=powmod(g,len<span class="number">-1</span>,FM);</span><br><span class="line">		BI invlen = powmod(BI(len),FM<span class="number">-2</span>,FM);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">			x[i]=x[i]*invlen%FM;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bitreverse(x,len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> half=<span class="number">1</span>,<span class="built_in">step</span>=<span class="number">2</span>;half!=len;half&lt;&lt;=<span class="number">1</span>,<span class="built_in">step</span>&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		BI wn = powmod(g,len/<span class="built_in">step</span>,FM);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="built_in">step</span>)&#123;</span><br><span class="line">			<span class="function">BI <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;i+half;++j)&#123;</span><br><span class="line">				BI t=(w*x[j+half])%FM;</span><br><span class="line">				x[j+half]=(FM-t+x[j])%FM;</span><br><span class="line">				x[j]=(x[j]+t)%FM;</span><br><span class="line">				w = w*wn%FM;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stand</span><span class="params">(BI *a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*n;i&gt;n;--i)&#123;</span><br><span class="line">		a[i<span class="number">-1</span>]=(a[i<span class="number">-1</span>]+a[i])%mod;</span><br><span class="line">		a[i-n<span class="number">-1</span>]=(a[i-n<span class="number">-1</span>]+a[i])%mod;</span><br><span class="line">		a[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">square</span><span class="params">(BI *a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(<span class="number">2</span>*n+<span class="number">1</span>));</span><br><span class="line">	nft(a,len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">		a[i]=a[i]*a[i]%FM;</span><br><span class="line">	&#125;</span><br><span class="line">	nft(a,len,<span class="number">1</span>);</span><br><span class="line">	stand(a,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(BI *a,BI *b,<span class="keyword">int</span> na,<span class="keyword">int</span> nb)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz((na+nb)+<span class="number">1</span>));</span><br><span class="line">	nft(a,len);nft(b,len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">		a[i] = a[i]*b[i]%FM;</span><br><span class="line">	&#125;</span><br><span class="line">	nft(b,len,<span class="number">1</span>);nft(a,len,<span class="number">1</span>);</span><br><span class="line">	stand(a,na);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initC</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		ans[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=<span class="number">2</span>*m;++i)&#123;</span><br><span class="line">		ans[i] = (ans[i<span class="number">-1</span>]+ans[i-m<span class="number">-1</span>])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">	<span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="keyword">sizeof</span>(r));</span><br><span class="line">	r[<span class="number">0</span>]=a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(LL n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	initC(m);</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) mul(r,a,m,m);</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>; square(a,m);</span><br><span class="line">	&#125;</span><br><span class="line">	LL ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		ret+=(r[i]*ans[i+m])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="comment">//freopen("m","w",stdout);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	LL n;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;powmod(<span class="number">2L</span>L,n,mod)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(n&lt;=m)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;getans(n-m,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求-m-阶线性递推关系式第-n-项"><a href="#求-m-阶线性递推关系式第-n-项" class="headerlink" title="求 $m$ 阶线性递推关系式第 $n$ 项"></a>求 $m$ 阶线性递推关系式第 $n$ 项</h2><blockquote>
<p>参考：<a href="https://wenku.baidu.com/view/bac23be1c8d376eeafaa3111.html" target="_blank" rel="noopener">2013/03/02 线性递推关系和矩阵乘法</a></p>
<p><strong>上面文献的意义</strong>：矩阵加速已经成为过去式了，多项式加速时代的到来，NFT 加速多项式的时代到来。</p>
</blockquote>
<p>设 $a_n = c_{m-1} a_{n-1} + c_{m-2} a_{n-2} + c_0 a_{n-m}$，给定了初值 $a_1,a_2,\cdots,a_m$ 的情况下，求 $a_n$</p>
<p>我们记</p>
<script type="math/tex; mode=display">
A = \begin{pmatrix}
c_1 & c_2 &\cdots& c_m \\
1 & 0&  & 0 \\
& &\vdots&  \\
0 & \cdots &1 & 0
\end{pmatrix}</script><p>并且显然</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
a_n \\
a_{n-1} \\
\vdots \\
a_{n-m+1}
\end{pmatrix} = 
A
\begin{pmatrix}
a_{n-1} \\
a_{n-2} \\
\vdots \\
a_{n-m}
\end{pmatrix}  = 
A^{n-m}
\begin{pmatrix}
a_{m} \\
a_{m-1} \\
\vdots \\
a_{1}
\end{pmatrix}</script><p>我们就可以用矩阵乘法在 $O(m^3 \log n)$ 解决这个问题了。</p>
<p><strong>但线性递推关系式可以不用矩阵优化到</strong> $O(m^2 \log n)$ ：</p>
<p>显然 $A$ 的特征多项式 $f(x) = x^m - c_1 x^{m-1}- \cdots -c_m$，所以 $A^n = c_{m-1} A^{n-1} + \cdots c_0 I$，也就是说 $A^n$ 可以由 $A^{m-1},A^{m-2},\cdots,I$ 线性表出，而 $A^{n_1+n_2} = A^{n1} A^{n_2}$ 然后运算就是卷积运算，相当于多项式乘法！也就是说我们可以在 $O(m^2 \log n)$ 时间复杂度，求出 $A^n = b_0 I + b_1 A + \cdots b_{m-1} A^{m-1}$, 注意到</p>
<script type="math/tex; mode=display">
A^i \begin{pmatrix}
a_{m} \\
a_{m-1} \\
\vdots \\
a_{1}
\end{pmatrix} =
\begin{pmatrix}
a_{i+m} \\
a_{i+m-1} \\
\vdots \\
a_{i+1}
\end{pmatrix}</script><p>所以我们只需预处理出 $a_1,\cdots,a_{2m-1}$ 这 $2m-1$ 个数即可。<a href="/templateOfCpp/" title="代码见我博客的模板">代码见我博客的模板</a></p>
<blockquote>
<p>这也提供了一般 $m$ 阶矩阵的 $n$ 次方的一个 $O(m^3+m^2\log n)$ 的算法！！！卧槽！我也太帅了吧。</p>
</blockquote>
<p><del>最后如果递推关系中仅有常数个 $c_i$ 不为 0，此时还能用 NFT（数论快速变换）</del> 利用 <a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">多项式带模除法: Division with remainder</a> 的 $O(m \log m)$ 算法，上述算法可以优化到 $O(m\log m \log n + m^2)$，（暂时不知道如何去掉 $m^2$）但是写法太复杂。搞定！参考 <a href="https://oi-wiki.org/math/linear-recurrence/" target="_blank" rel="noopener">这里</a>，不要涉及矩阵</p>
<p>注意到一次乘法之后，会变成 $I,A,\cdots A^{2m-1}$ 的线性组合，$A^{m},\cdots A^{2m-1}$ 这 $m$ 个要再用前 $m$ 线性表出，由于 $c_i$ 仅有常数个不为 0，可以 $O(m)$ 复杂度把他们写成前 $m$ 个的线性组合。</p>
<blockquote>
<p>当 $m&gt;10^4$ 时，我们就有必要写带 NFT 的版本了（NFT 模板可以在我博客中找到）有需求的时候再写吧。</p>
</blockquote>
<h2 id="sum-i-equiv-r-mod-m-binom-n-i-mod-M"><a href="#sum-i-equiv-r-mod-m-binom-n-i-mod-M" class="headerlink" title="$\sum_{i \equiv r \mod m} \binom{n}{i} \mod M$"></a>$\sum_{i \equiv r \mod m} \binom{n}{i} \mod M$</h2><p>数据范围：$1 \leq n \leq 10^{18},\; 2 \leq m \leq 2000,\; 0 \leq r &lt; m,\; 10^8 &lt; M &lt; 10^9$</p>
<p>记 $w$ 满足 $w^m = 1,w^n \neq 1, 0 &lt; n &lt; m$，则答案为 $\frac{1}{m}\sum_{i=0}^{m-1}F(w^i)$，其中 $F(x) = x^{m-r}(1+x)^n \mod x^{m}-1$</p>
<p>假设 $F(x) = \sum_{i=0}^{m-1} a_i x^i$，则答案就是 $a_0$，即答案是 $F(0)$</p>
<p>这个跟上面一样本质是一样的，做带模的多项式运算。</p>
<blockquote>
<p>参考：<a href="https://codeforces.ml/blog/zscoder" target="_blank" rel="noopener">zscoder 的博客</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poly</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">2003</span>;</span><br><span class="line">	<span class="keyword">int</span> d;</span><br><span class="line">	LL a[N];</span><br><span class="line">	Poly(<span class="keyword">int</span> _d):d(_d)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123;</span><br><span class="line">		<span class="keyword">return</span> a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	Poly <span class="keyword">operator</span>*(Poly &amp;A)&#123;</span><br><span class="line">		<span class="function">Poly <span class="title">R</span><span class="params">(d+A.d)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=A.d;++j)&#123;</span><br><span class="line">				R[i+j] += a[i]*A[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> R;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Poly <span class="title">mulmod</span><span class="params">(Poly &amp;A,Poly &amp;B,<span class="keyword">int</span> m,LL mod)</span></span>&#123;</span><br><span class="line">	Poly R = A*B;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=R.d;i&gt;=m;--i)&#123;</span><br><span class="line">		R[i-m] += R[i];</span><br><span class="line">		R[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	R.d = m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		R[i]%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">powmod</span><span class="params">(T x,U n,<span class="keyword">int</span> m,LL mod)</span></span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">r</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	r[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=mulmod(r,x,m,mod);</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;  x=mulmod(x,x,m,mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	LL n,r,mod;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;mod)&#123;</span><br><span class="line">		<span class="function">Poly <span class="title">A</span><span class="params">(m<span class="number">-1</span>)</span></span>;</span><br><span class="line">		A[<span class="number">0</span>]=A[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		Poly R = powmod(A,n,m,mod);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(R[r%m]*m%mod)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合数倒数交错和-sum-i-0-n-frac-1-i"><a href="#组合数倒数交错和-sum-i-0-n-frac-1-i" class="headerlink" title="组合数倒数交错和 $\sum_{i=0}^n \frac{(-1)^i}$"></a>组合数倒数交错和 $\sum_{i=0}^n \frac{(-1)^i}{{n \choose i}}$</h2><p>考虑积分 $F(n,m) = \int _0^1 x^m (1-x)^{n-m} dx$，显然 $F(n,m)=F(n,n-m),F(n,0) = \frac{1}{n+1}$<br>且分部积分即可知道 $F(n,m) = \frac{m}{n-m+1} F(n,m-1) = \frac{1}{(n+1){n \choose m}}$，再等比数列求和就有</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n \frac{(-1)^i}{{n \choose i}} = (n+1) \int _0 ^1 \sum _{i=0} ^n (-x)^ i (1-x)^ {n-i} dx = (n+1) \int _0 ^1 (1-x)^{n+1}-(-x)^{n+1}dx = \frac{n+1}{n+2} (1+(-1)^n)</script><h2 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h2>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>点灯问题之高斯消元法</title>
    <url>/gaussianElimination/</url>
    <content><![CDATA[<p>在知乎的 <a href="https://zhuanlan.zhihu.com/skymath" target="_blank" rel="noopener">数学&amp;算法</a> 专栏里看到 <a href="https://zhuanlan.zhihu.com/p/53646257" target="_blank" rel="noopener">点灯游戏的 $O(n^3)$ 算法</a>，觉得挺有意思，特此记录，并且补充代码</p>
<a id="more"></a>
<h2 id="点灯游戏简介"><a href="#点灯游戏简介" class="headerlink" title="点灯游戏简介"></a>点灯游戏简介</h2><p>一层大楼共有 $n \times n$ 个房间，每个房间都有一盏灯和一个按钮。按动一个房间的按钮后，这个房间和周围四个相邻的房间的灯的状态全部都会改变（由暗变为亮或者亮变为暗）。目标是通过按按钮把所有的灯都点亮（默认情况下全暗）。求点灯方案。</p>
<ol>
<li>全局枚举，复杂度 $O(2^{n^2})$</li>
<li>首行枚举，复杂度 $O(2^n)$ ，由于第一行的方案就决定了下一行的方案</li>
<li>线性方程组求解，复杂度 $O(n^6)$</li>
<li>上述线性方程组求解可以转化成 $n$ 个变量的线性方程组，复杂度 $O(n^3)$</li>
</ol>
<p>以上内容取自 <a href="https://zhuanlan.zhihu.com/p/53646257" target="_blank" rel="noopener">点灯游戏的 $O(n^3)$ 算法</a> </p>
<blockquote>
<p>最终方案做法概括：$n^2$ 个方程 $n^2$ 个未知数的线性方程组，由于用第$i$行的方程可以将第 $i+1$ 行的未知数表示成前 $i$ 行的线性组合，从而是第一行的现行组合，这样到最后一行。最后一行的方程还未使用，从而变成了 $n$ 个方程 $n$ 个未知数的线性方程组。</p>
</blockquote>
<p>由于方案可能不唯一，所以用 Python 自带的 numpy 以及 scipy 都不计算奇异矩阵。所以就自己写了高斯消元法来求解。</p>
<blockquote>
<p>注意 numpy 数据越界的问题！</p>
</blockquote>
<h2 id="高斯消元法普通版本"><a href="#高斯消元法普通版本" class="headerlink" title="高斯消元法普通版本"></a>高斯消元法普通版本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># numpy 是用C写的，所以本质是强类型的，需要注意</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tri</span><span class="params">(A, b, eps = <span class="number">1e-6</span>)</span>:</span></span><br><span class="line"><span class="comment"># 使A上三角，并返回A的秩 和 列变换px</span></span><br><span class="line">	n = len(A)</span><br><span class="line">	px = list(range(n))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">		j,k = i,i</span><br><span class="line">		<span class="keyword">while</span>(k&lt;n):</span><br><span class="line">			j=i</span><br><span class="line">			<span class="keyword">while</span>(j&lt;n <span class="keyword">and</span> np.fabs(A[j,k])&lt;eps): j+=<span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span>(j != n): <span class="keyword">break</span></span><br><span class="line">			k+=<span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span>(k == n): <span class="keyword">return</span> i,px</span><br><span class="line">		<span class="keyword">if</span>(i!=k):</span><br><span class="line">			px[i],px[k] = px[k],px[i]</span><br><span class="line">			A[:,[i,k]] = A[:,[k,i]]</span><br><span class="line">		<span class="keyword">if</span>(j != i):</span><br><span class="line">			b[[i,j]] = b[[j,i]]</span><br><span class="line">			A[[i,j]] = A[[j,i]]</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">			ratio = A[j,i]/A[i,i]</span><br><span class="line">			b[j] -= b[i]*ratio</span><br><span class="line">			A[j,i:n] -= A[i,i:n]*ratio</span><br><span class="line">	<span class="keyword">return</span> n,px</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trisolve</span><span class="params">(A, b)</span>:</span></span><br><span class="line">	ans = b.copy()</span><br><span class="line">	n = len(A)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">		ans[i] = ans[i]/A[i,i]</span><br><span class="line">		ans[:i] -= A[:i,i]*ans[i]</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(AA, bb, eps = <span class="number">1e-6</span>)</span>:</span></span><br><span class="line"><span class="comment"># 求解 Ax = b ，其中A是矩阵，b是列向量</span></span><br><span class="line"><span class="comment"># 答案是 ans[:,0] + k[1] ans[:,1] + ... + k[n-r] ans[n-r]</span></span><br><span class="line">	<span class="comment">#一定要类型转化，不然会很惨！</span></span><br><span class="line">	A = AA.copy()</span><br><span class="line">	b = bb.copy()</span><br><span class="line">	A = A.astype(np.float) </span><br><span class="line">	b = b.astype(np.float)</span><br><span class="line">	n = len(A)</span><br><span class="line">	r,px = tri(A,b,eps)</span><br><span class="line">	py = list(range(n))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n): py[px[i]] = i</span><br><span class="line">	<span class="keyword">if</span>(r == n): <span class="keyword">return</span> trisolve(A,b)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(r,n):</span><br><span class="line">		<span class="keyword">if</span>(np.fabs(b[i,<span class="number">0</span>])&gt;eps): <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">	ans = np.matrix(np.zeros([n,n-r+<span class="number">1</span>]))</span><br><span class="line">	ans[:r,<span class="number">0</span>] = trisolve(A[:r,:r],b[:r])</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(r,n):</span><br><span class="line">		ans[:r,i-r+<span class="number">1</span>] = trisolve(A[:r][:r],-A[:r,i])</span><br><span class="line">		ans[i,i-r+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> ans[py]</span><br><span class="line"></span><br><span class="line">A = np.matrix(<span class="string">'1,2;3,4'</span>)</span><br><span class="line">b = np.matrix(<span class="string">'2;4'</span>)</span><br><span class="line">ans = solve(A,b)</span><br><span class="line">print(ans)</span><br><span class="line">print((b-A*ans[:,<span class="number">0</span>]))</span><br><span class="line">print(A*ans[:,<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<h2 id="高斯消元法模素数版本之点灯问题-O-n-3-求解"><a href="#高斯消元法模素数版本之点灯问题-O-n-3-求解" class="headerlink" title="高斯消元法模素数版本之点灯问题 $O(n^3)$ 求解"></a>高斯消元法模素数版本之点灯问题 $O(n^3)$ 求解</h2><p>解的个数取 $\log_2$ 就是 <a href="http://oeis.org/search?q=A159257&amp;sort=&amp;language=&amp;go=Search" target="_blank" rel="noopener">A159257</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># numpy 是用C写的，所以本质是强类型的，需要注意</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv</span><span class="params">(a,p)</span>:</span> <span class="comment"># 0&lt;a&lt;p and gcd(a,p)=1</span></span><br><span class="line">	<span class="keyword">if</span>(a == <span class="number">1</span>): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> (p-p//a)*inv(p%a,p)%p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trip</span><span class="params">(A, b, p = <span class="number">2</span>)</span>:</span> <span class="comment"># 0 &lt;= A[i,j] &lt; p</span></span><br><span class="line"><span class="comment"># 使A上三角，并返回A的秩 和 列变换px</span></span><br><span class="line">	n = len(A)</span><br><span class="line">	px = list(range(n))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">		j,k = i,i</span><br><span class="line">		<span class="keyword">while</span>(k&lt;n):</span><br><span class="line">			j=i</span><br><span class="line">			<span class="keyword">while</span>(j&lt;n <span class="keyword">and</span> A[j,k]==<span class="number">0</span>): j+=<span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span>(j != n): <span class="keyword">break</span></span><br><span class="line">			k+=<span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span>(k == n): <span class="keyword">return</span> i,px</span><br><span class="line">		<span class="keyword">if</span>(i!=k):</span><br><span class="line">			px[i],px[k] = px[k],px[i]</span><br><span class="line">			A[:,[i,k]] = A[:,[k,i]]</span><br><span class="line">		<span class="keyword">if</span>(j!=i):</span><br><span class="line">			b[[i,j]] = b[[j,i]]</span><br><span class="line">			A[[i,j]] = A[[j,i]]</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">			ratio = A[j,i]*inv(A[i,i],p)%p</span><br><span class="line">			b[j] = (b[j]-b[i]*ratio)%p</span><br><span class="line">			A[j,i:n] = (A[j,i:n]-A[i,i:n]*ratio)%p</span><br><span class="line">	<span class="keyword">return</span> n,px</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trisolvep</span><span class="params">(A, b, p=<span class="number">2</span>)</span>:</span> <span class="comment"># 0 &lt;= A[i,j] &lt; p and 0&lt;A[i,i]&lt;p</span></span><br><span class="line">	ans = b.copy()</span><br><span class="line">	n = len(A)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">		ans[i] = ans[i]*inv(A[i,i],p)%p</span><br><span class="line">		ans[:i] = (ans[:i] - A[:i,i]*ans[i])%p</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solvep</span><span class="params">(A, b, p=<span class="number">2</span>)</span>:</span></span><br><span class="line"><span class="comment"># 求解 Ax = b ，其中A是矩阵，b是列向量</span></span><br><span class="line"><span class="comment"># 答案是 a[0] + k[1] a[1] + ... + k[n-r] a[n-r]</span></span><br><span class="line">	n = len(A)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">			A[i,j]%=p</span><br><span class="line">		b[i]%=p</span><br><span class="line">	r,px = trip(A,b,p)</span><br><span class="line">	py = list(range(n))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n): py[px[i]] = i</span><br><span class="line">	<span class="keyword">if</span>(r == n): <span class="keyword">return</span> trisolvep(A,b,p)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(r,n):</span><br><span class="line">		<span class="keyword">if</span>(b[i,<span class="number">0</span>] != <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">	ans = np.matrix(np.zeros([n,n-r+<span class="number">1</span>], dtype=np.int))</span><br><span class="line">	ans[:r,<span class="number">0</span>] = trisolvep(A[:r,:r],b[:r])</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(r,n):</span><br><span class="line">		ans[:r,i-r+<span class="number">1</span>] = trisolvep(A[:r,:r],(-A[:r,i])%p)</span><br><span class="line">		ans[i,i-r+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> ans[py]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lighton</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="comment"># x 是行向量</span></span><br><span class="line">	n = x.size</span><br><span class="line">	ans = np.matrix(np.ones([n,n]),dtype = np.int)</span><br><span class="line">	ans[<span class="number">0</span>,:] = x</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">			<span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span>): ans[i,j] ^= ans[i<span class="number">-2</span>,j]</span><br><span class="line">			ans[i,j] ^= ans[i<span class="number">-1</span>,j]</span><br><span class="line">			<span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>): ans[i,j] ^= ans[i<span class="number">-1</span>,j<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">if</span>(j+<span class="number">1</span>&lt;n): ans[i,j] ^= ans[i<span class="number">-1</span>,j+<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">light</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="comment"># n 是整数</span></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>): <span class="keyword">return</span> [np.matrix(<span class="string">'1'</span>)]</span><br><span class="line">	x = np.matrix(np.zeros([n,n+<span class="number">1</span>]),dtype = np.int)</span><br><span class="line">	y = np.matrix(np.zeros([n,n+<span class="number">1</span>]),dtype = np.int)</span><br><span class="line">	<span class="comment"># 先处理好第一二行</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">		x[i,i] = <span class="number">1</span></span><br><span class="line">		y[i,<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">		y[i,:] -= x[i,:]</span><br><span class="line">		<span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>): y[i,:] -= x[i<span class="number">-1</span>,:]</span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&lt;n):  y[i,:] -= x[i+<span class="number">1</span>,:]</span><br><span class="line">	<span class="comment"># 第i行由它的前两行决定</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">		last = np.matrix(np.zeros([n,n+<span class="number">1</span>]),dtype = np.int)</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(n): last[i,<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">			last[i,:] -= x[i,:]</span><br><span class="line">			last[i,:] -= y[i,:]</span><br><span class="line">			<span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>): last[i,:] -= y[i<span class="number">-1</span>,:]</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;n):  last[i,:] -= y[i+<span class="number">1</span>,:]</span><br><span class="line">		x = y</span><br><span class="line">		y = last</span><br><span class="line">	<span class="comment"># 此时 x为倒数第二行，y为倒数第一行，根据最后一行灯的情况列方程</span></span><br><span class="line">	A = np.matrix(np.zeros([n,<span class="number">2</span>*n]),dtype = np.int)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">		A[i,i] = A[i,i+n]=<span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>): A[i,i<span class="number">-1</span>+n] = <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&lt;n):  A[i,i+<span class="number">1</span>+n] = <span class="number">1</span></span><br><span class="line">	A = A*np.vstack((x,y))</span><br><span class="line">	b = np.matrix(np.ones([n,<span class="number">1</span>]),dtype = np.int)</span><br><span class="line">	ans = np.matrix(np.zeros([n,n]),dtype = np.int)</span><br><span class="line">	x = solvep(A[:,:n],b - A[:,<span class="number">-1</span>]).T</span><br><span class="line">	<span class="comment"># x 是方程的解，也就是首行的点灯情况</span></span><br><span class="line">	cnt = <span class="number">2</span>**(len(x)<span class="number">-1</span>)</span><br><span class="line">	ans = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(cnt):</span><br><span class="line">		<span class="comment"># 这里一定要用copy而不能直接等于</span></span><br><span class="line">		x0 = np.copy(x[<span class="number">0</span>,:]) </span><br><span class="line">		index = <span class="number">0</span></span><br><span class="line">		<span class="keyword">while</span>(i):</span><br><span class="line">			index+=<span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span>(i&amp;<span class="number">1</span>): x0+=x[index,:]</span><br><span class="line">			i&gt;&gt;=<span class="number">1</span></span><br><span class="line">		ans.append(lighton(x0&amp;<span class="number">1</span>))</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):  <span class="comment"># n = 19 时方案数 2^16 = 65536，所以会比较慢</span></span><br><span class="line">	n = int(input(<span class="string">'输入n：'</span>)) </span><br><span class="line">	m = light(n)</span><br><span class="line">	print(<span class="string">'方案数：'</span>+str(len(m)))</span><br><span class="line">	print(m)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没学 Python 之前这个操作我肯定是用 Matlab 做了。</p>
<p>不用 C 是因为操作矩阵的话用 C 还要写矩阵乘法。矩阵加法等操作，代码量大大提升。</p>
<p>不过没想到 Python 代码量也这么大，主要还是问题复杂或者说优化代码不可避免带来代码量的提高</p>
<p>高斯消元法对于行不满秩的情况也太繁琐了吧！怪不得它们都不实现。。。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 将图片换成字符</title>
    <url>/imageToChar/</url>
    <content><![CDATA[<p>我知乎上看到 <a href="https://zhuanlan.zhihu.com/p/126669800" target="_blank" rel="noopener">怎么用 Python 把图片转化为字符？</a> 挺有趣的，自己也尝试了一下，当然他也是参考 <a href="https://github.com/RameshAditya/asciify/blob/master/asciify.py" target="_blank" rel="noopener">这里</a>。</p>
<p>原理就是：将图片（位图）转化成灰度图，即 0~255 的数值，然后将这些数值换成特殊符号（自定义）</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># imageToChar.py 使用说明：</span></span><br><span class="line"><span class="comment"># 把图片(例如xx.png)和这个文件放在同一文件夹中</span></span><br><span class="line"><span class="comment"># 命令行进入上面的文件夹路径输入</span></span><br><span class="line"><span class="comment"># py imageTochar.py xx.png (自选宽度：78，可不填)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">chars = [<span class="string">'z'</span>, <span class="string">'l'</span>, <span class="string">'y'</span>, <span class="string">'#'</span>, <span class="string">'?'</span>, <span class="string">'*'</span>, <span class="string">'+'</span>, <span class="string">';'</span>, <span class="string">':'</span>, <span class="string">','</span>, <span class="string">'.'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(image, newW)</span>:</span></span><br><span class="line">	(w, h) = image.size</span><br><span class="line">	<span class="comment"># 0.58 大致是单个字符在DOS界面的宽高比</span></span><br><span class="line">	newDim = (newW, int(<span class="number">0.58</span>*h*newW/w))</span><br><span class="line">	newImg = image.resize(newDim)</span><br><span class="line">	<span class="keyword">return</span> newImg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">garytochar</span><span class="params">(grayImg,newW)</span>:</span></span><br><span class="line">	newPix = [];step=<span class="number">256</span>//len(chars) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i,data <span class="keyword">in</span> enumerate(grayImg.getdata()):</span><br><span class="line">		<span class="keyword">if</span>(i%newW == <span class="number">0</span>): newPix.append(<span class="string">'\n'</span>)</span><br><span class="line">		newPix.append(chars[data//step])  <span class="comment">#也可以用 data%len(chars)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">''</span>.join(newPix)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imagetochar</span><span class="params">(imgPath, newW = <span class="number">78</span>)</span>:</span></span><br><span class="line">	img = Image.open(imgPath)</span><br><span class="line">	newImg = resize(img,newW)</span><br><span class="line">	grayImg = newImg.convert(<span class="string">'L'</span>)</span><br><span class="line">	<span class="keyword">return</span> garytochar(grayImg,newW)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="keyword">import</span> sys</span><br><span class="line">	imgPath, newW, *tmp = sys.argv[<span class="number">1</span>:<span class="number">3</span>]+ [<span class="number">78</span>]</span><br><span class="line">	charPix = imagetochar(imgPath,int(newW))</span><br><span class="line">	print(charPix)</span><br></pre></td></tr></table></figure>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">原始图片</th>
<th style="text-align:center">字符图片</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src= "/img/loading.gif" data-lazy-src="dna049.png" alt="dna049"></td>
<td style="text-align:center"><img src= "/img/loading.gif" data-lazy-src="dna049char.png" alt="dna049"></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>第$n$个素数</title>
    <url>/nthPrimeNumber/</url>
    <content><![CDATA[<p>很早之前写过 <a href="/computationOfPiX/" title="$\pi(x)$ 的计算">$\pi(x)$ 的计算</a> ，在知乎上用它回答问题的时候，发现我怎么没有写 <strong>求第 $n$ 个素数。</strong></p>
<blockquote>
<p>做法依赖于 $\pi(x)$ 的计算，$\pi(x)$ 表示不超过 $x$ 的素数个数</p>
</blockquote>
<a id="more"></a>
<h2 id="素数定理-这里就不证了"><a href="#素数定理-这里就不证了" class="headerlink" title="素数定理( 这里就不证了)"></a>素数定理( 这里就不证了)</h2><script type="math/tex; mode=display">
\lim _{x \to \infty} \frac{\pi(x)}{x/\ln x} = 1</script><p>从而我们知道：</p>
<script type="math/tex; mode=display">
\lim _{x \to \infty} \frac{p_n}{n \ln n} = 1</script><p>其中，$p_n$ 为第 $n$ 个素数，显然 $p_n$ 是 $\pi(x) = n$ 最小的解。</p>
<h2 id="p-n-求解"><a href="#p-n-求解" class="headerlink" title="$p_n$ 求解"></a>$p_n$ 求解</h2><ul>
<li>预处理小于 $N$ 的素数</li>
<li>初始值 $n\ln n$</li>
<li>牛顿梯度法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e8</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;p[<span class="number">1</span>]=<span class="number">2</span>;isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)   isp[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])  p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>,t=(N<span class="number">-1</span>)/i + <span class="number">1</span>;j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j)&#123;</span><br><span class="line">            isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">8</span>; <span class="comment">// 不能再大了不然内存顶不住了</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span>*<span class="number">3</span>*<span class="number">5</span>*<span class="number">7</span>*<span class="number">11</span>*<span class="number">13</span>*<span class="number">17</span>*<span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM+<span class="number">1</span>][M+<span class="number">1</span>],sz[M+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    initprime();</span><br><span class="line">    pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;++i)&#123;</span><br><span class="line">        pi[i]=pi[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(isp[i])    ++pi[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sz[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=PM;++i)  phi[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        sz[i]=p[i]*sz[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=PM;++j)&#123;</span><br><span class="line">            phi[j][i]=phi[j][i<span class="number">-1</span>]-phi[j/p[i]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= M)  <span class="keyword">return</span> phi[x%sz[s]][s]+(x/sz[s])*phi[sz[s]][s];</span><br><span class="line">    <span class="keyword">if</span>(x/p[s] &lt;= p[s])  <span class="keyword">return</span> primepi(x)-s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x/p[s]/p[s] &lt;= p[s] &amp;&amp; x&lt;N)&#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">        LL ans = pi[x]-(s2x+s<span class="number">-2</span>)*(s2x-s+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=s2x;++i)&#123;</span><br><span class="line">            ans+=pi[x/p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primephi(x,s<span class="number">-1</span>)-primephi(x/p[s],s<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> pi[x];</span><br><span class="line">    <span class="keyword">int</span> ps2x = primepi(<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>)));</span><br><span class="line">    <span class="keyword">int</span> ps3x = primepi(<span class="keyword">int</span>(cbrt(x+<span class="number">0.2</span>)));</span><br><span class="line">    LL ans = primephi(x,ps3x) + LL(ps2x+ps3x<span class="number">-2</span>)*(ps2x-ps3x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =ps3x+<span class="number">1</span>,ed = ps2x;i&lt;=ed;++i)&#123;</span><br><span class="line">        ans -= primepi(x/p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(LL n)</span></span>&#123;  <span class="comment">// 可以用概率判别来替换</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;N) <span class="keyword">return</span> isp[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;p[i]&lt;=n/p[i]&amp;&amp;i&lt;N;++i)&#123; </span><br><span class="line">        <span class="keyword">if</span>(p[i]&amp;&amp;n%p[i]==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primep</span><span class="params">(LL n)</span></span>&#123;    <span class="comment">// Newton 梯度法</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= pi[N<span class="number">-1</span>])  <span class="keyword">return</span> p[n];</span><br><span class="line">    LL ans= n*<span class="built_in">log</span>(n), err = <span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">10</span>);</span><br><span class="line">    LL m = primepi(ans);</span><br><span class="line">    <span class="keyword">while</span>(m&lt;n||m&gt;n+err)&#123;</span><br><span class="line">        ans += (n-m)/(<span class="built_in">log</span>(m)<span class="number">-1</span>)*<span class="built_in">log</span>(m)*<span class="built_in">log</span>(m);</span><br><span class="line">        m = primepi(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span> = m-n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">step</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!isprime(ans))    --ans;</span><br><span class="line">        --ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ++ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    LL n;   <span class="comment">// n &lt; N*N </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n=987654321098 = 9.8*10^11 用时 128s 太慢了。</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;primep(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://primes.utm.edu/nthprime/index.php#nth" target="_blank" rel="noopener">第 $n$ 个素数和 $\pi(x)$ 的网站</a></p>
<p><a href="https://github.com/kimwalisch/primecount" target="_blank" rel="noopener">世界纪录保持者的求法</a></p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>悄悄话</title>
    <url>/scrite/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">math</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="cbb27fdce9c737e991c7ea253bd3df794ec0f5e5be5b95aff59aa58f645bd866">de0af34fc90a03bd4aa89b914dc3631985adf10cfbbd2c0c17c3da3aff4ff3553c18cc8e17755c6d30455e4191fc2a2a76dadb6da84eaf419e5a63b12b3a3d805545f31bae52ee026be4299894d7fbeefdb79ed5270a2b826e2cd90a76ccc448ec6650e1eac14c5e12176b21e5ec19740762455d4d58f1f6c422a104bb445071dab75846c51e41d1ca2d31e136d534a53802afbd320dec8f332c39c2ae6890c9f8f506ef2dd7c8bef61a89c861b37001f1b8f5f8dd98ee73c6e0dc1dabf5e7abcbfdba429525544c51276f3838d75b191a1a92d1b0006c2780b09f6d1d5ae18b66339ee86811097350cd48cdfe26e4130ecc486c594f86630133d34bb861b72de1be9ed0c5f123c5982d1cb6483504fb1731c8d87aadc591fe5a1b8d5c1d8b086aea7552e0de67eb6365f8eb9de2c058006946bb1ddadb78c9a0cde2eeae3efa5a8cd6638335fec5ff5f0ec0052132f4135967aab292d7aed9caceee7592552f402e50c42977e4770a109bca3eb29d66f6c8ad1ff0d97584c465467e68c3da42e4964d2263111725ec4442bbe286cf9ffec5f233ea461a92666dd176598904425e87d59e73c61008c36f265638a5b950774834cc3659622e2b5f531f739ffe4564e5868a4ab012cde88b6cdb00ec509e5a0c1ae2e36fd74004987b88178a9cba5a8842c3b8eed789fc258c4463bfd011ad756e44734ddd3819928179a38fb4d66f1045152523d454537755b2a0db65e05c35832f37bc7e07d94c9257c6d0c36d9b6cded900f79a7193b94f954dd84b92c08ff287618d0d365fd074bed53c770583c3df0529d02e7e87b67fc98daa5bdb6871598a2ea3dfb44555bc58beab68114ad61854ee5987c42549e182b2c1777038ffbe147051281e4719d301c1c72d2063a6bc7e33d6ce1437d0ff1150dc010077b56c2ca463de1866661b65492ad57c8b76d6c890b07cbc64a82988b29b43e061dc3bf36d341e070a05d45119e7558bb2a1fa8d1a8ba9eb99fb883408ab3039d2e260ddc8f2f75d3df5588bc1b3b667ef2aed4871b35c44b9048aaeecb9a0bc6e0d30b434e96353613fe9ecdb9c5d4f99c80dd2b97e5b4c2f19dce563fb4bf2252b04a8d699028a96c34eddecd8329e64893cef73ddd20d50422fbee2aea25842fa07efbdadc8686cd66f456e015638beaf5ab5a52374c7d471ca0f0a64d7cb03d82d43f6521628016916b6c4e681623dee6bfc64d40ff64e665ba36d6e0e92cc8497cc36c4b5ca10157e9a46efe07059bfbbbcf48ea1573e20afb450155e0adbb902bc022701e3f3f4c5c6213665243b4dcdfe51abdea8264c6ca396c26cbba04e68f4fe0d33373484979db356c510118e76b677716a64e6555a871bc645624025436085787294972ddfbda7b1ad29b80a4987a6413437cbf7a8cef51d94931e8b138d244e2595f8fef683e79f887ef5fdf89098c87cd555c9c517a3f7fe939a2a0b2a5a61fe5ab351c9c7d8193f627f66b29983700c7dc53dd952405af7a1281b243e34327c0adbbc5706941cd5f0f0075dd7db02533c5835954199324d50632bd28848b8d57da2726a0e88d1dc95861e96b05a65245015e90abbe961987f06975bc1fa639047eaf9203cbc5bd8b290f73a5dbd30c8361f1e42156088029c09c490559900feb2108862f6c3d6abdbfaab2cc5d4e13bfd7164f629c505bf61a811bb10f80fbf33905017dc199be07adfbe2a8654304ebceac694e2df4367d3897397ac18d2d110f47bcc1dc767dd70fd6a2f05b29f3b38ebd1e471aaac82a105b23230fb7bb63c61f6908f19d537b1b1f8338c79200a8c14e2593f15fa306d249aaae4283d2475f52019ce2e6922ed1b76afc6d447dafc2f74e5f73783a7f3b87a71db06f324fbe0e04ab805667c59f0d4f64389f7c3ffc4ca8039d740edd8a328daa19795b3049ee3e642b313de76aee93307f76056bf3d763c4cb664a102a7e6894a30cdac775b4291e6348c44a18fd687735c128bdd986169647b41121f6f5dead76c9e2de7949759221459c19be05f0b0270cccb5cc3ac07fb0436fd48b8f9e845aee0590b5d51c4b9194af1ce22a8e5d353eebcba79d4aa02ff4860482dc3105b6457650b1048091855228fae3dd67ebaf49f5bdbdf5fae693855ee1b24aba1d2adceaa383310054cae0f7f0ed55b5979a08f8a42d0ee8d6ba935ba6e72b57c43c5b226524d59c8cfb1562ffbed97d821dbf2cf914a95fb3e144d5dbf7d2c07ab5a0c65598435dfe1ba8753a4661f2a47cc69f4c77619662230a9a62086d4a37e30d97a4e735c4dd52b85d8d4d4f4c939ab017b121b0a15e47c6a3b0aa667143668e604f3ebf055745ec4e4711b6a0b45f8529a2604747d8cca2b1e7272fe74b11c830c6b6e6a7eeacb5d447161f845274a48fabd5643f19d41f40e87b3378d27ed522511d77497e9ec88df2d836611b0f7b7517f3214ca41d922bb8abeb3c7eb2f861d04084397a75578c26ec455698c1fe384316af0be0073b4ea8506b42a70cb5a47a22ffe3c9aab400e762a62a0791fcd29ea691eb7450b5c3b908d7fe3ae29f330f8b9b4e57a7f01491a3514a9d0a321d7de9ad0ed4b85daffab897f4a8f424f9f370cb84bd730ec68041d11c3d0b6a0e42b79fc1e34802f98badfcebc35497d0bf5241c12d0b1cd14213b99c05fb80f46a6d90744c8b15c48759e2e320f95e9eb494535e3b3cfbb0a0962244f7914e848b615bacebe306c572715ea1aa909f873b362009d10696527ccdf7ed61588b464a5f4fb5f95fb92dabba9a33917822f420a3ec5b535fb9f9bc8e53ce8edab31e1ca7b286d156523b6ca2f6792bd8e148e829b6a7587571e786b33d55e64ee428c61ee3a2886b137c129a5f22944c66d4a793e00d2ac6ce7a4dd50ecca3ad226bf1e137bf201af71ba070d6762c3d87ffa08ea2ea6efb1106fd2d2804f0d76e1cea85780f426b2d178bb0f6e8dc82e527de36e8ad5254c61522e0b849e42e834b21b66eddec0c13dd3a3be90258d273edb341b0d30f3cd42007f30014bfe52a82b81c1ce529335f0fb753341c896a2eca0c270335a9019111b1c754150861ba0a83eb64aebbf736b3782799bea329f890e642ce92cc3bd6b9bacb18ce500a027bd4be107e79e9f607e62f2830cb527dbf6a3345dea6646932b27a12638c4ba136d9a39a52f74d4e65cafb6f0402b14568c69165a474139badcce791d132646e683c29272b8b7483234f6a80cbf2ef5edcd49b4eda4cf05ee70ed98e14e1996da2da6386ea5ec2a27b155f757df5396b95805bc77a51abc9d82cfc6baa986c072611b701bada828687b8ab8c8d1e1d78dffe579fa6d35ec61f66b944dc4991638646215797ce80a7696e0c0406a2e61bd9bcc60fd1635413e42ff6f1c8486595aa7dc6de5b7f634c83f07eeb85740d5fc5dd71c414d9636247352982f7163611cff14a0a244755407b0fab5c01e84df1a3da3a5bda527a58e8143342189bdf17fecb611800a66fc4c14208946bd01fa15dc903fe571523d0955c40d180872b236ddee377eeee02a9f1e1efad1c15c53a9865de3645243294f8d7e77f635b33052f574389493477a1a8862c0594325715aae393008c12efcda0ff014dc488ea988d87e66891fea0bb3f7b32b5de0c89b1a7301e652b5ca0810ae3422704a1bc1f1c1eba8c7cadba41ac1bebfa2f145b0a459d37fa452a254523efa53d5662ef8d056492db14f534934733abe69def6fba98db2467b04903032a84dabaac891369da265df9c65ac92fa2d3d3156cdd6726882c0548b7588a8f923796ef0a6396b6c16844ba2622b153bd6c0bf38a872834ec793187c5f51ec044ce4b7eba3570b42e03bb0ac6519e19404de4122a68c162d353f009a27793a05522c42abc1a3a06b733d0fc3ea334e5f29c1c114f22ed5e35c86c54d969418ff14d3aaf50936d2e2b8b5d773adf539b2473b970cd22adaaf3fe1819cc174bc4da02f7f3113d833a99c2efc36b36533deb36fef5b0581b1c67587b5146509b461e6b70c1cbee3b0c66499cd11518a87d75fb09274d66e0672df5db949fcee1f636f25576e558d48dd7df0e39071a1b51011b299e65f806471c2ffcd746bf5e45bcfe57323eb7f4a3fb4726e1ffb86d604a989205704d5e55df3993c1c3a6b7b720671037316d47e4c4c1e9a5be9ef1437859a9f43bf9233098fc14682a7a238a4ceac85610313ca469f98e75e91a27efcec9875388bdf85caaf22a3ba2635cd097a311cde368dddf9e7f6ccbb0b8b8e7d1e684ca70a9c562a1127bfe5ee5969e6af1401b8e9d790fb8a2b0023f4dc07ee4442f13d1e3a335d3303d4e49e4449899d3d4fddc39a120a6358521ff54b81ae771b57f6a2394138475e6442cf4f622b33c28d815993c2556e2f56b01565074d851d0eb168c97aaa078aa2e181fd0a0ad3da7e9e51649955c618ec8b94249bfcf34fc941f527586498500eff6db67fd261d6d1be65f15cad29fb0a4038088a2a8e3b25bea8c0db7e1c72520577885e14384dc18e62496c2f1909eef9045d958fb89e05ce808dc4b8bfd7553d758ea89cbb7034fd74d2560c117f635bed86c319772e646d69d2ce0ac007d0be18c17cb778964d3c6c48cab43b1167d79f63a322fff54eb0417295537e20185c27443f0ca271a0b3df571133c8127c20f8ed4de60e7053b0d696a4525f849ebd93eba45f28fcd3129f319254738ad3a305d5b56737352917846c0264bb7ce83fa99df4dc0af4d044a1d08750949bf6aa0de14dc334f65b0a9507caad86fb38ddb4a6e5c2f8e4edc5ba913bdd2cccaca1cb03628226a8ed32a0df29d903bee0456509fcff0578b05a14b2d29a904a2f8b9afa73fa5e8026f65292baa305bcdc333cf1f91157731cc3b2bfb83187640dedc011cd08d6f6deb58a3a3bfe0372ff73727f2555818bfdf3a914449f5b0755171bcccb74c0dde5dd2d28f06bb0c2355337b99bd7b516266362944cc734b99b2d8202ed1360882246c16b1049458858402a23a2d05ca4eaed202a5bf08434d05b7df7aeea4cf6c7b26fd0f29269df794b24ea72c182a42ea8413563bb3b2697b74461439dc902caead572907e76b1ced2226d5a610f102b51854d61463354d9a648707db58aaa8bb48d730aba407ea58fd7a65a151a002583137fcfe3e62dc6d7d471a41a1bf145fd978c03933a34b2bd9647ae069755f571d1e8ff2e077592aeff5c2d6a77bd0fc94f54e35fbbdc0aa743f2d1b31117d0a3936d3af80b5318801923fc97893640a444e9f887bb257966cfd5e83f60b28a9171f6f6cee7a21c37db9bf831924132c97512e06964a71231257366cc1e8865d7fda8312d25e78cbe3f125ecf2027f2921f57bfd9f5e0a00d34302412cdcab7f2519a5bb63c06be2114dab001c29c94a53a2aee03f8bffb5adce283f299d393b0ffbf4fd3ee965dfe7c73203f4cb98d0f7d935b53605cb6b19ef1c1182670da29c43f435d42694eb204c8fc61abafe85b9e4dee3b3907b10e9a360d911b88c226f5aa7b02ee5ad48bb35e37d0456ce3d5e5e5eab8fc68c756ee02b78cfdeadfe2564d1db573ae241a890a5ce56b48573167ed04fc30309951793c98789606304edd6157fee70331620cb6f27cddb0de0fa86d473d8ea7ace16477ab53fce8ae8cbfd7d684c43b1f88cba08203fb257c054455f02a4ff93dd32bfa214f90e5831b7d29cff918fb171bec1c206ba2f51cba2b4cb5e1ad1ec8ffc6061ef2f5e66e6a9b9f85612ae4bf2281343de9692c825075a5ccff4c02ca9b79f54887986f1a27e2aab383b05522af1e3baaa326ced54bdc6a7e135a41eea6b0528019bfba80d7b065128d8ae3419e44432335a2ee944f9a30386abdc1558f215c5cc739c61a407360e9aa855d2d1c689a2fb8163259085114a535b12461d4ec7a3ab94e7b31835f3f64888b4a709d72282b1900659308b1c2c66a4450d8d0620d8ec17edb182bd850cc0ade514f615ceb47c6d58751c2fc58fc0d7601b33fafa63891047ad9b4230d58113bf64dc4acb582b6fa46c73b7d93d464d6a12f19640ba11fc2fc5e2615c2e3186a85de24acb93c4d1b79e312918f707ffbd28222df14e0b98fceb6dce001cfa874a8554d7e3775939f18848126f0d98d7151a5cbc14c2b5e0c727cd48ff49ba779be071a93969cac4443bf97ae823ccb141bbd83388ac861c21ca73d05720890292f15fc5213c9d11267724831da58b76f6ff150016165e9f4e808bee5d923d10f787fb61f1173267b314536abc206f2f4ae1a1c042d51bad6ef53bbde81293356dca157bf35a1041f40d077fd2c630fbfa1963f02226ab991767961c72dd8fc3d97ae827d4449561740ef81c77efe5d13e2d6a44d123396d3a0a6b274472d08fe2a3c35c100a8134f01b1f2fa115f5a57bd9c7ea1a1620fb9c32e0adf6d8df11e9992a372682e0cbb4d51531ff8114c833f6471829affae837f37001a842a1f7abf1e813aff633e9639212037f4a99c34fe0f40094bc0c7f26f943d69f6b90d7a65c92420f41afef36a669bc82664c15c5e885939e84212719b819b456d6ad2eceb0329f21d715669aab1b5e4e2267dc461d12905b0fabcb1f3e99cf7b957431b56ff17568844c752589c79c5a30282fff9b8f7f8823a17ac9dca702fa6f54e3bc75e5b741012f0a2f4844dffa084280c6172d4f5c1233dd359e669dbdcbeb445197ea901c1280da883a13401d76c00afa7bafee6d8ca465f54fe37716f63472147d7e228c327a2e64973cfb59fad9f5d1c3852037b00b7b4c627555c32fc9f9a9a26d3568d65e83885c3364768fd9a378504ff3a67a379e9849177fc6fba4307a81d51efd0a0d8025aa6f1c00dc8b067674896c39c88e98d3c3b825deab55e1224fb88619f323228a33747ba27dba3701e73bd0f8fc48c5a84a37bdca82f722c1fba835dbb40a15d9314db032d7ade1e7cc4fa0f6d31ca75a034dae9adb61502f8e623829bdfe5f2351accc1940f8db6e05a892263be3d6ed6ee8dbacfbe14ce6605c187131593a840f05a84eccd5aac1fa82ab2104c0b465694cf9deef59e45aa25dd21fe8045e51873ff1a06915de59be58e962616c4f6e0973270970b2447e912038450727106c0be8db1f18d30316aad7f5635917252e0d4fad448f7d0823f4058bb3420f2cf97a01e2c57178d44ff2267653fb37c3e1f5c4c99c360deb480c6df2bc1cbff84d805fd08dbfa6f3a167d489cdb18d66b9bdf02d296740a74807b4c533fc5f727a994cf4254f0a8d64613d06d36e38f529e74294186a97004ceeb7cd2af1570a2ad246b36b1d68b00143fd4ab2d809cd00c8c21250f92dfbaaa15b8ae42f2d6d119f57c7ce7c0453b8cc7156225e4981bd19f843d3243fd31c8bca8a7360f188dca9240c93fcbd46b8127de5f090c54a2b2b566931964ccef6df41e6de2d87e48f54ce74bd4d7f4a8a3d9792aecdb0c67b98ef6d78b19b5b2ddb4b3417f899226f4c0ffb5e22db9eba918c2c982e19ea1b07d13582b41bc05a9ef93f8e659bea35e7482fc8d8ed22de49a812530485a2f489b9aaffe1ee5259fb176ae5ee663d9d8283701fc38071f4e3cac196cccf0e06e9c880a11e5bd572ca25d769e9baade1afe42f916640285549ef5618c181b84f0061850906a44ca42834bf48b62f0b4d3e03f4d9e083e2652624a3d97ecb6df7af672be61dcafef020787c3929ffe7331d22ebf8485ce2efe71951dfb4b8bdf267d68a86549e7796ffa016224fa949f737d37669847ab229feb2b2afeeaf60ee18e49b16530c06ace7efb8cd7ac4e5ff40328e9d39c6ab1e78881102b4da91b3568e873fbb5f93615b5e8e7b11e90cf52067677f8831f87602efd8e2fd3e265d067f3df111ac4b6be6f52139b61ccef8d2b17c6cb6b799ec9f044b1ac2f756881c5526fd6bd0aed3bae2a740ae37706c15ab66b87ca2b0707ab1b1f4643ffd1f087531bf8e59489236b06e8f13bee87b6835948095e919de554bf13e9ab845d6358d64a581c79053a5a8f88322cb5367d3b6dd61dd57570c8d7c0ba3b7ac4ece635979d15aac854ed5d7947fd4a14470304a33c9c9872a083cf983065f36e0466f42d242ac11e5e4889a874a592ea16c66e991835317ecfc15b159f8179bb12741c6618c2ed477205e636c3eb80730771ee7b70a98ddbef760731a203497c9825497b8a782e25ce6bc3967aac7aeada58bd469b29db36d86e70871230aebcaf1ad840f63f6a931af0b99575df7ee8711aac7121ca4405ff2f6f638f3e49d2c4b9a4a09f298a46190590442405e7e8d9804709d195d6894623cd91126d203fb18c64b52c48a8958609450cd09f5af4d15f03fdedbd4eb683b88bc237a8f2310b5f6858f6ce4b5c7d48ed308a36ebded1ec23ccd07cd5f30c99b91e16c0c46d976fd44af1df187488ea115b2cfccf96fdadbb22a0552af831fc092ab74a724d228a8cad9f7fc061aab5a1cbaec76e24fd81ee8f9b051696127a70280acc3dbed865b68c6535dcc3d4d8135b2af55cfe572f2c55da2e762a751e5ed8a547cf0863009c271e5ea6f1fbd3dc3ad584daf32b9067f8d5ff85072da1ba1eb7b7620f11ca754ab52940da7474622bf72d5a37bd39b147815dcffb70c36238a59cf35379e83476aefc9ef50c8ef1ba413ced4ac58bfa0e0e8668cf3a107d57853d4079d338254f584edca0b3324d7f6783e58bbc8d4d5f53d6bf31076c5d93207eaf70bf1ebd9ddcad75a515f110a9cbe27bb53da9ec93462ea45817d6c8be943755f4381a2de725e7bc854cbc15d4c682eac2128dae78af243955235e763186284debfc6dee7de635459e1fd68030bd4495c463ca8bfd981c80b9b697a8579a7e83546ab769acf6ceb0fa2208a774723360bcc179cf778d67ac10188ae87d76700b9a8b137bf887e0e2c13ecb7e09aeeadf622c84fa1a00967784ab9b9199355a766e2a4ab311a33600f07ca60ccc3dc68070fae4db69e5cbc7287785f7fbd4eaba89b5d2c4533c69c95d6edda52f3cdf2587efdfeebb5630586b8727d85246b87d9279103ac1ad23d2ca0b0f57e883182bbdce142a913140f1e6c61278c20d593d51ea3033b8aa8b91aba43495e0a645e6e19b88dc0b7f51830afafba361f438e321ed00aaaca97be1a6d5a814673f83e655eaa253c377b6f78149ee722446cf09ac6cb33e4b9396e6d627d8a78c46cb24ea58d867764c7a4e5fb15298a618a5ae6244f9fe7ac7cfd475191d6ca862a1a5859fa42aee14f4d85229bf0181505f17a10f7cdff2db4cde75cd1b86381e43fc659143740970cbbc3ae0871777ec1d209497fda50b47d3356fd77f71f14d4a823f2de83e99e79eced2190aeb1130c169194cb0971387a9b724fdb4a1eb8729f0b6f5beca570f42400da1ad23a102abf4ef60600df600b654104a5b3ab7cbc0f4d8824c02bf53279dafe046ff557bd688e67abb887b76e3846f98239a78331382e66413aac5c7e127943aae9f1cb71121a51ce90a56824caa0e64f5989dfaf95993b137aa5fdfc094b0eae58350709238362f98d7fdb24c2626d0dedbe00f704bcfeb6ee333e386dcbe1ca1446b73b177f2a4b5d6e0306c3ede386ea2356e25301f0cd631c556671a3119524ae9f194fc256f9f47a88a975f5208d3f6347b872c52c7ba786d2b1440aa7bd4f05c50789c74c5003e24a8ab86ff328bf144a6b880d1d107540cdf7d4df5c74ee4dc97bb827a2ee15d78ca8b68a0e688192b075b476f5eef6b38e32eaba48700305a8466176f12dc6e95a7b6d8010005d37d29d7cadd9875b2e1d9f873a3fbc846f67c0d632d3cef0304f0a3ffbfc0376df51ee39466c5abc5e9d0921dddb0b3907ca8fb86cae3535f299cae3354f283ed7f4189ed7f380a263c14e44de9844e28ced5f188753cd183862900dff817b9f8fe06e16cb789d3bd1ff18ae2f8fa5a46347770b45f9cb6f5f13d84b1a29edcf9c980189ca51ddfca319610d01a171468361dd4b41be79f1f313ab15fcb803b009037d16aed5838adad1a85de48c51c40ec8b0a0732eb94a0823e3c33078e1fdf1b292e6edbb551ba63169036a0ec5bea9658011c2f7323206737d73e9b4dcd54cb88e91e46336c2a419ddaddffd52a717a08a533b6d8f309c6a983f910ed53eb13899f446bde5489ed78554691237282ff9eed753792e7d6d413233f7214ca29dc39ffaa3b89a5db4f1bd95a7b59258a068174dbed9d8cec25444867b45faed69e529315af01a8797c912cc5fbb4d9c0c016a6ecd201aa47fb527353c290ad0af99abfc378fb8e96f16b09ab2454323eab611d7722e46248b0cb4212b9cf6ff4377340909b98d676c1e70de00aeb8d55f7432e4b43cbdef1f9d84f01428da0961fb1ccb07b56f13a4bd85b977bbea07cd35e2bba727019dbb883992b8b11a1a891e7b4a2e07613df95dd918ccc32471a0023254c821a97ce2d452e66f992b704a96456a3ce513aec7ec47c4c555a7f067dff062f2d975ae6b5ed73a746c4ed13bf249a21dd1ca115cd7026ed91317f752190178df3a8f117efcf0f760e7988c4ed6a360ae319dd67c2652e07dce81f26f6482c867839c2c946380fe065d4ddf0e2de625c8eebb0869885cb353f90fa098db8467fbb6680c69acf8866edd59a849e33e8e605d192ebac9e08b9eaa85d4f2680d296a5109242f5ee1310ba735b14c7524896373862195574626ce08136d221eaa86c960b1813f7214b7b34ed3d57957f09c22c4782bf25ce386886388f9b98bb5a95d47752fbc696654b6e1f4de114e76d3685c4a1e5cd6962e3a8734c3087c37809782306d306e9dd74d5e9f04d42e0a7a3591bd1bf4127e5bef87510d8e6d4daf2fdebba5a5c9f79cdf3693d3cf20d77a5c2112734489148af6120e19b49f63344d34df4aced1d4eb28b07e3bed136eac9b6123e54c492528243d4e47976a7ad684bbee20fd1b9adb456538c748e92d5d8a628a7619be6d27262b49ca07aff34ca7295ad41419ff1e9171cdfc91f57a7586cde8075b5626c0d4a39ba361ed0070d35a99a58e4b92a9c339dc25f52e9965e01b95bd83381c5ffdb33ec00d3efd951226f22e0b058d98ea3cad143a52db2138479f6ceb7c78b7cd5cc6a2ad80d5c1826fc4851976037ad0b31526c9d516dd54617cbe76f1b1c96b8654fbe2b8c61e3c1927e913f0df79e0c9966f2bb20272b37557589f28f06ba0f8f230e768e2680551141760ae09f7c3ce48ac97e444b3bcc66986619930fff6b7039b15bcba37b7de528fbded8cc44eac3656f46582916f5b240d071671aa0d7c633af51f5c2b16b4945f82627b07bbe2613d93a0a1e85016837bcb678669d2dddfa58327c725a31c2ac239cb9f51a7eb66af06e5192c3119807136c917506f1634ebe65f364fdb4b864359771d5ba42dace2217140fe069494b807ab3b5e1fdb17605566ffd3b39b08189fa593261101070ebba49d9c2de549742aa1f2bbeaf44eb6ccd179c0f837554e7f2eff8b3fa3e115de1d3723ba3aa5381e6ae02e3772ade84b54299c29dc662d1707174aeed3f046e0ce00ee9c453460a2ffaa9d79f071f1bff6b960d3d3109de2d3f707404b8415378b455b1d479ffb807e9bd8610c3b4b5c79d785dbd246ae230824afccfbcc312e8089d5337249bb98972505998efcc690ef59d371e1fbd51e601b953f2f8fe9535a70331dd69006de542a782e912a9450f4af7d6814c89afa57e9c67efc59cd9b3ddacd488ac1a6f87a991d12cd626ccc4be054c8c1a786211ee767ae6606eb95e85fd5141e7e7dc4c40a1624218399ee9926d8269156b79b700d337f91f04fc00f7fc3b532c0bb4a0c7a8e344c6bb494d7138de64db964baeb93a688b77c71047c82ec2eb96c8d5df96d83ba95d95dfdca0b3bd929658c2929d13f3aeecba44b8722c92cdcd2c83cfd968b33e27b1d9e967fd88df4e637819eab6880e49ac970319babaa093108175cb6b3ada68f704adbb363ab3f2df38449f0ae3d98ab96bf98b1c6026e7b0f6e8d06fe37cc8cbbe89b7142f955ca0f74a61ed73f360453ab2fc293b256bc6c9ec722e329499f56aa2ef9a733ef676f1487fab239b6306a60fd98a70c9567871b2adf3e0440dba15b15e36b8533602501aacc01e733bc478f2a4a8188d4615d6d9bd4bba406f724c3933e392073bc9ecbf456904c41acdd77baa2a088446923f6f632b82a887cd655d1e402365349f64ca07db8662b26b8c7bd83bddab14655d5e7ffee705579961bd26f2d8ae7dd0fadd5020b9d0550614f8f28c5a4644439cbb7f89fbcb312cf7c8d8ee1fc9497d74135fd5cfe1cddfebeb88acf428677cd7d20f2c79149e7b6925e4d0e453841121a0dc98764e8e837c81642a240f204dfe489367e3639b8e4c99bcaade21940eddf11b96272cc0345397088623ea32f5fc335249242ec4aa940ff699d14f127eea0c1b8fb9cbaf5fad781fd82612fe48a3eae4cda3dceafcbfadfd47f0ae25fc54c9e4b22c6fc3ac785573d4c584ac27dde1fd54ad9cf24f109d46562d5a9bbc1d5bd267a0ac5f1d530c2a3813b3cef799decc20b435a6de5890b3ce66bbc62a651221293a59e4a9e90cb08eab0321c20ab2cb8a19e9a898e686e8f18d90704192fe888ec3e39ad709f4b2ed9cf68850430427ced1657b2fcd4899c5ed9d2e7a35d5fbf8ec95f62bebab5734b29aaf11a736bfbc069ce5b63db6528f01a8f5c934380df8b5047e524060dd84145b74b3363a1c36ce44d57403c0e62281d25cb0c5eaee2f97de3f1b34182b3100c603c3e2c499d3590d6f91cbde4040faef30651c9f51387f95e83440f6f06819e1a6661fa561d300a1b028926e074eef7eea6c7c30b601c246122b451f2a652e611de95aa880aef74a304cd39c7ab01122541fd860a72108941de525d0595b50c1f94d2d9bec0caf97393d665ea9f14c0255b76144a560f9007225b4c158cbf72f79145d5d090c5431d5bdf66eff270587db834cb290e8436d4ee1cb49344fc0f6787fe95ab0ad1f4bf49daa51334cdb3169832f1b7bb17ee6a78093e8959eac466cfce84858f7edb4c91ac70d5eedd111bdd9ba28477688eb75f938b7582f82d7e554eafb7fe233b5919c475a8457002b0d2f065bcd30ed4020220ed1b5482441b00cf94dd07614a0384f4270c7dbb3441133ca2a4bfb411c72e0cd4837edefaf8bdad32d7cb66e946daf200f3a8d7e0acfd5e87874acd411454bd756e532b8f88a4212ef6e772ae83eba7be34b75fea9c537dc24523e54c9dc85018a6781d42658b874d9d6b8b67b91b836918995fc762d0dcbb87a1506582234450ea3441f4b5575135ab23a9b929deae0df0d7c1da3b30703bda69fd5eed4bdd70667111c9c9607e89da2a49dcba4fff4624da4eaf4d34c2474c14aa6373a3d8566cdf8a0f2814d8498c0697b1aeb7b12da76a17f6006bd3761210650fe1171bada3a7fd8e70a00e549636ced9282b0b4266a7e511da9848dbabd626b0a7e7097b8475c858f9f64670db181d6abed1dce43b4a360c868196a2f67512158725e056199a0a63b68f473a4d400317f11c2216eee91943cd4cb25922e4b9463de807e8e7617670dad0299cd76be20cbf19e51abf0b25eb6b3e1ebfbc4bd24db82c56e16f67703ab1fd96c6c6f9dd302a096b1ade1dc29ed478ef3df0c9ac528bcd587a082e2598b248d9528268bc7c86e3e52a17343bcaa36646e788e24b2a3f13ae44e32e6608a3b1235a618b53fc23d379826cb490d494ea593e083a31af644cb29f8373416b4737d520aeda4b0d24206c2f66780dfbe180edf93a5e9d0ddc106b567a1d083fbe121bda20a8fd2289d5283e5018de8976e4e07d274ac6def7b06e025bb359ce0bba17205747ceb92e36a22b19e2150534d48a6040220578045047c9d3f040b8a37f67af4d6277550ebd106838ea9ae62a128d153b8021cb56bc4e947c09629319f45bd828eba320c0f1586bb286bba06c6a1286343b611e15b8da75bc73dc6ebff5277050f2d7ad6ef2851563745d508c01a0cbd1a093b9213162e424fcb095fa8ff7f938843d018ec3bd65d31ded64df4d502a4ebdc4abab62443244ffbaaa3266819d09a4973d416dc5986e4b090c0672c82b264693b5a0d7d14005096fb71a1f5bd27d57de20255d582fcf2b6380f32d753abb38b77bee8fdc087a20aee4e5ab435576967c117c6aa46a9bcf5f1e7760308377a9a44d86cfd8971b14689713c40a8ccf435c5da545f49915256c1cc9fdef921bd4186d13a4b0c23749526465f48fb35b182f9537454ad87025cb6741e67c39514312f211f15d1b4e2df56725a209141199eea94f84ebcee0a0dcb527932eb0707b84a0e69fd66ba9c6f7b341bf28cc1cb94c559c787695df0c1f49ef5f40b30af5e3ce4a34ac7a73ddab0d199915abf1b7d929fc10f5eebbf0422ba0b6a87984ecc0698583b1b29873f2b058dfee560a8e4259c331d9207dd39150125293eb406e394df0d2667b9a971ed8da06f3d5155e0e914b4b79eae88c5be8c261d9e06f66964bce45afd3396df9f60ecdd043d18013a286df1fc07f04b2493055a3348cac03fc20ce89a0f4871cee1987c438c48e257d7fe510862861b9057262669de9c1a1b04ad9d5e78566073f372df892f55b68483a5bd9ea9efd92ba8c9d6d26240149f132f777b0c424d0c605567eccbccc921d8c0a023930e54a4bda5ce814cb03fa7b4efa505c54593d6ff052b15165cfdd6dbc146bd2c28da4ab6ad95868804fa226baac9bf0dbffecf5a5acc9f866f5a3b20c178fd5c3b97896836840b4bc4b3b36d4e1f53d2cdbe4185fe1b66ab499d0888286880d93b539528024a2a2b1fb93040006f5b09549ee3d37ecc955cd9ab0f7e2668e258a2c93a15d88f4e709a761fd210af782626f38e7bd27cbf08f728145025d559b6f9c8fb2491ebc69ff2919324c9899d252a030ea66a52635ec2f9482e0c425ed8edb4611eefc598d2fb09ac63c37c911e9fad4f05531f52e0772fafe8e55cb1108fbc1fab75a6c042f82c25b7b92e3c264d44bf40a69712daabc1c444b1b65a57e3314e4dd95d74024b381d3adb3e34633a5245a0fe4f7def65790c6609d96a88b8b60ba289af43ecdbfc4a0c95d0f778149be1577d91bee7f5435df3e9866d59a544c22ddb3fbbdfb3c4525e92c223f65759972ed825de95deb9c8585f84c643dbb61373c2be7defa998ffa083894fdf1786e66d470f8d4a5bb2508038dbcd934f6baf6deb667a45136ee7ed2df131bf47039b3f37ca50b21feebc1609ef9209ebabfae326ca1cc063d2be412c3f19eba2e0ddd66efec08d46411888de9a23db804e2129fb0a1a101e9e12616f43415beda4022c660276a96089f989422d37df71105ab6e7ad7c2a43369cb31d799a354dee1203f72fdeefb748a77656f48e4bd08290ecb9eb3dac4ceedf317a9fa8228f11ce0c2d92c4c70ced85fc96b4d07c0358dcf50f930f84689f47392e3509b1a7a15f5e63a79a2adeeedb3e19f7a8c460adfc2fb48e37f98e62472548a1633cf2c1fe482d25768e14bcde275d1a0a5aac6cf448fa361f0039538a364d5461516f71de078d5c8eb3a38bab2944744774e9d0d2082a7e72e80358ddef25bea280bbe166caf4ea8ce90312793ad4d9b68a2680ff0aa932684803e2ae5a2c7efc8e406584b58a131f9634f7cdc456c832a9c4b373865ffbabceac72bee600c2d5a68339a1a588adfe1ca186beade89fc0aea8c0553a1e880508750f50cd2c3584933c9a61eb9a36dc18a42cd246fff0e70a9147154bdd3905dfbcb92f4b8da93ae52c245c0149b30a18ffe73281e380f11a123f0a300ddc8c11df059cdb84244f876282a45c8c4c43fff0badc2b4c33035d79766f1180a9cad4307c80a6adc8fcdd1b28832bc5083fdf335161d70460393a6423a1f28bc901f31190a5ac2ba65ca5c33210354439828e62c327f89134249c7e346d36e6191136beb5d8c09be8aabc13b7e68653a480c6ae91cec6f2cc0701c5805054ae98f5dc7d4ba966639461c7bc90a53ad4ff1441d8c632b49431c27aaf37f32d700f0fe84187cb23d063d41db159b136c51ea4f0a4f99d14461dc0ba0b25d41082e6de11c31ccda0302848517de693d93056661f011e4896f643e017dfa3b8d5952a4a3b62481d78bdf8fa8f0fec1f947133a0ff8df46b11f53d2a937cf04007e269bbbc5cb52ded5291784a6ce359a1a926eb1295a93ef9049f6702851196ea6c790ed796af267a01ac244588041e43df8b76ae6803d3d601a714d97a4144cae9e51e67432d5c137ba94be5b0b86026f510176ad5963e66b5543700a4c67a38aae57470fdac24fbf8a8c7ee18c596dfef5b116cba62e1370d84af4fa93b5f14d3c93d11d19d799fe98da1ec28044eddabd47664af3759601b9ceae286f401468ea2999a84c25666c82e6554e57cab8b436964a13c9dbca385c9e54bc5efc09c66e69febcb9cf64c1ef5ea69f6102d9dbbed94803b2ab811011a435949af8949f7ade6111b965e0c7aeace870d40160ddf7b22a52349607f7bd6fc59fe3ca3275b5ff0227b5f853d58bb932e14c1605e2ab7385b85542098bd328fa360e4d9e863d252ac0ac66092321b4e55222f49f9a789e73622df92fa55b1da6841763440f8ac96fb51b4d09e0cd0256d6a359ad41c19f475db0aea3acc8fd41475568fd06c87ef044e3195e7f1ecf0f9d2d7e9a9c395278361c8e8251f72e9ad50239e8c00f1b2fda524c6730ca814532a950edaba685264eef85ebd4a0f814da900c9d8b973f878c4bfd6db7b779ebcbaec17628b18a72d19a5541545b8a5b745d6624382db1bd8f6e2592d18a52b9bc3004fa7f0b5a5e255cf69de491ffbfb0484432a226d354927ae19867f126d17ad51aff822e584f26c3fb11bc3f2b98338c228528c963196da40e46943507fb8a12aa5932941520053c905024e291b6a83a7bdfd680d6b61416259070a605c662d4944ececfe7939ea66f45d3cd6b8de5768cd70153e3b965a768e9d54b7f121871b8d78f28886b1013bbd87a59442d805b8fcfa194cbd7f4d892f2341b6953cedc54d6a4258a6652a355e668795e31794ff1ed25daa01a98d32b773a845dea6fa3e3bffff37f8e5a7079429bc9df10e6f2c0496a02c0ae0e6a81f462b6fcdff7179363d67b397447fca5492a47fd8529b3ecd391c98ef45b2f3ebbb805bee885baff2e9876de5f522eb57251cfeeddb2483976cfd0b8db19f7b42e35dca8970fb221be6ca37d12eef3e2ef4e3f22cfdf79fe814d9ec3c1daf38c6d4b06c83a3d573bc1bfe36be73e2e6cef709c736162b42199a8820c9158eae04fe7fe044ad7259a747eeb40a133a5788e1daa8ce869499de33dacde1c402193fcfc2b8cb8e07c822ec70a598dc21e87a1f647951bf8b41f3c7a7d628d26164aa616e68598f68b7c03d29cc6eb161a23508fd708710149d694af2deea9f75b32163b52678b307876c17b9c5fca7513c941f1c7e3f054f02462beb573a45e72b91a0c5c7fca4aaf8dce87e337184f0031341f244aa7d24401d010cf4551b2b739d873c24de6adbf49fbd90f2afd98709eb148e04b122d6828ad71c2aff5d912cebbee5e45eb6f95c805d0da04b05a0cb86e31210835807627643776461d65f815a8dfca1f55414607073549ced34cad53726f1aaa13a86a4ea90275fe6fac11b593fd00dca43d9013d899a28b09043e4a32b96a1ad451ba914c1ec28012042e2e85f777422c1b0248e9f3e0173d84f3ab5cdd4c61f5d8a953d5df0868b50dfc0102634c21a04945a4dce881c776366fbc206aa274c16853ebd2313e4749bfd3c34efbbd2825739ab82282b6e8af2ea57cc6f68e21ebe360aa5ee86239fc2d3d7a7b30f4877e19371274cd66876fb31fb4b5e340b50fd90106dd38c3165199ed799b8199dc8f7d78f92a475328d137810a0b8acc1318e2be102eceb967dd8bd0311d8fb23f19c36ce304bc9369c6782ffa307e2aaa08b86f6988263d2a586007d2399cf39732713d74582d8a823eb50035c276ca0d346c8280c9c69b179d2da5bdf2e41dab672034d7eba8af36ae2c28d283d4537c4a40d678232d557b6944908c4a05a3d7afa88b4cd8c2bd4663e90c9e45236d951a3e7c70e560986ca23f4c60b4160cdae9fce0b0fb48b0dfa47f46261fd10c28145a9046a2a6147627b161b904c558da3086f4b398caf7e19a9514cfacce646674852b3a69e3af7ff68c7fa064b4e93ac16b62102f150cb8c6be4156cc3ed24e387051c4c7565652a8afb1b5ba8ddbc4e5228829ec1ffafa1819903217c46011b152164b5dc24fbb191bcbc7ea6c94900fa743454f6e54c4424070044708c8955f3017d9c708e06eb8576b9622a84d6fa82a24dfc668d511d11237e43fb49208359d0ca6c63c5d3783adee385081959440594cc3ff8313826d10d24aaeb2a2ba1044c2c14adf9508cbb5c6d5fd0923ec3849e07e8a1c92dcbc20a7268dc8f89ba1fb1a648448a5a7710eb909c24d39bdac3a0e23110ee68bf8440e361e61f5ebbc84677adecc820c52b0e398a4aec49ea43369a9931d6ce74ed14dcbae3e77a893595f1486908d3d5e8dc22325e56f7b602aca78c54ab29a6d55466c837fad61c5033f1ad01a3cecaf3335716c0b254517651ddb573f1b2c2489d43c73d73b5737340199c86f1471cfed67d59e5c9ea7d3b0aa47490ca86c360c4474bf44c13df3f6c2bd589f320c10f6bef92493e5336b5f1f243827d8ba8a2490b01fd8a769e3bf7c8547ac15fd57bb6a24805ff997714c7c00e43bc6f6a370a3f0d9466181c6bd226e07fcad5cb6de4eca663be62a19ead86e73354fb5619607b49cde0073dbcb6d4fbec26a76ec37642d442be54adabe511f5f97d774c24697a56e2c83576d94f3db8a75a644b4ad53b551ae0d1dc3689730673d4366326c3c0e7ef91e29160599761edaa245c8ba1fead2be0d0bc09fd04155adb62b96cef2df181a6b20c5c372df21c6461defbd7be8e92a733a94f5135f7ecbe60647e960aee6da097a08d39f55d7cc0a16f5b2f59ddbe80c9085a5255afa48a7c5063fea287f0377ccec2ef52bf23daaca60464357b4a0bb4bc495c290c67e29fe5ef8afdaf6d82d4370bfa5d54b9a1b84db558fc36ccb90166eb95b060fa488819391c293cc73d410e5da00d730cf82feb6913fb4ba62dddd467494edd116559d1c34d03ee8e92331bcf0c24d9fa1cbae8126937d5cc80efd51ea0536dfbd24f68a4df0d6d3dae4a21900535927ea5debf6a61cd9aa6e68c99aeae27d9fdeb02ab8b82df770d1a78e96003f4bf11a116ec7147aa8dbf4a89075263725d694c1be840dcd7dce408cb3a7d0c48578b0bab491f527b354c8661bb44285cfab11816a0f241154840d016834c1d5a25481f2c1058423c9ac4c60f8af4754d6d9bb607534f796d5f3d1695f1d6b65465ff13e0b94b0dd63abcfaf76077b1a77de391a122fc15447fa1a95e38c3743bb155871961fa49862a87815250ce902e07e9228e0524b8c5355d0e48ce580285008b17c9f2f107cc7e4fd31f3f8d07377e64f620db889257d224163c254d5d754b40f034ab841899589e4138353dba2ee58cd51bf5ed23b2fd618da27733e4f0e7a8279b9b1ad23e513949fff97d0cac2467d99052c666fd5d6d008e289d1d1b9e70d0faf7d79657f81baf44e27c4a8c3cbf70e8b02fbd6715898e53e727583e35a0ab0e97bf0f0d21003d29a2e66d3a6ea47ac963091c34426db8888e32d7070e0f9bb18181d6955f4ba1e6971a029ba3193594cc30405d1b4622205c137b61b4a792a2b875416ee84367a99b3e8e9b6c1c3b13742da5c880e1eb842199df584198d56c2b5536a5176fcf493e0dae310ea2bf13a4da19266431554e0ad8ff0318c8a282afecc31e407733319f211f4edd9cb8930ec786e54380acb7d897d16d06435a6cbece1371442fe3e3199edd1e456d3c9e91ea715691d3fb85065a64a923eb083051cd76f82e72178f62ee52b4ad3c3ef0f459734a3ec9d66028cf5ab34361b81003fdadfd67a93bdacc2a6ebc02fa5de4a788a197e301ad257c6cbef9fc33415d3eefa192b1897a5b25b28869e6fb8f2ff6709e78b8588b2ab7837474aad9b89f85e8a03f6a2a4037dde25c7ef8529ffbf0506c18fe1e5b193872f36d7a22f0cba81f33567857e83d0f27c716b013eba97f8c824eb6e4d2607bacdd4bbb34fe26a2ab043ce42c069b0394af938be41cdcb5aa12f090db44cd6752a987eb7d158864a75db05b73bee9aa226d613cc8a5bc22cc2cf7743e5ac9bb73c7cbeb268241c7d91cfe84b70daf266c643bb18519ada635fb6ec4a06122fe053385b39b1093b43b9bc86c5f1908dfb90745fce42785e5409f48a966b619359ba63f1c05710657b398231413c9ddbcf94b1d1fc50e62b520675cb709e7d9802d4838e3c8c17ac7da7f6468b210f3981f0889e2c89c7f2bfc1262549bc4d6637ed63763e5ddf6aacbe2c427b938cdd4fa452e3b0f45113becf75b61ebb3748c90dde32a512461a6133b80a61baf50ae69cf27257d74e33e03a4f7315ad314db89ebb8b9a05fa4bc871073b8afa6a8c78aecb24d32ad7bfaa7fd8fa3132019f7943403fd981a48921a52fd78f8af89e89113ecf7fd7add7ff06a0566fd7b914b37052c2074627c6838af20f4563b60ff09a92c28bd305d952218c7e0f71455ebcfa9d51adb63a962726736532af57fe7137b62df740c72ef95c07e9705245b992236584e720864095c573ccfbb7c7583e22b203d69085cba2576d2c0f29842326773a5b79b259010dbe50890973012d9b1df2eee3e16aee0cccb88ae5a0fdfd2bd5169953e845230e5dfb169e5688ccab214d837b09ff39f18d5b366da7c9affbc4e79ac36c2a68106bac5ac2ef0f060a6ae4b7b609dee74864c0d812367c883b20251deab43a59486f319c833caccccb3d2d4c0b969488819a805c8b225bc1fa9999d1ce4571de0c7a6f871a195c678b9296dbb06a5693f11365f2e767deb2b89acb3c773025e4e875a4a15ac955d6d6dbc723e2fd9a7a214d35406f75bffdb44efde7b13c499a0409026c597719b3ecb44aa7dde0d9e6eff7303f9b27559166c08799de99be34b574a7ebfed0048b7b1767c0da3753514897793b02092ae29ada054582f0cc30bfba80d77e36ced85b337c5faec7b71300dd27f4e5a9bc7e68dce2a21cd946566c459662fbb7c0d3dad1109d2ec9157360eae0ec5f29767a28efb60256d3482c6af1705867479caeb2756ceba09c005469da1ae059d72f8380a93f25acad755827a3bd19b7bcc05b3e64989330fe226b4ddbc8993af5ed40caf999301496f02fb4efe2f1b400b07c44715d744c3daf24fed76e21f7ee64cfa3e12eae05d1328dd10102a2c2197dd2cf2fe61941e9f0d9e5aa9e43ca4551d20bf953764e5ac1751931386541a2559e69c39f14ab4571148b3ea26b39cf60318f4b4316b8ff5ea73404236183749dae07edeab33bee41e9cbd751bbc1ebc03d295e3403443cce77eae200baaa9b864b87d8ef5ab4b5ef40c2f1bd2af46a451acfee2122120acfc466e221a6cf6d0acbebc7ce4b14d670103a201832146c8e75bf4fb3c0bd17391d20445f05ca1539dc71ffeaa9cf3f1cb0f2f117943527381c5f153fc40d60d6cf6a8cdd867718d6c7ee0365812c84d950871a6b12245de3be212d43ca14e673b4912306e1d3b013c1bc51218c811625d05be2c90b82d0aaad1a04d60de87a6d284bbd6d99143435ecb53ef60d78bc6d4e6aa4fde166f927d489b5bdd3220cca8884be1efdc174836f6ba22cf777e32ace65ab08829dccfae96fe4f0b8d8aa0f41a677b5b552c5f9fc60939aec47295b618f2a6d8095888ff4ce75c8935ec0dc338d1a802e1dae44b99335500ef8f36b146ad85376eb9116d60bddbab370861ebe1d2c3b7e17d90c09a62da8af26d7620684c0ee18a16a31e2ac20c7e6aed8c559a7e0488f9e7eb780e1cc6608ffb50bcbf22994fab211b03d550430e7f703ce4307575e8c938e9c7766235422fb4e9534b0bf6855e48559be39f1264a2f58cf2195ca0fb819b02bfd9179c1871dc040abe0fa7ea96c8393eeadd539e2228913081d4fb1016bf50eef4a01d051d74ba63cde2dd81c0c0f3144755b04172f1cac80ffb78d4472e2bca7f5917e87b884859ebce4ae9f216c74408c95e1eba3bda4d48e7caaf528e8aab5499e5227bddd9be56adce707f27f57751beddc5323bec69a2d0cdb5a5a672a86afabee718276e962b40387a2241f5abdad29592413a0591200def436e99d60ef2aa79db270876787a31b3c32cb42b9ae7901573430f47b1577e15964055533831fa12448b67b03afe5aeac1835737db43800559a394d1ea47f56acc00b9620f79557c381fe675a8867159a397f8670ba3e4b7626b8b44634179d08bbc387b323a0a1b6e6d4d2abff000197e4a8af748246c5a2591ba4cf78e875302de947d4fc64e334afaa211d4214b71c159bc8f1246d6a202631c9371651a511bda4209627ae886d89d47064c9a3fcc7c41f805a79891808dfc375b5238f57d42f033eade1df09c4ca780bdb6607e8be65f8f26141f09855d1881b348ad10f6f98c29e5a160230e0164641a149fda0d5d7a62dd51d1140becec36f431b3e33f1c7d475e0da77a2e5e54a038790da3b5a350e07224011939c53d0490287363095326eceaafc447c0015b61a979c007f4651a0a9d74fcb0e142d10b237881a01611a562dfe3be9a80c912b81c946d27f0c77386b36734f4b5746e14a4f53576c446fd79de1239c7dced2c1c17d2fe03e7e260764c20ef3c9ffd4d13ef34dc9529023bfd4c1edd189f9749adce863cb0ae024ce1748be7c02d53861bfb86e0031cd428e80fdb5ad96b4832939b99ffeb3a72f1bcf21c8ea96dce5011284e2d69afac6f433e237c3d2a324b00b4fe868ca8650def5ee9c239b2127283715d6dce80163abe35e87ff52704f5e54ea0729d4b24f7b17a6a18d2869530a79bbd9185c6efe36b347ede69115fd3ef7cf20d481ec575d660816e451ca69b695cf25812573d4ca2bb0f6409f90b8de01629838acd1d962dec15106448259dcf1b818b13c8476e23745acc68c4372a8f2db665f89f0ec332f9c39a6587ff596be6caa7d6006df21478c373b3e50242a64a820d40b46872625ba46f061e8b3dfaa4643a662c0ca5d1e347f152eb07c4c5a74684d8b1f8500da774623bc60203964babf91470b8984b37315cd8e34eaf322c9d3f35ecdba5a3e3a8452a78c2e036e20ce2bf8822ee243575d6638ac5895dc1c69bf6b66e10f235a31dffad4522600112dfdabd0726440be39b9271f1e68f972f57c741df280e5da409508f407f64accbf379c4740b016202bd9dd2b56e8f7083048523f43f5d690386c45b5f39bd063682add99c5eca9f489ca427bf674238443ef9c1b677b2bbb5098a2e863cae2e5c6562d73e34a0f6dfa480ec994ce030fe1365adf78b73b42fb180605656f5dd1f2bb722e0b938fb136d57146cf5f8ddb302cbff7c80b59e3c38f473b8321c8e22a4e5a995c9f05caae57aaf77485e1c1f9225cfe38228885da0f49e765bac0906d92ef43c9caa8e1ba26491ec9cdd569044370dea9059ce0274570c486323b867ec08d896021af0312e23f2a885e3855fa5985067facc994e6a5e7d14d3298d9f78636ea5d3a6cfdfeb7d8cbbbf7679fd09d9018824660573d98ca4c44cf13d5a9ad45edb70810b8aba6230fda0dfa9af182b627f418525ba3ff0e419f963f4e7ef7b2c23fc03058b2e9d244237921199ed1de7928daf3ca0366a6ce68fc2e2db3a08e9acfb709c1a760961d6aa53a8b894e3923d35dd6b069787ed8f998fa7cfe9319a928c8ed2038d34650625e6c043ff547c1d0211ca38319b25fa145222d03fa84df8d215d9f234a413a9ea6f988b2e160101c8a8813e9959a664610f70e718abbbf75112376fdba4b754e6e164743fe634730c7ec29fd44939815ba352e79207d739a231cbf84870e8c5735200a2f619c2485a538a7ab968b324cd9f453dc09fa5bf3668f945b36839e433c40a77f3688226f97a75a4729bb03a55cf54ba300f03f8d1a8da6bc19fb538fa7d98bd7be8395b9424db6879409fa568a51788ce00d129db39acbefb45639582ecddf7db5bd516989e0563650bcb52e01223010900361659b78c0aa143feb45c91b3fe04df62fe1ae6b4a13f6d4c991823b2d6c2b45cd55c827304b6292766d7a48dae0d37f8e14ad001310e145986ca66be1950bf2813251c1f93e4871bc0ac4d627d264bf560d9c9c7301851765b7127e0e0d74348960dc613c7bfadd5c6f6eb38b3e77fe04a56a8b39994a76211812301b613fd4a0a1c37f9924838602772f9a519d3e8e84cc4fa79195586425caaef1021e0009c068747f45d8f2374978e3c4c7aada4723b31169e5dc2dffc36bf2b96538e101d788148d086c03314a6f2ecd0be4f780b8447fac24a3501ddfeee6c8d79558bc5cf3af4339d1b1231a229314183ae4e0003acf264659161e41de27b4e41444f372c1c797037bb6f16900b6613359ba97c3a33a04337179b2829a560e2307b12fd0f98511e40f1a47c1731adbe5626672898564079a74dac81ce8754d3b8ccd53d8a4779551831ed38ba17e66e32084229e9fb3f4fd5d15ac94fa1a50c2195738d11a0078b109dc26b91971c7398a3ab7c10b1f762ead1c413649c35db1ae87f45264ef30988c6e10c40372d5a2b1503863acb4a07826e3198a91f8590a9cbf7351d9b39b72bb5c46034aee784547aaaa3a9e69cd227524460caf098b802305184af08888415fd744ccbf871af6c5b4e8b6dce4dc65f5cd3a7ed0a40122ed418e3506d8cf71f2619e5142073baf6604953be9fc73fa0ca89b07c9a38a522d13a22aab0571b891c808e1ffb2289ffbdaddd43f614501bdcb1a0c9b05adad39c2d263a29683f64d0ffe77204a6ba101fd85b1cb05555c397797ee4b28986c12e25c321012a5befcc2a5c3d7d61e581a0bfec0aaad28bb1a59b86383150ef0cc1e85c5ccf12c67ee5242c624c51d7d67fdcd013b5fcef3f20c0e2d265025f1117e3457a9ec0f6107b4868d9728c76367b4dce6419e9d64cf49e3d8edd2fdbcdbaf73d245604d631d28f92e138da1f12666ad73b1c66caf5abd55ab8011775f3d9fc8f911d5c60459fba75dc0102d6c6dc34538bd8f7dc4250a7d9f7132f43f9f4f40cd561c99284c6bc44ab3b64335be6e844d2885a6affc4cbc207af6a2c590c0a617c363cf121f8d65e2ab62f4385222279cf80a554f6fe0b518b0ad530308ea19ae7ce3faee92d0dfc780241d196cfb27b3da055d60ed16254ba652bfe4d3ee403c20bb71d9c49ea6924a35ba939428e51484c83cc4bed3550906e9a84dad52392360c1a9e1e4350fdffd57b63eb5891a5135f2e0cec4fadb91ce05bc5e6ea03fb7ef0f1097affe1f199407456a029def6b870a498dd0f87692a6b5282588fea4487b6cd99afc4c72ef06819e7ec23b5d6e6ae797d665ee4447970f96ba25796568ee0f8c794e266914b5a77d409f39d6448a608488f654f223810e4eb50aa0e63dc1dd532066ec82d517eb13d20c3785237a981735e454bb5dac2f0390fe083f45c11075ea432570b99271a70bd91de5d9fe77374bdbddcadd87b0d98208fe381970b9ca469ad910fefb866432afce16e5f211aa2b0490196b06ef702ac841d2ec3d3d781cd19b2b011c115295b1842ecc8bf7136562e31aaede31cad355fbe8ddddeb36842561886607c1410f2072cda1d937ab39aae46cb7e18a28ce4d1e159e445ee07f0557c92c8545f520484cc8b8f99a9f384e2ef86b55ba4d7add59453178669ee73831e36145e602b1bebcde5f3c72ee88af239480e0bb30f93c78f348ba367ce574bc0b69e0b2105143d5b5bdff7d91e3baa06f241e30b7d709fc46b370f45f39380fff8bcacf14b92d75cf3da4eb1c7034532a96e95a46f95049c14776b707a280c7ab08d63edbabcf2089388d4df43d4f9364683849fc8eb524fb1f79b668d276d30a1ea42f7288c3482af8cd015aa7ca8b0276544b668241f466ebaa340835e70f39756057845bdc18a1c53bd03cc26d0490272bc4afea81ba3463a78d3d24491581273992669d18cc0f145feec22adb613d2706c87f2b3c0a9e7b591f0644e99090fa5a3838e0f1ee8672a988b735f2b87e32084e02ab5f3e516cb986df63616e7493adc4504526ab93170415cb7d5393dae26c529324500f45b4b1f70deb38f038a9af5a196662ce804b3b437ef0658f98e5e2f000bde00ce379fa28b884361b55490ae7a83ca832e91198e06ea65f9888eb5738ef463f1577b08113904c2bdcbacb3fd071c254b99959fbdac1c339494d80697c74351dd4d74e69f364018780545459ef71ef8f359ba4a387968f00f69dce55db2a082b1b7d20f3030c8d39f6853cccb800067e0fbf68ab6bbf7a892d48c4f9b1976e3ced4d98b23be1903f7691323b0643495ea2e9d3ba56c7152ca0a42697a4ba1c3de18f2ded086432b5a6b93c2b6963569233978743a2c84a6d2874257b54e18287b2b4e428c68ddb3ff7f53d01c48ebc606eb036911c2f373745b38ea7734caaab58feafacceb9d7075b75c8042d6c4a09c728d173cbafa2155adc926fb12cca9a9b5279816cca9676d167b77caa6cf84869714592d1d813f8386e99586a7ad0f1f03e1cf6ea986a36f8a7bb303b9483657cac036c74f0b51b3b9982a3183b2fad94802086794d656ef6a882c1d2fc4b66f6a0c7531c98c0048de0361e287608fd10454d6cb63c42a90ef1c324c8ea279f829593ff8120ccc249c62223da333d65282d1f76472889b8d28c924b3bed411b86d314ae3f0a57765e9b5f0f3abf85847e6f70dcb1f2bd1cc253dbd080ad49cfd451760635cdfcf6c9c34f9b51de640a9c119014db14e4ae07d1c47ec22a65065359f2bdf7cf3288880464891cb41a8ac8bbf6d7aea408a999efb8b91db3963206598417f3bdb74eb8f25627c353e4c65220fe0765fa8bdb6344397fd50ecd8a19bc0f86cf63bfd35a26ec08ea8a8c9b97fbc8d7a67f7e22e592148756ba2d2a6b6443eb1920a135aa4e0665c7f29200416bda14b7e224f9e1e9df405e46857186a82454457d4288b734b899ddb03371f530a7fb380ab5ff9ca24ff3913875067b71432a61ecfe420cc676e1f924473bbd22b5ea3a5461f60f184e66186c842893cbf0f4a2a60889e1a17864a6e89dd5cfa533a6819bf5a6af62954878ed8842e88ad186e8d508fbc1aaf23eab5161dcaef6abdf8ebc6fae3ce1bb6efa0e9b26a84888751173355d2106ba45e38f6e8732f3ae23c13f349b67e751f78b87256a47a8d624b5ce7e07eda7af35df1639b8fd6e554275c60bd41339e5159329e9ef6189c655fd4251a75b5d3260faadb58ec3521acc40f363b355d987fbd7f057ca04b54c4b0b5946e24be803affde1efcda3f48c16490b68f379efa3b238b33bb6c5a046229b591a2b535bfea382197cbc8f8886b26969a87e4e87d9b536dd35f7cc5d8c303e00b388644b0282d4a862f82a077a75c97f3e66d3c286fcfaab0233ff1cd3bb88087802431bf06567de5b12ef99b6f504dc1ef76eb59fd0345d04fde380bb64cbb52f4357a18ee83c55f35efb1f080891ab06bfeebe5409ded6b10ab03426bb5d07245e3bedc6cecf6eb02233aec58e4726b8176fe827808b286d4f0fa3b80dc36b3a795a3767d092b3f507c8b64f8e144645fb8d42d5d9f5349cd2df1364c3cb372c742ad0e00d26796cbfbf17344f2264efd1e2717b6decfc48329151e29474cbf2ebea3dd435c232cd64a2a43f1d5c1e3d91719658e6327413f8af7667e5f5befcc485b094ba5055e605dbcccb6d3eb56c5178d8c015fc440b5bf6aa29827141611e0b5ddaf3512e7a2db14ebe947145b121319cf9d123e3287fdd5a2ad8ca63b662de00776c40cc1ea1151c9827a86ef24284b5f31a647caa934d3e90c4bf0cf0d2ed0981b35511e7149979490a7d88fcf941e59df0dad66bffac176099f402249bff40cc4b19f54287fdaba31b817d134e2d97ca842b655e2a5ab895c7476ec33c4f7e461c044a35496c28f0c4ff52e2dbfe06a5e6fda86ef3624b5c99f1f61fcb095a91ebbcae5c0f3d8cb5bab7162db3cec10f8b2cadbfbeb5826dd595fa876e3c79bffdf0e7329f637655ac0a0fb41204afd9e3feac3870e5c0441f12dfbea10de68b73927144600201bbeae4baf1f685b0356f3e9b9b9384e20d41c015ea364aa713c7c09328e1b3fdd89ef021f658b3e80b31a1b508a9121275c458e66f1ec6803495d4a7e2d04dce3409dd6fa081d9e564103f0a23985a704ed3990d2f4111d5e071cccccedf592cfaa2cb6d13867f6a7078641bd16c21ed8dd2af3cd222a7dcf039e589452ba3a3d98a253d13bee7594ac582cf04d9b4138fe0f07426260c2fbe05483316c1e56b552022c48a35adc9412ac7202dce98ce271f5cd21980ffd0b7f615b8e7e27bc4b8d1d936606a91446495ce98812f76855ebcaaee1f4235311848a23056c6ded1b037a5703b9a5746b06fa76ba8462a5a0c688075a973463cb84f0a50060a37b90b61dad26d9624e0f5e1a2e3fcc8082c5c7e62458adc533bd6682e8113df0d939fa5ed20589c82680cb64f08150c48977c5b1e2cd25e351e58bfaa0b266edafedf868024c4957b278ac98b4dcca5fdcd8cf8103b50979ad0e565c17976fc87e2507d6f704843ccb4309d1ab09eb1b869a9747d7c3842361cf088a2437ecfb0d13bbd5299a085305806ed8b1e5b747fd01b4a5c853a476f5b8e6edd8fccd9b7229e0809ec290a59bef86705b5ff0e58f7c78e24201285fbd1bf4e055699363dc09caceb939a5c7d002d788f3e5b18b6f3a401e2689bcba47771833c3f5e7f11f0bff51acb9751b4df4aeeab6ca639ad82015ca4407d1fc64bd41789140aaa3c05b1e1a8acee252f7f66a0746e8559f2893a374d07be2157efc2b0f84d78bad598afccf0ff143ca580bc859edb941eea9b0768bf611cfde74a7e9bd639e93d1b45f102a7abf915bb8a0530fccf9c8734448fe9a8ee48d61b685c4d165ce09bca3c883763cd1c2255a126e62d62f56c31c33521f5f87e80f2942c7f735e67eee51c003c8a59744f58eafa5ac1da5c328f09fd39fd4c4c92721a600d942a81b3deb799f5b8fff3668ab3988354471d61e7975c2618a4d69fde89fd057b2a92f0eeff8a0cd8b9bcdb9fbe4a0da0831654239dc5b2461cc47b73359b119ce96f360a749f131f348453adcadf148b4dee710d2d2b8c44b3f81d9da2a2efb9c9e95e7d980680017684bc17aab4e73f83ab593d0d491cd01f13ce046ce7df94f72dbbb1b0e2988631885504795cc0c79e9e6a2091a609884b0289de159ae30f7d4058223b8b80670b6b08f61ba704a85b39b499acc7531e4e51cea9f9c58c3a56f060ed19bf43e234539e4dd43339ff9347f5c01504e0957c92bc1b0413d82fb12c8c3f2f5a37a9d695e95e9c9f614241bf1bc4faf1dced1455e8b384ca6de885faceb7e96698144937442fec470a3fb92b467cc5b2bcf37f54ebcb77ee365da0929ada6b38473fa62003c0148c2558ee20c37506d6101b2a755a65705222ea2484743d122931fa6616de528797de306604979566cc3bc8832cfba08d61388cbca0bc1a823e3572957a658b0b2b4ea210684192b0313922bd92b9c004fb8da69e24727f4060c97a212188e66448617e5f2d44cf1d16a8b8f51a40c7ed9abd6331e4982e6244c26237c9523624a9bafe39e62bcbc0b762a726c0876e70aa8883f2cf40806762e7a5145752b43ec0ad477a13c9a7ebdb7bb67dadeae27dd7522a52430f8d2659de70f083d3b155a64d832b2310440f942d496f39d6876f69c39246f3c798b7a693d6051f9d8c4f937dc078bee9e0f8fc27e0323a0090b20c90b2a7574b4aae893827d30f262ae36d8303b552ea00ab789b037d4d502e91594e9fca6384f4f952dabbebb933b161343ba8214e4bc4839e58c8f1c0116fa18881bf798eaaac5924debc7d9797226e1a6548fd81a8a378299c9a8b7927bffc22df84fc4cdb7139f7ca6f5eb8415de41b065a93f0de876b1c1ae542514a61323d1647460271a64b14b229312c385b3f58abe4e53dde628ebd1d79fcb12d49dff734e101317805dc2ef29eb32ef5c340c0faae139e03301a237a89ab42868478d685b85b13bd09cf3a4f94b5f4747dbf8a331f113461f24e52e2dca823eece4c6ada78d288c05143b55959245ab7a1fb6fb855c4b31fd4a3d6fd6d3a25abe6b828f87a4889b56b67d566813a481178dc03958d4710cddefebab2b97ed7c7128b204d5bd732e5efb447a4fd83e16c2aa43db7f11208cddbb57efd33978619e85dc68e1b03a6ab23b0a3b542653447c16a36aedddf7d70e125c91be1fd3559e5f1ca3ee5227c5de1a5e55dcb1d2fc4849d7d0d5b163f082ad02d6f6bd339e9cc0b890ddff5905e3b90f3231c36e08123b926012c168a5e913b7746342c70df3f7cd3bb7cab8178228b1f232f38402bfda3cac9883f41f00b6873a02b9061a56ef2ff01dc37b75464f30b144ccfbb0273798e20e3679fefddaabb4aea03e9984f2054c01453ee1e6b38240b8db7b76811de2cfcaf31ceca42687ce974e88af9a4ae38518038504e7609b84ce7812d218a31830df2a68ba4112ec9962f183771a746ca3516fede5fd81bd611fc480dfd21881b8839403abb94ac92506f7f1ff77d028a7dfe270b136cfe344d622b982192bcec61f6f985458cbdf4836e92589748dfece82a8065d367fb8179c2167c66b43ab962fb8eca96e08dba6c040cbfa16c34e9b735969fa6dd6f919e6ef7452dc5357bae826a056e13018ab1491f9232c56197cfb7d5527b86cd01f0dde80fb75dd0e4c61d0dfc537fcf70d8986764f3bc7617d45cd092ece4506934ff5b1bbf4a9515378e8ba3497d5def2225d3ed41aa43760ee4402eeb1d60cf96b88ee90b74de60f02bf71f9a71eb776bf1c835e46ba0f7fec478f5520a5c875175ec4e6beddd8fc483561860f6dace18b0f01c327b274bded487697b5e118cf039706af32771d5f92127114a4a4ef12d7f5808cd393c0de12bba97a5d9ccfea500e4727962a8e83bf40368284ccb8219b08a5c0d1303320aacc034e969f0320533a4041208a43a0da88d3b1823c34a940bb85b3cf757e61569fa9ed7755322c948fcf1ba098c38349a332e73c9865ca4a04dde911079f59845b8da75f1dcc7f93ddd5cb07973b17c3d7d0ca62c3c639d5e8b8aa9d8df0f6aefbfa55e2a84b08fe29bac7790b2007d1403b3df3ecf6879d91e7b16538daf8a30dace0840d0eaaaece77f775d622ddba2b5551a41e7e50273d038b3c9ed8366c0c419313a6372f30f4e1cb5595afa99ac7bf96f2e1cff8fc5223dfe8980411698485086d2ab71a699de0116388674846bf3ce4b29e77b09767cb487e4333e95a62af418562d85c7a09c6b306340d5c06a4832abb135ca0a439e2d679928c179a686cf9a2d6f1525c94fc305ee673ac7eba346f316abc9087a7862700c825e3e8bab69d93f0972d410374f323570ee762f52fbff548e3eefe5ab9716d7432c1b7ed768617b34489ef04baa4d818ad7c06a995e29486c15aafb876a320b4dcf93d84aed7e226f4791357a08b2f547c9d106f576f6b05ccf2f36f6ef3d8c7707db793e6f706091b2c8083c51ec5257aaf36819a1ee31208c00170c0219e77af481f870987b1a5c5f6c58d4477354a97733e07a4d15f3d89092456894a11793a3e68a8bea9dcfa243f069710d23e6c1b6c50e693d4b565f87794d59c7f56019d9eb41751c32346ed49d953f297a49aaef2bf91e323ea968ae191b5665ed6ce2a679c038b946ab02b57b873cd445feb0560044071018e064aab0f3ac6765f3f67bebfecf466dc328a51e6b4eeec289aeac3bd2b39ee2b00699f0fc7b3c8bac97a036e21800ec742e371e64bf9eeb21e4dde230ef123035999b04a06de45656e707ded29ee7eb505b6df6a4b8cf70055feb68212c241bbed56b418802dfc20547fa611500ce4a30fde5df774dcedf2bc54b87ac241e69360c00ba835100cde46dced91ac7e55d9fdee05e8a045da88698a8e35d84ba49b1622581a539bb67eefc34b1d26e7cf0e4f54e82bf98deda7230ad0864361f106efec1cc48affad72187c891f2381dd3ee81b5d483999d4185793b7eddcd7f7cf804e198d902921f37c266b15f1dec556d36e501825bc67f1860bf70dd1338fe28eabf0bba436fd53013623f320bb0a33838d6dd787e430db172dfbe26d1217904477278bac45d7c12de4608804e5f301b61190bf0641e857fd15a50aa3d46d410d62eff249bc344b1d652abe4a551b83d5cf65aefc6eaaf24be19642daafe6538b3b59a4b5ac94b69b06857425dc6d19d44d34b5598e3c4249cfe1c7b830eb4c05f82588cdbcf34132dc6504cbf7dee8ac4fe92f09d51e0f604ab45203cd71c304a36be5170ea2634d3a7ee259e0b59a024f550fdeb24c5915b90fc7f05f8507cf23ed24803580d295a68ccb7ab33524471f3b29b12bff940e52b1a4318dcd0fdb95f8d73dfbff8051e8e7867dbf1d3d187a59ea22d86113e77f14712d3b2588445469fe8a2d79bd041071285d5a217eefa1a6444d1d10ffccff9f4266463db6dfbcff45cd9666ead02bb69b03b318c9279142f218b4734bfeec80502379b37f7ba89d2eabc68563bed1316514255c449106af4c5cb48515bdb681ae9700576f44789ad6a29bc1bbe6b67463fe745fcc1df323f533b276bda963852d0a8662bca200ab983515f9b6672fa7feae389b57c823ff8c50f41d544f5807e1e4458ebeae96e36555d6515fbb7b22d04b6538a3e856f825c0c40ab2c96812814431f29908359d8f3acb7790f0f195491247df39672ad720e3b9025097eb2a69b71fca74353c30ae53aa6acb5920cc0f63f991afc291bfa569b5344d73b9d3fe364d48bd47be6a979e1695b2ccbe13b9ffd53d2bdb218049ee6ab778791f2dea7cad8bfdf70ba90df6c81347fa08cf6fed701aa01a7d262db9d8eda9b511835d33c893db2758543cda79ccc20337734536bf700d432cf164ddd257ae4685de9dd4572db1e52469986a0f07732db4fa23f90c5b85040b4a5460a00116fd0d402110128f7853cf920ef7986585484eb2a6b7d28cf7a195cff664dcccebacc05463b8d0f815bb30e6eec7d72e5e2ae80ee9e7b7a9df005d50b26f34600678a845fee3b302efba767032d88daf79976ff581328910a6a22b4fe32cdc8696f81436284789df7bcabdf3ff556a0e485baf5b89a673059e21b19c420a69221580fda927b1ac82dc2f92bf63f6cdec7bb4d4e28172ffce426cfcba61203f07219a10ce8a5146d076ee40ab2c51e1bb52d42e3706e1f820727847af03b54e488ec1e95f1bd266250eabf84137af15dacde8af4ae27e38b033192bdee5bff084ef9f50bc319eef5adf51fcfd675f77cd99865a1c35455f03000705d7bc65518a3cff3008b3f3014da4063b1e0dbe20369bc69b9baf4cad9fe8bec3b9562777065aad04632744a64b5e4ed9b2879f472c05da10d093888ad04a61421df2bcc8b9222cec84c927c5e9223e0fb4dcfd2297c7f101eb04730e46c2b1bd428b39c690164c99064535822abf196745b19b941acefecddf81f0d138c90ea6c4569ed5a05a6b27424b24436994876c4ed9a4177c6755077bcb2fb38bfd46f58f9612bf162aed93595e5717ed6e53bd1c882e7d42d703501e7f2dd7c1e0b870c3ef777cb97d78b66ec4f21a42a0b51fcd63132089cc9890bf018a8c22d56274d169894c123be0200c6090a776aa75ab9eb3376e198140e23e6e96a4bd3df830a09ec6ec038c12e90b3f37635c12542672b3dc7cb42011597c1c754dfca390ee05179aaebcdb91c1914f71aeb2263da8ad8ce35f9b12669a5206be0668de7f049c62ba64cd03d4a732a84ab08c6d2fbd85db3819e8949ebf95e2a3a7ba6a91c84ebd57d76c390716b803a297dc2ba8f58481a38ab9515ccc6ff667a8afd6b6a835805d0b21b8af26d500cd21252376bc030405f9c6c8580268c823d5683759974e1cd29b3c6018bc33af1127cfda037fc709a32b5f7b1d729f1c2b07c19782dcf757f4c47a59918cf692e4396988e502fc815c59bb02b4cea333f36711fc8a6a31e2efe260e73ff9ba96a73c1a52a645dffe4fa42717020c282359617e809b95eb8a4b5805bb93e1a69e92843f6261b86b0d274f60ebcd5c9b59310d3325393b55a749f62c912c9c98ae8e129f31debb58abf3bcdf1fcda9636854770a4ff4b37713708047317dced311e21d0d56832d2b75ac38c9e977a9d64efdbef2947d30de7e6ea402273127b5c5ca50fdfcd388b38fa9ebfbbf30ddaa860932ef4a89ccd0d125ba37fc6768cfe8f263b5957a37ba45ddff4d79c71fa93c972ad35bee7cc1e1515abc1288c261b2699171f73e81da39a40b36cb4168f21380b02867334765149810edca47a5dc21215a82c55fe71ee84fd8853007573a81e00e3b6bb0461ad159a29ad7274e4ef8df9912dcc71152818e07888312bad405c363ae47aad99cd362bd21507a346b6f5b7af674a7669e31066b0704f7d3a955eb7fba5a8195923a45f8abec9e34dbfab91d09f9780c6e83a9f58da4ac0228ce1980594346ef469c3b1ebc32a52fd1372cd1214b6e469ce18dd8051267dd9a62dbb2df23a0b6dbc6620bbd9da150d7a973bc2ead920532eb2c2781619ded7f4817a043935388d8f898b31a33ceb7d9d3eb1603fa9a955aa7491d2f70329629d3b1f44ce720d1a7ff3f4c7468c2e225edc586fbf0140a04925957761d3e8fa5f9389830f6e43c225ba8ce6bf221895e378bccb8b535c9112cab6832ee09e15d0588fc0ebe749b295f5fba4e0cb79881e1110e7a52ce9d58b85929e8b3bbdc5a583966a9d63cd6fbec373715b1edf2d6345cb44bb4e7ff1a768e7f299733f295eff9138f4620cffea6b1721379317c7143ab47e274788a929cba60e1679120a20ea2d5f59b75f179cca4e7e832ce94fc257b23603e3c04e4244c87c4eda1bbb2080085a9efebfaf98efbc9e9fed174ec19a922acf0e2c8b0a7c9605b7335cb80ebcec24cca19c6bf8fcadfcb000d400df03062cd1a1a0e3dbe3359ba5b4aae13031129cd869af260cd1bc43a591b41260428b44d312df445a5621519c0cf79357bf513673c2ccc44bd8da340b55bb3a7c4415beaaf03a77df0d333f54513dc347d1aee94808180ab8387cef0bf35ea402cf31dab007cd6c52a37adc0d054963070455074c3bf436eda77b37af22e7b9f6c3afc242415cf546545957538e408ba3a4f92e3c6c7af04225c0953487ae3673349eeb6c967cd7c0b2c92aa74f3237ef20d1b1453b2077ae30956cbccf52a222f18e08bff11e9a246905fb46392da981e279951295efbf72c357785c56b8594e66cc53ed30067a1c98f7123b597933b3c65e11f834390b15c9c030b8475c9aa5065b1c1e762d66c4096b83d0543b99d87d69931af96e8b12550a3586de88beb4b055ca503720700b37724dca4bff6c296dc99183652b7f85c01fdd28755115dee53c5c270ca6b1e7ba46d48c688ff32b43132bf5e1654d3780a22c2c9490a360b1dfc9bdf8765d093650a23b301921f282f50d4d1083bd6b08e8a5a7fe8e437cde2d6d15d694f908a7ecc65fd472f2c5ba7e372a123aec69d93f1222050808fa82bc7f2016d650f87187e9f716a635002706ca5a0ac6e2c50bfe5d4e2d79aa7066504e11f155d0c47e80b3bf2f846334798558bcfe9718f2e602522b0eb6e23c182c920d40f89ea557909410ebff74e143e4381f55cde964bca9edb8d2c4b2962905522d808cf34289b8d4ff376717a0fff058fc1b22e2c094f3039ee7391066be69e3a051972f029a43f158582a6d51aca537b91a23f54568aeee126efd64d59a2ee4ef85b3de53830073be0b818d7dad967828c0b569c1c9c596bc291ec0c65050ade5636ac401a274761dd82af9602e13c4610895c5f5ce7744ad4d39b73b66f774f8fb404d750725baff237b50abdf78354ad1370082cd83a245d88b1138bcc9ba603324f731ac99aba682b1eda7b37f0cfdb6ad8bfeb364bd65389c78ee2e27722dde68d29c2e635febc9f8014957f403e</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Encrypt</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器和 Tab 的选择</title>
    <url>/ide/</url>
    <content><![CDATA[<p>由于 Sublime 本身以及插件的下载巨慢无比，并且 Python 插件中对 <code>\r \b</code> 不支持，让我很想转 VSCode</p>
<blockquote>
<p>VSCode + Jupyter Notebook + Sagemath 太快乐了！<br>VSCode 把 Jupyter Notebook 内置了。VSCode 太强了，统一 ide 指日可待(2020/8/21)。</p>
</blockquote>
<a id="more"></a>
<h2 id="IDE：（文本编辑器，代码编辑器，集成开发环境）"><a href="#IDE：（文本编辑器，代码编辑器，集成开发环境）" class="headerlink" title="IDE：（文本编辑器，代码编辑器，集成开发环境）"></a>IDE：（文本编辑器，代码编辑器，集成开发环境）</h2><ul>
<li>2011-2012 学校机房 VC++6.0 写 C ，属实 SB…</li>
<li>2012-now ACM 集训队 Codeblocks 写 C/C++，<del>依旧是写 C/C++ 的首选环境</del> (VScode 无敌)</li>
<li>2013-now MATLAB </li>
<li>2013-now Sublime (打开任何文本文件，编译运行 <code>C++，Python，Latex</code>)，别说了，爱过 0.0</li>
<li>2015-2015 VS 游戏公司实习</li>
<li>2015-2015 vim 配置 ACM/ICPC 区域赛服务器（只记得 <code>i :wq</code> 和 <code>vim.rc</code> 了）</li>
<li>2015-2017 macDown 写 markdown</li>
<li>2020.1-now  Typora 写 markdown (2020/8/6 被 VScode 取代)</li>
<li>2020.3-now VSCode 试图替代 Sublime （done！）</li>
<li>2020.5-now Jupyter Notebook 写 SegaMath 上流！</li>
<li>2020.8.29 使用 Windows Terminal Preview 也太快乐了</li>
</ul>
<blockquote>
<p>从 古董 VC++6.0 到重量级 VS，一直对微软的编辑器有这莫名的反感，但是这次 VSCode 全开源确实做的很不错。（新 Edge 浏览器也很不错，莫非微软变了？）</p>
</blockquote>
<h2 id="Vi-m-VS-Emacs"><a href="#Vi-m-VS-Emacs" class="headerlink" title="Vi(m) VS Emacs"></a>Vi(m) VS Emacs</h2><p>因为没用过 Emacs，<a href="/vimWithLinuxShell/" title="Vim">Vim</a> 只用在无图形界面的系统，例如服务器，所以对此问题无感。搜狐上的一篇 <a href="https://www.sohu.com/a/149343369_487482" target="_blank" rel="noopener">图文</a>挺有意思的。</p>
<h2 id="Tab-VS-Space"><a href="#Tab-VS-Space" class="headerlink" title="Tab VS Space"></a>Tab VS Space</h2><p>之前学 C 的时候默认都是用 tab 缩进，也用 tab 缩进了很多年（C/C++ 本身对缩进就不要求），后来学 Python 的时候，缩进是必要的，并且不允许用 tab 和 space 混合缩进，然后 Python 一群人就说 4 个空格代替 tab 可以使代码变得整体和美观，听起来很不错，但是 tab 党真的受不了！</p>
<blockquote>
<p>tab 设计出来不就是为了美观的缩进吗？ 而且 tab 的姿势很潇洒不觉得吗？</p>
<p>用 tab 缩进，用空格对齐 （前无空格，后无 tab）</p>
</blockquote>
<h2 id="VSCode-配置"><a href="#VSCode-配置" class="headerlink" title="VSCode 配置"></a>VSCode 配置</h2><p>添加： 中文，Font 20（左下角设置），主题（One Monokai Theme）</p>
<p>C/C++，C/C++ Compile Run，Python，Markdown All in One，Latex WorkShop，draw.io</p>
<blockquote>
<p>可以在下面多搞一个 terminal 然后 进入 py 测试</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="vi.jpg" alt="vscode"></p>
<blockquote>
<p>VSCode + WSL 也太快乐了吧</p>
</blockquote>
<h2 id="VSCode-快捷键"><a href="#VSCode-快捷键" class="headerlink" title="VSCode 快捷键"></a>VSCode 快捷键</h2><p>（sublime 完全退役了，爱过）</p>
<ul>
<li><code>shift + alt + f</code> 文件夹查找</li>
<li><code>F12</code> 定义跳转（很多都有）</li>
<li><code>alt + left</code> 回到跳转前的位置</li>
<li><code>F1</code> 无敌的搜索</li>
<li><code>F1</code> 搜索 <code>Clang</code> 配置 <code>C++</code> 代码风格</li>
</ul>
<h2 id="硬件环境（完美搭配）"><a href="#硬件环境（完美搭配）" class="headerlink" title="硬件环境（完美搭配）"></a>硬件环境（完美搭配）</h2><ul>
<li>杂牌组装台式机装 Windows7 + VMware 里装 Ubuntu(Linux 一个流行的发行版) </li>
<li>或者 杂牌组装台式机装 Win10 + WSL（无图形界面，也挺好）</li>
<li>MacBook</li>
<li>ipad pro + pencil</li>
<li>非 iphone</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>转义字符</title>
    <url>/convertChar/</url>
    <content><![CDATA[<p>转义字符在任何一种编程语言中都会提到（正则表达式也是）。写这篇博客的原因是，在 <a href="https://raycoder.me/p/Python-special-characters/" target="_blank" rel="noopener">友链 Ray 的博客</a> 中无意发现：</p>
<blockquote>
<p>Python 自带的 shell 以及 SublimeText3 配置的环境 不支持 <code>\b</code> 和 <code>\r</code></p>
<p>但是 C++ IDE 就支持，例如：Codeblocks</p>
</blockquote>
<a id="more"></a>
<p>以下图表来自 <a href="https://baike.baidu.com/item/转义字符/86397?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">转义字符</th>
<th style="text-align:left">意义</th>
<th style="text-align:center">ASCII 码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\a</code></td>
<td style="text-align:left">响铃(BEL)</td>
<td style="text-align:center">007</td>
</tr>
<tr>
<td style="text-align:left"><code>\b</code></td>
<td style="text-align:left">退格(BS) ，将当前位置移到前一列</td>
<td style="text-align:center">008</td>
</tr>
<tr>
<td style="text-align:left"><code>\f</code></td>
<td style="text-align:left">换页(FF)，将当前位置移到下页开头</td>
<td style="text-align:center">012</td>
</tr>
<tr>
<td style="text-align:left"><code>\n</code></td>
<td style="text-align:left">换行(LF) ，将当前位置移到下一行开头</td>
<td style="text-align:center">010</td>
</tr>
<tr>
<td style="text-align:left"><code>\r</code></td>
<td style="text-align:left">回车(CR) ，将当前位置移到本行开头</td>
<td style="text-align:center">013</td>
</tr>
<tr>
<td style="text-align:left"><code>\t</code></td>
<td style="text-align:left">水平制表(HT) （跳到下一个 TAB 位置）</td>
<td style="text-align:center">009</td>
</tr>
<tr>
<td style="text-align:left"><code>\v</code></td>
<td style="text-align:left">垂直制表(VT)</td>
<td style="text-align:center">011</td>
</tr>
<tr>
<td style="text-align:left"><code>\\</code></td>
<td style="text-align:left">代表一个反斜线字符 <code>\</code></td>
<td style="text-align:center">092</td>
</tr>
<tr>
<td style="text-align:left"><code>\’</code></td>
<td style="text-align:left">代表一个单引号（撇号）字符</td>
<td style="text-align:center">039</td>
</tr>
<tr>
<td style="text-align:left"><code>\”</code></td>
<td style="text-align:left">代表一个双引号字符</td>
<td style="text-align:center">034</td>
</tr>
<tr>
<td style="text-align:left"><code>\?</code></td>
<td style="text-align:left">代表一个问号</td>
<td style="text-align:center">063</td>
</tr>
<tr>
<td style="text-align:left"><code>\0</code></td>
<td style="text-align:left">空字符(NUL)</td>
<td style="text-align:center">000</td>
</tr>
<tr>
<td style="text-align:left"><code>\ddd</code></td>
<td style="text-align:left">1 到 3 位八进制数所代表的任意字符</td>
<td style="text-align:center">三位八进制</td>
</tr>
<tr>
<td style="text-align:left"><code>\xhh</code></td>
<td style="text-align:left">十六进制所代表的任意字符</td>
<td style="text-align:center">十六进制</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意： 转义字符与操作系统无关！</p>
<p>Python Shell 和无视 <code>\r</code> ,而 <code>\b</code> 会报错。</p>
<p>Sublime 的插件无视 <code>\r</code> ，<code>\b</code> 会被输出为: <code>&lt;0x08&gt;</code></p>
</blockquote>
<p>下面内容摘自<a href="https://baike.baidu.com/item/换行符/1410821?fr=aladdin" target="_blank" rel="noopener">百度百科</a>：</p>
<p>回车 (<code>\r</code>) 本义是光标重新回到本行开头，r 代表 <code>return</code> ，控制字符可以写成 CR，即 <code>Carriage Return</code><br>换行 (<code>\n</code>) 本义是光标往下一行（不一定到下一行行首），n 代表 <code>newline</code>，控制字符可以写成 LF，即 <code>Line Feed</code></p>
<p>在不同的操作系统这几个字符表现不同：<br>比如在 WIN 系统下，这两个字符就是表现的本义，<br>在 UNIX 类系统，换行 <code>\n</code> 就表现为光标下一行并回到行首，<br>在 MAC 上，<code>\r</code> 就表现为回到本行开头并往下一行，至于 ENTER 键的定义是与操作系统有关的。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 自动输入</title>
    <url>/autoInputWithPy/</url>
    <content><![CDATA[<p>在知乎上看到 <a href="https://zhuanlan.zhihu.com/p/115563930" target="_blank" rel="noopener">使用 Python 控制自己的电脑和键盘是一种什么样的体验？</a> 里面介绍的 pyautogui，于是在 <a href="https://pyautogui.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">pyautogui 官网</a> 上查了一下，因为挺有趣的特此记录：</p>
<blockquote>
<p>可以用来写一个 LOL 打人机拿首胜的脚本 0.0</p>
</blockquote>
<a id="more"></a>
<h2 id="安装-pyautogui"><a href="#安装-pyautogui" class="headerlink" title="安装 pyautogui"></a>安装 pyautogui</h2><p> <code>pip install pyautogui -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<h2 id="持续获取鼠标位置的示例"><a href="#持续获取鼠标位置的示例" class="headerlink" title="持续获取鼠标位置的示例"></a>持续获取鼠标位置的示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># getMousePosition.py</span></span><br><span class="line"><span class="keyword">import</span> pyautogui <span class="keyword">as</span> pg</span><br><span class="line">print(<span class="string">'Press Ctrl+C to quit.'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		x,y = pg.position() </span><br><span class="line">		positionStr = <span class="string">'X: '</span>+str(x).rjust(<span class="number">4</span>)+ <span class="string">' Y: '</span>+str(y).rjust(<span class="number">4</span>)</span><br><span class="line">		print(positionStr, end = <span class="string">''</span>)</span><br><span class="line">		print(<span class="string">'\b'</span>* len(positionStr), end =<span class="string">''</span>, flush = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">	print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>退格 <code>\b</code> 也太好玩了</p>
<p>唯一新的东西就是 <code>pg.position()</code> 来获取鼠标位置</p>
</blockquote>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pg <span class="keyword">as</span> pg</span><br><span class="line">pg.PAUSE = <span class="number">1</span> <span class="comment"># 每条语句相隔1s执行</span></span><br><span class="line"><span class="comment"># 鼠标操作</span></span><br><span class="line">pg.move(x,y,duration = num_seconds)   <span class="comment">#相对移动</span></span><br><span class="line">pg.moveTo(x, y, duration=num_seconds) <span class="comment">#数秒内鼠标移动到(x,y)位置</span></span><br><span class="line">pg.click(x=moveToX, y=moveToY, clicks=num_of_clicks, interval=secs_between_clicks, button=<span class="string">'left'</span>) <span class="comment"># 鼠标（默认左键）单击</span></span><br><span class="line">pg.doubleClick(x=moveToX, y=moveToY) <span class="comment"># 鼠标双击（可以用上面的）</span></span><br><span class="line">pg.mouseDown(x=moveToX, y=moveToY, button=<span class="string">'left'</span>) <span class="comment"># 鼠标按住</span></span><br><span class="line">pg.mouseUp(x=moveToX, y=moveToY, button=<span class="string">'left'</span>) <span class="comment">#鼠标抬起 </span></span><br><span class="line">pg.dragTo(x, y, duration=num_seconds) <span class="comment"># 拖拽</span></span><br><span class="line">pg.drag(x,, duration=num_seconds) <span class="comment">#相对拖拽</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 键盘操作</span></span><br><span class="line"><span class="comment"># 切屏</span></span><br><span class="line">pg.keyDown(<span class="string">'alt'</span>)</span><br><span class="line">pg.press(<span class="string">'tab'</span>)</span><br><span class="line">pg.press(<span class="string">'tab'</span>)</span><br><span class="line">pg.keyUp(<span class="string">'alt'</span>)</span><br><span class="line"><span class="comment"># 复制粘贴</span></span><br><span class="line">pg.keyDown(<span class="string">'shift'</span>)</span><br><span class="line">pg.press([<span class="string">'left'</span>]*<span class="number">3</span>)</span><br><span class="line">pg.keyUp(<span class="string">'shift'</span>) </span><br><span class="line">pg.hotkey(<span class="string">'ctrl'</span>,<span class="string">'c'</span>)</span><br><span class="line">pg.hotkey(<span class="string">'ctrl'</span>,<span class="string">'v'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全屏浏览器中 写入 网址并前往</span></span><br><span class="line">pg.moveTo(<span class="number">360</span>,<span class="number">52</span>)</span><br><span class="line">pg.click()</span><br><span class="line">pg.write(<span class="string">'dna049.com'</span>,interval = <span class="number">0.2</span>)</span><br><span class="line">pg.press(<span class="string">'enter'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># messageBox</span></span><br><span class="line">pg.alert(text=<span class="string">''</span>, title=<span class="string">''</span>, button=<span class="string">'OK'</span>) <span class="comment"># 提示消息小窗口</span></span><br><span class="line">pg.confirm(text=<span class="string">''</span>, title=<span class="string">''</span>, buttons=[<span class="string">'OK'</span>, <span class="string">'Cancel'</span>]) <span class="comment"># 选择窗口，返回选择的内容</span></span><br><span class="line">pg.prompt(text=<span class="string">''</span>, title=<span class="string">''</span> , default=<span class="string">''</span>) <span class="comment"># 输入消息窗口</span></span><br><span class="line">pg.password(text=<span class="string">''</span>, title=<span class="string">''</span>, default=<span class="string">''</span>, mask=<span class="string">'*'</span>) <span class="comment"># 输入密码窗口</span></span><br></pre></td></tr></table></figure>
<h2 id="挂机玩-LOL-上述-pyautogui-被弃用了"><a href="#挂机玩-LOL-上述-pyautogui-被弃用了" class="headerlink" title="挂机玩 LOL (上述 pyautogui 被弃用了)"></a>挂机玩 LOL (上述 pyautogui 被弃用了)</h2><p>很遗憾，LOL 拦截了虚拟键盘操作（包括 <code>pyautogui pywin32</code>）</p>
<p><del><strong>按键盒子</strong>貌似可以解决（没试过）。最后我们需要驱动级的模拟按键：<a href="https://github.com/starofrainnight/pywinio" target="_blank" rel="noopener">pywinio</a></del></p>
<blockquote>
<p>键盘操作 <strong>用<code>pip install keyboard</code></strong> ： <a href="https://github.com/boppreh/keyboard" target="_blank" rel="noopener">keyboard 示例</a>。</p>
<p>鼠标操作 <strong>用<code>pip install mouse</code></strong> ： <a href="https://github.com/boppreh/mouse" target="_blank" rel="noopener">mouse 示例</a> </p>
</blockquote>
<p><code>mouse keyboard</code> 两个项目是同一个人创建的，并且带有按键监听功能，持续更新，十分推荐。它的使用 github 上有，直接下面代码也能看懂。</p>
<h3 id="设计者需要考虑"><a href="#设计者需要考虑" class="headerlink" title="设计者需要考虑"></a>设计者需要考虑</h3><ul>
<li>买装备 （装备栏要注意固定）     </li>
<li>选择路线 （上中下随机，根据时间去具体的点）</li>
<li>如何攻击 （乱打）</li>
<li>何时回城 </li>
</ul>
<h3 id="使用者操作步骤"><a href="#使用者操作步骤" class="headerlink" title="使用者操作步骤"></a>使用者操作步骤</h3><ol>
<li>打开英雄联盟 训练模式或简单人机，选好英雄（建议寒冰）</li>
<li>所有的东西恢复默认设置，装备栏<strong>左上角对齐</strong></li>
<li>在命令行执行 <code>py lolAuto.py</code></li>
<li>切到游戏界面</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lolAuto.py</span></span><br><span class="line"><span class="keyword">import</span> keyboard <span class="keyword">as</span> kb </span><br><span class="line"><span class="keyword">import</span> mouse <span class="keyword">as</span> ms</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buyequipment</span><span class="params">(flag = True)</span>:</span></span><br><span class="line">	sleep(<span class="number">1</span>)</span><br><span class="line">	kb.send(<span class="string">'p'</span>)</span><br><span class="line">	sleep(<span class="number">0.5</span>)</span><br><span class="line">	<span class="keyword">if</span>(flag):</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">				ms.move(<span class="number">196</span><span class="number">-65</span>*j,<span class="number">695</span><span class="number">-125</span>*i)</span><br><span class="line">				ms.double_click()</span><br><span class="line">				sleep(<span class="number">0.12</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		ms.move(<span class="number">64</span>,<span class="number">192</span>)</span><br><span class="line">		ms.double_click()</span><br><span class="line">		sleep(<span class="number">0.5</span>)</span><br><span class="line">	sleep(<span class="number">0.5</span>)</span><br><span class="line">	kb.send(<span class="string">'p'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span><span class="params">()</span>:</span></span><br><span class="line">	kb.send(<span class="string">'a'</span>)</span><br><span class="line">	sleep(<span class="number">0.2</span>)</span><br><span class="line">	ms.click()</span><br><span class="line">	sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skill</span><span class="params">()</span>:</span></span><br><span class="line">	kb.send(choice(<span class="string">'qwer'</span>))</span><br><span class="line">	ms.click()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upgradeskill</span><span class="params">()</span>:</span></span><br><span class="line">	kb.press(<span class="string">'ctrl'</span>)</span><br><span class="line">	skill()</span><br><span class="line">	kb.release(<span class="string">'ctrl'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infield</span><span class="params">(road, direc)</span>:</span></span><br><span class="line">	x,y = road[<span class="number">0</span>][direc]</span><br><span class="line">	ms.move(x,y,<span class="literal">True</span>,<span class="number">0.2</span>)</span><br><span class="line">	sleep(<span class="number">0.2</span>)</span><br><span class="line">	ms.click(<span class="string">'right'</span>)</span><br><span class="line">	kb.press(<span class="string">'space'</span>)</span><br><span class="line">	sleep(<span class="number">28</span>)</span><br><span class="line">	<span class="keyword">if</span>(direc != <span class="string">'mid'</span>): sleep(<span class="number">6</span>)</span><br><span class="line">	kb.release(<span class="string">'space'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myexit</span><span class="params">(event)</span>:</span></span><br><span class="line">	<span class="keyword">if</span>(event.name == <span class="string">'k'</span>): os._exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	print(<span class="string">'Welcome lolAuto designed by dna049'</span>)</span><br><span class="line">	print(<span class="string">'请先打开 LOL 进入游戏，恢复默认设置，\n 然后把买装备的界面左上角对齐 \n 再打开次应用'</span>)</span><br><span class="line">	print(<span class="string">'按 k 键 结束！'</span>)</span><br><span class="line">	kb.hook(myexit)</span><br><span class="line">	sleep(<span class="number">10</span>)</span><br><span class="line">	<span class="comment"># road应该随着时间改变的！</span></span><br><span class="line">	road = [&#123;<span class="string">'top'</span>:[<span class="number">1687</span>,<span class="number">857</span>],<span class="string">'mid'</span>:[<span class="number">1776</span>,<span class="number">944</span>],<span class="string">'ad'</span>:[<span class="number">1864</span>,<span class="number">1034</span>]&#125;]</span><br><span class="line">	ms.click(<span class="string">'right'</span>)</span><br><span class="line">	kb.send(<span class="string">'space'</span>)</span><br><span class="line">	ms.move(<span class="number">960</span>,<span class="number">540</span>)</span><br><span class="line">	ms.click(<span class="string">'right'</span>)</span><br><span class="line">	buyequipment(<span class="literal">False</span>)</span><br><span class="line">	sleep(<span class="number">1</span>)</span><br><span class="line">	direc = choice([<span class="string">'top'</span>,<span class="string">'mid'</span>,<span class="string">'ad'</span>])</span><br><span class="line">	infield(road,direc)</span><br><span class="line">	start = timeB = timeE = timeS = datetime.now()</span><br><span class="line">	sleep(<span class="number">50</span>)</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		kb.press(<span class="string">'space'</span>)</span><br><span class="line">		x = <span class="number">1920</span> + randint(<span class="number">-150</span>,<span class="number">150</span>)</span><br><span class="line">		y = <span class="number">1080</span> + randint(<span class="number">-80</span>,<span class="number">80</span>)</span><br><span class="line">		ms.move(x//<span class="number">2</span>,y//<span class="number">2</span>,<span class="literal">True</span>,<span class="number">0.2</span>)</span><br><span class="line">		sleep(<span class="number">0.2</span>)</span><br><span class="line">		kb.release(<span class="string">'space'</span>)</span><br><span class="line">		attack()</span><br><span class="line">		<span class="keyword">if</span>((datetime.now()-timeS).seconds &gt; <span class="number">5</span>):</span><br><span class="line">			skill()</span><br><span class="line">			timeS = datetime.now()</span><br><span class="line">			sleep(<span class="number">0.5</span>)</span><br><span class="line">		<span class="keyword">if</span>((datetime.now()-timeE).seconds &gt; <span class="number">30</span>):</span><br><span class="line">			upgradeskill();upgradeskill()</span><br><span class="line">			timeE = datetime.now()</span><br><span class="line">			ms.move(road[<span class="number">0</span>][direc][<span class="number">0</span>],road[<span class="number">0</span>][direc][<span class="number">1</span>])</span><br><span class="line">			sleep(<span class="number">0.2</span>)</span><br><span class="line">			ms.click(<span class="string">'right'</span>)</span><br><span class="line">			sleep(<span class="number">4</span>)</span><br><span class="line">		<span class="keyword">if</span>((datetime.now()-timeB).seconds &gt; <span class="number">240</span>):</span><br><span class="line">			kb.send(<span class="string">'s'</span>)</span><br><span class="line">			kb.send(<span class="string">'b'</span>)</span><br><span class="line">			kb.sleep(<span class="number">8</span>)</span><br><span class="line">			buyequipment()</span><br><span class="line">			timeB = datetime.now()</span><br><span class="line">			infield(road,direc)</span><br><span class="line">		sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	print(<span class="string">'Bye lolAuto designed by dna049'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为没法知道自己在哪，所以写的很捞。还有就是这是全局的鼠标键盘操作，而不是针对 LOL 的，哎就这样吧。</p>
</blockquote>
<h3 id="pywinio-安装和使用"><a href="#pywinio-安装和使用" class="headerlink" title="pywinio 安装和使用"></a>pywinio 安装和使用</h3><p>由于 pywinio 安装和使用贼搞人，在此写一下教程，先去 <a href="https://github.com/starofrainnight/pywinio" target="_blank" rel="noopener">这里</a> 下载源码，然后解压到：</p>
<p><code>C:\Users\Administrator\AppData\Local\Programs\Python\Python38\Lib\site-packages</code></p>
<p>打开 cmd 进入上述目录，依次安装 <a href="https://github.com/starofrainnight/pywinio/blob/master/requirements_dev.txt" target="_blank" rel="noopener">requirements_dev.txt</a> 中的依赖包，然后 <code>pip install -e ./pywinio-master</code> 就安装成功了。</p>
<p><strong>使用</strong>： 如果是 64 位操作系统（基本都是吧），管理员身份输入：</p>
<p><code>bcdedit.exe /set TESTSIGNING ON</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pywinio</span><br><span class="line">g_winio = pywinio.WinIO()</span><br><span class="line">print(g_winio.get_port_byte(<span class="number">0xA07</span>))</span><br></pre></td></tr></table></figure>
<p>运行上述代码，如果报错，可参考 <a href="https://blog.csdn.net/bkk854762363/article/details/95319962" target="_blank" rel="noopener">这里</a></p>
<blockquote>
<p>好不容易安装好了，然后我也不会用，后来也没用了，辣鸡…</p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/heapWithPy/</url>
    <content><![CDATA[<p>堆（heap ）是一种经典的数据结构，C++ STL 中优先队列 <code>priority_queue</code> 和 Python 中的 <code>heapq</code> 都是堆的一种实现。这里说明一下堆的原理和 heapq 的使用：</p>
<blockquote>
<p><a href="/stl/" title="在我的这篇博客">在我的这篇博客</a> 中搜索 <code>优先队列</code> 可以看到堆的简单介绍。</p>
</blockquote>
<a id="more"></a>
<h2 id="（最小）堆是满足下面条件的二叉树"><a href="#（最小）堆是满足下面条件的二叉树" class="headerlink" title="（最小）堆是满足下面条件的二叉树"></a>（最小）堆是满足下面条件的二叉树</h2><ul>
<li>父节点小于等于子节点</li>
<li>用列表或者数组保存（这个也不是必须的，但一般都是这样做的）</li>
</ul>
<blockquote>
<p>堆根节点是最小的节点，堆的深度永远是 $O(\log n)$, 即是平衡的</p>
</blockquote>
<h3 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h3><ul>
<li>插入一个元素： 将它放在最后面，向上更新 $O(\log n)$</li>
<li>删除最小的元素： 将最后的元素放在根节点，向下更新 $O(\log n)$</li>
<li>查看最小的元素（根节点）</li>
<li>将一个列表初始化： 将列表从根更新，然后依次递归更新 $O(n)$</li>
</ul>
<blockquote>
<p>从上述操作可知，堆可以用于 <strong>堆排序</strong>，整体复杂度 $O(n \log n)$</p>
</blockquote>
<h3 id="实现一个堆还是挺简单的，不过我们没必要再造轮子了。-下面用例子看一下-Python-堆的使用"><a href="#实现一个堆还是挺简单的，不过我们没必要再造轮子了。-下面用例子看一下-Python-堆的使用" class="headerlink" title="实现一个堆还是挺简单的，不过我们没必要再造轮子了。 下面用例子看一下 Python 堆的使用"></a><strong>实现一个堆还是挺简单的，不过我们没必要再造轮子了。</strong> 下面用例子看一下 Python 堆的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="comment"># from heapq import *</span></span><br><span class="line">x= list(range(<span class="number">10</span>))</span><br><span class="line">random.shuffle(x)</span><br><span class="line">heapq.heapify(x)</span><br><span class="line">print(x)</span><br><span class="line">heapq.heappop()</span><br><span class="line">heapq.heappush(x,<span class="number">3</span>)</span><br><span class="line">heapq.heapreplace(x,<span class="number">-1</span>)</span><br><span class="line">heapq.heappushpop(x,<span class="number">-2</span>) <span class="comment">#先push后pop，效率自然更快</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>经典组合问题</title>
    <url>/classicalCombination/</url>
    <content><![CDATA[<p>在此记录一些经典的组合问题，方便日后查阅。</p>
<blockquote>
<p>卡特兰数，斯特林数，放球问题</p>
</blockquote>
<a id="more"></a>
<h2 id="卡特兰（Catalan-）数"><a href="#卡特兰（Catalan-）数" class="headerlink" title="卡特兰（Catalan ）数"></a><a href="https://baike.baidu.com/item/卡特兰数/6125746?fr=aladdin" target="_blank" rel="noopener">卡特兰（Catalan ）数</a></h2><p>$n$ 个 0 和 $n$ 个 1 组成的序列中始终要保持 <strong>任意前缀中</strong> 0 的个数不超过 1 的个数的序列个数为 $\frac{1}{n+1} {2n \choose n }$</p>
<blockquote>
<p>这个问题跟括号合理性等一系列问题合理性有关。</p>
</blockquote>
<p>$n$ 个 0 和 $m$ 个 1 组成的序列（$n \leq m$) 保持 <strong>任意前缀中</strong> 0 的个数不超过 1 的个数的序列个数为：</p>
<script type="math/tex; mode=display">
{n+m \choose n} - {n+m \choose n-1}</script><blockquote>
<p>把 0 当 $x$-轴，1 当 $y$-轴，不合理的情况必然经过 $y = x+1$, 在第一次不合理时，后面的路径就开始与 $y = x +1$ 对称，最终结束点为 $(n-1, m+1)$</p>
</blockquote>
<h2 id="斯特林（Stirling）数"><a href="#斯特林（Stirling）数" class="headerlink" title="斯特林（Stirling）数"></a><a href="https://baike.baidu.com/item/斯特林数" target="_blank" rel="noopener">斯特林（Stirling）数</a></h2><p>关于这个问题可以参考 <a href="https://www.cnblogs.com/gzy-cjoier/p/8426987.html" target="_blank" rel="noopener">这篇博客</a></p>
<blockquote>
<p>第一类斯特林数等到以后用到了再写吧</p>
</blockquote>
<p>第二类斯特林数： 将 $n$ 个不同的元素拆分成 $m$ 个非空集合的方案数 $S(n,m)$。显然有递推关系式：</p>
<script type="math/tex; mode=display">
S(n,m) = S(n-1,m-1)+mS(n-1,m)</script><p>又我们知道：</p>
<script type="math/tex; mode=display">
m^n = \sum _{i=0} ^ m S(n,i) \times i! \times {n \choose i}</script><p>将 $n$ 个任意的放在 $m$ 个不同盒子中。右边的枚举非空盒子数量 $i$，$i$ 个盒子因为是不同的所以要乘 $i!$ （不用担心算多了，因为一旦分配好了，盒子本身即使无区别，放了东西就有区别了）<br><a href="/inverseFormulaAndItsMatrixForm/" title="从我的这篇博文">从我的这篇博文</a> 直接可知 (把 $n$ 看作常数）：</p>
<script type="math/tex; mode=display">
S(n,m) m! = \sum_{i=0}^m (-1)^{m-i} {n \choose i} i^n</script><p>改写成大家通常见到的形式也就是：</p>
<script type="math/tex; mode=display">
S(n,m)  = \frac{1}{m!} \sum_{i=0}^m (-1)^{i} {n \choose i} (m-i)^n</script><blockquote>
<p>补充：知乎上 <a href="https://www.zhihu.com/people/hzy-46-50" target="_blank" rel="noopener">Hongzy</a> 写了一篇 <a href="https://zhuanlan.zhihu.com/p/150779987" target="_blank" rel="noopener">斯特林数入门</a> 的文章，写的甚好。</p>
</blockquote>
<h2 id="正整数分拆数"><a href="#正整数分拆数" class="headerlink" title="正整数分拆数"></a>正整数分拆数</h2><p>将正整数 $n$ 拆分成 $m$ 个非负整数之和的方案数 $f(n,m)$：</p>
<script type="math/tex; mode=display">
f(n,m) = \left\{ \begin{array}{lr} 
1 & n=m=1 \\
f(n,n) & n<m \\
1+f(n,n-1) & n=m \\
f(n,m-1)+f(n-m,m) & n>m>1 
\end{array} \right.</script><h2 id="正整数分拆成乘积数"><a href="#正整数分拆成乘积数" class="headerlink" title="正整数分拆成乘积数"></a><a href="https://oeis.org/A001055" target="_blank" rel="noopener">正整数分拆成乘积数</a></h2><p>记 $fcnt(n,m)$ 表示 $n$ 的乘法分解都不超过 $m$ 的数</p>
<script type="math/tex; mode=display">
fcnt(n,m) = \sum_{d|n} [d<=m] fcnt(\frac{n}{d},d)</script><ul>
<li>打表时间复杂度 $O(n^{\frac{5}{2}})$，空间复杂度 $O(n^2)$ 不推荐！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10004</span>;</span><br><span class="line"><span class="keyword">int</span> fcnt[N][N]; <span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFcnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)  fcnt[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">		<span class="keyword">int</span> sn = <span class="built_in">sqrt</span>(i+<span class="number">0.2</span>); </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>;d&lt;=sn;++d)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%d) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = N<span class="number">-1</span>;j&gt;=d;--j)  fcnt[i][j]+=fcnt[i/d][d];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=N<span class="number">-1</span>;j&gt;=i/d;--j)  fcnt[i][j]+=fcnt[d][i/d];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sn*sn == i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = N<span class="number">-1</span>;j&gt;=sn;--j)  fcnt[i][j]-=fcnt[sn][sn];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFcnt</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fcnt[<span class="number">1</span>][<span class="number">1</span>] != <span class="number">1</span>) initFcnt();</span><br><span class="line">	<span class="keyword">return</span> fcnt[n][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;getFcnt(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归（推荐复杂度不好分析）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcnt</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sn = <span class="built_in">sqrt</span>(n+<span class="number">0.2</span>),ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>;d&lt;=sn;++d)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%d)  <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(d&lt;=m &amp;&amp; d&gt;<span class="number">1</span>)  ans += fcnt(n/d,d);</span><br><span class="line">		<span class="keyword">if</span>(n/d&lt;=m) ans+= fcnt(d,n/d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sn*sn == n &amp;&amp; sn&lt;=m) ans-=fcnt(sn,sn);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n=98765432109876 = 9.8*10^13 用时 42s, N 大点，耗时会小点</span></span><br><span class="line">		<span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;fcnt(n,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="n-个球放在-m-个盒子中"><a href="#n-个球放在-m-个盒子中" class="headerlink" title="$n$ 个球放在 $m$ 个盒子中"></a><a href="https://blog.csdn.net/qq_39942341/article/details/80246780" target="_blank" rel="noopener">$n$ 个球放在 $m$ 个盒子中</a></h2><p>球有相同和不同两种情况，盒子也是，还有盒子能空和不能空，一共八种情况：</p>
<ul>
<li><p>球同，盒同，非空</p>
<p>正整数拆分数之和 $f(n,m) - f(n,m-1)$</p>
</li>
<li><p>球同，盒同，能空</p>
<p>正整数拆分数 $f(n,m)$</p>
</li>
<li><p>球同，盒异，非空</p>
<p>等价于 $x_1 + \cdots + x_m = n$ 的正整数解，插空法知道 $n-1 \choose m-1$</p>
</li>
<li><p>球同，盒异，能空</p>
<p>同上，$n+m-1 \choose m-1$</p>
</li>
<li><p>球异，盒同，非空</p>
<p>第二类斯特林数： $S(n,m)$</p>
</li>
<li><p>球异，盒同，能空</p>
<p>同上， $\sum_{i=1} ^m S(n,i)$</p>
</li>
<li><p>球异，盒异，非空：$m!S(n,m)$</p>
</li>
<li><p>球异，盒异，能空：$m^n$</p>
</li>
</ul>
<h2 id="有限制的线性方程组的解"><a href="#有限制的线性方程组的解" class="headerlink" title="有限制的线性方程组的解"></a>有限制的线性方程组的解</h2><p>$x_1+ \cdots +x_n = m, c_i &lt; x_i \leq d_i$ 的正整数解的个数？（通过平移不妨设 $c_i = 0$）</p>
<h3 id="m-较小时，动态规划直接做复杂度-O-m-2-n"><a href="#m-较小时，动态规划直接做复杂度-O-m-2-n" class="headerlink" title="$m$ 较小时，动态规划直接做复杂度 $O(m^2 n)$"></a>$m$ 较小时，动态规划直接做复杂度 $O(m^2 n)$</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = d[i]; x &gt; c[i]; --x)&#123;</span><br><span class="line">    dp[i][j] += dp[i<span class="number">-1</span>][j-x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="n-较小时，直接暴力做"><a href="#n-较小时，直接暴力做" class="headerlink" title="$n$ 较小时，直接暴力做"></a>$n$ 较小时，直接暴力做</h3><blockquote>
<p>首先化简为求解：$x_1+ \cdots +x_n = m, 0 \leq x_i \leq a_i$ 的正整数解的个数记作 f(n)</p>
</blockquote>
<p>我们先考虑 $n = 2$ 的情形，并且不妨设 $a_1 &lt; a_2$，我们分情况讨论可得</p>
<script type="math/tex; mode=display">
f(2) = \left\{ \begin{array}{ll}
1 + m & m \leq a_1 \\
1 + a_1 & a_1 < m < a_2 \\
\max(1 + a_1 + a_2 - m, 0) & a_2 \leq m 
\end{array} \right.</script><p>记 $g(m, x, y) = \max(0, 1 + \min(m, x) + \min(0, y - m)$ (定义域：$x \leq y$) 则显然此时有（不妨设 $a_{2i + 1} &lt; a_{2i}$）：</p>
<p>$f(1) = 1$, $f(2) = g(m, a_1, a_2)$, $f(3) = \sum_{x_3 = 0}^{\min(k, a_3)} g(k - x_3, a_1, a_2)$, $f(4) = \sum_{x = 0}^m g(x, a_1, a_2) \cdot g(m - x, a_3, a_4)$，可以一致这样搞下去（$n = 5, 6$ 可以依然可以用此方法），但是此时还不如直接用动态规划做法来做。</p>
<h3 id="d-i-c-i-为一个常数时，用包容排斥原理"><a href="#d-i-c-i-为一个常数时，用包容排斥原理" class="headerlink" title="$d_i - c_i$ 为一个常数时，用包容排斥原理"></a>$d_i - c_i$ 为一个常数时，用包容排斥原理</h3><blockquote>
<p>不妨设 $c_i = 0, d_i = k$</p>
</blockquote>
<script type="math/tex; mode=display">
{m-1 \choose n-1} - {n \choose 1} {m-k-1 \choose n-1} + \cdots (-1)^n {n \choose n} {m-nk-1 \choose n-1} = \sum_{i=0} ^ n (-1)^i {n \choose i} {m-ik-1 \choose n-1}</script>]]></content>
      <tags>
        <tag>Math</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 语法糖之防蛀牙</title>
    <url>/syntacticSugar/</url>
    <content><![CDATA[<p>因为 Python 的语法糖，代码简洁优美，越来越喜欢 Python 了。</p>
<blockquote>
<p>人生苦短，请用 Python</p>
</blockquote>
<a id="more"></a>
<ul>
<li>四则运算不会溢出</li>
<li>乘方，排列组合数内置且不会溢出</li>
<li>支持 <code>x,y = y,x</code> 等简单操作</li>
<li>分号可用来分割，实现一行多句</li>
<li>函数返回值可以是元组，列表，甚至是函数</li>
<li>lambda 表达式</li>
<li>列表生成式 ， 三元操作符： <code>[x//2 if x%2 == 0 else x for x in range(10)]</code></li>
<li><code>in,  enumerate</code> 在 <code>for</code>循环中使用</li>
<li>列表，元组反向标号从 <code>-1</code> 开始数，不用担心越界<ul>
<li>字符串的 <code>split</code> 和 <code>join</code> 方法，<code>eval</code> 计算器。</li>
</ul>
</li>
<li><code>map</code> 将一批数据同时用一个函数处理</li>
<li><code>zip</code> 把列表或元组打包</li>
<li><code>argv</code> 直接可用，不用再管 <code>argc</code></li>
<li>函数可变参数 <code>*args</code>（保存元组）, <code>**kwargs</code>（保存字典）</li>
<li><code>yield</code>  和 <code>yield from</code> 做生成器</li>
<li><code>reduce</code> 函数计算列表内全部乘积等（需要 <code>from functools import reduce</code>）。</li>
<li><a href="https://raycoder.me/p/Python-exec/" target="_blank" rel="noopener">exec 函数</a> 执行 Python 文件中的代码。</li>
<li>用 list 当函数参数实现传引用（指针）的功能</li>
<li>装饰器</li>
<li>带 <code>*</code> 赋值： <code>a,*b,c = [1,3,4,5,6,3,6]</code></li>
<li><code>raise ValueError(&#39;error type...&#39;)</code> 处理异常，哈哈</li>
<li>Python 交互界面中：<code>_</code> 返回的是最近一次的值</li>
<li>任意类有 <code>__init__</code> 和 <code>__repr__</code> 方法（不解释了，顾名思义）</li>
<li><a href="https://blog.csdn.net/goodlixueyong/article/details/52589979" target="_blank" rel="noopener">运算符重载</a>，<a href="https://www.yiibai.com/Python/operator-overloading.html#" target="_blank" rel="noopener">运算符重载 2</a> </li>
</ul>
<blockquote>
<p>非语法糖： 生成器表达式中, in 子句在声明时执行, 而条件子句则是在运行时执行</p>
</blockquote>
<h2 id="装饰器示例"><a href="#装饰器示例" class="headerlink" title="装饰器示例"></a>装饰器示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*arg, **kw)</span>:</span></span><br><span class="line">		print(<span class="string">'start %s'</span> %func)</span><br><span class="line">		<span class="keyword">return</span> func(*arg, **kw)</span><br><span class="line">	<span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcA</span><span class="params">(arg)</span>:</span></span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funB</span><span class="params">(arg)</span>:</span>   <span class="comment">#注意这里没有@</span></span><br><span class="line">	print(<span class="string">'不带@的装饰器: '</span>,end=<span class="string">''</span>)</span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line">x = funcA <span class="comment"># 函数也是对象0.0 骚操作</span></span><br><span class="line">x(<span class="string">'xxxxx'</span>)</span><br><span class="line">log(funB(<span class="number">12</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看 <code>log(funB(12))</code> 就知道了！因为 log 是 return 的是函数 wrapper ，然后 12 就作为 arg 传入了。 </p>
</blockquote>
<h3 id="类中装饰器：-自带-properity-staticmethod-classmethod"><a href="#类中装饰器：-自带-properity-staticmethod-classmethod" class="headerlink" title="类中装饰器： 自带 @properity @staticmethod @classmethod"></a>类中装饰器： 自带 <code>@properity @staticmethod @classmethod</code></h3><h2 id="To-be-Continue"><a href="#To-be-Continue" class="headerlink" title="To be Continue"></a>To be Continue</h2><blockquote>
<p>我始终相信极简的代码，优美的代码才是正确的编程姿势。</p>
</blockquote>
<h3 id="Python-的坑-动态语言火葬场岂是浪得虚名"><a href="#Python-的坑-动态语言火葬场岂是浪得虚名" class="headerlink" title="Python 的坑 :  动态语言火葬场岂是浪得虚名"></a><a href="https://Python-small-examples.readthedocs.io/en/latest/chapters/p08_keng.html" target="_blank" rel="noopener">Python 的坑</a> :  <strong>动态语言火葬场岂是浪得虚名</strong></h3><ul>
<li>列表快速复制是浅复制</li>
<li>注意传列表等同转指针</li>
<li><a href="https://www.cnblogs.com/xueli/p/4952063.html" target="_blank" rel="noopener">深复制和浅复制</a> 一定要细心</li>
<li>list 自带的 copy 是浅 copy</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 计算 LOL 中猫咪状态数</title>
    <url>/catWithPy/</url>
    <content><![CDATA[<p>我们知道在 LOL（英雄联盟）中，猫咪是可以进入队友身体的，如果 LOL 再出 5V5 克隆模式（<del>我猜不可能</del>），如果某一方选了猫咪这个英雄，场面上会有多少种状态呢（不考虑死亡）？</p>
<blockquote>
<p>这个问题在 2019 年 5 月猫咪刚出来的时候就在 <strong>好好做人群</strong> 讨论并给出了结论，只是没写成程序</p>
</blockquote>
<a id="more"></a>
<p>答案是：1296 （可以先拉到最后）</p>
<h2 id="问题数学化"><a href="#问题数学化" class="headerlink" title="问题数学化"></a>问题数学化</h2><p>每只猫可以进入其他猫咪的身体，求（我们更关心 $a_n$）：</p>
<ul>
<li><p>$n$ 只不同的猫咪，会有 $a_n$ 种状态</p>
</li>
<li><p>$n$ 只相同的猫咪，会有 $b_n$ 种状态</p>
</li>
</ul>
<p>我们想要得到 $a_n$ 和 $b_n$ 的表达式或者递推公式，然后写程序求 $a_n, b_n$ </p>
<blockquote>
<p>为了方便，我们约定 $a_0 = b_0 = 1$</p>
</blockquote>
<h2 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h2><p>我们可以根据能看到的猫咪数量 $r$ ，来分情况讨论，</p>
<blockquote>
<p>我们先考虑相同猫咪的情况，<del>简单一点</del>  <strong>下面分析全错！！！</strong></p>
</blockquote>
<p>例如，如果 $r=1$，那么其它猫咪都进入了某一只猫咪的身体，有 $b_{n-1}$ 种情况，类似的我们其实可以得到如下公式：</p>
<script type="math/tex; mode=display">
b_n = \sum_{r = 1} ^n \sum _{\begin{array}{c}x_1 + x_2 + \cdots + x_r = n \\ 1 \leq x_1 \leq x_2 \leq \cdots \leq x_r \end{array}} b_{x_1 -1} \cdots b_{x_r -1}</script><blockquote>
<p>$r$ 只可见的猫，分别真实包含了 $x_1, \cdots, x_r$ 只猫，而这 $x_i$ 只猫有一个在最外面，所以它的内部有 $b_{x_i - 1}$ 种可能。</p>
</blockquote>
<p>$b_1 = 1, b_2 = 2$ 是显然的。我们来计算$b_3, b_4, b_5$</p>
<p>$3 = 1+2 = 1 \times 3$，所以 </p>
<script type="math/tex; mode=display">
b_3 = b_2 + b_1 + 1= 4</script><p>$4 = 1+3 = 2+2 = 1+1+2 = 1 \times 4$, 所以</p>
<script type="math/tex; mode=display">
b_4 = b_3 + b_2 + b_1 \times b_1 + b_1 +1 = 9</script><p>类似的对 5 做分解可知：</p>
<script type="math/tex; mode=display">
b_5 = b_4 + b_3 + b_1 \times b_2 + b_2 + b_1 ^2 + b_1 + 1 =20</script><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正整数拆分 n = x_1 + x_2 + ... + x_r, 且 x_i &gt;= low</span></span><br><span class="line"><span class="comment">#low 表示递归的时候最小取值</span></span><br><span class="line"><span class="comment">#ans 保存递归得到的前部分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naturalcut</span><span class="params">(n, r, low, ans = [])</span>:</span> </span><br><span class="line">	<span class="keyword">if</span> r &lt;= <span class="number">1</span>: </span><br><span class="line">		<span class="keyword">yield</span> ans+[n]</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(low, <span class="number">1</span> + n//r):</span><br><span class="line">			<span class="keyword">yield</span> <span class="keyword">from</span> naturalcut(n-i, r<span class="number">-1</span>, i, ans +[i])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allcut</span><span class="params">(n)</span>:</span></span><br><span class="line">	b = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">		b += list(naturalcut(n,i,<span class="number">1</span>))</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面两个函数和后面代码出现两个类似的函数完全是一致的，只是表现形式不一样</span></span><br><span class="line"><span class="comment"># 上面的简单明了，后面的效率更高一点，所以两个都保存了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbn</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span>:	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	bn=[<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">		bn.append(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> allcut(t):</span><br><span class="line">			product = <span class="number">1</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">				product *= bn[i<span class="number">-1</span>]</span><br><span class="line">			bn[<span class="number">-1</span>] += product</span><br><span class="line">	<span class="keyword">return</span> bn</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,x <span class="keyword">in</span> enumerate(getbn(<span class="number">8</span>)):</span><br><span class="line">    print(str(i)+<span class="string">'只相同猫咪有 '</span>+ str(x)+<span class="string">'种状态'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们现在考虑不同猫咪的情况</p>
</blockquote>
<p>我们依然根据猫咪在场上的数量 $p_1 + \cdots +p_r$ ，对猫咪进行讨论，则有</p>
<script type="math/tex; mode=display">
a_n = \sum _{r = 1} ^ n \sum _{\begin{array}{c} x_1 p_1 + \cdots + x_r p_r = n \\ 0 < x_1  < \cdots < x_r\end{array}} n! \prod _{i=1}^r  \frac{x_i ^{p_i} a_{x_i -1}^{p_i}}{ (x_i !)^{p_i} p_i!}</script><blockquote>
<p>真实包含了 $x_i$ 只猫的猫有 $p_i$ 只 (这也是为什么$x_i$ 严格递增)，</p>
<p>$x_i^{p_i}$  ：每只猫都要选择一个出来当最外面的猫</p>
<p>$a_{x_i - 1}^{p_i}$ ： 去掉最外面的猫，里面有 $x_i - 1$ 只猫</p>
<p>最后一个式子，经典排位组合问题就不提了。</p>
</blockquote>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正整数拆分 n = x_1p_1 + ... + x_rp_r, 且 low&lt;=x_1&lt;...&lt;x_r</span></span><br><span class="line"><span class="comment">#low 表示递归的时候最小取值</span></span><br><span class="line"><span class="comment">#ans 保存递归得到的前部分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naturalcuts</span><span class="params">(n, r, low, ans = [])</span>:</span> </span><br><span class="line">	<span class="keyword">if</span> r == <span class="number">1</span>: </span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n//low):</span><br><span class="line">			<span class="keyword">if</span> n%i == <span class="number">0</span>:	<span class="keyword">yield</span> ans + [(n//i,i)]</span><br><span class="line">	<span class="keyword">elif</span> r &gt;<span class="number">1</span>:</span><br><span class="line">		x = n - r*(r<span class="number">-1</span>)//<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(low, <span class="number">1</span> + x//r):</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, x//i - r +<span class="number">2</span>):</span><br><span class="line">				<span class="keyword">yield</span> <span class="keyword">from</span> naturalcuts(n-i*j,r<span class="number">-1</span>,i+<span class="number">1</span>,ans + [(i,j)])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allcuts</span><span class="params">(n)</span>:</span></span><br><span class="line">	a = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">		a += list(naturalcuts(n,i,<span class="number">1</span>))</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getan</span><span class="params">(n)</span>:</span></span><br><span class="line">	an = [<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">		an.append(<span class="number">0</span>)</span><br><span class="line">		factn = math.factorial(t)</span><br><span class="line">		<span class="keyword">for</span> item <span class="keyword">in</span> allcuts(t):</span><br><span class="line">			product = factn</span><br><span class="line">			<span class="keyword">for</span> x,p <span class="keyword">in</span> item:</span><br><span class="line">				product //= math.factorial(x)**p</span><br><span class="line">				product //= math.factorial(p)</span><br><span class="line">				product *= an[x<span class="number">-1</span>]**p</span><br><span class="line">				product *= x**p</span><br><span class="line">			an[<span class="number">-1</span>] += product</span><br><span class="line">	<span class="keyword">return</span> an</span><br><span class="line"></span><br><span class="line">print(getan(<span class="number">10</span>))	<span class="comment">#9只不同猫咪状态数是 100000000（正好一亿）!!! 这也太整了吧</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码能如此简洁多亏了，Python 的这个生成器写法太优美了！！！</p>
</blockquote>
<p>当然了，如果只是 5 只猫咪，那我们其实也可以枚举出所有情况得到 $a_n = 1296, b_n = 20$：</p>
<p><img src= "/img/loading.gif" data-lazy-src="0.png" alt="0"></p>
<h2 id="以下内容更新于-2020-3-17"><a href="#以下内容更新于-2020-3-17" class="headerlink" title="以下内容更新于 2020/3/17"></a>以下内容更新于 2020/3/17</h2><p>在和我大学同学 <strong>祺祺</strong> 讨论之后，他猜测 $a_n = (n+1)^{n-1}$，一开始我是不相信的，不过数据对比之后发现，卧槽，秀啊。所以说明有一种更优美的理解：</p>
<p>假定 LOL 峡谷地图实际上在一只超大的 $0$ 号猫咪肚子里面，那么这些猫咪就构成了以 $0$ 为根的树，我们求得这 $n+1$ 个（有编号）节点无根树个数，然后我们把 $0$ 号节点变成根，就得到了我们所有的状态。</p>
<blockquote>
<p><a href="http://oeis.org/A000273" target="_blank" rel="noopener">$n$ 个节点的无根树个数是 $n^{n-2}$</a>，最早于 A.Cayley 在 1889 年首先公布并证明（现在看来不算严谨的证明），后来有了树的 Prufer 编码，就可以漂亮的解决证明这个问题了。可参考 <a href="http://www.matrix67.com/blog/archives/682" target="_blank" rel="noopener">Matrix67 的博客</a> 或下面说明</p>
</blockquote>
<h3 id="Prufer-编码"><a href="#Prufer-编码" class="headerlink" title="Prufer 编码"></a><a href="https://baike.baidu.com/item/prufer数列/2182091?fr=aladdin" target="_blank" rel="noopener">Prufer 编码</a></h3><p>$n$ 个节点的无根树（也就是简单无向图），可以唯一的给出一个长度为 $n-2$ 的编码，同样每一个长为 $n-2$ 的编码都可以唯一的产生一棵 $n$ 个节点的无根树 （这就证明了上面结论）</p>
<p>给定一颗 $n&gt;2$ 个节点的无根树，每次找出无根树中，度数为 $1$ 的节点中编号最小的节点 $A$，记录节点 $A$ 的邻接点，然后删除节点 $A$ 和它的边。这样一直继续下去，直到只剩下两个节点。</p>
<blockquote>
<p>度数为 $i$ 的节点恰好在 Prufer 编码中出现 $i-1$ 次</p>
</blockquote>
<p>给你一个长度为 $n-2$ 的 Prufer 编码，我们只要找出 <strong>没有在当前编码中最小的</strong> 跟编码中第一个节点相连即可。重复下去即可得到无根树。</p>
<h3 id="后来我发现，我-b-n-算错了！！！，因为很多情况算重复了，为了算-b-n"><a href="#后来我发现，我-b-n-算错了！！！，因为很多情况算重复了，为了算-b-n" class="headerlink" title="后来我发现，我 $b_n$ 算错了！！！，因为很多情况算重复了，为了算 $b_n$"></a>后来我发现，我 $b_n$ 算错了！！！，因为很多情况算重复了，为了算 $b_n$</h3><script type="math/tex; mode=display">
b_n = \sum _{r = 1} ^ n \sum _{\begin{array}{c} x_1 p_1 + \cdots + x_r p_r = n \\ 0 < x_1  < \cdots < x_r\end{array}} \prod_{i = 1} ^ r {b_{x_i - 1}+p_i -1 \choose p_i}</script><p>上述公式包括 <strong>正整数拆分</strong> 和 <strong>给相同的球染色问题</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正整数拆分 n = x_1p_1 + ... + x_rp_r, 且 low&lt;=x_1&lt;...&lt;x_r</span></span><br><span class="line"><span class="comment">#low 表示递归的时候最小取值</span></span><br><span class="line"><span class="comment">#ans 保存递归得到的前部分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naturalcuts</span><span class="params">(n, r, low, ans = [])</span>:</span> </span><br><span class="line">	<span class="keyword">if</span> r == <span class="number">1</span>: </span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n//low):</span><br><span class="line">			<span class="keyword">if</span> n%i == <span class="number">0</span>:	<span class="keyword">yield</span> ans + [(n//i,i)]</span><br><span class="line">	<span class="keyword">elif</span> r &gt;<span class="number">1</span>:</span><br><span class="line">		x = n - r*(r<span class="number">-1</span>)//<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(low, <span class="number">1</span> + x//r):</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, x//i - r +<span class="number">2</span>):</span><br><span class="line">				<span class="keyword">yield</span> <span class="keyword">from</span> naturalcuts(n-i*j,r<span class="number">-1</span>,i+<span class="number">1</span>,ans + [(i,j)])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allcuts</span><span class="params">(n)</span>:</span></span><br><span class="line">	a = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">		a += list(naturalcuts(n,i,<span class="number">1</span>))</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbn</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span>:	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	bn=[<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">		bn.append(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span> item <span class="keyword">in</span> allcuts(t):</span><br><span class="line">			product = <span class="number">1</span></span><br><span class="line">			<span class="keyword">for</span> x,p <span class="keyword">in</span> item:</span><br><span class="line">				product *= math.comb(bn[x<span class="number">-1</span>]+p<span class="number">-1</span>,p)</span><br><span class="line">			bn[<span class="number">-1</span>] += product</span><br><span class="line">	<span class="keyword">return</span> bn</span><br><span class="line"></span><br><span class="line">print(getbn(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://oeis.org/A000081" target="_blank" rel="noopener">这正好是 $n+1$ 个无编号的有根树个数</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Math</tag>
        <tag>LOL</tag>
      </tags>
  </entry>
  <entry>
    <title>输出源代码的 Python 代码</title>
    <url>/printSelfWithPy/</url>
    <content><![CDATA[<p>之前，现在用 Python 写一遍</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">with</span> open(sys.argv[<span class="number">0</span>]) <span class="keyword">as</span> f:</span><br><span class="line">	print(f.read(), end =<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>但是利用传入参数读文件属实耍赖，所以在写一个不用读文件的版本：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = list(range(<span class="number">6</span>))</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">'a = list(range(6))'</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">'print(a[0])'</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="string">'for i in range(6):'</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="string">'    print("a["+str(i)+"] = "+chr(39)+a[i]+chr(39))'</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="string">'for i in range(1,5): print(a[i])'</span></span><br><span class="line">a[<span class="number">5</span>] = <span class="string">'print(a[5], end = "")'</span></span><br><span class="line">print(a[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    print(<span class="string">"a["</span>+str(i)+<span class="string">"] = "</span>+chr(<span class="number">39</span>)+a[i]+chr(<span class="number">39</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>): print(a[i])</span><br><span class="line">print(a[<span class="number">5</span>], end = <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后一行是因为 Python 默认以 print 回车结尾<br>我无法用 tab 缩进，只能用空格缩进，这是唯一不完美的地方</p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 写 Windows 关机程序</title>
    <url>/shutdownWithPy/</url>
    <content><![CDATA[<p>用 Python 的 Tkinter GUI 做一让用户输入指定文字（比如叫我爸爸 0.0 哈哈哈），否则关机的程序(只合适 Windows 用户)</p>
<a id="more"></a>
<h2 id="Windows-关机命令-shutdown"><a href="#Windows-关机命令-shutdown" class="headerlink" title="Windows 关机命令 shutdown"></a>Windows 关机命令 shutdown</h2><p>在命令行窗口输入 help shutdown 可以看到详细的参数列表</p>
<h2 id="用-Tkinter-创建出输入框"><a href="#用-Tkinter-创建出输入框" class="headerlink" title="用 Tkinter 创建出输入框"></a>用 Tkinter 创建出输入框</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># baibai.py</span></span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> tkinter.simpledialog <span class="keyword">import</span> askstring</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.withdraw() <span class="comment"># 隐藏tkinter的主界面</span></span><br><span class="line">os.system(<span class="string">'shutdown -s -t 30'</span>) <span class="comment"># 30s内关机</span></span><br><span class="line">x, answer = <span class="string">''</span>,<span class="string">'白白是我爸爸'</span></span><br><span class="line">hint = <span class="string">'输入：'</span>+ answer + <span class="string">'，否则在30s内关机！'</span></span><br><span class="line"><span class="keyword">while</span> x != answer:</span><br><span class="line">	x = askstring(<span class="string">'askstring'</span>,hint)</span><br><span class="line"><span class="keyword">if</span>(x == answer):	os.system(<span class="string">'shutdown -a'</span>) <span class="comment"># 用户正确输入了就不关机了</span></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>
<h2 id="用-pyinstaller-打包"><a href="#用-pyinstaller-打包" class="headerlink" title="用 pyinstaller 打包"></a>用 pyinstaller 打包</h2><p><code>pyinstaller -F baibai.py -w</code></p>
<p>就可以在 <code>dist</code> 文件夹中找到对应的 exe 文件了。然后发给小伙伴让 Ta 们叫你爸爸 0.0</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>图片转化成位数据</title>
    <url>/imageToByte/</url>
    <content><![CDATA[<h2 id="把图片变成数据"><a href="#把图片变成数据" class="headerlink" title="把图片变成数据"></a>把图片变成数据</h2><p>有时程序需要加载本地图片，然后打包的时候就很不方便，所以 wxPython 支持 img2png.py、img2py.py、img2xpm.py 等工具来支持这种操作，但是我调用的时候一直出错，在网上查了很多方式最后找到了解决方案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># imageToBite.py</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dna049.png'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	bData = base64.b64encode(f.read())</span><br><span class="line">	pData = bData.decode()</span><br><span class="line">	print(pData)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这段代码就是把图片变成数据 bite。 相应的修改图片就可以换着用了，如果很多就批处理自己照样写。</p>
<p>然后在命令行执行</p>
<p><code>py imageToBite.py &gt; a.txt</code></p>
<p>就可以把数据存下来，然后复制到下面程序的 data 中就行了。</p>
<p><strong>然后在 wxPython 框架下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wx.lib.embeddedimage <span class="keyword">import</span> PyEmbeddedImage</span><br><span class="line">bitmap = PyEmbeddedImage(data).GetBitmap()</span><br></pre></td></tr></table></figure>
<p>就可以咯</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-gui 之 wxPython 做拼图游戏</title>
    <url>/pythonGui/</url>
    <content><![CDATA[<blockquote>
<p>一定要先写逻辑代码，再写用户界面代码</p>
</blockquote>
<h2 id="GUI-的共性"><a href="#GUI-的共性" class="headerlink" title="GUI 的共性"></a>GUI 的共性</h2><blockquote>
<p>好读不好写！！！，因为一看类名函数名就知道每行代码是干嘛的，但是因为大小写还有单词选择可选的很多， 所以一定要配置  <strong>代码补全！！！</strong></p>
</blockquote>
<p>其实任何语言的 GUI 都是类似的，基本就是使用操作系统提供的窗口 API 接口，然后就是时间响应机制，这样就导致了语言特点其实用的特别少，然后真正开发都是使用别人的引擎。</p>
<a id="more"></a>
<p>例如 C++ 开发就会用到 cocos2d， Unity 等（5 年前去游戏公司实习过），还有 MATLAB 的 GUI 开发是真的方便，框架设计特别简单，添加按钮什么的拖拽就可以了，还有就是添加响应函数的时候右键就可以自动帮你定位到要写响应函数的地方，简直就是神器。好了废话不多说了，学习 Python 的 GUI 设计，选的是 wxPython 和 pygame。学习两个库的一些基本操作，然后分别用两种包写拼图游戏。</p>
<h2 id="wxPython-学习"><a href="#wxPython-学习" class="headerlink" title="wxPython 学习"></a>wxPython 学习</h2><p>先用 pip 安装 wxPython</p>
<p><code>pip install wxPython -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com</code></p>
<p>wxPython <a href="https://wxPython.org/pages/overview/#hello-world" target="_blank" rel="noopener">官网</a> 给了 hello World 两个简单示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wx; a=wx.App(); wx.Frame(<span class="literal">None</span>, title=<span class="string">"Hello World"</span>).Show(); a.MainLoop()</span><br></pre></td></tr></table></figure>
<p>一行代码做一个 GUI 界面，可能这就叫做人生苦短，请用 Python 吧！</p>
<p>推荐 <a href="http://xoomer.virgilio.it/infinity77/wxPython/Widgets/wx.Bitmap.html#GetSubBitmap" target="_blank" rel="noopener">wxPython 库查阅</a> 和 <a href="https://www.cnblogs.com/ajucs/p/3903690.html" target="_blank" rel="noopener">键盘事件列表</a></p>
<h2 id="pygame-学习"><a href="#pygame-学习" class="headerlink" title="pygame 学习"></a>pygame 学习</h2><p>这一张图就够了感觉！</p>
<p><img src= "/img/loading.gif" data-lazy-src="pygamecheatsheet.png" alt="pygame"></p>
<p>然后还有 <a href="Python_ext pygame.pdf">ppt</a> 以及<a href="pygame_docs.pdf">库查询手册</a> </p>
<h2 id="拼图游戏开始了"><a href="#拼图游戏开始了" class="headerlink" title="拼图游戏开始了"></a>拼图游戏开始了</h2><p>本来是想用 wxPython 和 pygame 两种方式实现同一个拼图游戏，后来 wxPython 的编写（主要是函数查询）把我搞的生无可恋，就不想写 pygame 版本的实现了。下面是源码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># JigsawGame.py writed by dna049 at 2020/2/28  last update: 2020/3/14</span></span><br><span class="line"><span class="comment"># 这是个加注释的版本，有些望文生义的我就不注释了</span></span><br><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64 </span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urlrequest 	<span class="comment"># 用于从网上加载图片</span></span><br><span class="line"><span class="keyword">import</span> webbrowser <span class="comment">#打开网页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk 		<span class="comment"># 用于选择文件夹</span></span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> filedialog <span class="comment"># 用于选择文件夹</span></span><br><span class="line"><span class="keyword">from</span> wx.lib.embeddedimage <span class="keyword">import</span> PyEmbeddedImage 	<span class="comment"># 用于把数据变成位图</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JigsawGame</span><span class="params">(wx.Frame)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kw)</span>:</span> <span class="comment">#这个方法只会在最开始调用一次</span></span><br><span class="line">		super(JigsawGame, self).__init__(*args, **kw)</span><br><span class="line">		self.Centre()  	<span class="comment"># 整个窗口出现在屏幕正中心</span></span><br><span class="line">		<span class="comment"># 选择文件</span></span><br><span class="line">		self.fileOpen = <span class="literal">False</span> 	<span class="comment"># 标记是否选择了正确(.png, .jpg, .jpeg, bmp)的文件</span></span><br><span class="line">		self.fileLoad = <span class="literal">False</span> 	<span class="comment"># 标记是否读取了文件(因为只需读取一次)</span></span><br><span class="line">		self.order = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)] 	<span class="comment"># 0-8这9个位置的初始值都是0-8，后面会变动</span></span><br><span class="line">		self.eB = <span class="number">8</span> 	<span class="comment">#标记空白块的位置，8就是右下角</span></span><br><span class="line">		<span class="comment"># 创建面板（面板上可以放按钮，文本框，静态文本，图层等等东西）</span></span><br><span class="line">		<span class="comment"># style 参数设置是让他可以接收到上下左右键！</span></span><br><span class="line">		self.pnl = wx.Panel(parent = self, style = wx.BORDER_NONE)</span><br><span class="line">		<span class="comment"># 这个就是左下角的欢迎界面，还有字体的设置</span></span><br><span class="line">		welcome = wx.StaticText(self.pnl, pos=(<span class="number">20</span>, <span class="number">521</span>), \</span><br><span class="line">			lAbel = <span class="string">'欢迎来到我的博客:'</span>, \</span><br><span class="line">			style = wx.aligned_RIGHT)</span><br><span class="line">		blog = wx.StaticText(self.pnl, pos = (<span class="number">180</span>, <span class="number">521</span>), \</span><br><span class="line">			lAbel = <span class="string">'dna049.com'</span>)</span><br><span class="line">		blog.SetForegroundColour(<span class="string">'pink'</span>)</span><br><span class="line">		font = blog.GetFont()</span><br><span class="line">		font.PointSize += <span class="number">2</span></span><br><span class="line">		font = font.Bold()</span><br><span class="line">		welcome.SetFont(font)</span><br><span class="line">		blog.SetFont(font)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 这个是操作提示的静态文本</span></span><br><span class="line">		self.hint = wx.StaticText(self.pnl, pos=(<span class="number">710</span>, <span class="number">20</span>), \</span><br><span class="line">			lAbel = <span class="string">'操作：\n\n↑\n← ↓ →\n\n\nW\nA S D'</span>, \</span><br><span class="line">			style = wx.aligned_CENTER)</span><br><span class="line">		self.hint.SetFont(font)</span><br><span class="line">		self.hint.SetForegroundColour(<span class="string">'red'</span>)</span><br><span class="line">		self.hint.Hide()</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 一开始的界面中提示按鼠标的静态文本，贼大的那个</span></span><br><span class="line">		self.st = wx.StaticText(self.pnl, pos =(<span class="number">200</span>, <span class="number">200</span>), \</span><br><span class="line">			lAbel = <span class="string">'鼠标点击空白处\n选择一个照片来玩拼图吧'</span>, \</span><br><span class="line">			style = wx.aligned_CENTER)</span><br><span class="line">		font.PointSize += <span class="number">16</span></span><br><span class="line">		self.font = font.Bold()</span><br><span class="line">		self.st.SetFont(self.font)</span><br><span class="line">		self.st.SetForegroundColour(<span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 绑定鼠标左键和下面的onleftdown方法</span></span><br><span class="line">		self.pnl.Bind(wx.EVT_LEFT_DOWN, self.onleftdown)</span><br><span class="line">		<span class="comment">#绑定键盘事件和下面的onkeydown方法</span></span><br><span class="line">		self.pnl.Bind(wx.EVT_KEY_DOWN, self.onkeydown)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">onleftdown</span><span class="params">(self, event)</span>:</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">not</span> self.fileOpen):</span><br><span class="line">			self.fileName = self.myfile()</span><br><span class="line">			<span class="keyword">if</span> os.path.basename(self.fileName).split(<span class="string">'.'</span>)[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">'png'</span>, <span class="string">'jpg'</span>, <span class="string">'jpeg'</span>, <span class="string">'bmp'</span>]:</span><br><span class="line">				self.fileOpen = <span class="literal">True</span></span><br><span class="line">				self.st.Destroy()</span><br><span class="line">				self.run()</span><br><span class="line"></span><br><span class="line">	<span class="comment">#如果已经完成了，那就不让你再玩了，否则就开始按键检测然后还是移动</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">onkeydown</span><span class="params">(self, event)</span>:</span></span><br><span class="line">		<span class="keyword">if</span>(self.fileLoad <span class="keyword">and</span> <span class="keyword">not</span> self.isfinish()):</span><br><span class="line">			myKey = [wx.WXK_LEFT, ord(<span class="string">'A'</span>), wx.WXK_RIGHT, ord(<span class="string">'D'</span>), wx.WXK_UP, ord(<span class="string">'W'</span>), wx.WXK_DOWN, ord(<span class="string">'S'</span>)]</span><br><span class="line">			keycode = event.GetKeyCode()</span><br><span class="line">			self.move(myKey.index(keycode)//<span class="number">2</span> <span class="keyword">if</span> (keycode <span class="keyword">in</span> myKey) <span class="keyword">else</span> <span class="number">-1</span>)</span><br><span class="line">		self.pnl.Layout()</span><br><span class="line">		self.isfinish()</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 出现让你选择图片的界面，返回文件绝对路径的文件名</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">myfile</span><span class="params">(self)</span>:</span></span><br><span class="line">		chooseFile = tk.Tk()</span><br><span class="line">		chooseFile.withdraw()</span><br><span class="line">		fileName = filedialog.askopenfilename()</span><br><span class="line">		<span class="keyword">return</span> fileName</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 从网上下一个表情包，返回值是位图用来加载</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">onlinefile</span><span class="params">(self)</span>:</span></span><br><span class="line">		url = <span class="string">'https://dna049.com/PythonGui/yes.png'</span></span><br><span class="line">		image = urlrequest.urlopen(url).read()</span><br><span class="line">		bData = base64.b64encode(image)</span><br><span class="line">		pData = bData.decode()</span><br><span class="line">		self.urlYes = PyEmbeddedImage(pData).GetBitmap()</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 把从本地选择出的图片进行调整大小，调整完之后切成3*3的块，然后在画板上画出来</span></span><br><span class="line">		<span class="comment"># 并且进行标记好更新，逻辑代码很短归功于Python的短小精湛！</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">writefile</span><span class="params">(self)</span>:</span></span><br><span class="line">		tmp = wx.Image(self.fileName)</span><br><span class="line">		im = tmp.ConvertToBitmap()</span><br><span class="line">		(sizeW, sizeH) = im.GetSize()</span><br><span class="line">		t = max(<span class="number">0.2</span>, sizeW/<span class="number">720</span>, sizeH/<span class="number">521</span>)+<span class="number">0.02</span></span><br><span class="line">		im = tmp.Scale(int(sizeW/t), int(sizeH/t)).ConvertToBitmap()</span><br><span class="line">		(sizeW, sizeH) = im.GetSize()</span><br><span class="line">		sizeW //= <span class="number">3</span>;sizeH //= <span class="number">3</span></span><br><span class="line">		self.img = []</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">			self.img += [im.GetSubBitmap(( (i%<span class="number">3</span>)*sizeW, (i//<span class="number">3</span>)*sizeH, sizeW, sizeH))]</span><br><span class="line">		self.img += [wx.Bitmap.FromRGBA(sizeW, sizeH, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>)]</span><br><span class="line">		self.lastPart = im.GetSubBitmap(( <span class="number">2</span>*sizeW, <span class="number">2</span>*sizeH, sizeW, sizeH))</span><br><span class="line">		ps = [((x%<span class="number">3</span>)*(sizeW +<span class="number">1</span>), (x//<span class="number">3</span>)*(sizeH+<span class="number">1</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">		self.sbt = [wx.StaticBitmap(self.pnl, bitmap = self.img[i], \</span><br><span class="line">			pos=ps[i], size=(sizeW, sizeH) ) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)] </span><br><span class="line"></span><br><span class="line">		<span class="comment"># 检测到鼠标左键按下，就开始看文件打开过没有，打开了就无视，没打开就开启文件选择</span></span><br><span class="line">		<span class="comment"># 打开成功之后就把部分提示关闭，然后开始为下一步拼图做准备</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">not</span> self.fileLoad):</span><br><span class="line">			self.fileLoad = <span class="literal">True</span></span><br><span class="line">			self.writefile()</span><br><span class="line">			self.disorder()</span><br><span class="line">			self.pnl.Layout()</span><br><span class="line">			self.hint.Show()</span><br><span class="line">			self.pnl.SetFocus()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">disorder</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">111</span>): self.move(randint(<span class="number">0</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self, direction)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> direction == <span class="number">0</span>:   self.moveleft()</span><br><span class="line">		<span class="keyword">elif</span> direction == <span class="number">1</span>: self.moveright()</span><br><span class="line">		<span class="keyword">elif</span> direction == <span class="number">2</span>: self.moveup()</span><br><span class="line">		<span class="keyword">elif</span> direction == <span class="number">3</span>: self.movedown()</span><br><span class="line"></span><br><span class="line">		<span class="comment">#判断是否是合理移动，合理就丢给下面函数更新</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span>	<span class="title">checkmove</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">		<span class="keyword">if</span>(end <span class="keyword">not</span> <span class="keyword">in</span> range(<span class="number">9</span>)):         <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		<span class="keyword">if</span>(start%<span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> end%<span class="number">3</span> == <span class="number">2</span>): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		<span class="keyword">if</span>(start%<span class="number">3</span> == <span class="number">2</span> <span class="keyword">and</span> end%<span class="number">3</span> == <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">moveleft</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span>(self.checkmove(self.eB, self.eB+<span class="number">1</span>)): self.sbtnew(self.eB, self.eB+<span class="number">1</span>);self.eB+=<span class="number">1</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">moveright</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span>(self.checkmove(self.eB, self.eB<span class="number">-1</span>)): self.sbtnew(self.eB, self.eB<span class="number">-1</span>);self.eB-=<span class="number">1</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">moveup</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span>(self.checkmove(self.eB, self.eB+<span class="number">3</span>)): self.sbtnew(self.eB, self.eB+<span class="number">3</span>);self.eB+=<span class="number">3</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">movedown</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span>(self.checkmove(self.eB, self.eB<span class="number">-3</span>)): self.sbtnew(self.eB, self.eB<span class="number">-3</span>);self.eB-=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># 如果操作合理，那就更新每个格子上的图片，并更新order列表</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sbtnew</span><span class="params">(self, posB, posA)</span>:</span></span><br><span class="line">		(x, y) = self.order[posB],self.order[posA] </span><br><span class="line">		self.order[posB], self.order[posA] = (y, x)</span><br><span class="line">		self.sbt[posB].SetBitmap(self.img[y])</span><br><span class="line">		self.sbt[posA].SetBitmap(self.img[x])</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 每次有按键的时候检测是否拼好了，拼好了就贴上最后一块并把表情包打印出来</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isfinish</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.order == [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]:</span><br><span class="line">			self.sbt[<span class="number">8</span>].SetBitmap(self.lastPart)</span><br><span class="line">			self.onlinefile()</span><br><span class="line">			wx.StaticBitmap(parent = self.pnl, bitmap = self.urlYes, pos=(<span class="number">500</span>, <span class="number">300</span>))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">		<span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 程序入口，进入__init__ 函数后，就开始进行鼠标和键盘的监听循环中</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	loveDays = datetime.now() - datetime(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">20</span>) </span><br><span class="line">	app = wx.App()</span><br><span class="line">	<span class="comment"># 创建上面类的对象，标题是喜欢zly妹妹，窗口不允许最大化，也不能调整大小</span></span><br><span class="line">	myGame = JigsawGame(<span class="literal">None</span>, \</span><br><span class="line">		title=<span class="string">'dna049 喜欢zly妹妹的第'</span>+str(loveDays.days)+<span class="string">'天'</span>, \</span><br><span class="line">		size = (<span class="number">800</span>, <span class="number">600</span>), \</span><br><span class="line">		style=wx.DEFAULT_FRAME_STYLE ^ wx.RESIZE_BORDER ^ wx.MAXIMIZE_BOX)</span><br><span class="line">	myGame.Show()</span><br><span class="line">	app.MainLoop()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>wx.EVT_KEY_DOWN 不响应 <code>Tab Enter → ↑ ↓ ←</code></p>
<p>wx.EVT_KEY_UP 响应所有键</p>
<p>wx.EVT_CHAR 仅响应<code>F1 - F12 PrintScreen  ScrollLock PauseBreak</code></p>
<p><strong>wx.Button 和 wx.EVT_KEY_DOWN 等冲突让我懵逼了吐了</strong> </p>
</blockquote>
<h3 id="还是解释一下代码吧"><a href="#还是解释一下代码吧" class="headerlink" title="还是解释一下代码吧"></a>还是解释一下代码吧</h3><ol>
<li>首先创建窗口，窗口名是喜欢 zly 妹妹的第 xxx 天，日常表白 0.0</li>
<li>窗口上放一个面板（panel）然后在上面放很多静态文本，比如我的博客呀，还有操作提示</li>
<li>然后绑定监听鼠标左键，按下了就会让你选择一个文件来玩拼图游戏</li>
<li>然后选择好了图片后，把图片平均切成 <code>3*3</code> 的块，最后一块（右下角)用黑白填充</li>
<li>把这些块打乱，打乱方式是随机的移动（防止随便打乱拼不回去）</li>
<li>监听 键盘 WASD 和上下左右键并写好相应的响应函数</li>
<li>每次接受到监听就检测是否拼好</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 入门</title>
    <url>/pythonLearning/</url>
    <content><![CDATA[<p>在苏铭和蓝莓带领下，最近开始学习 Python，下面是走过的坑，吐槽正式开始</p>
<blockquote>
<p>Python 在代码书写上要求极高，所有很多时候代码复制过来报错。。还有代码区分空格和 Tab</p>
<p>Python 中，对象赋值本质上是对象的引用</p>
<p>不要把 Python 代码写成 C/C++ 的风格！同样 SageMath 的代码也不要迁就 Python</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Python 官网慢的我想吐，几次都没有下下来，最后是在一次中午时分用手机流量定位了下载的地方，然后直接在电脑上手动输入长达 30 字符的网址（带文件名）直接下载，然后网速“飞快”，终于下下来了 26M 的 windows 64 位 Python3.8.2。然后就是用 pip 安装各种包，然后安装的时候真的是一头包，各种报错，各种而且奇慢无比，我吐了。后来终于找到解决方案：引用豆瓣源（其他源也行）。例子如下：</p>
<a id="more"></a>
<p><code>pip install numpy -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com</code></p>
<p><code>pip install wxPython -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com</code></p>
<p>安装好一些必要的包之后就可以跑程序了。</p>
<blockquote>
<p>pip freeze/list 查看所有安装了的包</p>
</blockquote>
<p><a href="https://pypi.org/" target="_blank" rel="noopener">PyPi</a> ：Python Package Index 查看所有发布的包的索引。</p>
<h2 id="简单的终端-Python-程序示例"><a href="#简单的终端-Python-程序示例" class="headerlink" title="简单的终端 Python 程序示例"></a>简单的终端 Python 程序示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># score.py</span></span><br><span class="line">tmp = input(<span class="string">'苏铭的Python分数：'</span>)</span><br><span class="line"><span class="keyword">if</span> tmp.isdigit():</span><br><span class="line">	score = int(tmp)</span><br><span class="line">	<span class="keyword">if</span> score &gt; <span class="number">100</span>:</span><br><span class="line">	    print(<span class="string">'我信了你的鬼话'</span>)</span><br><span class="line">	<span class="keyword">elif</span> score &gt;=<span class="number">60</span>:</span><br><span class="line">		print(<span class="string">'可以呀苏铭'</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		print(<span class="string">'菜的呀苏铭'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">'你输入的是什么鬼哦'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="简单的-GUI-Python-程序示例"><a href="#简单的-GUI-Python-程序示例" class="headerlink" title="简单的 GUI Python 程序示例"></a>简单的 GUI Python 程序示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.py</span></span><br><span class="line"><span class="keyword">import</span>	wx  <span class="comment">#需要安装wxPython包，见上面pip安装</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frame1</span><span class="params">(wx.Frame)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, superior)</span>:</span></span><br><span class="line">		wx.Frame.__init__(self, parent= superior, title = <span class="string">'Example'</span>,pos = (<span class="number">400</span>,<span class="number">200</span>),size=(<span class="number">350</span>,<span class="number">500</span>))</span><br><span class="line">		panel = wx.Panel(self)</span><br><span class="line">		text1 = wx.TextCtrl(panel,value = <span class="string">'Hello'</span>,pos = (<span class="number">250</span>,<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	app = wx.App()</span><br><span class="line">	frame = Frame1(<span class="literal">None</span>)</span><br><span class="line">	frame.Show(<span class="literal">True</span>)</span><br><span class="line">	app.MainLoop()</span><br></pre></td></tr></table></figure>
<h2 id="IDE-选择-sublime-大法好-VSCode-无敌"><a href="#IDE-选择-sublime-大法好-VSCode-无敌" class="headerlink" title="IDE 选择(sublime 大法好, VSCode 无敌)"></a>IDE 选择(<del>sublime 大法好</del>, VSCode 无敌)</h2><p>当时我是大 sublime 啊， 百度 sublime+ Python 就可以获得<a href="https://www.cnblogs.com/honkly/p/6599642.html" target="_blank" rel="noopener">完整教程</a> 配置 和 <a href="https://blog.csdn.net/gui951753/article/details/82667860#安装Python3和sublime3" target="_blank" rel="noopener">代码补全</a> 配置，安装 packageControl <strong>网速慢的话可以早上 7 点起来尝试</strong>。(缺点是每次要先 Ctrl+S 保存再 F5 编译，然后下次编译上次的编译窗口不能自己关，我也不知道怎么搞解决这两个问题，可惜！)</p>
<p><code>再也不用担心tab不是tab了！ view ---&gt;  Indentation ---&gt; Convert Indentation to tabs</code></p>
<p><code>多行注释：ctrl + shift + /</code></p>
<blockquote>
<p><strong>一定要配置代码补全!!!, 特别是在用各种包的时候</strong></p>
</blockquote>
<h2 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h2><ol>
<li>下载好 Python 后有自带文档</li>
<li><a href="https://www.runoob.com/Python/Python-tutorial.html" target="_blank" rel="noopener">Python 菜鸟教程</a></li>
<li>百度一下，你就知道。不行可以选择 <a href="cn.bing.com">必应</a></li>
<li>网易公开课，我选择的是南京大学的 Python 玩转数据，用手机 app 才能看，建议观看 1-25 集和 43-50 集。 1.5 倍速。</li>
<li>爬虫（下面示例）</li>
<li>Pygame 库的使用（<del>PY 游戏</del>，那也才刺激了吧 0.0）</li>
<li><a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">100 天学会 Python</a></li>
<li><a href="https://github.com/ageitgey/face_recognition" target="_blank" rel="noopener">人脸识别</a></li>
</ol>
<p>基本语法掌握了之后就要掌握类了，Python 的类挺有趣的，哈哈.类中写得变量是类的属性，而每个对象的属性要加 <code>self.</code> 的，然后方法里面的变量是方法内部临时变量。</p>
<h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initprime</span><span class="params">(n)</span>:</span></span><br><span class="line">    isp = [x%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">for</span> x  <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    isp[<span class="number">1</span>] = <span class="literal">False</span>;isp[<span class="number">2</span>]= <span class="literal">True</span></span><br><span class="line">    p = [<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> isp[i]: p.append(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> p:</span><br><span class="line">            <span class="keyword">if</span>(i*j&lt;=n):  isp[i*j] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i%j == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> isp,p</span><br><span class="line"></span><br><span class="line">print(initprime(<span class="number">100008</span>)[<span class="number">-1</span>][<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="爬虫示例"><a href="#爬虫示例" class="headerlink" title="爬虫示例"></a>爬虫示例</h2><p>总结爬虫方法：</p>
<ol>
<li>观察想要想要爬虫的网站中特定数据的网址，用 F12（适用于 Chorme, Edge 等）打开代码检查。找到数据对应的意义和名称</li>
<li>设计流程图和代码框架</li>
<li>Coding</li>
</ol>
<p>本来就不会写，学习了 <a href="https://leetcode-cn.com/circle/article/gy4iKU/" target="_blank" rel="noopener">leetcode</a> 上的代码后，制作了青春（<del>阉割</del>）版的爬取 lol 所有壁纸到当前文件夹的 lolIamge 文件夹中，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urlrequest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getimage</span><span class="params">(heroID)</span>:</span></span><br><span class="line">	heroId = str(heroID)</span><br><span class="line">	url = <span class="string">'https://game.gtimg.cn/images/lol/act/img/skin/big'</span> + heroId</span><br><span class="line">	heroDir = <span class="string">r'lolImage\\'</span> + heroId</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(heroDir):	os.mkdir(heroDir)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): </span><br><span class="line">		heroEnd = <span class="string">'0'</span> + str(i//<span class="number">10</span>) + str(i%<span class="number">10</span>) + <span class="string">'.jpg'</span></span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			image = urlrequest.urlopen(url + heroEnd).read()</span><br><span class="line">		<span class="keyword">except</span>:	<span class="keyword">break</span></span><br><span class="line">		imageName = heroDir + <span class="string">r'\\'</span> + heroEnd</span><br><span class="line">		<span class="keyword">with</span> open(imageName, <span class="string">'wb'</span>) <span class="keyword">as</span> f:	f.write(image)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'lolImage'</span>):	os.mkdir(<span class="string">'lolImage'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000</span>):	getimage(i)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python 处理字符串的 <code>split</code> 函数强的不行，给爬虫提供了特别便利的条件</p>
</blockquote>
<h2 id="机器学习示例"><a href="#机器学习示例" class="headerlink" title="机器学习示例"></a><a href="# http://open.163.com/newview/movie/free?pid=ME9KEIKS7&amp;mid=MEF16V4ED">机器学习示例</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello ML.py</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree <span class="comment"># https://sklearn.apachecn.org/</span></span><br><span class="line">features = [[<span class="number">140</span>,<span class="number">1</span>], [<span class="number">130</span>,<span class="number">1</span>],[<span class="number">150</span>,<span class="number">0</span>],[<span class="number">170</span>,<span class="number">0</span>]]</span><br><span class="line">lAbels = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">clf = tree.DecisionTreeClassifier()</span><br><span class="line">clf = clf.fit(features,lAbels)</span><br><span class="line">print(clf.predict([[<span class="number">160</span>,<span class="number">0</span>]]))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有需求再去这里学习吧：<a href="https://www.bilibili.com/video/BV164411S78V?from=search&amp;seid=1436888055285204045" target="_blank" rel="noopener">B 站视频</a>，<a href="http://www.ai-start.com/ml2014/html/" target="_blank" rel="noopener">对应笔记</a></p>
</blockquote>
<h2 id="有趣的-Python-特征"><a href="#有趣的-Python-特征" class="headerlink" title="有趣的 Python 特征"></a>有趣的 Python 特征</h2><ul>
<li>内联表达式：[i**2 for i in range(10)]</li>
<li><a href="https://raycoder.me/post/5mrednz2a/" target="_blank" rel="noopener">exec 函数</a> 执行 Python 代码（一般用于文件读取）</li>
<li>元组（tuple）可以做加法和乘法来改变它的值！但是本质上元组的值并没有改变，只是新开了一段连续的内存，然后用刚刚那个指针指向了这段内存！！！所以<strong>元组是不可变的</strong>这句话没毛病</li>
<li>一个元素构成的元组要写成<code>(a,)</code>形式，是因为否则到处都是元组 0.0（因为我们在处理优先级的时候经常加<code>()</code>）</li>
<li>上述说明了为什么内联表达式不支持用 tuple，用的是 list（列表）</li>
<li>生成器可以用 list and tuple，搞完生成器就空了</li>
<li><code>map(func,data)</code> 一次算一堆的值。</li>
<li>Python 中没有<code>++,--</code> 这类自增自减运算</li>
</ul>
<h2 id="打包成可执行文件（-exe）"><a href="#打包成可执行文件（-exe）" class="headerlink" title="打包成可执行文件（.exe）"></a>打包成可执行文件（.exe）</h2><p> 最简单的方法： pip 安装 pyinstaller (借助豆瓣源，见安装段落)，然后执行</p>
<p><code>pyinstaller -F example.py -w</code></p>
<blockquote>
<p>其中 <code>-F</code> 表示单个文件， <code>-w</code> 表示关闭命令行窗口</p>
</blockquote>
<p>问题是，一个几 kb 的 Python 程序，打包就 10M+ 。。。这谁顶得住啊，<a href="https://www.zhihu.com/question/281858271" target="_blank" rel="noopener">解决方案</a> </p>
<blockquote>
<p><a href="https://blog.csdn.net/ZhaDeNianQu/article/details/87717293" target="_blank" rel="noopener">反解析和防止被反解析</a></p>
</blockquote>
<h2 id="datetime-包学习（哈哈哈）"><a href="#datetime-包学习（哈哈哈）" class="headerlink" title="datetime 包学习（哈哈哈）"></a>datetime 包学习（哈哈哈）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">day = now - datetime.datetime(<span class="number">2019</span>,<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">print(<span class="string">'喜欢茶茶子妹妹的第'</span>+str(day.days)+<span class="string">'天'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>每个包都有各自的代码规范，使用的时候注意一点可以省很多麻烦。个人比较喜欢的代码规范方式：</p>
<ol>
<li>逗号后面加空格 <code>,</code></li>
<li>类的手写字母大写，例如：<code>class MyHoney():</code></li>
<li>函数或者类的方法全小写</li>
<li>变量或者类中属性首单词字母小写，后面单词首部大写，例如 <code>myName</code></li>
<li>常量全大写</li>
<li>个人不是很喜欢用下划线，不过也是一个不错的选择</li>
<li>函数，类中方法，模块隔行显示</li>
<li>用 tab 缩进，用空格对齐 (强烈抵制用 4 个空格代替 tab！！！)</li>
<li><a href="/syntacticSugar/" title="多用语法糖">多用语法糖</a>
</li>
</ol>
<h2 id="Python-之禅（Zen-of-Python）"><a href="#Python-之禅（Zen-of-Python）" class="headerlink" title="Python 之禅（Zen of Python）"></a>Python 之禅（Zen of Python）</h2><p>在 Python 命令行中输入 <code>import this</code> 就会出现：</p>
<blockquote>
<p>The Zen of Python, by Tim Peters</p>
<p>Beautiful is better than ugly.<br>Explicit is better than implicit.<br>Simple is better than complex.<br>Complex is better than complicated.<br>Flat is better than nested.<br>Sparse is better than dense.<br>Readability counts.<br>Special cases aren’t special enough to break the rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In the face of ambiguity, refuse the temptation to guess.<br>There should be one— and preferably only one —obvious way to do it.<br>Although that way may not be obvious at first unless you’re Dutch.<br>Now is better than never.<br>Although never is often better than <em>right</em> now.<br>If the implementation is hard to explain, it’s a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>Namespaces are one honking great idea — let’s do more of those!</p>
</blockquote>
<p>就不翻译了，最喜欢的一句:</p>
<p> <strong>Now is better than never although new is often better that <em>right</em> now</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算及其在 Nim 游戏中的应用</title>
    <url>/xorAndItsApplicationInNimGame/</url>
    <content><![CDATA[<p>异或运算是一种很神奇用途很广的运算. 从性质上, 异或运算作为二元运算, 关于所有非负整数构成一个 Abel 群, 0 作为幺元, 每个元的逆元都是自身(等价于说 $char(N ^ \star,xor)=2$)。</p>
<a id="more"></a>
<h2 id="异或的定义和简单性质"><a href="#异或的定义和简单性质" class="headerlink" title="异或的定义和简单性质"></a>异或的定义和简单性质</h2><p>异或, 英文: exclusive OR, 缩写 xor, 习惯记作 $\wedge$。这个运算 $1\wedge 1=0\wedge 0=0,1\wedge 0=0\wedge 1=1$。 对任意是两个非负整数 $a,b$ 将其写成二进制, 然后各位分别进行异或操作即可. 容易根据上面定义说明之前提到的性质. 下面再介绍一个重要但不是很明显的性质:</p>
<p><strong>引理</strong>: 若 $k=a_1\wedge ⋯\wedge a_n≠0$ 则必然存在 $i$, 使得 $a_i \wedge k&lt;a_i$。<br>证明: 因为 $k \neq 0$, 所以必然记 $k$ 得最高位是第 $t$ 位, 则必然存在 $i$, 使得 $a_i$ 的第 $t$ 为不为 0(否则 $k$ 的第 $t$ 位的 1 咋来的). 那么此时 $a_i \wedge k$ 的第 $t$ 为 0, 前面的位不变, 从而小于 $a_i$。</p>
<h2 id="异或的简单应用"><a href="#异或的简单应用" class="headerlink" title="异或的简单应用"></a>异或的简单应用</h2><p>简单的直接贴代码吧, 不废话.</p>
<h3 id="用异或来改变两个数"><a href="#用异或来改变两个数" class="headerlink" title="用异或来改变两个数"></a>用异或来改变两个数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">swap(UI &amp; a, UI &amp; b)&#123;</span><br><span class="line">	a = a^b;</span><br><span class="line">	b = a^b;</span><br><span class="line">	a = a^b</span><br><span class="line">&#125; <span class="comment">// UI 表示 unsigned int, 写的很骚气.</span></span><br></pre></td></tr></table></figure>
<h3 id="异或找出唯一出现奇数次的数"><a href="#异或找出唯一出现奇数次的数" class="headerlink" title="异或找出唯一出现奇数次的数"></a>异或找出唯一出现奇数次的数</h3><p>把这一堆数全体直接异或即可.</p>
<blockquote>
<p>这个方法可以推广到找出两个只出现奇数次的, 其它出现偶数次的两个数, 方法就是先异或之后的值按照最高位进行标记然后分成两组, 再来一遍.</p>
</blockquote>
<h2 id="Nim-取石子问题"><a href="#Nim-取石子问题" class="headerlink" title="Nim 取石子问题"></a>Nim 取石子问题</h2><p>在 2002 年国家 IO 集训队中张一飞写了<a href="nimGame.pdf">&lt;&lt;由感性认识到理性认识——透析一类搏弈游戏的解答过程&gt;&gt;</a>中明确的表面了这个取 Nim 石子游戏用异或可以完美的解决.</p>
<blockquote>
<p>我把他结果简单表达如下, 并在做一点小小的改变之后得到类似的结果</p>
</blockquote>
<p>游戏规则 1 : 甲乙两人面对若干堆石子，其中每一堆石子的数目任意给定, 两人轮流取走一些石子, 每次至少取一枚石子, 每次只能从某一堆中取, 可以取完, 谁无法取子, 谁就是输家(规则 2 正好相反).</p>
<blockquote>
<p>在规则 1 中张一飞一步一步由浅入深, 从具体例子过度到理性的判断, 最终给出若所有石子数异或结果为 0, 则后手胜, 反之先手胜.</p>
</blockquote>
<p>首先对于此类取石子博弈问题: <strong>必败准则</strong></p>
<blockquote>
<p>必胜局面必然存在一步转化成为一个必负局面;<br>必负局面必然任意一步转化都会成为必胜局面.</p>
</blockquote>
<p>而对于异或也有类似的结果: $k=a_1\wedge  \cdots \wedge a_n$</p>
<blockquote>
<p>若 $k \neq 0$ 由引理知道, 可以减小某个 $a_i$ 使得之后的异或和为 0.<br>若 $k=0$, 则任意改变都会导致异或和不为 0.</p>
</blockquote>
<p>这样操作下去堆数一定在一直减小.<br>对于规则 1: 由于空局面是负局面容易看出, 若异或和为 0 则先手负, 反之先手胜.<br>而对于规则 2, 由于空局面是胜局面,而 1 局面是负局面, 这就有些尴尬了. 并且局面并不能像规则 1 一样进行局面分解, 因此十分麻烦.</p>
<h3 id="规则-2-的感性判断"><a href="#规则-2-的感性判断" class="headerlink" title="规则 2 的感性判断"></a>规则 2 的感性判断</h3><ol>
<li>去掉任意多的 0 和偶数个 1 并不会影响结果(是对的, 但是要分情况推敲一下)</li>
<li>无法根据子局面的胜负来判断总局面的胜负.</li>
<li>负局面的价值远远高于胜局面, $(1),(n,n&gt;1),(1,2n,2n+1)$, 奇数个 1, 偶数个 2 是负局面(用数学归纳法容易证明)</li>
<li>从小的开始枚举, 为被负局面包含的极小局面是胜局面, 被所有胜局面包围的是负局面, 这样可以一直进行下去直到得到我们的结果.</li>
<li>前戏终于结束了, 要来真的了 0.0(好害怕)</li>
</ol>
<h3 id="规则-2-的理性判断"><a href="#规则-2-的理性判断" class="headerlink" title="规则 2 的理性判断"></a>规则 2 的理性判断</h3><p>经过总时长 8 个小时左右的零碎时间思考, 最终给出下面结果:</p>
<ol>
<li>首先我们先剔除所有 0 和偶数个 1 得到新的局面至多有一个 1. 如果为空, 则为胜局面.</li>
<li>对于堆数 $n=1$ 的情形,  $a1=1$ 为负局面, 其它为胜局面.<br>对于堆数 $n&gt;1$ 是若 $a_1\wedge ⋯\wedge a_n=0$ 为负局面, 其它为胜局面.<br><strong>证明</strong>: 首先证明结论对 $n=2$ 是成立, 即 $a_1=a_2$(不可能同时为 1)时是负局面, 因为 $a_1=a_2=2$是负局面, 若 $a_1=a_2&lt;k$ 是负局面, $a_1=a_2 = k$, 则下一步必然是 $(a1,a2)=(m&lt;k,k)$ 为胜局面(若 $m=0,1$ 时显然, 否则下一步 $(a_1=a2)=(m,m)$ 为负局面). 因此结论对 $n=2$ 成立. 现在若结论对于 $n&lt;k$ 成立, 那么由引理若 $a_1\wedge ⋯\wedge a_n=0$ 则下一步必然导致 $a′_1 \wedge ⋯ \wedge a′_n \neq 0$. 若其中某个 $a′_i=0$, 那么由归纳法必然导致结论成立. 那么后手就可以取走一些石子导致 $a′′_1 \wedge ⋯\wedge a′′_n=0$. 另外一出现多于 2 个 1 直接剔除(不会改变异或和的值). 这样下去堆数必然减少, 由归纳法可知结论成立.</li>
</ol>
<p>例如<code>1∧3∧5∧7=0</code> 从而可以判断这是一个负局面.(可以简单试试这个策略玩一玩这个游戏)</p>
<blockquote>
<p>感谢张一飞的论文, 感谢 FDU 高数杭老师提供题目, 感谢蔡学弟把问题分享给我。感谢网友批评指正。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Matsumura《Commutative Algebra》读书笔记</title>
    <url>/commutativeAlgebraByMatsumura/</url>
    <content><![CDATA[<p>在学习非交换环论的过程中, 发现交换环有些东西依然没搞清楚, 复习一下, 顺便再理一理 Matsumura 这本言简意赅的《Commutative Algebra》. 以下环都是指 <strong>含幺交换环(commutative ring with identity)</strong></p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>可以说书中没一句废话, 开头直接给出下面概念, 并且叙述一些常见等价刻画: </p>
<ol>
<li><p>理想的 radical 的定义</p>
</li>
<li><p>prime ideal 的(等价)定义</p>
</li>
<li><p>primary ideal 的定义, 说明 primary ideal 的 radical 是 prime ideal (反之不尽然), 并给出一个理想成为 primary ideal 的充分条件: 包含某个极大理想的某次幂.</p>
</li>
<li><p>定义了环 $A$ 上的 Zariski 拓扑(素谱) $Spec(A)$, 极大谱 $\Omega(A)$, 包含某个集合的素理想全体构成闭集(容易验证确实构成拓扑空间), 给出素谱的基本开邻域基. 由于每个理想都包含在某个极大理想中, 极大理想都是素的, 因此 $Spec(A) = \emptyset \Leftrightarrow A = 0$, 也就是说 $Spec$ 的定义是没有毛病的. $Spec(A)$ 连通当且仅当 $A$ 中无非平凡幂等元.</p>
<script type="math/tex; mode=display">
V(I) = V(J) \Longleftrightarrow \sqrt{I} = \sqrt{J}</script></li>
<li><p>说明环之间的同态映射 $f: A \to B$ 可以诱导 $Spec(B) \to Spec(A)$ 之间的连续映射, 也就是说 $Spec$ 定义了一个环范畴到拓扑空间范畴的一个逆变函子.</p>
</li>
<li><p>给出了一个关于素理想并的常见引理: 一个理想包含在最多两个不是素理想的理想的并中, 则它必然包含在其中一个理想中. 当然这也说明了任意两个真理想的并不会是整个环.</p>
</li>
<li><p>给出了两个理想互素的定义(和为整个环), 并说明此时它们的积等于交. 证明用到 $(I+J)(I \cap J) \subset IJ$.</p>
</li>
<li><p>定义乘闭子集 $S$ 准备做局部化, 应用 Zorn 引理说明与 $S$ 不相交的理想中任意极大元都是素理想, 由此可以证明: $A$ 中幂零元全体 $nil(A)$ 是 $A$ 中所有素理想的交, 也等于 $A$ 中所有极小素理想的交. 再由此结论, 可以说明每个理想 $I$ 的 radical: $\sqrt{I}$ 是所有包含 $I$ 的素理想的交.</p>
</li>
<li><p>定义环 $A$ 在 $S$ 处的局部化 $S^{-1}A$. $S^{-1}A = 0 \Leftrightarrow 0 \in S$. 并且我们有自然映射 $\phi : A \to S^{-1}A, \quad a \mapsto a/1$, 它满足泛性质: 若 $f: A \to B$ 是环同态, 且 $f(S)$ 均为 $B$ 中可逆元, 那么有 $g: S^{-1}A \to B$ 使得 $f = g \phi$</p>
</li>
<li><p>$A$ 中与 $S$ 不交的理想(素, 准素)和 $S^{-1}A$ 中的理想(素, 准素)有保序一一对应.</p>
</li>
<li><p>类似于环, 可以对模 $M$ 作局部化$S^{-1}M \simeq S^{-1}A \otimes M$, 这个同构可以由两个自然的合理的互逆映射给出. 并且我们还有同构 $S^{-1}(M \otimes N) = S^{-1} M \otimes S^{-1}N$. 由于张量函子右正合, 用定义可以证明 $S^{-1}A \otimes -$ 是正合函子. 也就是说 $S^{-1}A$ 是平坦 $A$-模.</p>
</li>
<li><p>给出有限表示(finite presentation)的定义: 即一个有限生成模, 且其生成关系也是有限生成的. 等价于说有正合列: $A^m \to A^n \to M \to 0$ 此时我们有:</p>
<script type="math/tex; mode=display">
S^{-1}(\hom(M,N)) \simeq \hom(S^{-1}M, S^{-1}N)</script><p>证明的关键在于对于自由模$M=A^n$时有上述自然同构, 再由有限表示, 应用 five lemma 证明上式.</p>
</li>
<li><p><strong>局部整体关系</strong> $M \to \prod_{\max p} M_{p}$ 是单的. 其中 $M_{p} = (A - p)^{-1} M$. 证明应用定义说明 $Ann(x) = A$ 即可.</p>
</li>
<li><p><strong>整环的特殊情形</strong> 当 $A$ 为整环时, $A$ 在任意乘闭子集处的局部化都可以看做它的分式域的子环, 实际上我们有</p>
<script type="math/tex; mode=display">
A = \bigcap_{\max p} A_{p}</script><p>证明类似整数作有理数. 定义 $D = \lbrace a \in A \mid ax \in A \rbrace$ 说明若 $x \notin A$ 可知 $D \subset A$ (真包含), 因此 $D$ 在某个极大理想 $P$ 中, 可推出 $x \notin A_{P}$.</p>
</li>
<li><p>我们有自然的同构 $A/I \otimes M \simeq M/IM$, 同构可由正合列 $0 \to I \to A \to A/I \to 0$, 用 $- \otimes M$ 作用上去, 再由定义有 $I \otimes M \to IM$ 的自然满同态( $M$ 平坦时可以说明是同构), 得到正合列: $0 \to IM  \to M \to A/I \otimes M \to 0$<br>特别地, 我们有: $S^{-1}(A/I) = S^{-1}A / I(S^{-1}A)$</p>
</li>
<li><p><strong>Jacobson radical</strong>: $rad(A) = \lbrace x \mid 1+xy \in U(A) \rbrace$ 为所有极大理想的交.</p>
</li>
<li><p><strong>局部环</strong>: 若环 $A$ 只有一个极大素理想 $\mathfrak{m}$, 则称 $A$ 为局部环, $A/\mathfrak{m}$ 称为 $A$ 的 residue field.<br>局部环之所以重要是因为, 任意环 $A$ 在素理想 $p$ 处作局部化都是一个局部环 $A_p$. 此时 $A_p$ 的 residue field 记作 $k(p)$. 它恰好是整环 $A/p$ 的分式域 $K(A/p)$. 由 $A \to A/p$ 到 $A_p \to K(A/p)$ 因此, 我们有 $k(p) \simeq K(A/p)$</p>
</li>
<li><p><strong>局部映射</strong>: 若环 $(A, \mathfrak{m}, k)$ 和 $(A’, \mathfrak{m}’, k’)$ 为局部环, 且有环同态 $\phi: A \to A’$ 使得 $\phi(\mathfrak{m}) \subseteq \mathfrak{m}’$, 则称为局部映射, 此时 $\phi$ 自然诱导了环同态 $k \to k’$.<br>现在对任意环同态 $\phi: A \to B$, 考虑连续映射</p>
<script type="math/tex; mode=display">
\hat{\phi}: Spec(B) \to Spec(A), \quad P \to \phi^{-1}(P) = P \cap A = p</script><p>此时 $\phi(A-p) \subseteq B-P$, 即 $\phi$ 诱导了局部映射 $\phi_P: A_p \to B_P$.</p>
</li>
<li><p><strong>半局部环</strong> 若环 $A$ 只有有限个极大理想 $\mathfrak{m}_1, \mathfrak{m}_2, \cdots , \mathfrak{m}_r$, 则称 $A$ 为半局部环(semilocal ring).<br>由于不同极大理想必然互素, 因此</p>
<script type="math/tex; mode=display">
rad(A) = \mathfrak{m}_1 \cap \cdots \cap \mathfrak{m}_r = \prod \mathfrak{m}_i</script></li>
<li><p><strong>NAK lemma</strong> 设 $I$ 是环 $A$ 的理想, $M$ 是有限生成(f.g.) $A$-模. 若 $IM = M$, 则存在 $t \in I$ 使得 $(1+t)M = 0$, 特别地, 若还有 $I \subseteq rad(A)$, 则 $M=0$.<br><strong>Proof</strong>: 设 $M=Am_1 + \cdots + Am_s$, 对 $s$ 数学归纳, $s=0$ 时, 结论显然, 设 $M’ = M / Am_s$, 则由归纳假设, $\exists x \in I$ 使得 $(1+x)M’=0$, 即 $(1+x)M \subseteq Aw_s$, 由于 $M = IM$, 我们有 $(1+x)M = I(1+x)M \subseteq I(Aw_s) = Iw_s$, 因此存在 $y \in I$ 使得 $(1+x)w_s = yw_s$. 所以<br>$(1+x-y)(1+x)M = 0$, $t = x-y+x+(x-y)x$ 即为所求.<br><strong>NAK lemma</strong> 常用如下应用形式: $I$ 为环 $A$ 的理想, $N \subset M$ 为 $A$-模, 若 $M = N + IM$, 且 $I$ 幂零或 $M$ 有限生成, 则 $M=N$.</p>
</li>
</ol>
<blockquote>
<p>不要以为有限生成, 理想幂零, 环是整环或者 reduced 条件很苛刻, 其实实际碰到的也都是这些环, 主要问题在于有没有丰富的结果, 这些条件在何时发挥着作用. 有限生成可以用数学归纳, 幂零理想可以用于幂次和根理想.</p>
</blockquote>
<ol>
<li>给定局部环 $(A, \mathfrak{m},k)$ , $M$ 是 $A$-模, 若 $\mathfrak{m}$ 幂零(例如 $A$ 是 Artinian)或者 $M$ 有限生成, 则 $M$ 的子集 $G$ 生成 $M$, 当且仅当它在 $M/\mathfrak{m}M = M \otimes k$ 下像 $\bar{G}$ 生成 $M \otimes k$.</li>
</ol>
<blockquote>
<p>由于 $M \otimes k$ 是域 $k$ 上的向量空间, 因此它的一组基提升之后就能生成 $M$, 但是一般地并不能保证这些生成元线性无关.</p>
</blockquote>
<ol>
<li><p>$M$-regular: $a \in A$ 称为 $M$-regular, 若 $0 \to M \xrightarrow{a} M$, 显然, $M$-regular 元全体构成了一个乘闭子集. 设 $S_0$ 为 $A$-regular 元全体, 则 $S_0^{-1}A$ 称为 $A$ 的 total quotient ring. 此时 $\phi: A \to S_0^{-1} A$ 是环单同态.</p>
</li>
<li><p>若 $M$ 是 Noetherian 环 $A$ 上有限生成模,那么我们有投射表示:</p>
<script type="math/tex; mode=display">
\cdots \to X_i \to X_{i+1} \to \cdots X_0 \to M \to 0</script><p>其中 $X_i$ 为有限自由 $A$-模, 特别地, 此时 $M$ 是有限表示(finite presentation). 此时多项式环 $A[x_1, \cdots, x_n]$ 也是 Noetherian, 类似的形式幂级数环 $A[[x_1, \cdots, x_n]]$ 也是 Noetherian, $A$ 上的有限维代数也是 Noetherian.</p>
</li>
</ol>
<blockquote>
<p>任意环中, 理想链的长度不低于极大理想的个数.</p>
</blockquote>
<ol>
<li><p>环 $A$ 是 Artinian, 当且仅当它作为 $A$-模是有限长的, 当且仅当它是 Noetherian, 并且它的素理想都是极大的.</p>
</li>
<li><p>设 $\mathfrak{a}$ 是环 $A$ 的理想, $b \in A$, 若 $\mathfrak{a} + bA$ 和 $\mathfrak{a}:bA$ 都有限生成, 则 $\mathfrak{a}$ 有限生成.<br><strong>Proof</strong>: 设 $a_i \in \mathfrak{a},\quad b_j \in A$ 使得 $\mathfrak{a} + bA = \sum a_iA + bA$ 且 $\mathfrak{a} : bA = \sum c_j A$. 设 $\mathfrak{a}’ = \sum a_iA + \sum bc_j A \subseteq \mathfrak{a}$. 对任意 $a \in \mathfrak{a}$, 我们有 $a \in \mathfrak{a}’ + bA$, 即 $a \equiv rb \mod \mathfrak{a}’$. 因此 $rb \in \mathfrak{a}$. 即 $r \in \mathfrak{a}: bA$, $rb \in \mathfrak{a}’$, 因此 $a \in \mathfrak{a}’$, 即 $\mathfrak{a} = \mathfrak{a}’$.</p>
</li>
<li><p>(Cohen)环 $A$ 是 Noetherian, 当且仅当它的每个素理想都是有限生成的.<br><strong>Proof</strong>: 记 $A$ 中所有非有限生成理想构成的集合为 $F$, 取 $F$ 中极大元 $\mathfrak{a}$ (Zorn 引理保证可行性), 那么由条件知道 $\mathfrak{a}$ 不是素理想, 因此存在 $a,b \in A$, 使得 $a, b \notin \mathfrak{a}$ 且 $ab \in \mathfrak{a}$. 又因为 $\mathfrak{a}$ 的极大性知: $\mathfrak{a}+bA$ 和 $\mathfrak{a}:bA$ 有限生成, 所以 $\mathfrak{a}$ 有限生成, 所以 $F = \emptyset$.</p>
</li>
<li><p>定义 $Supp(M) = \lbrace p \in Spec(A) \mid M_p \neq  0 \rbrace$. 若 $M$ 有限生成, 则 $Supp(M) = V(Ann(M))$. 此时 $Supp(M)$ 就是零化 $M$ 的理想的闭包, 没毛病, 完美.</p>
</li>
</ol>
<h2 id="平坦性-Flatness"><a href="#平坦性-Flatness" class="headerlink" title="平坦性(Flatness)"></a>平坦性(Flatness)</h2><p>设 $S: \quad \cdots \to N  \to N’ \to N’’ \to \cdots$ 是任意 $A$-模序列.<br>称 $A$-模 $M$ 是平坦的, 如果 $S$ 正合, 则 $S \otimes M$ 正合.<br>称 $M$ 忠实平坦的(faithful flat), 如果 $S$ 正合当且仅当 $S \otimes M$ 正合.<br>例子: 投射模是平坦的, 自由模是忠实平坦的.</p>
<h4 id="平坦模的等价刻画"><a href="#平坦模的等价刻画" class="headerlink" title="平坦模的等价刻画"></a>平坦模的等价刻画</h4><ol>
<li>$M$ 是平坦的.</li>
<li>若 $0 \to N \to N’$ exact, 则 $0 \to N \otimes M \to N’ \otimes M$ exact.</li>
<li>对任意(有限生成)理想 $I$, $0 \to I \otimes M \to M$ exact. 即 $I \otimes M \simeq IM$.</li>
<li>$Tor_1 ^A(M,A/I) = 0$ 对任意(有限生成)理想 $I$ 成立.</li>
<li>$Tor_1 ^A(M,N) = 0$ 对任意(有限生成)模 $N$ 成立.</li>
<li>若 $\sum a_i x_i = 0$, 则存在 $b_{ij} \in A, y_j \in M$ 使得 $\sum a_i b_{ij} = 0$ 且 $x_i = \sum b_{ij}y_j$.</li>
</ol>
<h4 id="平坦模的基本性质"><a href="#平坦模的基本性质" class="headerlink" title="平坦模的基本性质"></a>平坦模的基本性质</h4><p><strong>Transitivity</strong>: 设 $\phi: A \to B$ 是平坦环同态(即 $B$ 看做 $A$-模是平坦的), 那么平坦 $B$-模 $N$ 也是平坦 $A$-模. (直接用定义证明即可)</p>
<p><strong>Change of base</strong>: 设 $\phi: A \to B$ 是环同态, 若 $M$ 是平坦 $A$-模, 则 $M \otimes B$ 是平坦 $B$-模.</p>
<p><strong>Localization</strong>: $S^{-1}A$ 是平坦 $A$-模. (直接用元素定义可证)</p>
<p><strong>Tor 函子和张量函子交换</strong>: 设 $\phi: A \to B$ 是平坦同态, $M,N$ 是 $A$-模, 则有</p>
<script type="math/tex; mode=display">
Tor_i ^A(M,N) \otimes _A B = Tor_i ^B(M \otimes_A B,N \otimes_A B)</script><p>当 $A$ Noetherian 且 $M$ 有限生成, 则</p>
<script type="math/tex; mode=display">
Ext_i ^A(M,N) \otimes _A B = Ext_i ^B(M \otimes_A B,N \otimes_A B)</script><p><strong>Proof</strong>: 给定 $M$ 的一个投射(自由)表示: $\cdots \to X_1 \to X_0 \to M \to 0$. 由于 $B_A$ 平坦, 我们得到 $M \otimes_A B$ 的投射表示: $\cdots \to X_1 \otimes_A B  \to X_0 \otimes_A B \to M \otimes_A B \to 0$. 因此我们有:</p>
<script type="math/tex; mode=display">
Tor_i ^B(M \otimes_A B,N \otimes_A B) = H_i(X. \otimes_A N \otimes_A B) = H_i(X. \otimes_A N)\otimes_A B = Tor_i ^A(M,N) \otimes _A B</script><p>当 $A$ Noetherian 且 $M$ 有限生成时, 我们可以给 $M$ 的一个有限自由表示, 再由 $B$ 平坦得到了, $M \otimes _A B$的有限自由表示:<br>$\cdots \to X_1 \otimes_A B \to X_0 \otimes_A B \to M \otimes_A B \to 0$ 由此得到复形:</p>
<script type="math/tex; mode=display">
0 \to \hom_B(M \otimes _A B, N \otimes _A B) \to  \hom_B(X_0 \otimes _A B, N \otimes _A B) \to \hom_B(X_1 \otimes _A B, N \otimes _A B) \to \cdots</script><p>由于 $X_i$ 是有限自由模, 因此 $\hom_B(X_i \otimes B, N \otimes B) = \hom_A(X_i, N) \otimes _A B$. 所以</p>
<script type="math/tex; mode=display">
Ext_i ^B(M \otimes_A B,N \otimes_A B) = H_i(\hom_A(X_i, N) \otimes _A B) = H_i(\hom_A(X_i, N)) \otimes _A B = Ext_i ^A(M,N) \otimes _A B</script><blockquote>
<p>特别地, 去 $B = S^{-1}A$.</p>
</blockquote>
<p>设 $M$ 是平坦 $A$-模, 则 $A$-regular 元都是 $M$-regular 元. 这只因为 $0 \to A \xrightarrow{a} A$ 可推出 $0 \to M \xrightarrow{a}M$.</p>
<h4 id="局部环上有限生成模是自由模"><a href="#局部环上有限生成模是自由模" class="headerlink" title="局部环上有限生成模是自由模"></a>局部环上有限生成模是自由模</h4><p>$(A,\mathfrak{m},k)$ 是局部环, $M$ 是平坦 $A$-模, 若 $\mathfrak{m}$ 幂零或 $M$ 有限生成, 则 $M$ 是自由模.<br>在<strong>基本概念 21</strong>中, $G$ 生成了 $M$, 如果 $G$ 中元素线性无关, 那么 $G$ 自然就是 $M$ 的一组基(从而是自由模), 也就是说, 我们只需证明 $G =\lbrace x_1 \cdots x_n \rbrace$在 $M/mM = M \otimes k$下的象线性无关, 则由 $G$ 线性无关. 而<strong>$\mathfrak{m}$ 幂零或 $M$ 有限生成</strong>这个条件本质上是保证 $M/mM \neq 0$ (由 NAK lemma). 然后对 $n$ 应用数学归纳, 并利用 <strong>平坦模等价刻画 6</strong> 说明线性无关性. 从而命题得证.</p>
<blockquote>
<p>局部环上的投射模都是自由模</p>
</blockquote>
<h4 id="平坦模"><a href="#平坦模" class="headerlink" title="平坦模"></a>平坦模</h4><p>设 $A \to B$ 是平坦同态, 设 $I,J$ 是 $A$ 是理想, 则</p>
<ol>
<li>$(I \cap J)B = IB \cap JB$ </li>
<li>$(I : J)B = IB : JB$, 其中$J$是有限生成的.</li>
</ol>
<p><strong>Proof</strong>: 由正合列: $0 \to I \cap J \to A \to A/I \otimes A/J$, 张量上 $B$得到 $0 \to (I \cap J)B \to B \to B/IB \otimes B/JB$. 因此 $(I \cap J)B = IB \cap JB$.<br>当 $J$ 有限生成时, 只需证明 $J = aA$ 的形式: 由正合列 $0 \to (I :aA) \to A \xrightarrow{f} \to A/I$. 其中 $f(x) = ax \mod I$. 张量上 $B$ 即可得到结论, 对于一般情况应用</p>
<script type="math/tex; mode=display">
(I: \sum_{i=1} ^n a_i A) = \bigcap_{i=1} ^n (I : a_i A)</script><blockquote>
<p>平坦映射讲一个保持理想的交, 一种反映平坦的地方吧.</p>
</blockquote>
<h4 id="平坦的局部整体性"><a href="#平坦的局部整体性" class="headerlink" title="平坦的局部整体性"></a>平坦的局部整体性</h4><p>设 $f: A \to B$ 是环同态(即 $B$ 是交换结合 $A$ 代数), 那么下面条件等价:</p>
<ol>
<li>$B$ 作为 $A$-模平坦.</li>
<li>$B_P$ 作为 $A_p$-模平坦, 其中 $p = P \cap A, \quad P \in Spec(B)$</li>
<li>$B_P$ 作为 $A_p$-模平坦, 其中 $p = P \cap A, \quad P \in \omega(B)$<br><strong>Proof</strong>: $1 \to 2 \to 3$ 显然, $3 \to 1$, 只需证明 $Tor_1 ^A(B,N)=0$. 由$Tor_1 ^{A_p}(B_P, N_p) = 0, P \in \omega(B)$. 知道结论成立.</li>
</ol>
<h3 id="忠实平坦-faithful-flat-f-f"><a href="#忠实平坦-faithful-flat-f-f" class="headerlink" title="忠实平坦 faithful flat (f.f.)"></a>忠实平坦 faithful flat (f.f.)</h3><p>一个自然的问题, 平坦模何时成为忠实平坦模呢?<br>设 $M$ 是 $A$-模, 下面条件等价</p>
<ol>
<li>$M$ 是 f.f. $A$-模;</li>
<li>$M$ 是平坦 $A$-模, 且对任意 $A$-模 $N \neq 0$, $N \otimes M \neq 0$;</li>
<li>$M$ 是平坦 $A$-模, 且对任意 $A$ 的极大理想 $\mathfrak{m}$, $mM \neq M$.<br><strong>Proof</strong>: $1 \to 2$: 由 $0 \to N \to 0$ 和 $0 \to N \otimes M \to 0$ 同时正合性证毕. $2 \to 3$: 由于 $A/\mathfrak{m} \neq 0$, 所以 $M/\mathfrak{m} M \simeq A/\mathfrak{m} \otimes M \neq 0$. $3 \to 2$: 对任意 $0 \neq x \in N$, 存在 $I$ 使得 $Ax \simeq A/I$, 设 $\mathfrak{m}$ 为包含 $I$ 的一个极大理想, 于是 $IM \subseteq \mathfrak{m}M \subset M$, 从而 $(A/I)\otimes M = M/IM \neq 0$. 又由 $M$ 平坦知: $0 \to (A/I) \otimes M \to N \otimes M$ 正合, 所以 $N \otimes M \neq 0$. $2 \to 1$: 设 $S: N’ \xrightarrow{f} N \xrightarrow{g} N’’$ 为 $A$-模序列. 若 $S \otimes M : N’\otimes M \xrightarrow{\hat{f}} N \otimes M  \xrightarrow{\hat{g}} N’’\otimes M$. 由于 $- \otimes M$ 函子正合. $Im(gf) \otimes M = Im(\hat{f}\hat{g})=0$. 从而$Im(gf)=0$, 即 $S$ 是复形, $H(S) \otimes M = H(S \otimes M) = 0$, 从而 $H(S) = 0$, 证毕.</li>
</ol>
<h4 id="局部环中平坦和忠实平坦"><a href="#局部环中平坦和忠实平坦" class="headerlink" title="局部环中平坦和忠实平坦"></a>局部环中平坦和忠实平坦</h4><p>设 $(A,\mathfrak{m}), (B,\mathfrak{n})$ 是局部环, $\phi: A \to B$ 是局部同态, 若 $M \neq 0$ 是有限 $B$-模或 $\mathfrak{n}$ 幂零，则</p>
<script type="math/tex; mode=display">
M \text{是平坦模} \Longleftrightarrow M \text{是忠实平坦模}</script><p>由 $\mathfrak{m} M \subseteq \mathfrak{n}M \neq M$ (NAK lemma), 从而由忠实平坦模的等价刻画知结论成立.<br>推论 1: $B$ 在 $A$ 上平坦等价于忠实平坦.(取 $M=B$)<br>推论 2: 若 $M$ 是有限生成 $A$-模或 $\mathfrak{m}$ 幂零, 则 $M$ 平坦等价于忠实平坦(其实本结论可以由 <strong>局部环上有限生成模是自由模</strong> 小节直接推出).</p>
<h4 id="忠实平坦模的性质"><a href="#忠实平坦模的性质" class="headerlink" title="忠实平坦模的性质"></a>忠实平坦模的性质</h4><p>类似于平坦模, transitive, change of base 都成立. 并且它还满足 descent property: 若 $B$ 是 $A$-代数, $M$ 是忠实平坦 $B$-模, 也是忠实平坦 $A$-模, 那么 $B$也是忠实平坦 $A$-模.<br><strong>忠实平坦在环扩张中起了很重要的作用</strong><br>设 $\phi: A \to B$ 是 f.f. 同态 则:</p>
<ol>
<li>对任意 $A$-模 $N$, $N \to N \otimes B, \quad x \mapsto x \otimes 1$ 是单的. 特别地, $\phi$ 是单的, 因此 $A$ 可以看做 $B$ 的子环.</li>
<li>对任意 $A$ 的理想 $I$, 我们有 $IB \cap A = I$</li>
<li>$\hat{\phi}: Spec(B) \to Spec(A)$ 是满的.</li>
</ol>
<p><strong>Proof</strong>: </p>
<ol>
<li><p>$0 \neq x \in N$, 则 $0 \neq Ax \subset N$. 因此 $Ax \otimes B \in N \otimes B$($B$平坦). 又 $Ax \otimes B = (x \otimes 1)(A \otimes B) = (x \otimes 1)B$. 由 $B$ 忠实平坦知 $x \otimes 1 \neq 0$. </p>
</li>
<li><p>由于 $B \otimes _A (A/I) = B/IB$ 在 $A/I$上 忠实平坦, 因此 $A/I \subseteq B/IB$. 因此 $IB \cap A \subset I$. 又反方向显然, 证毕. </p>
</li>
<li><p>设 $p \in Spec(A)$. $B_p = B \otimes A_p$ 在 $A_p$ 上忠实平坦, 因此  $pB_p \neq B_p$ <strong>(这是关键的一步)</strong>. 取 $B_p$ 中一个包含 $pB_p$ 的极大理想 $\mathfrak{m}$. 则 $pA_p \subseteq \mathfrak{m} \cap A_p$, 因此 $pA_p = \mathfrak{m} \cap A_p$. 设 $P = \mathfrak{m} \cap B$. 则</p>
<script type="math/tex; mode=display">
P \cap A = \mathfrak{m} \cap B \cap A = \mathfrak{m} \cap A = \mathfrak{m} \cap A_p \cap A = pA_p \cap A = p</script><p>要理解上面式子关键在于 $0 \to A \to A_p \to B_p = A_p \otimes B$. 最后 $\mathfrak{m}$ 被拉回之后就在 $B$ 中了.</p>
</li>
</ol>
<h4 id="忠实平坦的等价刻画"><a href="#忠实平坦的等价刻画" class="headerlink" title="忠实平坦的等价刻画"></a>忠实平坦的等价刻画</h4><p>之前已经给了一些平坦的等价可以, 都是与张量积有关, 下面给出的都与谱有关. 即与素理想有关.<br>设 $\phi: A \to B$ 是平坦映射, 以下结论等价:</p>
<ol>
<li>$\phi$ 是忠实平坦的;</li>
<li>$\phi$ 是平坦的, 且 $\hat{\phi}: Spec(B) \to Spec(A)$ 是满的;</li>
<li>$\phi$ 是平坦的, 且对任意 $A$ 中极大理想 $\mathfrak{m}$,存在 $B$ 中极大理想 $\mathfrak{m}’$ 使得 $\mathfrak{m}’ \cap A = \mathfrak{m}$.<blockquote>
<p>这注定了它和 NAK lemma 之间密切的联系.</p>
</blockquote>
</li>
</ol>
<p>$1 \to 2$ 已证, $2 \to 3$ 是因为存在 $p’ \in Spec(B)$ 使得 $p’ \cap A = \mathfrak{m}$. 找一个包含 $p’$ 的极大理想 $\mathfrak{m}’$. 则 $\mathfrak{m} \cap A = \mathfrak{m}$ (由于 $\mathfrak{m}$ 极大). $3 \to 1$ 是因为此时 $\mathfrak{m}B \subseteq \mathfrak{m}’B = \mathfrak{m} \subset B$. 因此 $B$ 在 $A$ 上忠实平坦.</p>
<h4 id="忠实平坦上的平坦"><a href="#忠实平坦上的平坦" class="headerlink" title="忠实平坦上的平坦"></a>忠实平坦上的平坦</h4><p>设 $B$ 是 $A$ 上的忠实平坦 $A$-代数. $M$ 是 $A$-模. 则 $M$ 是 $A$ 上的(忠实)平坦模 $\Longleftrightarrow$ $M$ 是 $B$ 上的(忠实)平坦模。</p>
<p>$\Longrightarrow$ 就是 change of base 的结果. $\Longleftarrow$ 成立是因为一般地我们有:</p>
<script type="math/tex; mode=display">
(S \otimes_A M) \otimes_A B = (S \otimes_A B) \otimes_B (M \otimes_A B)</script><h4 id="整环上的忠实平坦"><a href="#整环上的忠实平坦" class="headerlink" title="整环上的忠实平坦"></a>整环上的忠实平坦</h4><p>设 $A$ 设整环, 整环 $B$ 满足 $A \subseteq B \subseteq Q(A)$, 其中 $Q(A)$ 是 $A$ 的分式域. 则 $B$ 在 $A$ 上忠实平坦当且仅当 $B=A$.<br><strong>Proof</strong>: 若 $B \neq A$, 则对任意 $0 \neq x \in B \backslash A$, $x = y/s,\quad y,s \in A, s \notin U(A)$, 从而 $sB \cap A = A \neq sA$. 因此 $B$ 在 $A$ 上不忠实平坦, 所以 $B = A$.</p>
<blockquote>
<p>但是 $A$ 与 $Q(A)$ 之间的任意环都是平坦的(这可以由 <strong>平坦模的等价刻画 6</strong> 得到)</p>
</blockquote>
<h3 id="Going-up-and-Going-down"><a href="#Going-up-and-Going-down" class="headerlink" title="Going-up and Going-down"></a>Going-up and Going-down</h3><p>在这里还是重提以下 Going-up 和 Going-down 是什么鬼吧, 这部分之前一直糊里糊涂的过了.</p>
<p>设 $\phi: A \to B$ 是环同态. 我们说 Going-up 条件成立是指:<br>对任意 $p \subset p’ \in Spec(A)$, 对任意在理想 $p$ 上的 $P \in Spec(B)$(即$P \cap A = p$). 都存在 $P’ \in Spec(B)$, 使得 $P’ \cap A = p’$ 且 $P \subset P’$</p>
<blockquote>
<p>上面 $p \subset p’$ 是真包含, 若上述 $P’$ 存在, 包含关系必然也是真包含的.</p>
</blockquote>
<p>类似地, 我们说 Going-down 条件成立是指:<br>对任意 $p \subset p’ \in Spec(A)$, 对任意在理想 $p’$ 上的 $P’ \in Spec(B)$(即 $P’ \cap A = p’$). 都存在 $P \in Spec(B)$, 使得 $P \cap A = p$ 且 $P \subset P’$.<br>这等价于:<br>对任意 $p \in Spec(A)$, 对任意包含 $pB$ 的极小素理想 $P$ 都有 $P \cap A = p$.</p>
<blockquote>
<p>上面 $p \subset p’$ 是真包含, 若上述 $P$ 存在, 包含关系必然也是真包含的.</p>
</blockquote>
<h4 id="平坦-Going-down"><a href="#平坦-Going-down" class="headerlink" title="平坦 Going-down"></a>平坦 Going-down</h4><p>设 $\phi: A \to B$ 是平坦映射, 则 $\phi$ 满足 Going-down 条件.<br><strong>Proof</strong>: 设 $p’ \subset p \in Spec(A)$, $P \in Spec(B)$ 使得 $P \cap A = p$. 则 $B_P = B_p$ 在局部环 $A_p$ 上平坦, 因此忠实平坦, 所以 $Spec(B_P) \to Spec(A_p)$ 是满的, 设 $P^{\star} \ subset B_P$ 满足 $P^{\star} \cap A_p = p’A_p$. 则 $P’ = P^{\star} \cap B$ 即为所求.</p>
<h4 id="整-Going-up"><a href="#整-Going-up" class="headerlink" title="整 Going-up"></a>整 Going-up</h4><p>设 $A \subset B$ 是环, 且 $B$ 在 $A$ 上整. 则:</p>
<ol>
<li>$Spec(B) \to Spec(A)$ 是满的</li>
<li>$B$ 中在某个 $Spec(A)$ 上的所有素理想互不包含.</li>
<li>Going-up 条件成立.</li>
<li>若 $A$ 是局部环, $p$ 是唯一极大理想, 则 $B$ 中在 $p$ 上的素理想都是极大理想.</li>
</ol>
<p>先证$4$: 设 $\mathfrak{n}$ 为 $B$ 的一个极大理想, 设 $\mathfrak{m} = \mathfrak{n} \cap A$. $\bar{B} = B / \mathfrak{n}$ 是域, 并且在环 $\bar{A} = A/\mathfrak{m}$ 上整, 对 $A$ 中任意非零元 $x$. $1/x \in \bar{B}$. 因此</p>
<script type="math/tex; mode=display">
(1/x)^n + a_1 (1/x)^{n-1} + \cdots a_n = 0</script><p>所以 $\frac{1}{x} = -(a_1 + a_2 x + a_n x^{n-1} \in A$. 即 $\bar{A}$ 是域, $\mathfrak{m} = p$ 为 $A$ 的唯一极大理想. 设 $P \in Spec(B)$ 使得 $P \cap A = p$. 则 $\bar{B} = B/P$ 是整环, 且在域 $\bar{A} = A/p$ 上整, 易知 $\bar{B}$也是域, 即 $P$ 是极大理想.<br>再证 <code>1, 2</code>: 对任意 $p \in Spec(A)$. $B_p = B \otimes _A A_p = (A-p)^{-1}B$ 在 $A_p$ 上整且包含 $A_p$. 又因为 $B$ 中在 $p$ 上的素理想与 $B_p$ 中在 $pA_p$ 的素理想一一对应, 在由 <code>4</code> 知道 它对应于 $B_p$ 中的极大理想, 因此 <code>1, 2</code>得证.<br>最后证明 <code>3</code>: 设 $p \subset p’ \in Spec(A)$, $P \in Spec(B)$ 使得 $P \cap A = p$, $B/P$ 包含 $A/p$ 且在其上整. 由 $1$ 知, 存在 $P’/P$ 使得 $P’/P \cap A/p = p’/p$. 所以 $P’ \in Spec(B)$ 满足 $P’ \cap B = p’$.</p>
<blockquote>
<p>一个有用的结论: 整环 $B$ 在 $A$ 上整, 则 $B$ 是域当且仅当 $A$ 是域.</p>
</blockquote>
<h3 id="代数几何中的-Constructible-Set"><a href="#代数几何中的-Constructible-Set" class="headerlink" title="代数几何中的 Constructible Set"></a>代数几何中的 Constructible Set</h3><h4 id="Noetherian-空间"><a href="#Noetherian-空间" class="headerlink" title="Noetherian 空间"></a>Noetherian 空间</h4><p>称一个拓扑空间 $X$ 为 Noetherian, 如果它满足闭集的降链条件, 等价于开集的升链条件.<br>显然有限个 Noetherian 空间的并还是 Noetherian 空间, Noetherian 空间的子空间还是 Noetherian 空间. Noetherian 空间是紧的.</p>
<blockquote>
<p>由于 Noetherian 环 $A$ 满足素理想的降链条件, 此时 $Spec(A)$ 是 Noetherian 空间.</p>
</blockquote>
<h4 id="不可约闭集-irreducible-closed-set"><a href="#不可约闭集-irreducible-closed-set" class="headerlink" title="不可约闭集(irreducible closed set)"></a>不可约闭集(irreducible closed set)</h4><p>一个闭集称为不可约的, 如果它不能写成两个真闭子集的并. </p>
<blockquote>
<p>在 Noetherian 空间中, 每个闭集都可以写成有限个不可约闭子集的并. 并且这些不可约子集互不包含, 称每一个都为这个闭集的不可约部分.</p>
</blockquote>
<h4 id="局部闭集-locally-closed"><a href="#局部闭集-locally-closed" class="headerlink" title="局部闭集(locally closed)"></a>局部闭集(locally closed)</h4><p>一个集合 $Z$ 称为 locally closed 如果 $\forall z \in Z, \quad \exists U_z$  使得 $U_z \cap Z$ 是开邻域 $U_z$ 中的闭集. 这等价于说 $Z$ 是拓扑空间 $X$ 中某个开集和闭集的交. 特别地, 开集和闭集都是 locally closed.</p>
<h4 id="Noetherian-空间中-constructible-集"><a href="#Noetherian-空间中-constructible-集" class="headerlink" title="Noetherian 空间中 constructible 集"></a>Noetherian 空间中 constructible 集</h4><p>设 $X$ 是一个 Noetherian 空间, 称集合 $Z \subseteq$ 是一个 constructible 集, 如果它是有限个 locally close 集合的并.<br>(非 Noetherian 空间中也可以定义 constructible 集, 但是很复杂)<br>显然 constructible 集关于交并差都是封闭的.</p>
<p>设 $X$ 是一个 Noetherian 空间, 称集合 $Z \subseteq$ 是一个 pro-constructible(对应的 ind-constructible)集, 如果它是任意一族 constructible 集的交(对应的并).</p>
<p><strong>constructible 集</strong> 判定方法, Noetherian 空间 $X$ 的子集 $Z$ 称为 constructible 集的充要条件是:<br>对任意不可约闭子集 $X_0 \subseteq X$, 若 $X_0 \cap Z$ 在 $X_0$ 中稠密, 则 $X_0 \cap Z$ 包含 $X_0$ 中某个非空开集.<br><strong>Proof</strong>: 必要性: 若 $Z$ 是 constructible 集, 则</p>
<script type="math/tex; mode=display">
X_0 \cap Z = \bigcup _{i=1} ^m (U_i \cap F_i)</script><p>其中 $U_i$ 是 $X$ 中开集, $F_i$ 是 $X$ 中不可约闭子集(这是可以做到的是因为 Noetherian 空间中闭集都可以写成有限个不可约闭集的并), 且 $U_i \cap F_i$ 是非空的(如果空就直接踢掉了). 则 $\bar{U_i \cap F_i} = F_i$(这是因为否则 $\bar{U_i \cap F_i} \cup (c(U_i) \cap F_i) = F_i$, 但是 $F_i$ 是不可约闭集). 因此</p>
<script type="math/tex; mode=display">
X_0 = \bar{X_0 \cap Z} = \bigcup _{i=1} ^m F_i</script><p>因此必有某个 $F_i = X_0$. 从而 $U_i \cap X_0 = U_i \cap F_i$ 是 $X_0$ 中的一个非空开集.<br>充分性: 我们对 $\bar{Z}$ 进行应用所谓的超限数学归纳. 首先, $\emptyset$ 是 constructible 集, 其次假设 $\bar{Z}$ 中所有满足条件且 $\bar{Z’} \subset \bar{Z}$(严格包含)的 $Z’$ 都是 constructible 集. 我们证明此时 $Z$ 也是 constructible 集:<br>设 $\bar{Z} =  F_1 \cup \dots \cup F_r$ 是 $\bar{Z}$ 的不可约分解. 那么 $\bar{F_1 \cap Z} =  F_1$(毕竟不可约闭集). 因此, 由条件存在 $F_1$ 中的真子集 $F_1’$ 使得 $\emptyset \neq F_1 - F_1’ \subseteq Z$. 此时定义 $F^{\star} = F_1’ \cap F_2 \cap cdots \cap F_r$. 那么 $Z = (F_1 - F_1’) \cup (Z \cap F^{\star})$. 由于 $F_1 - F_1’$ 是 locally closed, 又因为 $Z \cap F^{\star}$ 满足条件: 若 $X_0$ 是不可约闭集且 $X_0 = \bar{Z \cap F^{\star} \cap X_0} \subseteq \bar{F^{\star}} = F^{\star}$, 从而 $Z \cap F^{\star} \cap X_0 = Z \cap X_0$ 从而包含 $X_0$ 中的一个非空开集. 并且 $\bar{Z \cap F^{\star}} \subseteq F^{\star} \subset Z$. 由数学归纳知 $Z \cap F^{\star}$ 是 constructible 集. 从而 $Z = (F_1 - F_1’) \cup (Z \cap F^{\star})$ 是 constructible 集.</p>
<blockquote>
<p>以上结果对一般地 Noetherian 空间都成立.</p>
</blockquote>
<h4 id="考察上述定义在-Spec-A-上的具体表现"><a href="#考察上述定义在-Spec-A-上的具体表现" class="headerlink" title="考察上述定义在 $Spec(A)$ 上的具体表现"></a>考察上述定义在 $Spec(A)$ 上的具体表现</h4><p><strong>$Spec(A)$ 中的不可约闭集</strong>: 设 $F$ 是 $Spec(A)$ 中的闭集, 则 $F$ 不可约当且仅当, $F = V(p)$, 其中 $p \in Spec(A)$, 可以看出此时 $p$ 由 $F$ 唯一决定。<br>充分性由 $p \in V(p)$ 显然.<br>必要性. $F = V(I)$. 若 $I$ 不是素理想, 则存在 $a, b \notin I, ab \in I$, 即$F = (F \cap V(a)) \cup (F \cap V(b))$. 矛盾于 $F$ 不可约.设 $\phi: A \to B$ 是环同态, 设 $X = Spec(A), Y = Spec(B)$, 由自然的 $f: Y \to A$. 那么 $f(Y)$ 在 $X$ 中稠密, 当且仅当 $\ker(\phi) \subseteq nil(A)$. 特别地, 当 $A$ reduce 时, $f(Y)$ 在 $X$ 中稠密, 当且仅当 $\phi$ 是单同态.<br>证明 $\bar{f(Y)} = V(I)$, 其中 $I = \bigcap_{p \in Y} \phi^{-1}(p) = \phi^{-1}(\bigcap_{p \in Y} p) = \phi^{-1}(nil(B))$. 显然 $\ker(\phi) \subseteq I$.<br>若 $f(Y)$ 在 $X$ 中稠密, 则 $V(I) = X$. 因此 $I \subseteq nil(A)$, 从而  $\ker(\phi) \subseteq nil(A)$. 另一方面, 若 $\ker(\phi) \subseteq nil(A)$, 则 $I = \phi^{-1}(nil(B)) \subseteq nil(A)$. 从而 $\bar{f(Y)} = X$.</p>
<blockquote>
<p>之前提到了, $Spec$ 是环范畴到拓扑范畴的逆变函子, 现在是说, 这个拓扑空间的一些性质可以与环的一些性质有一个对应关系, 这个函子保持了很好的性质.</p>
</blockquote>
<p>之前关于 constructible 集的定义都是在 Noetherian 空间中考虑的, 因此我们下面考虑的环一般是 Noetherian 环:</p>
<p><strong>(Chevalley)</strong> 设 $A$ 是 Noetherian 环, $B$ 是 $A$ 上的有限生成代数(从而也是 Noetherian 环). 设 $\phi: A \to B$ 是自然映射, 记 $X = Spec(A), Y = Spec(B)$ 则 $f: Y \to X$. 则 $f$ 将 $Y$ 中 constructible 集 映成 $X$ 中的 constructible 集.</p>
<blockquote>
<p>先证明 $f(Y)$ 是 constructible 集, 在利用下面的引理.</p>
</blockquote>
<p>另一方面设 $A$ 是 Noetherian 环, $X’$ 是 $X = Spec(A)$中的 constructible 集, 那么存在 $A$ 的有限生成代数 $B$ 使得 $Spec(B)$ 在 $Spec(A)$ 中的像恰好是 $X’$.</p>
<blockquote>
<p>对于 $X’ = D(a) \cap V(I)$, 然后考虑 $B = \lbrace 1,a,a^2,\cdots \rbrace ^{-1} (A/I)$, 然后考虑 constructible 集.</p>
</blockquote>
<p><strong>pro-constructible 集</strong> 设 $A$ 是 Noetherian 环, $\phi: A \to B$, $\bar{\phi}(Spec(B))$ 是 $Spec(A)$ 中的 pro-constructible 集.</p>
<h4 id="f-spec-B-to-Spec-A-成为-开-闭-连续映射"><a href="#f-spec-B-to-Spec-A-成为-开-闭-连续映射" class="headerlink" title="$f: spec(B) \to Spec(A)$成为(开,闭)连续映射"></a>$f: spec(B) \to Spec(A)$成为(开,闭)连续映射</h4><p>设$A$是 Noetherian 环, $B$ 是 $A$ 上的有限生成代数, 假设它们之间的自然映射 $\phi: A \to B$ 满足 Going-down 条件, 则对应的自然映射 $f: Spec(B) \to Spec(A)$ 是开(连续)映射.</p>
<blockquote>
<p>设 $U$ 是 $Spec(B)$ 中开集, 则 $f(U)$ 是 constructible 集, 再由 Going-down 条件知道 $Spec(A) - f(U)$ 是闭集.</p>
</blockquote>
<p>设 $\phi: A \to B$ 满足 Going-up 条件, 且 $B$ 是 Noetherian 环, 则 $f: Spec(B) \to Spec(A)$ 是闭映射.</p>
<h3 id="Noetherian-环上的-Associated-Primes"><a href="#Noetherian-环上的-Associated-Primes" class="headerlink" title="Noetherian 环上的 Associated Primes"></a>Noetherian 环上的 Associated Primes</h3><p>给定一个 Noetherian 环上的模 $M$, 我们称 $A$ 的一个素理想为 $M$ 的 associated prime, 如果它满足下面等价的条件:</p>
<ol>
<li>$\exists x \in M$ 使得 $Ann(x) = p$;</li>
<li>$M$ 包含一个子模同构于 $A/p$.</li>
</ol>
<p>我们把 $M$ 中所有的 associated prime ideal 记为 $Ass(M)$. 有时也用 $Ass_A(M)$ 来防止歧义.</p>
<blockquote>
<p>由下面三个结论说明, $Ass(M)$ 确实是 $M$ 的一个重要不变量.</p>
<p>(本节)环默认为 Noetherian 环.</p>
</blockquote>
<h4 id="Ann-x-全体中的极大元在-Ass-M-中"><a href="#Ann-x-全体中的极大元在-Ass-M-中" class="headerlink" title="$Ann(x)$ 全体中的极大元在 $Ass(M)$ 中"></a>$Ann(x)$ 全体中的极大元在 $Ass(M)$ 中</h4><p>设 $p$ 是 $\lbrace Ann(X) \mid 0 \neq x \in M \rbrace$. 则 $p \in Ass(M)$</p>
<p>由上, 显然可知道 $Ass(M) = \emptyset \Longleftrightarrow M=0$. 即 $Ass(M)$ 是元素是十分丰富的. $M$ 中的零因子是 $Ass(M)$ 中元素的并.</p>
<h4 id="Ass-M-与局部化可交换"><a href="#Ass-M-与局部化可交换" class="headerlink" title="$Ass(M)$ 与局部化可交换"></a>$Ass(M)$ 与局部化可交换</h4><p>给定一个乘闭子集 $S$, 记 $A’ = S^{-1}A, M’ = S^{-1} B$, 则</p>
<script type="math/tex; mode=display">
Ass_A(M’) = f(Ass_{A’}(M’) = Ass_A(M) \cap \lbrace p \mid p \cap S = \emptyset \rbrace</script><p>其中 $f: Spec(A’) \to Spec(A)$ 为自然映射.</p>
<h4 id="Supp-M-的极小元全体等于-Ass-M-的极小元全体"><a href="#Supp-M-的极小元全体等于-Ass-M-的极小元全体" class="headerlink" title="$Supp(M)$ 的极小元全体等于 $Ass(M)$ 的极小元全体"></a>$Supp(M)$ 的极小元全体等于 $Ass(M)$ 的极小元全体</h4><p>$Ass(M) \subset Supp(M)$ 且 $Supp(M)$ 中的极小元在 $Ass(M)$ 中(从而 $Supp(M)$ 的极小元全体等于 $Ass(M)$ 的极小元全体).<br><strong>Proof</strong>: 设 $p \in Ass(M)$, 则由正合列 $0 \to A/p \to M$, 从而 $0 \to A_p/pA_p \to M_p$ 正合. 由 $A_p/pA_p \neq 0$, 从而 $M_p \neq 0$, 从而 $p \in Supp(M)$.<br>设 $p \in Supp(M)$, 由于局部化和 $Ass(M)$ 可交换, $p \in Ass_A(M)$ 等价于  $pA_p \in Ass_{A_p}(M_p)$. 因此, 我们不妨设 $(A, p)$ 是局部环, $M \neq 0$. 且对任意 $q \subset p, M_q = 0$, 即 $Supp(M) = \lbrace p \rbrace$. 由于 $Ass(M)$ 非空, 且包含于 $Supp(M)$ 中, 因此 $p \in Ass(M)$.</p>
<blockquote>
<p>设 $I$ 是 $A$ 的理想, 则 $Ass(A/I)$ 中的极小元全体为包含 $I$ 的极小素理想全体. 从而 $\bigcap _{p \in Ass(A/I)} p = \sqrt{I}$</p>
</blockquote>
<p>若 $0 \to M’ \to M \to M’’$ 是 $A$-模正合列, 则 $Ass(M) \subset Ass(M’) \cup Ass(M’’)$<br><strong>Proof</strong>: 设 $p \in Ass(M)$, 则存在 $N \subseteq M$ 使得 $N \simeq A/p$. 若 $N \cap M’ = 0$(本质上是和 $f(M’)$ 的交). 则 $N$ 同构于 $M’’$ 的一个子模, 因此 $p \in Ass(M’’)$. 若 $N \cap M’ \neq 0$, 则任取 $0 \neq x \in N \cap M’$, 则 $Ann(x) = p$.</p>
<p>设 $M \neq 0$ 是 Noetherian 环上的有限生成模, 则存在(长为 $n$ 的)子模链 $(0) = M_0 \subset \cdots \subset M_{n-1} \subset M_n = M$ 使得 $M_i / M_{i-1} = A/p_i$, 其中 $p_i \in Spec(A)$. 从而 $Ass(M) \subset \lbrace p_1 \cdots p_n \rbrace$ 是有限集.<br><strong>Proof</strong>: 由 $M \neq 0$ 则 $Ass(M) \neq \emptyset$, 选择 $M_1 \subseteq M$, 使得 $M_1 \simeq A/p_1$, 若 $M_1 \neq M$, 再对 $M/M_1$ 做同样的事情, 由于 $M$ 是 Noetherian 的, 因此次过程在有限步后终止. 又因为</p>
<script type="math/tex; mode=display">
Ass(M) \subseteq Ass(M_1) \cup Ass(M_2/M_1) \cup \cdots \cup Ass(M_n /M_{n-1})</script><p>再由 $Ass(M_i/M_{i-1}) = Ass(A/p_i)=p_i$ 知结论成立.</p>
<h3 id="Primary-Decomposition-准素分解"><a href="#Primary-Decomposition-准素分解" class="headerlink" title="Primary Decomposition(准素分解)"></a>Primary Decomposition(准素分解)</h3><blockquote>
<p>本节设 $M$ 是 Noetherian 环 $A$ 上的模.</p>
</blockquote>
<p>称一个 $A$-模是 <strong>co-primary</strong> 如果它仅有一个 associated prime ideal. $N \subseteq M$ 称为 $M$ 的 primary 子模, 如果 $M/N$ 是 co-primary. 若 $Ass(M/N) = \lbrace p \rbrace$, 则称 $N$ 为 $p$-primary 或称 $N$ 属于 $p$(的 primary submodule).</p>
<h4 id="co-primary-等价刻画"><a href="#co-primary-等价刻画" class="headerlink" title="co-primary 等价刻画"></a>co-primary 等价刻画</h4><p>$M$ 是 co-primary 的, 当且仅当 $M \neq 0$, 且若 $a \in A$ 是 $M$ 的零因子, 则 $a$ 在 $M$ 上 locally nilpotent($\forall x \in M, \exists n$, such that  $a^n x = 0$).<br><strong>Proof</strong>: 若 $Ass(M) = \lbrace p \rbrace$, 则对任意 $x \in M$, $Ass(Ax) \subseteq Ass(M) = \lbrace p \rbrace$, 若 $Ass(Ax) = \emptyset$(取 $n = 1$ 即可), 若 $Ass(Ax) =  \lbrace p \rbrace$. 因此 $p$ 是 $Supp(Ax) = V(Ann(x))$ 中唯一的极小元素. 即 $p = \sqrt{Ann(x)}$.<br>另一方面, 定义 $p = \lbrace a \in A \mid a \text{在} M \text{上 locally nilpotent} \rbrace$. 它显然是一个理想. 对任意 $q \in Ass(M)$, 存在 $x \in M$  使得 $q = Ann(x)$. 因此 $p \subseteq \sqrt{q} = q$. 另一方面由于 $p$ 为所有 associated prime 理想的并, 因为 $q \subseteq p$. 从而 $Ass(M) = \lbrace p \rbrace$.</p>
<blockquote>
<p>当 $M = A/q$ 时, 上述条件恰好就是 $q$ 为准素理想的定义.</p>
</blockquote>
<h4 id="p-primary-的交依然是-p-primary"><a href="#p-primary-的交依然是-p-primary" class="headerlink" title="p-primary 的交依然是 p-primary"></a>p-primary 的交依然是 p-primary</h4><p>设 $p$ 是 $A$ 的素理想, $Q_1, Q_2$ 是 $M$ 的 $p$-primary 子模. 则 $Q_1 \cap Q_2$ 也是 $M$ 的 $p$-primary 子模.</p>
<blockquote>
<p>由 $0 \to M / Q_1 \cap Q_2 \to M/Q_1 \oplus M/Q_2$ 显然</p>
</blockquote>
<h4 id="准素分解闪亮登场"><a href="#准素分解闪亮登场" class="headerlink" title="准素分解闪亮登场"></a>准素分解闪亮登场</h4><p>设 $N$ 是 $M$ 的一个子模, 我们称 $N = Q_1 \cap \cdots \cap Q_r$ 是 $N$ 的一个准素分解, 如果 $Q_i$ 是 $M$ 中的 primary 子模. 我们称一个准素分解是 irredundant 如果每个准素子模都不能去掉, 并且 $Ass(M/Q_i)$ 各不相同. 对于任意准素分解, 我们都可以通过有限次剔除之后使得它的每一个准素子模都不可去掉, 而如果有两个准素子模属于相同的 associated prime $p$, 则我们可以把它们交起来构成一个新的准素子模, 从而可知</p>
<blockquote>
<p>任意准素分解都可以化成 irredundant 准素分解.</p>
</blockquote>
<p>设 $N = Q_1 \cap \cdots \cap Q_r$ 是 $N$ 的一个 irredundant 准素分解, 若 $Q_i$ 属于 $p_i$. 则 $Ass(M/N) = \lbrace p_1 \cdots p_r \rbrace$.<br><strong>Proof</strong>: 由自然单同态 $0 \to M/Q_1 \oplus \cdots \oplus M/Q_r$. 因此 $M/N \subseteq \cup Ass(M/Q_i) = \lbrace p_1 \cdots p_r \rbrace$. 另一方面 $(Q_2 \cap \cdots \cap Q_r)/N$ 同构于 $M/Q_1$ 的子模, 从而 $Ass(Q_2 \cap \cdots \cap Q_r)/N) = \lbrace p_1 \rbrace$. 从而 $p_1 \in Ass(M)$. 其它的类似.</p>
<p>设 $N$ 是 $M$ 的一个 $p$-primary 子模. 设 $q$ 是一个理想. 若 $p \subseteq q$,  则 $N = M \cap N_q$, 反之 $N_q = M_q$.<br><strong>Proof</strong>: 由于 $Ass(M/N) = \lbrace p \rbrace$. 若 $p \subseteq q$, 则 $A-q$ 中无 $M/N$ 的零因子, 即 $M/N \to (M/N)_q = M_q / N_q$ 是单射, 从而 $N = M \cap N_q$. 反之 $Ass(M_q/N_q) = Ass(M/N) \cap \lbrace \text{包含于} p \text{的素理想} \rbrace = \emptyset$. 从而 $M_q/N_q = 0$.</p>
<blockquote>
<p>推论 1: 若 $N = Q_1 \cap \cdots \cap Q_r$ 是 $N$ 的一个 irredundant 准素分解, 其中 $p_1$ 是 $Ass(M/N)$ 中的极小素理想. 则 $Q_1 = M \cap N_{p_1}$ 由 $N$ 和 $p_1$ 决定.<br>推论 2: 设 $I$ 是 Noetherian 环 $A$ 的理想 $N = \sqrt{I}$(有限生成). 则存在 $n \in \mathbb{N}$ 使得 $N^n \subseteq I$. 特别地若 $Q$ 是 $R$ 的 $p$ 准素理想, 则存在 $n \in \mathbb{N}$ 使得 $P^n \subseteq Q \subset P$.</p>
</blockquote>
<p><strong>准素分解</strong> 设 $M$ 是(Noetherian 环) $A$-模. 对每个 $p \in Ass(M)$, 我们可以选取 $p$-primary 子模 $Q(p)$, 使得</p>
<script type="math/tex; mode=display">
(0) = \bigcap_{p \in Ass(M)} Q(p)</script><p><strong>Proof</strong>: 给定一个 $p \in Ass(M)$, 我们考虑 $M$ 的一些子模构成的集合:  $\mathfrak{N} = \lbrace N \subseteq M \mid p \notin Ass(N) \rbrace \neq \emptyset$( $(0)$ 在其中). 由 Zorn 引理可知其存在极大元 $Q(p) \neq M$. 由 $Q(p)$ 的极大性, 知道 $Ass(M/Q(p) = \lbrace p \rbrace$. 从而</p>
<script type="math/tex; mode=display">
Ass(\bigcap_{p \in Ass(M)} Q(p)) = \bigcap_{p \in Ass(M)} Ass(Q(p)) = \emptyset</script><p>由上可知, 若 $M$ 有限生成, 则将上面定理应用于 $M/N$, 再由 $Ass(M/N)$ 是有限集, 从而 $N$ 有 primary decomposition.</p>
<h3 id="分次环和分次模"><a href="#分次环和分次模" class="headerlink" title="分次环和分次模"></a>分次环和分次模</h3><p><strong>分次环</strong>：称 $A = \bigoplus _{n \geq 0} A_n$ 是分次环, 如果 $A_n$ 是 $A$ 的加法子群, 且 $A_n A_m \subseteq A_{m+n}$. 我们称 $A_n$ 中的非零元素 $x$ 为 $n$ 次齐次元, 并记作 $\deg x = n$.</p>
<blockquote>
<p>$A_0$ 是 $A$ 的子环.<br>例子: $A = F[x_1, \cdots x_m]$, 其中 $A_i$ 是 $i$ 次单项式生成的子空间, 此时 $A$ 成为了分次环.</p>
</blockquote>
<p><strong>分次模</strong>：称分次环 $A = \bigoplus _{n \geq 0} A_n$ 上的模 $M$ 称为分次 $A$-模, 如果 $M = \bigoplus _{n \geq 0} M_n$ 满足 $M_n$ 是加群直和, 且 $A_n M_m \subseteq M_{m+n}$</p>
<p>设 $A = \bigoplus _{n \geq 0} A_n$, 则</p>
<ol>
<li>环 $A$ 是 Noetherian 当且仅当 $A_0$ 是 Noetherian, 且 $A$ 作为 $A_0$ 代数式有限生成的.</li>
<li>若环 $A$ 是 Noetherian, $M_A$ 是有限生成分次 $A$-模, 则对任意 $n, M_n$ 是有限生成 $A_0$-模.</li>
</ol>
<p><strong>Proof</strong>: </p>
<ol>
<li>充分性显然, $A_+ = \bigoplus _{n \geq 1} A_n$ 是 $A$ 的一个理想, 且 $A/A_+ \simeq A_0$ 是环同构, 于是 $A_0$ 是 Noetherian 环. 由 $A_+$ 作为理想是有限生成的. 设 $A_+ = Au_1 + \cdots + Au_m$, 其中每个 $u_i$ 都是齐次元. 下面用数学归纳法证明 $A = A_0[u_1,\cdots,u_m]$, 从而 $A$ 是有限生成 $A$-代数. 显然 $A_0 \subseteq A_0[u_1,\cdots,u_m]$. 设 $n &gt; 0, 0 \neq u \in A_n \subseteq A_+$, 从而可设 $u = \sum_{i=1} ^m a_i u_i$, 通过比较次数, 不妨设 $a_i$ 都是齐次元, 且 $\deg a_i + \deg u_i = n$. 于是 $\deg a_i &lt; n$. 由归纳假设 $a_i \in A_0[u_1, \cdots, u_m]$. 从而 $u \in A_0[u_1, \cdots, u_m]$, 即 $A_n \subseteq A_0[u_1, \cdots, u_m]$, 证毕.</li>
<li>由于 $A=A_0[u_1, \cdots, u_m]$, 其中 $u_i$ 为齐次元. 设 $M = Ay_1 + \cdots Ay_t$. 其中每个 $y_i$ 都是 $M$ 中的齐次元. 对任意 $0 \neq m \in M_n$, 记 $m = \sum_{i=1}^t a_i y_i$, 其中 $a_i$ 是齐次元. 且 $\deg a_i + \deg y_i = n = \deg m$, 另一方面, 对任意 $i$, $A$ 中阶为 $n-\deg y_i$ 的”单项式”(作为 $u_1, \cdots, u_m$ 的单项式)只有有限个, 又 $M_n$ 是 $\lbrace f_i y_i \mid f_i \text{是} A \text{阶为} n - \deg y_i \text{单项式} \rbrace$ 的 $A_0$ 线性组合. 所以 $M_n$ 是有限生成 $A_0$-模.</li>
</ol>
<h4 id="次模的-Poincare-数"><a href="#次模的-Poincare-数" class="headerlink" title="次模的 Poincare 数"></a>次模的 Poincare 数</h4><p>设 $A$ 是分次 Noetherian 环, 且设 $A_0$ 是 Artinian 环. 如果 $M_A$ 是有限生成分次 $A$-模, 则由上面结论知, 每一个 $M_n$ 都是有限生成 $R_0$-模, 从而是有限长的. 记作 $l(M_n)$. 记 $P(M,t) = \sum_{n=0}^{\infty} l(M_n)t^n \in \mathbb{Z}[[t]]$, 称为 $M$ 的 Poincare 级数.</p>
<p>引理: 设 $A$ 是 Artin 环, 若 $0 \to M_0 \to M_1 \to \cdots \to M_s \to 0$ 是有限生成 $A$-模正合列. 则 $\sum_{i=1} ^s l(M_i) = 0$<br><strong>Proof</strong>: $s=0,1$ 时显然, $s=2$ 时, 由 $0 \to M_0 \to M_1 \to M_2 \to 0$, 则有 $l(M_1)=l(M_0)+l(M_2)$. 对于 $M_i \to M_{i+1}$ 有分解: $M_i \to \text{Im} M_i \to 0$ 以及 $0 \to \text{Im} M_i \to M_{i+1}$. 于是有: $l(M_k) = l(\text{Im} M_{k-1} + l(\text{Im} M_k)$. 累加可得到结论.</p>
<p>(Hilbert-Serre) 设 $A$ 是分次 Noetherian 环, $A_0$ 是 Artinian 环, 若 $A = A_0[x_1, \cdots x_m]$, 其 $deg x_i = e_i &gt; 0$, 则对任意有限生成分次 $A$-模 $M$, 存在某个多项式 $f(t) \in \mathbb{Z}[t]$, 使得 $P(M,t)$ 为</p>
<script type="math/tex; mode=display">
\frac{f(t)}{\prod_{i=1}^m (1-t^{e_{i}})}</script><p>的有理展开.<br><img src= "/img/loading.gif" data-lazy-src="Hilbert.png" alt="证明过程"></p>
<p><strong>(Hilbert-Serre)多项式</strong> 设 $A$ 是分次 Noetherian 环, $A_0$ 是 Artinian 环, 若 $A = A_0[x_1, \cdots x_m]$, 其 $deg x_i = 1$, 则对任意有限生成分次 $A$-模 $M$, 存在次数不超过 $m-1$ 的多项式 $\bar{l}(t) \in \mathbb{Q}[t]$, 使得 $n \gg 0$ 时, $\bar{l}(t) = l(M_n)$.<br><strong>Proof</strong>: 应用之前的结果, 以及 $\frac{1}{(1-t)^k}$ 的展开.</p>
<p>命题: 设 $f(x) \in \mathbb{Q}[x]$ 是一个 $n$ 次多项式. 则 $f(x)$ 在 $n+1$ 个相邻的整数取整数值当且仅当 $f(x)$ 是 $C_x ^0 , C_x ^1, \cdots, C_x ^n$ 的整线性组合.<br><strong>Proof</strong>: 设 $f(x) = a_0 C_x ^0 + a_1 C_x ^1 + \cdots + a_n C_x ^n, a_i \in \mathbb{Q}$. 则 $f(x+1) - f(x) = a_1 C_x ^0 + \cdots + a_n C_x ^{n-1}$ 在 $n$ 个相邻的位置取整值. 由归纳假设可知 $a_1, \cdots a_n \in \mathbb{Z}$, 从而 $a_0 \in \mathbb{Z}$.</p>
<h4 id="ring-of-filtration"><a href="#ring-of-filtration" class="headerlink" title="ring of filtration"></a>ring of filtration</h4><p>我们定义环$A$的 filtration 为理想降链:</p>
<script type="math/tex; mode=display">
A = J_0 \supseteq J_1 \supseteq J_2 \supseteq \cdots</script><p>满足$J_n J_m  \subseteq J_{n+m}$.</p>
<p>给定一个 filtration, 我们可以定义一个分次环 $A’$(容易验证)</p>
<script type="math/tex; mode=display">
A’ = \oplus_{n=0} ^{\infty} J_n / J_{n+1}</script><p>特别地, 给定环 $A$ 的理想 $I$, 它的幂定义了一个 filtration, 称为 $I$-adic filtration, 对应的分次环记作 $gr^I(A)$.</p>
<p>若 $I$ 是 Noetherian 环 $A$ 的一个理想, 则 $gr^I(A)$ 也是 Noetherian.<br><strong>Proof</strong>: 由于 $I$ 有限生成, $I = a_1 A + \cdots a_r A$, $A/I$ Noetherian, 所以 $gr^I(A) = A/I[\bar{a_1}, \cdots, \bar{a_r}]$ 为 Noetherian.</p>
<h4 id="module-of-filtration"><a href="#module-of-filtration" class="headerlink" title="module of filtration"></a>module of filtration</h4><p>设 $M$ 是 $A$-模, $I$ 是 $A$ 的理想, 定义 $M$ 的 filtration 为子模降链:</p>
<script type="math/tex; mode=display">
M = M_0 \supseteq M_1 \supseteq M_2 \supseteq \cdots \quad (\star)</script><p>我们称 $(\star)$ 为 $I$-admissible 如果对任意 $n$ 成立 $IM_n \subseteq M_{n+1}$. $I$-adic 若 $M_n = I^n M$, essential $I$-adic 若 $(\star)$ 是 $I$-admissible 且存在 $n_0$, 当 $n &gt; n_0$ 时, $M_{n+1} = IM_n$.</p>
<p><strong>filtration topology</strong> 给定 $M$ 的一个 filtration $(\star)$, 我们可以定义 $M$ 上的拓扑: 对任意 $x \in M$, $x$ 的领域基为 $\lbrace x +M_n \mid n&gt;0 \rbrace$.</p>
<blockquote>
<p>显然上述拓扑是 Hausdorff 的当且仅当 $\bigcap M_n = (0)$.</p>
</blockquote>
<p>若上述 filtration $(\star)$ 是 $I$-adic 的, 则称上述拓扑为 $I$-adic 拓扑. 显然一个 essential $I$-adic 拓扑也定义了 $M$ 上的一个 $I$-adic 拓扑.</p>
<h4 id="Rees-环"><a href="#Rees-环" class="headerlink" title="Rees 环"></a>Rees 环</h4><p>设 $I$ 是 $A$ 的理想. 记 $T(I) =  A + Ix  + I^2x^2 + \cdots \leq A[x]$.<br>称 $T(I)$ 为由理想 $I$ 决定的 Rees 环可看作是 $A[x]$ 的子代数</p>
<p>引理: 若 $A$ 是 Noetherian. 则 $T(I)$ 是 Noetherian.<br><strong>Proof</strong>: $I = a_1 A + \cdots + a_r A$. 于是作为 $A[x]$ 的 $A$ 子代数. $T(I) = A[a_1 x, \cdots, a_r x]$ 是 $A[x_1, \cdots, x_r]$ 的商代数, 由 Hilbert 基定理, $T(I)$ 是 Noetherian 环。</p>
<h4 id="Rees-模"><a href="#Rees-模" class="headerlink" title="Rees 模"></a>Rees 模</h4><p>对于 $M_A$, $A[x] \otimes_A M$ 是 $A[x]$-模, 其中元素可以唯一表示 $\sum_i x^i \otimes m_i$(和为有限和). 另一方面 $M[x] = \lbrace \sum_i m_i x^i \text{ (有限和) } \mid m_i \in M \rbrace$. 于是 $M[x]$ 可自然地看做 $A[x]$-模. 并且作为 $R[x]$-模, 有同构</p>
<script type="math/tex; mode=display">
M[x] = R[x] \otimes _R M, \quad \sum_i m_i x^i \mapsto \sum_i x^i \otimes m_i</script><p>记 $T_I(M) = M + MIx + MI^2x^2 \cdots \leq M[x]$. 作为 $T(I)$-模, $T_I(M)$可由 $M$ 生成, $M = \sum_{j=1} ^s m_jA$ 是有限生成 $A$-模, 则 $T_I(M) = \sum_{j=1} ^s m_j T(I)$是有限生成 $T(I)$-模. 从而若 $A$ 是 Noetherian, $M_R$ 是有限生成模, 则 $T_I(M)$ 是 Noetherian $T(I)$-模.</p>
<h4 id="Artin-Rees-引理"><a href="#Artin-Rees-引理" class="headerlink" title="Artin-Rees 引理"></a>Artin-Rees 引理</h4><p>设 $I$ 是 Noetherian 环 $A$ 的理想, $M$ 是有限生成 $A$-模. $M_1, M_2$ 是 $M$ 的子模. 则存在 $k \in \mathbb{N}$ 使得对任意 $n \geq k$,</p>
<script type="math/tex; mode=display">
I^n(M_1 \cap M_2) \subseteq I^nM_1 \cap M_2 = I^{n-k}(I^k M_1 \cap M_2) \subseteq I^{n-k}(M_1 \cap M_2)</script><p><strong>Proof</strong>: 只需证明存在 $k$ 使得对任意 $n \geq k$, $I^nM_1 \cap M_2 \subseteq I^{n-k}(I^k M_1 \cap M_2)$(其它都包含关系显然). 考虑 Rees 环 $T(I)$ 及 Rees 模 $T_I(M)$, 以及 $T_I(M)$ 的子模 $N = M_1 \cap M_2 + (IM_1 \cap M_2)x + \cdots + (I^n M_1 \cap M_2)+ \cdots$. 由 $T_I(M)$ 是 Noetherian 模, $N_{T(I)}$是有限生成模. 不妨设 $N =  T(I)u_0 + T(I)u_1 x + \cdots T(I) u_k x^k$, 其中 $u_j \in I^j M_1 \cap M_2$. 对任意 $n \geq k, u \in I^n M_1 \cap M_2$ 我们有 $ux^n  \in (I^n M_1 \cap M_2)x^n \subseteq N$. 于是存在 $f_j \in T(I)$, 使得 $ux^n = \sum_{j=1} ^k f_j u_j x^j$. 比较 $x^n$ 的系数, 得到 $u = \sum_{j=1} ^k f_j’ u_j$. 其中 $f_j’ \in I^{n-j}$. 由于</p>
<script type="math/tex; mode=display">
I^{n-j}(I^jM_1 \cap M_2 = I^{n-k}I^{k-j}(I^jM_1 \cap M_2 \subseteq I^{n-k}(I^k M_1 \cap M_2)</script><p>从而 $u \in I^{n-k}(I^k M_1 \cap M_2)$. 证毕.</p>
<blockquote>
<p>取 $M_1 = M, M_2 = N \leq M$ 我们可以得到:<br>设 $I$ 是 Noetherian 环 $A$ 的理想, $N$ 是有限生成模 $M$ 的子模, 则存在 $k$ 使得 $n \geq k$ 时, </p>
<script type="math/tex; mode=display">
I^n N \subseteq I^n M \cap N = I^{n-k}(I^k M \cap N) \subset I^{n-k}N</script></blockquote>
<p><strong>Krull 交定理</strong>：设 $I$ 是 Noetherian 环 $A$ 的理想, $M$ 是有限生成 $A$-模, 记 $I^w M = \cap {n=1} ^{\infty} I^n M$, 则 $I(I^w M) = I^w M$, 从而 $I^w M = \lbrace x \in M \mid \exists b \in I, x = bx \rbrace$.<br>取 $M_1 = M, M_2 = I^w M$, 则存在 $k$, 使得当 $n \geq k$ 时</p>
<script type="math/tex; mode=display">
I^w M =  I^n M \cap I^w M = I^{n-k}(I^k M \cap I^w M) = I^{n-k} (I^w M)</script><p>所以 $I^w M = I(I^w M)$. 显然 $\lbrace x \in M \mid \exists b \in I, x = bx \rbrace \subseteq I^w M$. 另一方面 $I^w M   = I(I^w M)$ 当且仅当 $I + Ann(I^w M) = A$. 这是存在 $b \in I$, 使得 $1-b \in Ann(I^w M)$. 即对任意 $x \in I^w M , x=bx$.</p>
<blockquote>
<p>当 $A$ 是 Noetherian 整环时, $I^w M = \cap {n=1} ^{\infty} I^n M =(0)$<br>当 $I \subseteq J(A)$ 时, $I^w M = \cap {n=1} ^{\infty} I^n M =(0)$<br>特别地, 当 $A$ 是 Noetherian, $\cap {n=1} ^{\infty} J^n = 0$.<br>当 $A$ 不是 Noetherian 环时, 上述结果可能不成立, 例如实数 $\mathbb{R}$ 上在 $0$处无穷次可导的函数全体 $A$. $J$ 是在 $A$ 中在 $0$ 处取值为 $0$ 的函数全体($A$的唯一极大理想), 则 $e^{-\frac{1}{x^2}} \in A$</p>
<p>非交换环有一个著名的 Jacobson 猜想: $R$ 是左右 Noetherian 环, 则 $\cap_{n=1} ^{\infty} J(R) = 0$.</p>
</blockquote>
<h3 id="Dimension-Theroy"><a href="#Dimension-Theroy" class="headerlink" title="Dimension Theroy"></a>Dimension Theroy</h3><p>设 $A$ 是环, $n+1$ 个素理想构成的序列 $p_0 \supset p_1 \supset \cdots \supset p_n$ 称为长为 $n$ 的素理想链. 对任意 $p \in Spec(A)$, 满足 $p = p_0$ 的最长素理想链的称为 $p$ 的高度, 记作 $ht(p)$. 显然 $ht(p) = 0$表 示 $p$ 为 $A$ 的极小素理想.<br><strong>理想的高度</strong>：设 $I$ 为 $A$ 的真理想, 定义 $I$ 的高度为包含 $I$ 的所有素理想高度的最小值.</p>
<script type="math/tex; mode=display">
ht(I) = \inf \lbrace ht(p) \mid p \supset I \rbrace = ht(\sqrt{I})</script><p><strong>环的 Krull 维数</strong>：$A$ 的维数定义为最长的素理想链的长度.即</p>
<script type="math/tex; mode=display">
\dim(A) = \sup \lbrace ht(p) \mid p \in Spec(A) \rbrace</script><p>PID has Dimension $\leq 1$.<br><strong>Proof</strong>: 若 $(p) \supset (q) \supset (0)$. 则存在 $b \neq 0$ 使得$q = pb$, 从而 $(p)(b) \subset (q)$, 所以 $(b) \subseteq (q)$, 所以存在 $c$ 使得 $b = cpb$, 因此 $cp = 1$(domain 中), 从而$(p)=A$. 证毕.</p>
<p>由上述定义可知: 对任意 $p \in Spec(A), ht(p) = \dim(A_p)$, 对任意理想 $I$,  $\dim(A/I) + ht(I) \leq \dim(A)$.</p>
<p><strong>模的 Krull 维数</strong>：设 $M \neq 0$ 是 $A$-模. 定义 $M$ 的维数为:</p>
<script type="math/tex; mode=display">
\dim(M) = \dim(A/Ann(M))</script><p>当 $M = 0$ 时, 记 $\dim(M) = -1$.</p>
<p>若 $M \neq 0$ 是 Noetherian 环 $A$ 上的有限生成模, 则下列条件等价:</p>
<ol>
<li>$M$ 是有限长的.</li>
<li>环 $A/Ann(M)$ 是 Artinian.</li>
<li>$\dim(M) = 0$.</li>
</ol>
<p>由 Noetherian 环成为 Artin 环的充要条件知 $2 \leftrightarrow 3$. 再由有限生成 Artinian 模是有限长的可知 $2 \to 1$. 现在证明 $1\to 3$: 我们不妨考虑 $Ann(M) = (0)$ 的情形, 若 $l(M)$ 有限, 若 $\dim(A) &gt; 0$, 则存在极小素理想 $p$ 不是极大素理想. 由于 $M$ 是有限生成的, 且 $Ann(M)=(0)$, $M_p \neq 0$, 即 $p \in Supp(M)$ 是极小素理想, 因此 $p \in Ass(M)$. 即 $M$ 中包含一个同构于 $A/p$ 的子模. 由于 $\dim(A/p) &gt; 0$, 我们有 $l(A/p) = \infty$(这是因为有限长, 则为 Artinian, 从而维数为 0), 从而矛盾于 $l(M)$ 有限长.</p>
<h4 id="Noetherian-半局部环"><a href="#Noetherian-半局部环" class="headerlink" title="Noetherian 半局部环"></a>Noetherian 半局部环</h4><p>众所周知的几个关于维数的等价刻画本来是在 Noetherian 局部环中考虑的, 这里可以推广到 Noetherian 半局部环.</p>
<p>设 $A$ 是 Noetherian semi-local 环, $\mathfrak{m} = J(A)$. $A$ 的理想被称为<strong>ideal of definition(IOD)</strong>，如果存在 $k&gt;0$ 使得 $\mathfrak{m}^k \subseteq I \subseteq \mathfrak{m}$.</p>
<blockquote>
<p>当 $A$ 是局部环时, IOD 就是 $J$-准素理想.</p>
</blockquote>
<p>$I$ 是 IOD 的等价定义</p>
<ol>
<li>$I \subseteq \mathfrak{m}$ 且 $A/I$ 是 Artinian.</li>
<li>$I \subseteq \mathfrak{m}$ 且 $\dim(A/I)=0$.<br><strong>Proof</strong>: $1 \leftrightarrow$ 显然, 若 $I$ 是 IOD, 即存在 $k&gt;0$ 使得 $\mathfrak{m}^k \subseteq I subseteq \mathfrak{m}$. 从而包含 $I$ 的素理想必然是极大理想, 从而 $\dim(A) = 0$. 另一方面, 若 $I \subseteq \mathfrak{m}$ 且 $A/I$ 是 Artinian. 则 $J(A/I) = \mathfrak{m}/I$ 幂零, 从而 $\mathfrak{m}^n \subseteq I$.<blockquote>
<p>由于此时 $A/I$ 是 Artinian, 所以就可以由 Poincare 数, 以及 Hilbert-Serre 多项式. 完美的一 P.</p>
</blockquote>
</li>
</ol>
<p>设 $I$ 是 IOD, $M$ 是一个有限生成 $A$-模. 设 $A^{\star} = gr^I(A) = \otimes I^n / I^{n+1}$，$M^{\star} = gr^I(M) = \otimes I^n M / I^{n+1} M$</p>
<p>设 $I = A x_1 + \cdots Ax_r$. 那么 $A^{\star}$ 是 $B=A/I[X_1, \cdots, X_r]$ 的同态像. 因此 $F_{M^{\star}}(n) = l(I^n M/ I^{n+1} M)$ 是关于 $n$ 的次数不超过 $r-1$ 的多项式(由 Hilbert-Serre 的结果). 从而<br>​</p>
<script type="math/tex; mode=display">
\chi(M, I;n) \triangleq l(M/ I^{n+1} M) = \sum_{j=1} ^ {n-1}F_{M^{\star}}(j)</script><p>是一个次数不超过 $r$ 的多项式.<br>对于不同的 IOD $I’$, 存在 $s, s’$ 使得 $(I’)^s \subseteq I, I^{s’} \subseteq I’$. 从而 $deg chi(M, I;n) = chi(M, I’;n)$. 即 $chi(M, I;n)$ 是 $M$ 的一个不变量, 记作 $d(M)$.</p>
<blockquote>
<p>若有一个 IOD 被 $r$ 个元素生成, 则 $d(M) \leq r$.</p>
</blockquote>
<p>引理 0: 设 $I$ 是 Noetherian 半局部环 $A$ 的一个 IOD, 给定有限生成模的一个短正合列: $0 \to M’ \to M \to M’’ \to 0$. 则 $d(M) = \max(d(M’),d(M’’))$ 更进一步, 当 $n \gg 0$ 时, $\chi(M,I;n) - \chi(M’,I;n) - \chi(M’’,I;n)$ 的次数小于 $d(M’)$</p>
<p><strong>Proof</strong>: 由于 $l(M’’/I^n M’’) = l(M/M’+I^n M) \leq l(M/I^M)$, 从而 $d(M’’) \leq d(M)$. 更进一步, $\chi(M,I;n)-\chi(M’’,I;n) = l(M’+I^n M/I^n M) = l(M’/M’ \cap I^n M)$. 因此由 Artin-Rees 引理, 存在 $r$ 使得 $M’ \cap I^n M \subseteq I^{n-r} M’$, 从而 $l(M’/I^n M’) \geq l(M’/M’ \cap I^n M) \geq l(M’/I^{n-r} M’)$. 从而 $\chi(M,I;n)-\chi(M’’,I;n)$ 与 $\chi(M’,I;n)$ 有相同的最高次项.</p>
<p><strong>引理 1</strong>: 设 $A$ 是 Noetherian 半局部环, 则 $d(A) \geq dim(A)$<br>对 $d(A)$ 进行数学归纳. 若 $d(A)=0$, 则存在 $k$ 使得 $\mathfrak{m}^k = \mathfrak{m}^{k+1} \cdots$. 由 <strong>Krull 交定理</strong> 知 $\mathfrak{m}^k=(0)$. 从而 $l(A)$ 是有限长的, $\dim(A)=0$.<br>若 $d(A) &gt; 0$. 不妨设 $r = \dim(A)&gt;0$, 设 $p_0 \supset \cdots p_r = p$ 是长为$r$ 的素理想链. 任取 $x \in p_{r-1} \backslash p$. 则 $\dim(A/xA+p) \geq r-1$. 再由正合序列</p>
<script type="math/tex; mode=display">
0 \to A/p \xrightarrow{x} A/p \to A/xA+p \to 0</script><p>我们有 $d(A/xA+p) &lt; d(A/p) \leq d(A)$(这个严格小是因为上面”更进一步”的结论). 因此, 由数学归纳 $r-1 \leq \dim(A/xA+p) \leq d(A/xA+p) &lt; d(A)$, 证毕.</p>
<blockquote>
<p>上述引理表明 Noetherian 半局部环的维数有限, 且对于任意 Noetherian 及其素理想 $p, ht(p) = \dim(A_p)$ 有限, 从而 <strong>Noetherian 环满足素理想的降链条件</strong>, 当然 Noetherian 也可以由无限 Krull 维数, 例如: <img src= "/img/loading.gif" data-lazy-src="NagataNoether.png" alt="Nagata example"> <img src= "/img/loading.gif" data-lazy-src="NoetherJudge.png" alt="补充"></p>
</blockquote>
<p><strong>引理 2</strong>: 设 $M \neq 0$ 是 Noetherian 半局部环 $A$ 上的有限生成模. $x \in J(A)$. 则</p>
<script type="math/tex; mode=display">
d(M) \geq d(M/xM) \geq d(M)-1</script><p>取 IOD $I \ni x$. 则 $\chi(M/xM,I;n) = l(M/xM+I^n M) = l(M/I^nM) - l(xM + I^n M/I^n M)$ 且 $xM + I^n M /I^n M \simeq xM/xM \cap I^n M \simeq M/(I^n M:x)$, 又因为 $I^{n-1} \subseteq (I^n M:x)$ 从而</p>
<script type="math/tex; mode=display">
\chi(M/xM,I;n) \geq l(M/I^nM) - l(M/I^{n-1}M) = \chi(M,I;n) - \chi(M,I;n-1)</script><p><strong>引理 3</strong>: 设 $M \neq 0$ 是 Noetherian 半局部环 $A$ 上的有限生成模. 设 $\dim(A) = r$. 那么存在 $r$ 个元素 $x_1, \cdots, x_r \in J(A)$ 使得 $l(M/x_1 M + \cdots x_r M) \leq \infty$.<br><strong>Proof</strong>: 应用数学归纳法, 并说明在 $J(A)$ 不包含在 $Ann(M)$ 的任意极小素理想即可.</p>
<p><strong>维数等价定理</strong>：设 $M \neq 0$ 是 Noetherian 半局部环 $A$ 上的有限生成模. 则 $d(M) = dim(M)$ 为使得 $l(M/x_1 M + \cdots x_r M) \leq \infty$ 的最小的 $r$. 其中 $x_1, \cdots x_r \in M$.<br>若 $l(M/x_1 M + \cdots x_r M) \leq \infty$ 则由引理 2 知, $d(M) \leq r$. 当 $r$满足条件的最小值, 由引理 3 知, $r \leq \dim(M)$. 从而只需证明 $\dim(M) \leq d(M)$. 取 $M$ 的一个子模链 $M = M_1 \supset M_2 \supset \cdots \supset M_{k+1} = 0$. 使得 $M/M_{i+1} \simeq A/p_i, p_i \in Spec(A)$. 那么 $p_i \supseteq Ann(M)$. 且 $Ass(M) \subseteq \lbrace p_1, \cdots, p_k \rbrace$(这些之前就证明过了). 从而 $Supp(M) = V(Ann(M))$. 包含 $Ann(M)$ 的极小素理想是 $Supp(M)$ 的极小素理想, 从而在 $Ass(M)$ 中, 从而在 $\lbrace p_1, \cdots, p_k \rbrace$. 即 $Ass(M) = \lbrace p_1, \cdots, p_k \rbrace$. 因此(其中第一个等号要对 $M$ 的降链应用引理 0)</p>
<script type="math/tex; mode=display">
d(M) = \max d(A/p_i) \geq \max \dim(A/p_i) = \dim(A/Ann(M)) = \dim(M)</script><p><strong>广义 Krull 维数定理</strong>：$I=(a_1, \cdots, a_r)$ 是 Noetherian 环 $A$ 的理想. 则任意包含 $p$ 的极小素理想 $p$ 的高度不超过 $r$. 特别地, $h(I) \leq r$.<br><strong>Proof</strong>: 由于 $pA_p$ 是 $A_p$ 中包含 $IA_p$ 的唯一素理想, 因此 $\dim(A_p/IA_p)=0$. 从而环 $A_p/(a_1 A_p + \cdots a_rA_p)$ 是 Artinian. 因此 $ht(p) = \dim(A_p) \leq r$.</p>
<h4 id="Noetherian-局部环和-regular-local-ring-正则局部环"><a href="#Noetherian-局部环和-regular-local-ring-正则局部环" class="headerlink" title="Noetherian 局部环和 regular local ring(正则局部环)"></a>Noetherian 局部环和 regular local ring(正则局部环)</h4><p>设 $(A, \mathfrak{m},k)$ 是维数为 $d$ 的 Noetherian 局部环. 此时 IOD 和属于 $\mathfrak{m}$ 的准素理想是一回事. 我们知道 IOD 的生成元个数至少为 $d$ 并且存在 IOD 的生成元个数恰好为 $d$, 若 $\lbrace x_1, \cdots, x_d \rbrace$ 生成了一个 IOD 则称为 <strong>system of parameters</strong>(SOP). 若一个 SOP 生成了唯一极大理想 $\mathfrak{m}$. 则我们称 $A$ 为 <strong>正则局部环</strong></p>
<p>由于 $\mathfrak{m}$ 的极小基个数等于 $\text{rank}_k \mathfrak{m}/\mathfrak{m}^2$. 因此一般地我们有</p>
<script type="math/tex; mode=display">
\dim(A) \leq \text{rank}_k \mathfrak{m}/\mathfrak{m}^2</script><p>等号取得, 当且仅当 $A$ 是 Noetherian 局部环.</p>
<p>设$(A, \mathfrak{m})$是 Noetherian 局部环, $\lbrace x_1, \cdots, x_d \rbrace$ 是一个 $SOP$. 则</p>
<script type="math/tex; mode=display">
\dim(A/(x_1, \cdots, x_i) = d-i = \dim(A) - i</script><p>设 $A$ 是 Noetherian 环, 则 $\dim A[x_1, \cdots, x_n] = \dim A + n$.<br><strong>Proof</strong>: 对 $B = A[x]$ 证明即可. 对任意 $p \in Spec(A)$, 选择 $P$ 为满足 $P \cap A = p$ 中极大元. 则 $ht(P/pB) = 1$. 又 $ht(P) = ht(p) + ht(P/pB) = ht(p)+1$. 再由 $Spec(B) \to Spec(A)$ 是满的. 因此 $\dim(B) = \dim(A) + 1$.</p>
<p>推论: 设 $k$ 是域, 则 $\dim k[x_1, \cdots, x_n] = n$. 理想 $(x_1, \cdots, x_i)$ 是高度为 $i$ 的素理想.<br><strong>Proof</strong>: 由于 $(0) \supset (x_1) \supset (x_1,x_2) \supset \cdots \supset (x_1, \cdots, x_i)$ 是长为 $n$ 的素理想链. 在由 $\dim k[x_1, \cdots, x_n] = n$ 知结论成立.</p>
<h2 id="Depth"><a href="#Depth" class="headerlink" title="Depth"></a>Depth</h2><h4 id="M-regular-sequence"><a href="#M-regular-sequence" class="headerlink" title="$M$-regular sequence"></a>$M$-regular sequence</h4><p>我们称 $a_1, \cdots, a_r$ 是一个 <strong>$M$-regular sequence</strong>: 如果它满足:</p>
<ol>
<li><p>$\forall 1 \leq i \leq r, a_i$ 不是 $M/(a_1, \cdots, a_{i-1})M$ 的零因子;</p>
</li>
<li><p>$(a_1, \cdots, a_r)M \neq M$.</p>
</li>
</ol>
<blockquote>
<p>上述定义与 $a_1, \cdots, a_r$ 的次序有关, 例如 $k$ 为域, $A=k[x, y,z], a_1 = X(Y-1), a_2 = Y, a_3= Z(Y-1)$ 是 $A$-regular sequence, 但 $a_1, a_3, a_2$不是.</p>
</blockquote>
<p>类似地, 可以定义一个理想 $I$ 上的(极大) $M$-regular sequnence.</p>
<p><strong>引理 1</strong>: 假设 $a_1, \cdots, a_r$ 是 $M$-regular 且</p>
<script type="math/tex; mode=display">
a_1 \xi_1 + \cdots a_r \xi_r = 0</script><p>则 $\xi_i \in (a_1, \cdots, a_r)M$.</p>
<p><strong>引理 2</strong>: 假设 $a_1, \cdots, a_r$ 是 $M$-regular, 则 $a_1 ^{n_1} + \cdots a_r ^{n_r}$ 也是.</p>
<p>若 $a_1, a_2, \cdots \in A$ 是一个 $M$-regular sequence. 则由严格子模升链 $a_1 M \subset (a_1, a_2)M \subset \cdots$. 因此有理想严格升链 $a_1 \subset (a_1, a_2) \subset \cdots$. 从而若 $A$ 是 Noetherian 环, 则 $M$-regular sequence 的长度总是有限的, 因此每个理想 $I$ 上 $M$-regular sequence 都可以推展为一个极大 $M$-regular sequence.</p>
<p>定理: 设 $M$ 是 Noetherian 环 $A$ 上的有限生成模. $I$ 是 $A$的理想, 满足 $IM \neq M$. $n$ 为给定正整数. 则下列条件等价:</p>
<ol>
<li>$\text{Ext}_A ^i(N, M) = 0 (i&lt;n)$ 对任意满足 $Supp(N) \subseteq V(I)$ 的有限生成 $A$-模成立;</li>
<li>$\text{Ext} _A ^i(A/I, M) = 0 (i&lt;n)$;</li>
<li>存在一个满足 $Supp(N) = V(I)$ 的有限生成模 $N$ 使得 $\text{Ext}_A ^i(N, M) = 0 (i&lt;n)$;</li>
<li>$I$ 中存在长度为 $n$ 的 $M$-regular sequence $a_1, \cdots, a_n$.</li>
</ol>
<p><strong>Proof</strong>: $1 \to 2 \to 3$ 显然, $3 \to 4$: 我们有 $Ext_A ^0 (N,M) = \hom_A (N,M) = 0$. 若 $I$ 中无元素是 $M$-regular, 则 $I$ 包含在 $Ass(M)$ 全体的 (Noetherian 所以有限)并中, 从而 $I$ 包含于某个素理想 $P$ 中, 从而由单射 $A/P \to M$. 在 $P$ 处作局部化, 我们有 $\hom_{A_P}(k, M_P) \neq 0$, 其中 $k = A_P / P A_P$. 由于 $P \in V(I) = Supp(N)$. 从而 $N_P \neq 0$, 从而由 <strong>NAK lemma</strong> $N \otimes k = N_P / PN_P \neq 0$. 从而 $\hom(N \otimes k, k) \neq 0$. 从而 $\hom_{A_P}(N_P, M_P) \neq 0$. (三个映射的复合, 第一个满第三个单). 然而它 $\hom_A(N,M)=0$ 在 $P$ 处局部化的结果, 矛盾. 从而 $\exists a_1 \in I$, 若 $n&gt;1$, 取 $M_1 = M/a_1 M$. 由模的短正合列</p>
<script type="math/tex; mode=display">
0 \to M \xrightarrow{a_1} M \to M_1 \to 0</script><p>得到同调群的长正合列:</p>
<script type="math/tex; mode=display">
\cdots \to Ext_A ^i (N,M) \to Ext_A ^i (N,M_1) \to Ext_A ^{i+1} (N,M) \to \cdots</script><p>这说明 $Ext_A ^i(N,M_1) =0 (i&lt;n-1)$,  因此 $a_1^r$ 也零化 $Ext_A^i(N,M)$. 从而 $Ext_A(N,M) = 0 (i &lt;n)$</p>
<p>我们将上述 $I$ 中最长的 $M$-regular 序列称为 $I$-depth of $M$. 记作 $depth_I(M)$. 上述定理表明 </p>
<script type="math/tex; mode=display">
depth_I(M) = \min \lbrace i \mid Ext_A ^i(A/I,M) \neq 0 \rbrace</script><p>当 $(A, \mathfrak{m})$ 是(Noetherian 局部环时), 我们用 $depth(M), depth_A(M)$ 来表示 $depth_{\mathfrak{m}}(M)$ 称作 $M$ 的深度.</p>
<p>对任意 $P \in Spec(A)$, $depth M_P = 0 \Longleftrightarrow PA_P \in Ass_{A_P}(M_P) \Longleftrightarrow P \in Ass(M) \to depth_p(M) = 0$. 一般地, 由于局部化函子正合, 因此 $depth_{A_P} (M_p) \geq depth_P (M)$</p>
<p>若 $M = 0$, 定义 $depth_I(M) = 0$; 若 $IM = M \neq 0$, 定义 $depth_I(M) = \infty$.</p>
<h4 id="Grade"><a href="#Grade" class="headerlink" title="Grade"></a>Grade</h4><p>设 $M$ 是 Noetherian 环 $A$ 上的有限生成模. 定义 $M$ 的 garde 为:</p>
<script type="math/tex; mode=display">
grade M = \inf \lbrace i \mid Ext_A ^i (M,A) \neq 0 \rbrace</script><p>由上面定义知:</p>
<script type="math/tex; mode=display">
grade M = depth_I(A), \quad I = Ann(M)</script><p>同理, 由定义知: $grade M  \leq proj.dim M$</p>
<p>对于 $A$ 中任意理想 $I$, $depth_I(A)$ 为 $I$ 中最长的 $A$-sequence 序列 $a_1, \cdots, a_r$ 的长度. 又此时 $ht(a_1, \cdots, a_r) = r$. 从而 $depth_I(A) \leq ht(I)$</p>
<p><strong>引理 1</strong>: 设 $M \neq 0 ,N$ 是 Noetherian 环 $A$ 上的有限生成模, 若 $grad M = k$, $proj. dim N = l &lt; k$. 则 $Ext_A ^i(M,N) = 0 (i &lt; k-l)$<br><strong>Proof</strong>: 对 $l$ 数学归纳, $l=0$ 时, $N$ 为自由 $A$-模的直和因子, 因此结论成立. $l&gt;0$ 时, 由正合列: $0 \to N’ \to L \to N \to 0$, 其中 $L$ 自由, 于是$\dim N’ = l-1$. 由归纳法得证.</p>
<p><strong>引理 2</strong>: (<strong>Ischebeck</strong>) 设 $(A, \mathfrak{m})$ 是 Noetherian 局部环, $M \neq 0 \neq N$ 是有限生成 $A$-模. 若 $depth M = k, \dim N = r$. 则</p>
<script type="math/tex; mode=display">
Ext _A ^i (N,M) = 0 \quad (i< k-r)</script><p><strong>Proof</strong>: 对 $r$ 归纳法证明.(并不简单, 都是用模的短正合列, (再由投射分解, 得到复形的短正合列, 从而)导出同调群之间的长正合列, 然后应用数学归纳得出结论)</p>
<p>定理: 设 $(A,\mathfrak{m})$ 是 Noetherian 半局部环, 且 $M \neq 0$ 是有限生成 $A$-模. 那么对任意 $p \in Spec(A), \quad depth M \leq \dim(A/p)$.<br><strong>Proof</strong>: 由于 $\hom(A/p,M) \neq  0$, 上面引理反证即可.</p>
<p><strong>引理 3</strong>: 设 $M,N$ 是局部环 $(A,\mathfrak{m},k)$ 上的有限生成模, 则</p>
<script type="math/tex; mode=display">
M \otimes_A N \neq 0 \Longleftrightarrow M \neq 0 \neq N</script><p>若 $M \neq  0 \neq N$, 则由 <strong>NAK lemma</strong> 知: $M \otimes k =  M/\mathfrak{m}M \neq 0 \neq N \otimes k$. 由于 $k$ 是域. $(M \otimes N) \otimes k = (E \otimes k) \otimes_k  (F \otimes k) \neq  0$. 从而 $M \otimes N \neq 0$.</p>
<p><strong>引理 4</strong>: 设 $E,F$ 是环 $A$ 上的有限生成模, 则 $Supp(E \otimes F) = Supp(E) \cap Supp(F)$.<br><strong>Proof</strong>: 对任意 $p \in Spec(A,\quad (E \otimes F)_p = (E_p \otimes_{A\p} F_p)$.<br>由引理 3, $(E \otimes F)_p \neq 0 \Longleftrightarrow E_p \neq 0 \neq F_p$.</p>
<p><strong>引理 5</strong>: 设 $M \neq 0$ 是 Noetherian 局部环 $A$ 上的有限生成模, $a_1, \cdots, a_r$ 是 $M$-regular 序列. 那么</p>
<script type="math/tex; mode=display">
\dim M/(a_1, \cdots, a_r)M =  \dim M -r</script><p><strong>Proof</strong>: 首先由于此时 $\dim M = d(M)$, 我们有 $\dim M/(a_1, \cdots, a_r)M \geq \dim M -r$, 另一方面, 若 $x$ 是 $M$-regular 元, 那么由引理 4 $Supp(M/xM) = Supp(M) \cap Supp(A/xA) = Supp(M) \cap V(x)$. 由因为 $x$ 不在 $Supp(M) = V(Ann(M))$ 的极小素理想中. 从而</p>
<script type="math/tex; mode=display">
\dim(M/xM) = \dim(A/Ann(M)+xA) < \dim(A/Ann(M)) = \dim(M)</script><p><strong>引理 6</strong>: 设 $M$ 是 Noetherian 环 $A$ 上的有限生成模, $I$ 是 $A$的理想, 则</p>
<script type="math/tex; mode=display">
depth_I(M) = \inf \lbrace depth M_p \mid p \in V(I) \rbrace</script><p><strong>Proof</strong>: 将等式右边记作 $n$. 若 $n=0$. 则存在 $P \supseteq I$ 使得 $M_P = 0$. 从而 $I \subseteq p \in Ass(M)$. 从而 $depth_I(M) = 0$. 若 $0 &lt; n &lt; \infty$. 此时 $I$ 不包含于任何 $M$ 的 associated 素理想中, 因此存在 $M$-regular 元 $a \in I$. 记 $M’ = M/aM$. 则由 depth 和 $M$-regular 的关系(上面定理)知  $depth (M’)_P = depth M_P/aM_P = depth M_P -1, \text{ for } P \supset I$. 且 $depth_I(M’) = depth_I(M)-1$. 从而归纳法知结论成立, 当 $n = \infty$ 时, 对任意 $P \in V(I), \quad PM_P = M_P$. 若 $IM \neq M$, 对任意 $P \in Supp(M/IM) = V(I) \cap Supp(M)$, 我们有 $(M/IM)_P \neq 0$. 若 $P$ 是 $Supp(M/IM)$ 中的极小素理想, 则 $Supp_{A_P}(M/IM)_P = \lbrace PA_P \rbrace$. 因此 $(M/IM)_P = M_P/IM_P$ 在 $M_P$ 中 coprimary. 又因为 $P$ 是 $M_P$ 的零因子且有限生成, 所以存在 $s&gt;0$ 使得 $P^s \subseteq IM_P$. 因此 $PM_P \neq M_P$ 矛盾. 从而 $IM = M, \quad depth_I(M) = \infty$.</p>
<h3 id="Cohen-Macaulay-Rings"><a href="#Cohen-Macaulay-Rings" class="headerlink" title="Cohen-Macaulay Rings"></a>Cohen-Macaulay Rings</h3><p>设 $M$ 是 Noetherian 环 $A$ 上的有限生成模, 当 $M\neq 0$ 时, $\hom(M,M) \neq 0$, 从而由引理 2(Ischebeck) 知 $depth M \leq \dim M$. 我们称 $M$ 是<strong>Cohen-Macaulay</strong>(C.M.), 如果 $M = 0$ 或 $depth M = \dim M$. 若 $A$ 作为 $A$-模是 $C.M.$, 则称 $A$ 是 $C.M.$环.</p>
<p>设 $(A,\mathfrak{m})$ 是局部环, $M$ 是有限生成 $A$-模. 则:</p>
<ol>
<li>若 $M$ 是 C.M. 模, $p \in Ass(M)$, 则 $depth(M) = \dim(A/P)$. 从而 $Ass(M)$ 中元素没有包含关系.</li>
<li>若 $a_1, \cdots, a_r$ 是 $\mathfrak{m}$中的 $M$-regular 序列, 取 $M’ = M/(a_1, \cdots, a_r)M$. 则 $M$ 是 C.M. 当且仅当 $M’$ 是 C.M.</li>
<li>若 $M$ 是 C.M. 模, 则对任意 $P \in Spec(A)$, $A_P$ 模 $M_P$ 是 C.M. 模, 且当 $M_P \neq 0$ 时, $depth_P(M) = depth _{A_P} M_P = \dim M_P$</li>
</ol>
<p><strong>Proof</strong>:<br>1) 由于 $Ass(M) \neq 0$, 所以 $M \neq 0$, 因此 $depth(M) = \dim M$. 又因为 $P \in Supp(M)$, 我们有 $\dim M \geq \dim A/P \geq depth M$. 证毕.</p>
<p>2) 由 <strong>NAK lemma</strong>, 我们有 $M = 0 \Longleftrightarrow M’ = 0$. 若 $M \neq 0$. 则由引理 5 知 $\dim M’=\dim M -r$. 由 $depth$ 的 $M$-regular 序列刻画知, $depth M’ = depth M - r$.</p>
<p>3) 我们假定 $M_P \neq 0$. 此时 $P \supseteq Ann(M)$. 我们有 $\dim M_P \geq depth_{A_P} M_P \geq depth_P(M)$. 对 $depth_P(M)$ 数学归纳, 若 $depth_P(M) = 0$, 则 $P$ 包含于某个 $P’ \in Ass(M)$. 因为 $Ann(M) \subseteq P \subseteq P’$. 由 1)的结论, 包含 $Ass(M)$ 中的素理想是包含 $Ann(M)$ 的极小素理想, 从而 $P = P’$. 从而 $\dim M_P = 0$. 若 $depth_P(M)&gt;0$, 取一个 $M$-regular 元 $a \in P$, 记 $M_1 = M/aM$. 由于局部化函子是正合的, $a$ 也是 $M_P$-regular. 因此 $\dim (M_1)_P = \dim M_P/aM_P = \dim M_P-1$ 且 $depth_P(M_1) = depth_P(M) - 1$. 由 2) $M_1$ 是 C.M. 从而由归纳法, $\dim (M_1)_P = depth_P(M_1)$, 证毕.</p>
<p>引理 7: 设 $(A, \mathfrak{m})$ 是 C.M. 局部环, 则对任意序列 $a_1, \cdots, a_r \in \mathfrak{m}$, 下列条件等价:</p>
<ol>
<li>$a_1, \cdots, a_r$ 是 $A$-regular 序列</li>
<li>$ht(a_1, \cdots, a_i) = i (1 \leq i \leq r)$</li>
<li>$ht(a_1, \cdots, a_r) = r$</li>
<li>存在 $a_{r+1} \cdots a_n \in \mathfrak{m}, (n = \dim A)$ 使得 $\lbrace a_1, \cdots a_n \rbrace$ 是 SOP.</li>
</ol>
<p><strong>Proof</strong>: $1 \to 2$: 由广义 Krull 定理: $ht(a_1, \cdots, a_i) \leq i$, 再由 $a_1, \cdots, a_r$ 是 $A$-regular 序列知 $ht(a_1, \cdots, a_i) \geq i$. $2 \to 3$ 显然, $3 \to 4$: 若 $\dim A = r$ 则结论是平凡的. 若 $\dim A &gt; r$, 则可以找到 $a_{r+1} \in \mathfrak{m}$ 不在包含 $(a_1, \cdots, a_r)$ 的极小素理想中, 从而 $ht(a_1, \cdots, a_{r+1}) = r+1$. 于是一直这样进行下去即可. $4 \to 1$: 只需证明每个 SOP $x_1, \cdots, x_n$ 都是 $A$-regular 序列. 若 $P \in Ass(A)$, 则 $\dim A/P = n$. 因此 $x_1 \notin P$(否则它在 $A/P$ 下的像怎么生成 $\mathfrak{m}/P$). 因此 $x_1$ 是 $A$-regular. 记 $A’ = A/(x_1)$. 则 $A’$ 是 C.M. 维数为 $n-1$ 局部环. 由归纳法结论成立.</p>
<p>设 $I$ 是 C.M. 局部环 $(A, \mathfrak{m})$ 的真理想, 则</p>
<ol>
<li>$ht(I) = depth_I(A) = \dim A - \dim(A/I)$</li>
<li>对任意素理想 $p \subset q, ht(q) = ht(p) + ht(q/p)$.<br><strong>Proof</strong>: 1. $ht(I) = r$. 我们可以选择 $a_1, \cdots, a_r \in I$ 使得 $ht(a_1, \cdots, a_i) = i \quad 1 \leq i \leq r$. 由引理 7, $a_1, \cdots, a_r$ 是 $I$ 中 $A$-regular 序列. 从而 $ht(I) \leq depth_I(A)$. 另一方面, 若 $b_1, \cdots, b_s$ 是 $I$ 中 $A$-regular 序列, 则 $ht(b_1, \cdots, b_s) = s \leq ht(I)$. 因此 $ht(I) = depth_I(A)$. 由于 $ht(I) = \inf \lbrace ht(P) \mid P \in V(I) \rbrace$, $\dim(A/I) = \sup \lbrace \dim A/P \mid P \in V(I) \rbrace$. 若 $ht(P) = \dim(A) - \dim(A/P)$, 对任意 $P \in Spec(A)$ 成立, 那么 $ht(I) = \dim A - \dim(A/I)$ 显然也成立. 由于 $A_P$ 是 C.M. 环, $ht(P) = \dim(A_P) = depth_P(A)$. 从而我们可以找 $P$ 中一个 $A$-regular 序列 $a_1, \cdots, a_r$. $A/(a_1, \cdots, a_r)$ 是维数为 $n-r$ 的 C.M. 环, $P$ 是包含 $a_1, \cdots, a_r$ 的极小素理想. 从而 $\dim(A/P) - n-r$(由上面的性质).</li>
<li>若 $p supset q$ 是 $A$ 的素理想, 则 $A_q$ 是 C.M. 环, 从而 $\dim A_q = ht pA_q + \dim A_q / pA_q$. 即 $ht(q) = ht(p) + ht(q/p)$.</li>
</ol>
<p><strong>Cohen-Macauly Ring</strong> 称一个 Noetherian 环 $A$ 是 Cohen-Macaulay 如果对任意 $A_P \in Spec(A)$, $A_P$ 是 C.M. local ring. 实际上只要在对 $A_P \in \omega(A)$ 成立即可.</p>
<p>设 $A$ 是 Cohen-Macaulay 环, 则多项式环 $A[x_1, \cdots, x_n]$ 也是 Cohen-Macaulay 环.</p>
<h2 id="To-be-Continue"><a href="#To-be-Continue" class="headerlink" title="To be Continue"></a>To be Continue</h2>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次校运动会 + 山地半程马拉松</title>
    <url>/maoshanMarathon2017/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">日常表白 zly</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="18bf13e2bec1fd13f57b7ab4cd97f91ecdf1586962894b4aa487517dd480ee6d">010b98dc5bd6c4293af1e30087aa0bbd2c8f23083857701b8012ad7103bda0c7c5cb1b450020ec279a5b5292f15e6295091639c3627acebd29896ea0ca446b3ad0a913d216973768a62825eac708c3bd0e06088135a26e0b0eb55907f3861ce8537c1062f7dc9f0862b3b302b8f5548f50074d24e8d9b292b90ca057b48e29e5ae00f312177967b017c0b4615515b8fcfc942a09eca7fa6957a7a5d6b7a07d008d2a00a5fa22dd84b38bba070a301ad4e3f88a9f2e3157b6900d4052a8ecd17be280870b04d3f471cc8e9f704d55966fe3212474f46b90efcf052ff86ae0a757bb223f5d3eadb197d237b838445b93a072d52b639eab6f616be5e3913ae26ab9240297664ed963f2035f1f28c9c0473259c04b6b8586fb6bc635dcafac5ae0079fcbe901199d9e755cfe771665ccfc02f0b6022e385cc97cdc080be564c32539ea00ae98eb8ac4a61afa9ce5bd2c2926825b083ffe802bb94b41cc8199cb5cddb80c19b4e12bd8796472b15af3535fd0d9e6e74b20ee163db26d91f17891297f0480c0cf287941c926e648f62265f72e04fc0e69c35437f0b0972f88435c7514882305ab8e98ff9dfa532431bb047db47e246093d3c54326949fce3fbbca35b17ecc0907b0562bcaf89bc1cd624ea6c75ab54b61366929615e298fba71f25ebb9129df1059f3db9e7063f0f2013d3176277172d5ec1717aa0d33c16685017c9c78e843afe47cea9477eef4e4028033d21628b6dee0c8926c16303d8c8537468713a67c5e1ca965169c21020ec722cbf0e4dae43bb7eec44c8500ee224cabb3db782cdb30968a420befae390aaef066a1065f6c1e31bd14a6491075501e488be3dd64f0d95c6c4c0addcee02fa818ad34e852243ff08b66fd73a3cd2bf5ad6a9ebdd41968f9c297e59eb06b275cb2d2f4c778ecd346251ce40c3e4128cdaf3b57dbab435f34e9e834a00e9a6a49a99748d3f2b338b5ec67e231d3e4ef57e984143b1c2bc63eb1e91b97df0ad1299c2467eb7f86a9c8d7c07eecbb6fdf8349b4c1729ddc1568beb7dd4ec3731fea76306c464800c06c007c651327b8077c3566c76ce2fff57bf617a67992a89b0cb62e08a8b0b60304796c5e60bd909e23a948ddd9f02af243d545de3878f2230ad8e45df564af31458ed41e15739835e6552edfc056a54d2595aef7e5a696cb9299c10eb26d65e0d3b6b545fc0366ee540f5676e1a17efe18be39f08a4f38f4ee75ed9b6d98aeed8e8ffabafd38d5e16d75bf3de040775fa66dcfe4716964b1b506adbfdfca585ed9f409da9f0d0726fb21fb8388cc49112c9af637d8bf06875ee8b9b2ba64152e7d3b748d6cca6d33dafdf07aab09325c2c13b8a2fb9e4ef4e786847b77b7a5be8bfdb288c17ef4d821fc4739bd0f30203bbefba3cf189e20678704a5a9eab94adceef83f36d299eeedcde4185381cfd2447b5f4f552b1dd2bd6386b430266498c04e813d03388bcd2a9912cd473bc796daa1c177b3f6285d3f82c767ddb7c1793c6579cfbb5ada799d819b387c291a068ad70966e430a30624f227a4cd716d6f483c2c476642b83821a525a006a082959ca256b3a7df07d6a7c77d9ce4b37f07db2d6ccce277aad991d32b6a6edd27a75012ca938bcfd9a1f618c47e6f5224bccd29507f2ec357d95e82ccbf8fd9b81f82aa069a4d54391086e7dc2d994fc1e90de34719907245e1cf504f5f1d8254bd8ca975357dd789dae3d7cf86d4f3d080e3a91005acf3a59c844ad4a8b152461b5933837b7f25ee57bd7a29c14ece6b94d9904db63d0489bf7715d0f513b7b7fc0027895f1394dfde8cb84d0702f8a857f22bd1d75bb1e274fb1de9a607193dcebe6fe7b843e3af900b7c97d24cd02c4721d61e3bd2f45b4e163309551b733323c4f03e57236ee5208fff563553a19b1bc6e9b45cb9f425a8f2a3a67e707b58ee3003e56850074d2694eddc4fba86760c9c85a7c64eabc984cf0b1adb60556df22daedd0435f3d47e2521fd43017a5243fdcec82834d915471e1ed4f80a8828fd90ced230f21e5e5a0db0b094b530a6e0bcdb78abe0e4fa4adb1ca7271460db2670840190a0b5fa2d5840d8f781b0dad21e55744c0af767d71784681e81d4f79fa783e67baebcc32fe6dcdd1d5b61364e8d51f38362483bbf5a72a53e725f85cc9aa2243b0677d1cad9223c2496b3ed82f3917b1f6a248b577de90b51f1c5630d11f5f73f67b201336a43f522bb14921056213bca3dd2644510481b027bf545e6071a64ac613f88d657bb6a4f6d1297a057859383da522c5114977928e9a6415e9611f37e0dbf923d9af0d9d218cfeb69deeae3a8815e9d947e31cefa4b25ce7885d261ae2964fe488f6456b7eeb0d936273c00112122a41908c47f7efcf391b7f8dd063843698b0f4262a2e31e6c3fb651031a0b83eb3d279ca7149250a0c931a40ff4e5afa8a0644ddbe5dd3faa60148bde4684fa8a10928246e4157d686743be905841433c39f7711a8fde4c6c28544f0e898ed04ae7bc67f888689d1d4c4e16b29c7d528f3336bfb52f826e73c275baccdfb25a62b7a2d345cbe943abace97953a3042b424a043021446cafd4ba697b8f98cdcbe35424dde989e54ce5794fbdb6b0eb63a1b070a3a66f12ce43d919ce1640e653b0fd937054de2db48ad12984f200d8e142e184d8d7d1da1e98194358502fc9d98595ba2c90df90df436cc6457abf37e8c3cecdd32d9af58058d9c98c2597f5985780e2f02e6531b6bce94f9e6176c310afeb4cfe6c41a80861a6ff4f0226b39712823cbc57ba983844bc0d6cf3294ec1c7fce34903a4e41fd75d4b06c0ad6bfd7bc3497757dc24e4fa9d1a255c641910fd12be17c3238276d0b2f652dc7d28b605e78160e9b2ebf25363be7c394e24e114887aecc5fab629717dd39b3b446c44e061c7d3765050d17fed96ccf653df097a98f77a014e67081513da4969e7ec2e7bb1527e088dc2f9401bdceae214dea998cce0026a01e0d461a2238d7f629fa2abadb1d8daef26dc7c0edb506f9ac5e7347c916eb1f93e755cf5146c9339df57760ae6338b8344bd18612c0099def5bc68b34b436f85b70a3a3a67d8b1b42ace70a968cc221d9c3faf8542c39544fc683ba6b556014a8b79cdf49acc8cd5e8a616b64ac724c15c1211159979cb0ce8fe16a2cf5cbbc83d1aeb6611e9193779df3af4d0ad559c61b6a0ffdf29707efd73b82fc7ada4f2be537d1830d8dd2ecc0d178d16a5c20877b9ebdac4b99744594d352d2962c5b74584f7e36cede5d84fd65411b832bc87816f9a1d69b1fceddf0af814ae20a8514fbcaeeeebce773b7e6498c9979ba039225c63ff2e22e61e23d50fa88ce1849c45944a7307ce974d613e63cbba0c5a16906b2117c03bd3dbd72d25b91f2ed7c8e820405e3bb04d9c0b74035bad09b62d1a6f1ad9d71756b2232e5a149a5a368c9411753f9959bb6f744b67bbddd390b5b359c7d26540122147acb1cc3e502c2a7129a04491369f94c406d35c34b6ca931d020886712add9b0d215ec636675a7d120885d71cba1a7a989bc61010b84f0ecc08a6080161532d1d578aa99d8a811aea47eb4404be93a254f564157d8ee091422e2d1c1e4e91a3c3f2d6da0cb32fe73a9cde18b50bcb70c2794692bb36f707ed4d5eae6ac37b1fe0dff2e6fe6271969b81f553e1986c05d66437fffcf442445a3a61c5a22538c3e26092e57109b842f25d27abc6b3b772a6c7eb3c723ec2dd97760642edb654e8fe9b9e802e797839e544d3c6dfc68a139ecd9c03c62639908343f353f68375702dd1b01356d0a2b74bd45b3521f718421669c2d93e1c7ba2fe80ebd0c2a29bd250b5dc867e5413f0387d63aa5dcbf76c2f41886c0e33fb0b01</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Encrypt</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>《Lecture on Modules and Rings》读书笔记</title>
    <url>/LectureOnModuleAndRing/</url>
    <content><![CDATA[<p>为了把看过的知识变成自己的东西，在此理一下思路（导师建议学的东西记录一下，不然以后过不了多久又忘了，花了时间就要有收获）</p>
<a id="more"></a>
<h2 id="自由模"><a href="#自由模" class="headerlink" title="自由模"></a>自由模</h2><p>给定一个环 $R$，其上(右)自由模</p>
<script type="math/tex; mode=display">
F_R = R^{(I)} = \bigoplus_{i \in I} R_i, \quad R_i = R</script><p>有两种等价刻画：</p>
<ol>
<li><p>$F_R$ 有一组基 $\lbrace e_i : i \in I \rbrace \subset F$ 使得 $F_R$ 上任意元素都可以唯一的写成 $e_i$ 的 $R$-线性组合</p>
</li>
<li><p>$F_R$ 有一组基 $\lbrace e_i : i \in I \rbrace \subset F$ 满足“universal property”: 对 $M_R$ 中任意 $\lbrace m_i : i \in I \rbrace$ 有唯一的 $R$ 模同态 $f: R_R \to M_R$ 使得 $f(e_i) = m_i ,i \in I$</p>
<blockquote>
<p>$R^I$ 表示 $R$ 的 $I$ 次积, 当指标集 $I$ 有限时, 积与直和(余积)等价,此时 $R^{(I)}$ 通常写成 $R^n$</p>
</blockquote>
</li>
</ol>
<h3 id="IBN-Invariant-Basis-Number-性质"><a href="#IBN-Invariant-Basis-Number-性质" class="headerlink" title="IBN (Invariant Basis Number) 性质"></a>IBN (Invariant Basis Number) 性质</h3><p><strong>Generation Lemma</strong> 表明，对任意模，若 ${e_i : i \in I}$ 是其一族极小生成集，且 $I$ 是无限集，则 $M$ 不能由基数小于 $I$ 的集合生成。</p>
<p>由 <strong>Generation Lemma</strong> 可知，若 $R^{(I)} = R^{(J)}$,且 $I$ 无限，那么 $|I| = |J|$，但是当 $I$ 有限时，结论并不一定成立，例如 $R = End(_kV)$,其中 $V$ 为可数无穷维空间，则 $R \simeq R^2$. 因此提出 <strong>IBN​</strong> 的概念：</p>
<p><strong>IBN (Invariant Basis Number)</strong> 称环 $R$ 满足 <strong>IBN</strong> 性质，如果对任意</p>
<script type="math/tex; mode=display">
m,n \in \mathbb{N}, R^m \simeq R^n \Longrightarrow m=n</script><p>由定义不难看出，$R$ 不满足 IBN 性质，当且仅当, 存在 $R$ 上 $m×n$ 矩阵 $A$ 和 $n×m$ 矩阵 $B$ 使得</p>
<script type="math/tex; mode=display">
AB = I_n, BA =I_m</script><p>因此 IBN 性质是对称概念.</p>
<blockquote>
<p>由 IBN 上述等价定义知 $f: R \to S \neq 0$ 为环同态，则 $S$ 满足 IBN 性质可推出 $R$ 满足 IBN 性质。</p>
</blockquote>
<p>由上面的结论又可以给出很多满足 IBN 性质的例子：<br>Divison rings, local rings, semilocal rings, nonzero commutative rings, finite rings.</p>
<h3 id="stably-finiteness"><a href="#stably-finiteness" class="headerlink" title="stably finiteness"></a>stably finiteness</h3><p>称环 $R$ 为 stably finite，如果对任意 $n$</p>
<script type="math/tex; mode=display">
R^n \simeq R^n \oplus N \Longrightarrow N=0</script><p>等价定义: </p>
<ol>
<li>对任意 $n$, $R^n$ 是 hopfian</li>
<li>对任意 $n$, $M_n(R)$ 是 Dedekind-finite 的.</li>
</ol>
<p>由 2 可知 stably finite 是对称概念.</p>
<blockquote>
<p>由 $Mn(R)$ Dedekind-finite 可知:<br>若 $g:R→S$ 是嵌入(单射)同态(不要求幺元映成幺元), 那么若$S$  stable finite, 则 $R$ 也是.</p>
</blockquote>
<p>由上可知:</p>
<script type="math/tex; mode=display">
\prod _{i \in I} R _i \quad \text{ stably finite } \iff R _i \quad \text{ stably finite for all } i</script><p><strong>例子</strong>: Commutative Rings, Noetherian Rings</p>
<p><strong>性质</strong>:<br>若环 $R$ 不是 stably finite, 我们可以做一个最大的商环 $\bar{R}$ 使得 $\bar{R}$ stably finite.<br>$\bar{R}$可以如下构造, 并可以说明它确实 stably finite.<br>设 $T$ 为所有形式 $I-YX$ ( 方阵$X$,$Y$满足$XY = I$的中元素生成的理想。可以证明: $\bar{R} = R/T$</p>
<p>自然地, 我们要问啥时候 $\bar{R} = 0$? 这当且仅当存在 $C,D \in M_m(R)$,行向量$x$,列向量$y$ 使得</p>
<script type="math/tex; mode=display">
x(I-DC)y = 1</script><h3 id="rank-condition"><a href="#rank-condition" class="headerlink" title="rank condition"></a>rank condition</h3><p>称环 $R$ 满足 rank condition, 如果对任意 $n$, $R_n$ 中生成元的个数都大于$n$.<br>等价定义 1: 任意满同态 $f: R^m \to R^n$可推出 $m \geq n$.<br>等价定义 2: 环 $R$ 不满足 rank condition, 当且仅当, 存在 $n&gt;k \geq 1$, 那么存在 $n \times k$ 矩阵 $A$ 和 $k×n$ 矩阵 $B$使得$AB=I_n$</p>
<blockquote>
<p>由上面等价定义 2 知道 rank condition 是个对称的概念.</p>
</blockquote>
<p>若有环同态 $f:R→S$, 其中 $S$ 满足 rank condition, 那么 $R$ 也满足.</p>
<p>rank condition 与 stably finite 以及 IBN 之间的关系 $R \neq 0$:</p>
<script type="math/tex; mode=display">
\text{stably finite} \Longrightarrow \text{rank condition} \Longrightarrow \text{IBN}</script><p>套用一下定义,以及它们各自的等价定义,逆反命题就可以证明.</p>
<blockquote>
<p>stably finite 与 rank conditon 的密切联系</p>
</blockquote>
<p>对任意环 $R$, 下面结果等价:</p>
<ol>
<li>$R$ 满足 rank condition</li>
<li>$\bar{R} \neq 0$</li>
<li>$R$ 有一个非零 stably finite 的同态像 </li>
<li>对任意 $n \in \mathbb{N}, \quad C,D \in M_n(R)$，若 $CD=I_n$, 则对任意行向量 $x$ 和列向量 $y$, $x(I-DC)y \neq 1$</li>
</ol>
<p>这里难点在于 1 推出 4, 可以用反证法, 用增广矩阵得到</p>
<script type="math/tex; mode=display">
\begin{pmatrix} C \\ x(I-DC) \end{pmatrix} \left(D ,(I-DC)y \right) = \begin{pmatrix} CD & 0 \\ 0 & x(I-DC) \end{pmatrix} = I_{m+1}</script><blockquote>
<p>在 simple ring 中 stably finite 等价于 rank condition</p>
</blockquote>
<h3 id="strong-rank-condition"><a href="#strong-rank-condition" class="headerlink" title="strong rank condition"></a>strong rank condition</h3><p>称环 $R$ 满足 right strong rank condition, 如果对任意 $n$, $R^n$ 中任意线性相关的元素个数不超过 $n$.<br>等价定义 1: 任意单同态 $f: R^m \to R^n$ 可推出 $m \leq n$<br>等价定义 2: 任意 $m$个未定元 $n &lt; m$ 个方程的线性方程组在 $R$ 中必有非零解.(用线性相关的定义可知)</p>
<blockquote>
<p>实际上 strong rank condition 不是对称概念, 所以严格上, 我们要指出 left, right.</p>
</blockquote>
<p>由 (strong) rank condition 的等价定义可知:</p>
<blockquote>
<p>由于 $R^n$ 是自由$R$- 模,因此,可以推出 right strong rank condition 可推出 rank condition.</p>
</blockquote>
<p><strong>注意</strong> right strong rank condition 不像之前的满足 $f: R \to S$, 满足”性质”, 则 $R$ 满足”性质”.</p>
<p>$A \times B$ 满足 (right) strong rank condition (RSRC) 当且仅当 $A$ 或者 $B$ 满足 RSRC </p>
<p>由上面性质知道, stably finite 和 strong rank condition 是两个独立的概念, 彼此不搭嘎. 例如: </p>
<ol>
<li>$R = \mathbb{Q} &lt; x, y&gt;$ 是 stably finite, 但不满足 RSRC.</li>
<li>而由上面性质知道, 我们只要构造一个满足 RSRC 和一个不满足 stably finite 的积即可.</li>
</ol>
<p>满足 RSRC 的例子:<br>Noetherian rings, Commutative Rings.</p>
<blockquote>
<p>最后给出一个线性无关的等价定义:</p>
</blockquote>
<p>$u_1,\cdots,u_m$ 在 $M = R^n$ 中线性无关, 当且仅当</p>
<script type="math/tex; mode=display">
0 \neq u_1 \wedge \cdots \wedge u_m \in \bigwedge ^m (M)</script><h3 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h3><p>自由模下的关系(任意箭头一般都不可逆):</p>
<p><img src= "/img/loading.gif" data-lazy-src="MRing1.png" alt="MRing1"></p>
<p>一般地, Dedekind finite + Rank condition 依然无法推出 stably finite. 例如:</p>
<p>设 $R$ 为由元素$s,t,u,v;w,x,y,z$ 生成的 $k$ 代数,设 $A = \begin{pmatrix} s &amp; u \\ t &amp; v \end{pmatrix}, B = \begin{pmatrix} x &amp; y \\ z &amp; w \end{pmatrix}$ ,其中生成元满足关系: </p>
<script type="math/tex; mode=display">
AB=I_2</script><p>由此可知, $R$ 是 domain, 但是一般地, $BA \neq I_2$ 因此 $M_2(R)$ 不是 Dedekind finite 的. 因此 $R$ 不满足 stably finite 条件.<br>定义 $f: R \to k$ 为 $f(s)=f(v) = f(x) = f(w) = f(1) = 1$, $f(u) = f(t) = f(y) = f(z) = 0$. 因此由 $k$ 满足 rank condition, so is $R$.</p>
<h2 id="投射模"><a href="#投射模" class="headerlink" title="投射模"></a>投射模</h2><h3 id="投射模的定义"><a href="#投射模的定义" class="headerlink" title="投射模的定义"></a>投射模的定义</h3><p>称一个右 $R$-模 $P$ 为 projective module（投射模）,如果<br>对任意 $R$ 模满同态 $g:B\to C$ 和任意 $R$ 模同态 $h:P\to C$,存在 $R$ 模同态 $h’: P \to B$ 使得 $h = gh’$</p>
<blockquote>
<p>由定义显然自由模都是投射模.</p>
</blockquote>
<p>等价定义: 从右模范畴到 Abel 范畴 $\hom(P,-)$ 的函子是 exact functor(正合函子).<br>由定价定义易知:</p>
<script type="math/tex; mode=display">
\bigoplus_{i \in I} P_i \text{ 投射当且仅当 } P_i, i\in I \text{ 投射 }</script><p>由之前说明的自由模都是投射模可知以下条件等价</p>
<ol>
<li>$P_R$ 投射</li>
<li>$P_R$ 是某个自由 $R$ 模的直和因子</li>
<li>任意满同态 $B_R\to P_R$ 可裂</li>
</ol>
<p>由此可知:(Eilenberg’s Trick) 若 $P_R$ 投射,则存在自由模 $F_R$ 使得 $P \oplus F \simeq F$</p>
<blockquote>
<p>Proof: 由 $P_R$ 投射模, 所以存在 $Q_R$ 使得 $P \oplus F \simeq F$ 为自由模, 取 $F$ 为 $E$ 的可数直和即可.</p>
</blockquote>
<p>不是投射 $\mathbb{Z}$ 模的例子:</p>
<script type="math/tex; mode=display">
\mathbb{Z} / 2 \mathbb{Z}, \quad M = \mathbb{Z} \times \mathbb{Z} \times \cdots</script><p>一个有趣的结果:<br>设 $P = \mathbb{Z} \oplus \mathbb{Z} \oplus \cdots \subset M$, 则 $\hom_{\mathbb{Z}}(M/P,\mathbb{Z}) = 0$<br>证明关键点在于 $M = A_2 + A_3$, 其中 $A_k = \lbrace (k a_1,k^2 a_2,\cdots,k^n a_n,\cdots): a_i \in \mathbb{Z} \rbrace$,<br>然后说明 $A_k\in P$, 且 $f(M)=f(A_2)+f(A_3) \subset f(P)$ 即可.    </p>
<h3 id="Dual-Basis-对偶基"><a href="#Dual-Basis-对偶基" class="headerlink" title="Dual Basis(对偶基)"></a>Dual Basis(对偶基)</h3><p>$P_R$ 是投射模, 当且仅当它有对偶基, 即存在一族元素 $\lbrace a_i: i\in I \rbrace \subset P$ 和线性函数 $\lbrace f_i: i \in I \rbrace \subset P^{\star} = \hom(P,R)$ 使得对任意 $a \in P$, 只有有限个 $f(a_i)$ 非零, 且 $a = \sum a_i f_i (a)$.</p>
<p>对任意 $R$-模 $M_R$, $M^{\star} = \hom(M,R)$ 是左 $R$-模, $M^{\star \star} = \hom(M^{\star} ,R)$ 是右 $R$-模, 我们有自然的右模同态, $\epsilon: M \to M^{\star \star}$ 定义为: $\epsilon(a) = \hat{a}$, 其中 $\hat{a} (f) = f(a)$ 为求值函数.</p>
<blockquote>
<p>特别地, 当 $M_R$ 是投射的, $\epsilon$ 是单同态, $M_R$ 是有限生成投射时, $\epsilon$为同构.</p>
</blockquote>
<p>例: $e \in R$ 为幂等元, 则 $R = eR \oplus (1-e)R$, 所以, $P = eR$ 为有限生成投射模.</p>
<h3 id="Invertible-Modules-and-Fractional-Ideals-可逆模-可逆理想"><a href="#Invertible-Modules-and-Fractional-Ideals-可逆模-可逆理想" class="headerlink" title="Invertible Modules and Fractional Ideals(可逆模,可逆理想)"></a>Invertible Modules and Fractional Ideals(可逆模,可逆理想)</h3><blockquote>
<p>此小节中默认 $R$ 为交换环</p>
</blockquote>
<p>很大一类的交换环上的投射模是由环扩张 $S \supset R$ 得到的.<br>现在, 给定(交换)环扩张 $S \supset R$. 考虑模 $S$ 的 $R$-子模, 设 $P,Q$ 为模 $S$ 的 $R$-子模, 定义:</p>
<script type="math/tex; mode=display">
PQ = \lbrace \sum p_i q_i : p_i \in P, q_i \in Q \rbrace, \quad Q:P = \lbrace s \in S: sP \in Q \rbrace,\quad P^{-1} = \lbrace s \in S : sP \subset R \rbrace = R:P</script><p>注意到 $P^{-1}$ 依赖于环扩张 $S$ 的选取.</p>
<p>由上面定义,我们立即有下面引理(条件 <code>1,2</code> 等价):</p>
<ol>
<li>存在 $S$ 的 $R$-子模 $Q$ 使得 $PQ = R$</li>
<li>$PP^{-1} = R$</li>
</ol>
<p>由于上述定价,我们把满足条件的 $P$ 称为 <strong>Invertible  $R$-submodule</strong> of $S$<br>在此条件下,我们有:</p>
<ol>
<li>$P$ 是有限生成投射 $R$-模 (利用 $\sum p_i q_i = 1$)</li>
<li>任意 $R$-子模 $M \in S$, 自然映射 $f: P \otimes _R M \to PM$ 是 $R$-模同构</li>
<li>$P^{\star} \simeq P^{-1}$ (因此 $P^{\star}$ 可以成 $S$ 的子模)</li>
<li>$P_R$是自由模,当且仅当存在$s \in R$使得$P = sR$(此时$s$必然是$s$中的可逆元)<blockquote>
<p>结论 4 经常用于说明一个模是投射模但不是自由模.</p>
</blockquote>
</li>
</ol>
<p>下面有一个很精彩的例子:<br>设$R \subset S$ 为交换环, $g \in S$满足 $g^2,g^3 \in R$, 即 $g^n \in R$ 对 $n&gt;1$ 成立. 定义$P_r = (1+rg, g^2)$, 那么</p>
<script type="math/tex; mode=display">
P_r P_s = (1+rg,g^2)(1+sg,g^2) = (1+(r+s)g+rsg^2,g^2+sg^3,g^2+rg^3,g^4)</script><p>显然上面集合包含 $g^2(1+(r+s)g+rsg^2)-rsg^4 = g^2 +(r+s)g^3$,<br>因此包含 $rg^3,sg^3,g^2,1+(r+s)g$, 因此</p>
<script type="math/tex; mode=display">
P_r P_s = (1+(r+s)g,g^2,rg^3,sg^3)</script><p>再由 $g^3(1+(r+s)g) - (r+s)g^2g^2 = g^3$ 可知: </p>
<script type="math/tex; mode=display">
P_r P_s = (1+(r+s)g,g^2) = P_{r+s}</script><p>因此 $P_r P_{-r} = P_0 = (1, g^2) = R$, 即 $\lbrace P_r: r \in R \rbrace$ 是一族 Invertible $R$-submodule of $S$(因此投射), 且 $P^{\star} = P_r^{-1} = P_{-r}$. $P_r$ 是 $R$-free 当且仅当 $u(1+rg) \in R$ 对所有的 $u \in U(R[g])$</p>
<blockquote>
<p>之前说过 $P^{-1}$ 依赖于 $R$ 的扩张 $S$ 的选取,现在我们在 $R$ 的所有 regular element(正则元)这个乘闭子集 $C_R$ 上做局部化得到环 $K$, 那么自然映射此时是单同态, 因此局部化得到的环可以看做 $R$ 的扩张(由 $R$ 唯一决定). 且对任意 $k \in K$, 都存在 regular element $u$ 使得 $u_k \in R$.</p>
</blockquote>
<p>称 $K$ 的 $R$-子模为 <strong>fractional ideal(分次理想)</strong> 通常记为 $\mathfrak{A}$</p>
<p>引理: 对任意 fractional ideal $\mathfrak{A} \subset K$ 且 $\mathfrak{A} \cap C_R \neq \emptyset$, 则有 $\hom(\mathfrak{A}, K) \simeq K$.</p>
<p>Proof: 作映射 $\lambda : K \to \hom_R(\mathfrak{A},K)$ 为: $\lambda(k)(a) = ka$, 证明单满即可.</p>
<p>对任意 fractional ideals $\mathfrak{A},\mathfrak{B} \subset K$, 我们也有类似引理的证明: 当 $\mathfrak{A} \cap C_R \neq \emptyset$</p>
<script type="math/tex; mode=display">
\hom_ R(\mathfrak{A},\mathfrak{B}) \simeq \mathfrak{B}:\mathfrak{A}</script><blockquote>
<p>特别地, 若 $\mathfrak{A} \cap C_R \neq \emptyset$, 则 $\mathfrak{A}^{\star} = \mathfrak{A} ^{-1} = R:\mathfrak{A}$.</p>
</blockquote>
<p>对任意 fractional ideal $\mathfrak{A} \subset K$, 下面等价:</p>
<ol>
<li>$\mathfrak{A}$ 是 invertible module($\mathfrak{A} \mathfrak{A}^{-1} = R$)</li>
<li>$\mathfrak{A}$ 是投射模,且 $\mathfrak{A} \cap C_R \neq \emptyset$</li>
<li>$\mathfrak{A}$ 是有限生成投射模,且 $\mathfrak{A} \cap C_R \neq \emptyset$<blockquote>
<p>此条件下 $\mathfrak{A}$ 自由模当且仅当 存在 $s \in K$ 使得 $\mathfrak{A} = sR$(此时 $s \in U(K)$)</p>
</blockquote>
</li>
</ol>
<p>由上可知: 若 $R \neq K$, 则 $K$ 不是投射模.</p>
<p>Proof: 如果是, 那么必然有限生成投射, 因此</p>
<script type="math/tex; mode=display">
K= \sum _{i=1} ^n R c _i d _i ^{-1} (c _i \in R, d _i \in C _R)</script><p>那么 $d = d_1 \cdots d_n \subset U(K)$, 我们有 $K = dK \subset R$ 矛盾于条件.</p>
<blockquote>
<p>因此 $\mathbb{Q}_{\mathbb{Z}}$ 不是投射模.</p>
</blockquote>
<h3 id="交换环上的-Picard-Group"><a href="#交换环上的-Picard-Group" class="headerlink" title="交换环上的 Picard Group"></a>交换环上的 Picard Group</h3><p>实际上, 第二小节和第三小节中的 Invertible Module 都是”秩为 1”的有限生成投射模, 对于交换环, 秩的概念定义如下:</p>
<p>由于若 $P,Q$ 为$R$-模, $P \otimes Q$ 也是 $R$-模, 且当 $P,Q$ 投射时, $P \otimes Q$ 也是投射模.</p>
<p>当 $P$ 是有限生成投射$R$-模时, 对于 $R$ 的任意素理想 $\mathfrak{p}$, 在其上局部化得到 $P_{\mathfrak{p}} = P \bigotimes_{R} R_{\mathfrak{p}}$ 也是有限生成投射的. 由于 $R_{P}$ 交换局部环, 因此 $P_{\mathfrak{p}}$ 是自由的(交换局部环上有限生成投射模是自由模).因此就有秩, 也就是说我们有从 $R$ 的素谱到 $\mathbb{Z}$(带离散拓扑)的一个连续映射. 当这个映射是常值映射时(这要求 $R$ 中无非平凡幂等元),就称这个常值为投射模 $P$ 的秩.</p>
<blockquote>
<p>注意到若 $rk(P)=n,rk(Q)=m$ 那么 $rk(P^{\star})=n, rk(P \otimes Q) = mn$</p>
</blockquote>
<p><strong>引理</strong> 设 $R \subset S$ 为交换环, 那么在任意 $S$ 的可逆 $R$-子模都是秩为 1 的投射模.</p>
<p>Proof: 用一个 Invertible Module(可逆模)的定义, 以及成为自由模的条件, 即可证明.</p>
<p>设 $Pic(R)$ 为 $R$ 上所有秩为 1 的有限生成投射模的同构等价类. 将 $P$ 的等价类记作 $[P]$<br>我们定义乘法(满足结合律, 交换律):</p>
<script type="math/tex; mode=display">
[P][Q] = [P \otimes Q]</script><p>$[R]$ 成为 $Pic(R)$ 中的幺元, $[P]^{-1} = [P^{\star}]$.<br>即 $Pic(R)$ 关于上述乘法构成 Abelian group. 称为交换环 $R$ 的 Picard group.</p>
<blockquote>
<p>实际上 “Pic” 还是交换环范畴到 Abelian group 范畴的函子.</p>
</blockquote>
<p>具体到 $R \subset K$, $K$ 中所有 invertible fractional ideals 是 $R$ 上秩为 1 的有限生成投射模(记为 $I_{R}$) 但是一般地 $R$ 上所有秩为 1 的有限生成投射模并不一定同构与某个 invertible fractional ideal.</p>
<p><strong>定理</strong> 对自然映射 $f: R \to K$, 我们有正合列</p>
<script type="math/tex; mode=display">
 1 \to U(R) \to U(R) \to I_{R} \to Pic(R) \to Pic(K)</script><h3 id="semi-Hereditary-Rings"><a href="#semi-Hereditary-Rings" class="headerlink" title="(semi)Hereditary Rings"></a>(semi)Hereditary Rings</h3><p>在交换环中, Dedekind (domain) ring 定义为交换整环 $R$, 所有理想都是 Invertible Ideal(或者说投射的). 这说明 $R$ 必然是 Noetherian domain. 因此 Dedekind ring 也可以定义为 Noetherian domain 中整闭的 Krull 维数为小于等于 1 的环, 也可以定义为满足每个理想都是一些素理想的有限积的交换整环.</p>
<p>把上述 Dedekind ring 推广到非交换的情形, 我们有如下 <strong>Hereditary ring</strong> 的定义:<br>A ring $R$ 称为右(左)Hereditary ring, 如果它的每个右(左)理想都是投射的, 如果它既为左又右,那么就成为 Hereditary ring.</p>
<p><strong>Kaplansky’s Theorem</strong> 设 $R$ 为 right Hereditary ring. 任意 $R$-自由模的子模 $P$ 都同构于 $R$ 的一些理想的直和. 特别地, $P$ 是投射的.</p>
<p>由于每个模都可以看成自由模的同态像, 投射模是某个自由模的直和因子, 又由 Kaplansky 定理知:</p>
<ol>
<li>在一个 right hereditary $R$ 上, 一个 $R$-模 $P_R$ 投射, 当且仅当它能嵌入到一个自由模中.</li>
<li>环 $R$ 投射, 当且仅当, 每个投射 $R$-模的子模都是投射的.</li>
<li>若环 $R$ 是 PRID(principal right ideal domain), 那么每个自由 $R$-模的子模都是自由的.</li>
</ol>
<p>类似于 Hereditary ring 的定义, 我们称一个环 $R$ 为 <strong>semihereditary ring</strong>: </p>
<p>$R$ 称为右(左)semihereditary ring, 如果 $R$ 的每个 f.g.(finitely generate 有限生成)右(左)理想都是投射 $R$ 右(左)模. 如果既左又右, 称为 semihereditary ring.<br>我们称交换的 semihereditary ring 为 Prufer ring.</p>
<p>类似于 <strong>Kaplansky’s Theorem</strong> 我们有 $R$ 为 right semihereditary ring. 任意 $R$-自由模的有限生成子模 $P$ 都同构与有限个 $R$ 的理想的直和.</p>
<blockquote>
<p>right semihereditary 的等价刻画:</p>
</blockquote>
<p>$R$ 为 right semihereditary ring 当且仅当投射右 $R$ 模的有限生成子模都是投射的.</p>
<p>例子:</p>
<ol>
<li>Semisimple ring is hereditary.</li>
<li>PRID is right hereditary, 例如 $D[x]$, 其中 $D$ 是 division ring.</li>
<li>$M_n(R)$ is semihereditary, 其中 $R$ 为 Dedekind ring.</li>
<li>von Neumann regular ring is semihereditary.</li>
<li>$\begin{pmatrix} \mathbb{Z} &amp;  \mathbb{Q} \\ 0 &amp; \mathbb{Q} \end{pmatrix}$ 是 right hereditary, left semihereditary, but not left hereditary. Note that this example is also left artinain but not right Noetherian.</li>
</ol>
<h3 id="Hereditary-Artinian-Ring"><a href="#Hereditary-Artinian-Ring" class="headerlink" title="Hereditary Artinian Ring"></a>Hereditary Artinian Ring</h3><p>Hereditary Artinian ring 十分的重要(因为简单 0.0), 一般一个概念加上 Artinian 条件就会变得特别简单, 例如 Artinian commutative domain is field.</p>
<p>设 $J = rad R$ 为环 $R$ 的 Jacobison radical. 若 $R$ 是 Artinian ring. 以下结论等价:</p>
<ol>
<li>$R$ is right hereditary.</li>
<li>$J$ 作为右 $R$-模是投射的.</li>
<li>对任意幂等元 $e$, $eJ$ 是投射右 $R$-模.</li>
<li>$R$ 的任意极大右理想都是投射右 $R$-模.<blockquote>
<p>证明难度还是有的, 要用到任意有限生成 Artinian 模都是有限长的.</p>
</blockquote>
</li>
</ol>
<p>例子:</p>
<p>设 $R$ 是 divison ring $D$ 上的 $n \times n$ 上三角矩阵全体, 则 $R$ 是 hereditary Artinian ring.</p>
<h3 id="Trace-Ideal"><a href="#Trace-Ideal" class="headerlink" title="Trace Ideal"></a>Trace Ideal</h3><p>Definition: 对任意 $P_R$, 定义 $tr(P) = \sum im(f)$ 其中, $f$ 跑遍 $P^{\star}$. 容易看出 $T = tr(P)$ 是 $R$ 的理想, 称为 Trace Ideal. 它满足:<br>若 $P_R$ 是投射的, 则 $PT = P, T^2 = T, ann(P) = ann_r(T)$<br>特别的, 若 $P_R$ 是有限生成投射的, 那么其对偶基 $\lbrace a_i f_i \rbrace_{1\leq i \leq n}$. 那么 $tr(P)$ 可由有限集 $\lbrace f_j(a_i) \rbrace$ 生成.<br>另外,若 $tr(P) = R$, 我们称 $P$ 是生成子.</p>
<p><strong>引理</strong> 设 $T$ 是交换环 $R$ 的有限生成幂等理想, 则存在幂等元 $e \in R$ 使得 $T=eR$.<br>Proof: 关键在于把 $T$ 写成 $T = \sum_{i=1} ^n Tx_i$</p>
<p>由上述引理和 $T = Tr(P)$ 的性质, 不难证明下面定理:<br><strong>定理</strong> 设 $P_R$ 是交换环 $R$ 有限生成投射模, 那么存在幂等元 $e$ 使得 $T=Tr(P)=eR, N = ann(P) = (1-e)R$, 特别地, $R = T \otimes N$, 投射模 $P_R$ 是 faithful(忠实的)当且仅当 $T = R$.<br>当 $R$ 无非平凡幂等元时, 则 $P \neq 0$ 是(有限生成投射)生成子. </p>
<blockquote>
<p>定理中条件缺一不可, 且幂等元 $e$ 可以根据有限对偶基显式表达出来.</p>
</blockquote>
<p>Trace ideal 的应用:<br><strong>引理</strong> 设 $R \subset S$ 是环(不要求交换), 则 $R$ 是 $S_R$ 的直和因子, 当且仅当, $Tr(S_R) = R$.<br>Proof: 若 $R$ 是 $S_R$ 的直和因子, 则 $Tr(S_R) \supset Tr(R_R) = R$, 所以 $Tr(S_R) = R$.<br>若 $Tr(S_R) = R$, 那么存在 $f_i \in S_R^{\star},s_i \in S, (1 \leq i \leq n)$ 使得 $\sum f_i(s_i) = 1$.<br>定义映射 $\lambda: S \to R$ 为: $\lambda(s) = f(s_i s)$. 为环同态, 且在 $R$ 上限制为恒等映射.(因此 $R$ 是 $S_R$ 的直和因子).</p>
<p><strong>定理</strong> 设 $R \subset S$, 其中 $R$ 是交换环, $S$  是 f.g. 右 $R$-模. 则 $R$ 是 $S_R$ 的直和因子.<br>Proof: 由 $ann(S_R) = 0$, 在由上面引理即证。</p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>2017 横店马拉松</title>
    <url>/hengDianMarathon2017/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">日常表白 zly</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="f23ac8c1235d88f0476c7a3b36b424664b2bcd8fa71cb253588c1aa9ef98f7c6">f4647356fba07bf28b4b6a3e7b03b38f4628766f98ae0424ccbd481648acbe8d8e1a1a201c2ee8266a97cd27c77d0c7ae8343e85c556bc585af85269b33afbc2a1b9f85c50484bd25d762aa292c3e67a1a1e0d6b0eae21d996a3ba75104199754f52cd4fdb5ea7354b80a3f21b708e4072509d0c0737413c01b3b7e6715bd3bc4b4a938c6354736f246d21daa1e82838e1e3dbf36d43a9b90ceff1eb11e6966db9f3e694537b41fc46555bd4523491be08cb99295c142442ef0982d91f96ce75543494d7ebfade9e020b9284a6ccde05891807db3913bb3442b1f2ad9a5b7271956b0bfd6325db5e4c63348a53203fc6129fb5574cce3061b7ed41c9357582966e615c2f17ba12376ad721c011e9f926906c193fc0fb2bb6fb5e32c923be676ffa83cb51223d88b860c139c4bfec42599c652f1047665dcf11499e0b4f3f5ea75921d73423a7f487fba61ac3ab276da1d532716aa72118646326780caea5d8359342120dddae58da865754729b9d0e39f9dcb568dcf606c224efee88660ac99f53f550fc0257d2b86571dfbafdf8bbd04b2998deb1a67bb0a2394eb60e71a0ba187909c5e7e41cd60239e2dd617174fe2017224c5ef2248f54032175205851693f5ce06232dfc98a6113b2ca128417133883e459c5f02711073345000581f83466fa927bcb54222dda8c569f8ae5916f58374c751dcd17ab303f455ab93bafb69408c9ae6ad3611615ad4b054951eed1352d10614250677d16219fb80823334c10f14238d9bdc2caa52b009be35f496ef1c995b69543c6c4550714e9e30bc357dee92212c874a6812a1160ceb9ca2099e43492bbd212d3c1251b46e2e7ccbbf6128a31c4f040b2c1889ee4aa386b4f14c83f1d6ffa541ca36006b62b354e7acf5d55e84ee8beadd9937316c868d70f6da46509a2c7d7413afea4d614da7a6ba9bf3e30fc5210b67f5395947860d719f48d49061234eaf6ed43f9478f426fedb4a3810b938f189da27b8b76769fb1c7f785275679cde0daabd7b3da613edeba650be3a8b7b01068b7707f009402b92961e94f1529f8766d66416e47000a15482129f16c79d7f5b60b69dc9bbc5384c8364410021f28f9a47630cabf344d2b8bdf30e785cc238565530358b776fd78a329975cfcd9fc5f71c001577b9897c3b05ecd0fb890637b46857682b6b99d83ff16581f003c8603190d1f80292970620b33cbac80a7d80f2f28a4a383e654624ec53ca5e32dcb7b834f152d0ad1d75679ed4e428efee34bf48f85cca17ca680bedde196427f1a1d3abb9793ccbe10e478b7577b2ad0bcd1d166f30491f8764fa9511c4cfe93673f4d5629b31ebc27666024a115ba60deba08cb9d1dd1f79fc168f0011fb4fc9c87e0c22f4bbb9a676ad750c042d22f71714a6cdd8c96a7dcf484657769eac71ba120e560138d8be47f82f0afb4d7b64177136c9cedc3a06642b90ae72f50a0dd004dcb6421305f0963b93670018e2e9c7bacd8e979d8f713603b52722e9680758e0866fcd13a964aef9118525e089e5536af69f96cc31495a1d7b053385b735f2ce2048ce301e414d14b2c2e3183252029620e5d85e3a5a038140b308f20ffc8acae3f9ff03a189bf0f645a261c204ab710ecce3e7e68e7b1970688e04bc9757ec71fcfabe7cb3b9706dbd8145b8f1d68a2cd77d5dcdf8588564709ed5894ff0ed3ab2a5b7d905aa0ddd13840ffb3e807b11125e7d00653339de0d8305b391247847bdfba872609528e2784b4f6283920b650ca0f625d3cbe3a2325e1f31fef03b45d0c6649f3ab2e66a3f91ac4554bfae5ed8847954f3f8728abdf237d1c748ace0cef18bd5ad32eb35430357c8a16be38a4f54b17ceb2eb3a720e3a7d206c5e9ebb7cb1e94444f6e2547fb3082bab2b76fd641f7f4553f730133608c709fb9e5a86322384026c9d381c0f79138f1427cfd773a7782075f64b0eaf7bb11aaa2c29b5544a3746ccf11fa7bc04cf33dc417d6369f8330e27c2248e454abd8efe0067851022d5ce0aeae5a4046132ed033f1bef723c476cb974141a224ebb2556a6d0dbe45d0027b688525d37c48d21859fb5b0275428139d52d0cade210f149fcedca838e20d8c0f7d6633eca25a2052a21d712ef70d9548c08adf0b817346cb22cdd23c27d95170bed2e80a46b2117052b9689780e76d6f865fec29b30f66d2b7fbf771da9ab944c0d772d6c5429305e030cbbb0dc8b613069a16f2e8ded597f88b959134d39bdfc398d4333ed35f3f3fc8326d1a07d5be4610df74ff190ffc32b2dca09bbe262f7b4f0abf788bfa6e001dff1e45d5fd4ab666ffd501b181e3d0791960cd1025d2d174adda1041d1558530c582a17a7b2959b631a383f801e7bd30d1312bbe04b0dd63aead6652725530d9dcbe6f3d41f1a6375e8bc4e86e852082ea73e90063c30587a4cb5ef592714dee050ed8d2fa324eab921c84bf73335bc0da8c3f62e4e02e30e6ae391764fbc4f28f7c3e778caa08c8eada0c51b25724bd452a9729bcf6c562dfa94bab98d0cc4420e5cd0448c637935fbf8eab434e1c767c587c474f7e09bec01458416eb18b3511f917dda8fb4ae8a7a00e2b59af88b9a4412dbaa9b8530ba6140b2f5c527137d3b693f968630493a07f7d9749ade7dea1aa774ccfd1803ec6dea06591b9679b628c5e3431fa3ce612b022a016eacf40837bca0c418758987bc5a8e539087c4c92dc92a14aab72ce3690737a21f67bf63fe9297d954bd1a842cfd038cd7d0d812104ebc49e385848eeb74295181c6e3d39c38f9e80bcb426646e1fe94ad69847a5540a557cea96a6dad7ac62e35dea7dc92db075d0cdbd2139c3653128d66bdd89427cacaa3d0e42ec4bdad83a72bc19a7881e029a3485b6a0f6c2899d800fbf3dc71cabb66857afa887c3a795fe4af2453fc95676d497fe21b5ad205fd4eef5440419294a3a660062dcd962667da541d02fbc2f3fd00468a596972afc00223c5b8bea33a52d8c0db0384b659840883dacd6e5b6f610890d496cc67a357ab966a5e7a62b00c5817f18f4072d897b8363018a35ca7eb07caa826449ae4541550b3502d74c09d8b92075f88c9c9a467ca00e3ecc8a3e5095531a87a7f290a1540d2aa6a4292e2385da8b007bd89e9dac231a53eb03dcaeb863a262067d40b2d34fc1d5a54f0a579dcba1275848c279fcb64f326caa738b16a88afc18d9573c78b92a9a4ddaacf82aef7379e2961e267817fd6673db46d868e406c593d1be830bc80f6a68e512026952609be28d79acd30c768456d66d8d24839ed92b4907dda0516d349f4ddeef8a2250cd192ee948147036a76ac3716a8672cfcb84e84e423300989601377e388a5d5fb2d287c8487d1deff3102ea307ad2e512b946401060c9d44573fe94a5ef1b9f91477ca6952767e6368ca22268f1d7de61c4f318b53310971336040f006f3e01727e54606305cda2bc7dd3be96d536142a07754d1b93099cd23748c33fea09142b48d30b0e1d0e17771ac3a5cd0f84094e7b939b8fcc804bc1cc6761ec2d44c953b37b65126b3a4d4ac7326fd0db6d039f4ce533f515e48fa1ddc624f0e1ce658a890e593fda448281e3adf01690bb3b2b3b50dbcd29346d1b0d4f51ff7544231547631dce7e20508135ce5d6265fc414614c9d875447a2f40e2deb4ac7c8cc23b03db0b6a92a5fa3957be549b86010c01f7b346ddcc0b9fa4495dc67434585d5e6f8589efaad5eb6aae76af76428d95bf6834223c29494fe34514d5c4efab0e0d851f11d5547a34add0b0d56f8bb488ffaa2ba5810b623781609e5d46cf596c0f1dbfbd890778a1b78e921f0e3f002c7e890015805ce662f810687c30f8c743cba22d9ade687ccb356b5e5f5603eed66fc520c5de53cba5e0fe825085570d31b231f64edfd6f7d15ed49a167d1c57401617a9b29d1fca7845d7890e4f12582d4b882932608a6fff54b205421fbc6d66dd1b183cc3ff08baf67831b6f0531f583eb66ceb8a09c0a1eeea55860432f02308bc380076cadde0f4dc15b065cc2da35ac589f54baf4149745e773101eed709a4821fde73453790760841136e72c58f4393a45e88e01f13212578e7a828a3984e4a2b90a56cffb36bb353116b45551bd16f624efb80b0dc3ec6a1a75ed46eecd1a5710046de618751bcaed877fe1d484cbc4a7840194eb884fd555031f3312251c9b6656af0ac2cbd2a96034aa694053ca4c72b8819ccb9881a38100184c22f9f7d7f2de92457430fd32f74c31e16ce969fb571597240d380d39d82ab6f31535f6e4b537a757255b69bf011c99b4a938d4347d11e981e8990db6410a082a52a5fdd38d4e27642d3abead5509b0e6c9543df00f0765425bbf9bf2d44f830e8f0d09bd2442dcaedd0781acebac3e76c2159ed07f7318bfd0948c78fda776bd892a60dc292c31c6e829fe6fef8b1484fbd1117fcf7abeae43dc7f518b97efd6a9b0278b2b703447be1d9f730a421e8da19fc6310030729b38468cfc99ed1b1cb863059c6e846f203b3b1da912ea94a6901af</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Encrypt</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>非交换环概念框架图</title>
    <url>/graphOfNoncommutativeRing/</url>
    <content><![CDATA[<p>最近在看 T.Y.Lam（林节玄）的书，深知非交换环的小技巧深不见底，不过仔细品味了一番之后也觉得十分有趣。最后给一张各种概念之间的关系，每一种概念都有很多等价定义，概念之间关系的推导也十分微妙，充满了技巧性。</p>
<a id="more"></a>
<p><img src= "/img/loading.gif" data-lazy-src="0.png" alt="noncommutaiveRings"></p>
<p>上面带 <code>=</code> 号的条件是说在此条件下，两个概念等价。<br>推理的细节，以及各个概念的定义为这里就不写了。</p>
<blockquote>
<p>有兴趣可以查阅 GTM 131 T.Y.Lam《A First Course in Noncommutative Rings》</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>与单个矩阵交换的矩阵全体</title>
    <url>/matrixCommuteWithOne/</url>
    <content><![CDATA[<p>这个结果还是有些重要的所以记录一下，但是呢？我太懒了，直接截图吧 0.0</p>
<a id="more"></a>
<p><img src= "/img/loading.gif" data-lazy-src="m1.png" alt="m1"></p>
<p><img src= "/img/loading.gif" data-lazy-src="m2.png" alt="m2"></p>
<p><img src= "/img/loading.gif" data-lazy-src="m3.png" alt="m3"></p>
<p><img src= "/img/loading.gif" data-lazy-src="m4.png" alt="m4"></p>
<p><img src= "/img/loading.gif" data-lazy-src="m5.png" alt="m5"></p>
<p>总体问题还是很复杂，但是特殊情形十分简单：</p>
<blockquote>
<p>若方阵的特征多项式是最小多项式，那么与它交换的矩阵必然是 它的多项式。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>幂零矩阵的一个充要条件</title>
    <url>/nilpotentMatrix/</url>
    <content><![CDATA[<p>前几天一个学弟告诉我，关于复数域上幂零矩阵 $A$ 的一个充要条件：</p>
<script type="math/tex; mode=display">
A = AB-BA, \quad \exists B \in M_n(\mathbb{C})</script><p>特此记录。</p>
<a id="more"></a>
<p>证明分几个小步骤：</p>
<ol>
<li><p>必要性对若当块成立，若$A$为（上三角）若当块，那么取 $B=diag \lbrace 0,1,⋯,n−1 \rbrace$ 即可，若 $A$ 为分块若当块（若当标准型），那么取对应的分块 $B$ 即可。又由于</p>
<script type="math/tex; mode=display">
P^{-1}AP = P^{-1}APP^{-1}BP - P^{-1}BP P^{-1}AP</script><p>因此，由对若当标准型成立,可知道对一般形式成立。</p>
</li>
<li><p>$tr(A^k) = 0, 1 \leq k \leq n$ ，则$A$ 幂零。</p>
<p>由若当标准型可知，只需证明：</p>
<script type="math/tex; mode=display">
\begin{cases} x_1 + x_2 + \cdots + x_n = 0 \\ 
x_1 ^ 2 + x_2 ^ 2 + \cdots + x_n ^2 = 0 \\ 
\cdots  \\ 
x_1 ^ n + x_2 ^n + \cdots + x_n ^n  = 0 
\end{cases}</script><p>推出，$x_1 = x_2 = \cdots x_n = 0$ ，不妨设</p>
<script type="math/tex; mode=display">
\begin{cases} x_1 t_1 + x_2 t_2 + \cdots + x_r t_r = 0 \\ 
x_1 ^ 2 t_1  + x_2 ^ 2 t_2 + \cdots + x_r ^2 t_r= 0 \\ 
\cdots  \\ 
x_1 ^ r t_1 + x_2 ^r t_2 + \cdots + x_r ^r t_r = 0 
\end{cases}</script><p>其中 $x_i$ 互不相同，那么，假设 $r&gt;1$ 则由 Vandemode 行列式不为 0 知， $t_i = 0$ 矛盾，因此 $r=1$， 此时 $x_i=0$。</p>
</li>
<li><p>$C=AB-BA$ 且 $AC=CA$ 则，$C$ 幂零。</p>
<script type="math/tex; mode=display">
\forall k,tr (C^k) = tr(C^{k-1}AB - C^{k-1}BA) =tr(C^{k-1}AB) - tr(AC^{k-1}B) = 0</script><p>因此由上面结论知，$C$ 幂零</p>
</li>
<li><p>综合上述结论，充分性显然。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaplansky 定理</title>
    <url>/kaplanskyTheorem/</url>
    <content><![CDATA[<p>(非交换)环中有一个有趣的（Kaplansky）定理说：</p>
<blockquote>
<p>如果环 $R$ 中元素 $a$ 有不止一个右逆，那么 $a$ 有无数多个右逆。</p>
</blockquote>
<p><strong>像极了出轨只有零次，或者无数次。</strong></p>
<a id="more"></a>
<blockquote>
<p>(Kaplansky) Suppose an element $a$ in a ring $R$ has more than one right inverse. Show that $a$ has infinitely many right inverses.</p>
</blockquote>
<h2 id="Kaplansky-若环-R-中元素-a-有不止一个右逆，那么它有无数个右逆"><a href="#Kaplansky-若环-R-中元素-a-有不止一个右逆，那么它有无数个右逆" class="headerlink" title="(Kaplansky) 若环 $R$ 中元素 $a$ 有不止一个右逆，那么它有无数个右逆"></a>(Kaplansky) 若环 $R$ 中元素 $a$ 有不止一个右逆，那么它有无数个右逆</h2><p>证明：（反证法）设 $a$ 的所有右逆构成的集合为 $A = \lbrace x \in R \mid a x = 1 \rbrace$.</p>
<p>若 $A$ 有限，不妨设 $A = \lbrace x_1,x_2,\cdots,x_n \rbrace, (n&gt;1)$ , 则</p>
<script type="math/tex; mode=display">
a(1- x_i a + x_1) = a-(a x_i) a + a x_1 = 1</script><p>并且, 若 $1 - x_i a + x_1 = 1 - x_j a + x_1$, 即 $x_i a = x_j a,$ 那么 $x_i = x_i(a x_i)=(x_j a) x_j$, 也就是说   </p>
<script type="math/tex; mode=display">
A = \lbrace x_1,x_2,\cdots,x_n \rbrace =  \lbrace 1- x_1 a + x_1,1- x_2 a + x_1,\cdots,1- x_n a + x_1 \rbrace</script><p>所以存在 $k$ 使得 $1 - x_k a + x_1 = x_1$，即 $x_k a = 1$ 所以对任意 $1 \leq i \leq n$,</p>
<script type="math/tex; mode=display">
x_i = (x_k a) x_i = x_k (a x_i) = x_k</script><p>即所有 $x_i$ 都相同，矛盾与 $A$ 中元素个数大于 1，证毕。</p>
<h2 id="等价叙述：-如果环-R-中元素-a-有右逆而没有左逆，那么-a-有无穷多个右逆"><a href="#等价叙述：-如果环-R-中元素-a-有右逆而没有左逆，那么-a-有无穷多个右逆" class="headerlink" title="等价叙述： 如果环 $R$ 中元素 $a$ 有右逆而没有左逆，那么 $a$ 有无穷多个右逆"></a>等价叙述： 如果环 $R$ 中元素 $a$ 有右逆而没有左逆，那么 $a$ 有无穷多个右逆</h2><blockquote>
<p>通俗的讲就是，如果你喜欢一个不喜欢你的人，那你不仅仅只喜欢这个人。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Zariski Topology on  $k^n$</title>
    <url>/zariskiTopologyOnKn/</url>
    <content><![CDATA[<p>$k^n$ 最常见的拓扑自然是欧式拓扑，但是下面介绍的 Zariski 拓扑也是十分重要和“常见”的拓扑，并且它也保持了很多自然的性质，又有其独特的地方，值得了解一番。</p>
<blockquote>
<p>详见 Jacobson《Basic Algebra 2》</p>
</blockquote>
<a id="more"></a>
<h2 id="Zariski-Topology"><a href="#Zariski-Topology" class="headerlink" title="Zariski Topology"></a>Zariski Topology</h2><p>给定一个交换环 $A$ ,$Spec(A)$  表示 $A$ 理想全体构成的集合，带上一个 Zariski topology，拓扑中闭集为所有形式</p>
<script type="math/tex; mode=display">
V(I)=\lbrace P \in Spec(A) | I \subset P \rbrace , I \subset A</script><p>的集合，那么它必然会满足拓扑关于闭集的公理。</p>
<h3 id="k-n-上的-Zariski-拓扑"><a href="#k-n-上的-Zariski-拓扑" class="headerlink" title="$k^n$ 上的 Zariski 拓扑"></a>$k^n$ 上的 Zariski 拓扑</h3><p>由于 $k^n=\lbrace(a_1,a_2,\cdots,a_n)| a_i \in k \rbrace$  到 $k$ 的多项式函数与 $k[x_1,x_2,\cdots,x_n]$ 同构。所有 $k^n$ 上的拓扑</p>
<p>本质上是由交换环 $k[x_1,x_2,\cdots,x_n]$ 的 Zariski 拓扑所确定。</p>
<script type="math/tex; mode=display">
V(S)=\lbrace (a_1,a_2,\cdots,a_n) \in k^n | f(a_1,a_2,\cdots,a_n) = 0 , \forall f \in S \rbrace</script><ol>
<li><p>$V(k[x_1,x_2,\cdots,x_n]) = \emptyset$</p>
</li>
<li><p>$V(\emptyset)=k[x_1,x_2,\cdots,x_n]$</p>
</li>
<li><p>$\cap_{i \in I} V(S_i) = V(\cup_{i \in I} S_i)$</p>
</li>
<li><p>$V(S) = V(I(S))$</p>
</li>
<li><p>$V(I_1) \cup V(I_2) = V(I_1 I_2)$</p>
</li>
</ol>
<p>所以，上述 $V(S)$ 全体作为闭集构成了 $k^n$ 的一个拓扑，称为 $k^n$ 上的 Zariski 拓扑。</p>
<h3 id="性质（设-k-是代数闭域）"><a href="#性质（设-k-是代数闭域）" class="headerlink" title="性质（设 $k$ 是代数闭域）"></a>性质（设 $k$ 是代数闭域）</h3><ol>
<li><p>拓扑基： $k^n$ 中开集有形式 $k^n \setminus V(S) = \cup_{f \in S} O_f$ 其中 $O_f = k^n \setminus V(f)$ 为开集。<br>因此 ${O_f|f \in k[x_1,x_2,⋯,x_n]}$ 构成了 $k^n$ 上的拓扑集</p>
</li>
<li><p>$k^a$ 是 $T_1$空间。</p>
</li>
<li><p>$k^n$ 是不可约空间，即有限个非空开集交集非空。</p>
</li>
<li><p>$k^n$ 多项式映射在 Zariski 拓扑下连续。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>玩具：HC6800-ES 开发版</title>
    <url>/singleChip/</url>
    <content><![CDATA[<p>这里记录一些我的新玩具: <code>51单片机</code> 的基础常识，作为初学者，下文必然是错误百出。</p>
<blockquote>
<p>很久没更新博客了,毕竟很久没写程序了。数学类的嵌套的定义又太多，很不好写。</p>
</blockquote>
<a id="more"></a>
<h2 id="新玩具"><a href="#新玩具" class="headerlink" title="新玩具"></a>新玩具</h2><p>这次淘宝买的新玩具是：HC6800-ES V2.0 开发版，内部单片机是 STC89C52。见下图</p>
<p><img src= "/img/loading.gif" data-lazy-src="HC6800.png" alt="HC6800"></p>
<p>作为小白看了一下视频，但是呢，感觉视频什么的太慢，还是看书看手册来的爽。安装好单片机版 C 语言的 IDE Keil4 以及烧录软件之后，装一下开发版驱动，就可以在不知道单片机原理的情况下轻松的控制单片机了。例如什么 LED 灯闪烁，跑马灯，等等很基础的程序。</p>
<p>下面是单片机的管脚图和说明：</p>
<p><img src= "/img/loading.gif" data-lazy-src="89C52.png" alt="89C52"></p>
<p><img src= "/img/loading.gif" data-lazy-src="STC89C52_1.png" alt="STC89C52_1"></p>
<p><img src= "/img/loading.gif" data-lazy-src="STC89C52_2.png" alt="STC89C52_2"></p>
<p>从图上看知道 P0,P1,P2,P3 是重要的 I/O 口，例如我们把 P2 接到 LED 灯，那么给低电平 0，就可以使灯亮。还有 P0，P1 不仅可以作为 I/O 口，还可以作为地址，计时器、计数器来用。还有 P3，等等。由于我用的是开发版，每个口接什么基本上已经固定了，用的时候查相应的官方资料就行了。它也提供了很多程序例子，因此还是很好掌握的，只是要记点东西才能灵活操作它。</p>
<h2 id="HC6800-ES-VS2-0-常见管脚接法"><a href="#HC6800-ES-VS2-0-常见管脚接法" class="headerlink" title="HC6800-ES-VS2.0 常见管脚接法"></a>HC6800-ES-VS2.0 常见管脚接法</h2><ol>
<li><p>P2 口 8 个位接了 8 个 LED 灯，至 0 灯亮。</p>
</li>
<li><p>P1.5 接了蜂鸣器。循环至 0 至 1 发声。</p>
</li>
<li><p>P3.0 ~ P3.3 接了独立键盘（不过开发版上竟然接反了 K1 和 K2），使用按键的时候要软件消除抖动，一般延迟 10ms 来完成。</p>
</li>
<li><p>通过 P1 的数据，来判断矩阵键盘按的键。（见下图)  <img src= "/img/loading.gif" data-lazy-src="keyboard.png" alt="keyboard"></p>
</li>
</ol>
<ol>
<li><p>数码管使用 P0, 通过 LSA=P2.2, LSB=P2.3, LSB=P2.4 的 0-1 指来控制显示的地方。</p>
</li>
<li><p>常用定时器和中断标程。</p>
</li>
</ol>
<h2 id="1602-液晶显示"><a href="#1602-液晶显示" class="headerlink" title="1602 液晶显示"></a>1602 液晶显示</h2><p>这个虽然很复杂，但是生产该显示屏的会提供<code>lcd.h</code>和<code>lcd.c</code>然后我们只要先初始化 LCD：<code>LcdInit()</code>再执行字节输出函数：<code>LcdWriteData(char c)</code>即可。</p>
<h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>程序功能: 按下 k1 键 LED 跑马灯，K2 蜂鸣器发生，K3 数码管显示 1-8。由于不会中断，所以跑马灯写的很挫。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> led P2</span></span><br><span class="line">sbit k1=P3^<span class="number">1</span>;</span><br><span class="line">sbit k2=P3^<span class="number">0</span>;</span><br><span class="line">sbit k3=P3^<span class="number">2</span>;</span><br><span class="line">sbit LSA=P2^<span class="number">2</span>;</span><br><span class="line">sbit LSB=P2^<span class="number">3</span>;</span><br><span class="line">sbit LSC=P2^<span class="number">4</span>;</span><br><span class="line">sbit <span class="built_in">beep</span>=P1^<span class="number">5</span>;</span><br><span class="line">u8 beepS,i,ledState = <span class="number">0</span>,DigState = <span class="number">0</span>;</span><br><span class="line">u8 code smgduan[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">					<span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;; <span class="comment">//显示0~F的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 t)</span></span>&#123; 	<span class="comment">//  每次约10us</span></span><br><span class="line">	<span class="keyword">while</span>(t--);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ledStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ledState = <span class="number">1</span>;</span><br><span class="line">	led=<span class="number">0xfe</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i!=<span class="number">7</span>;++i)&#123;</span><br><span class="line">		led = _crol_(led,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">delay</span>(<span class="number">50000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ledStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ledState = <span class="number">0</span>;</span><br><span class="line">	led = <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">()</span></span>&#123;</span><br><span class="line">	DigState = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">switch</span>(i)&#123;	 <span class="comment">//位选，选择点亮的数码管</span></span><br><span class="line">			<span class="keyword">case</span>(<span class="number">0</span>):</span><br><span class="line">				LSA=<span class="number">0</span>;LSB=<span class="number">0</span>;LSC=<span class="number">0</span>; <span class="keyword">break</span>;<span class="comment">//显示第0位</span></span><br><span class="line">			<span class="keyword">case</span>(<span class="number">1</span>):</span><br><span class="line">				LSA=<span class="number">1</span>;LSB=<span class="number">0</span>;LSC=<span class="number">0</span>; <span class="keyword">break</span>;<span class="comment">//显示第1位</span></span><br><span class="line">			<span class="keyword">case</span>(<span class="number">2</span>):</span><br><span class="line">				LSA=<span class="number">0</span>;LSB=<span class="number">1</span>;LSC=<span class="number">0</span>; <span class="keyword">break</span>;<span class="comment">//显示第2位</span></span><br><span class="line">			<span class="keyword">case</span>(<span class="number">3</span>):</span><br><span class="line">				LSA=<span class="number">1</span>;LSB=<span class="number">1</span>;LSC=<span class="number">0</span>; <span class="keyword">break</span>;<span class="comment">//显示第3位</span></span><br><span class="line">			<span class="keyword">case</span>(<span class="number">4</span>):</span><br><span class="line">				LSA=<span class="number">0</span>;LSB=<span class="number">0</span>;LSC=<span class="number">1</span>; <span class="keyword">break</span>;<span class="comment">//显示第4位</span></span><br><span class="line">			<span class="keyword">case</span>(<span class="number">5</span>):</span><br><span class="line">				LSA=<span class="number">1</span>;LSB=<span class="number">0</span>;LSC=<span class="number">1</span>; <span class="keyword">break</span>;<span class="comment">//显示第5位</span></span><br><span class="line">			<span class="keyword">case</span>(<span class="number">6</span>):</span><br><span class="line">				LSA=<span class="number">0</span>;LSB=<span class="number">1</span>;LSC=<span class="number">1</span>; <span class="keyword">break</span>;<span class="comment">//显示第6位</span></span><br><span class="line">			<span class="keyword">case</span>(<span class="number">7</span>):</span><br><span class="line">				LSA=<span class="number">1</span>;LSB=<span class="number">1</span>;LSC=<span class="number">1</span>; <span class="keyword">break</span>;<span class="comment">//显示第7位	</span></span><br><span class="line">		&#125;</span><br><span class="line">		P0=smgduan[i];	<span class="comment">//发送段码</span></span><br><span class="line">		<span class="built_in">delay</span>(<span class="number">50000</span>); 	<span class="comment">//间隔一段时间扫描	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	DigState = <span class="number">0</span>;</span><br><span class="line">	P0 = <span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyPress</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k1==<span class="number">0</span>)&#123;		<span class="comment">// 检测k1是否按下</span></span><br><span class="line">		<span class="built_in">delay</span>(<span class="number">1000</span>);<span class="comment">//消除抖动 一般大约10ms</span></span><br><span class="line">		<span class="keyword">if</span>(k1==<span class="number">0</span>)&#123;	<span class="comment">//再次判断按键是否按下</span></span><br><span class="line">			<span class="keyword">if</span>(ledState==<span class="number">0</span>)	ledStart();</span><br><span class="line">			<span class="keyword">else</span>	ledStop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!k1);	 <span class="comment">//检测按键是否松开</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k2==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">delay</span>(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(k2==<span class="number">0</span>)&#123;</span><br><span class="line">			beepS=<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">while</span>(beepS&lt;<span class="number">200</span>)&#123;</span><br><span class="line">				<span class="built_in">beep</span>=~<span class="built_in">beep</span>;</span><br><span class="line">				<span class="built_in">delay</span>(beepS);</span><br><span class="line">				++beepS;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!k2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k3==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">delay</span>(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(k3==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(DigState == <span class="number">0</span>)	DigDisplay();</span><br><span class="line">			<span class="keyword">else</span>	DigStop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!k3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)	keyPress();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>五引理</title>
    <url>/fiveLemma/</url>
    <content><![CDATA[<p>在同调代数中，Five lemma，Snake lemma，Nine lemma （五引理，蛇形引理，马蹄引理）都是重要的引理。这里介绍一下 五引理。其实它的一般形式是有两个四引理得出的。</p>
<a id="more"></a>
<p>以下范畴为：Abel 范畴(这里仅在模范畴中考虑，此时 monic 即为单同态，epic 即为满同态)。</p>
<h2 id="五引理"><a href="#五引理" class="headerlink" title="五引理"></a>五引理</h2><p>若下交换图中每一行都正合且 $f$ epic, $q$ monic, $g,p$ isomorphism, then $h$ is isomorphism.<br><img src= "/img/loading.gif" data-lazy-src="fivelemma.png" alt="五引理"></p>
<h2 id="五引理的特殊形式"><a href="#五引理的特殊形式" class="headerlink" title="五引理的特殊形式"></a>五引理的特殊形式</h2><p>若下交换图中每一行都正合且 $f, h$ isomorphism,then $g$ is isomorphism.<br><img src= "/img/loading.gif" data-lazy-src="fivelemmaS.png" alt="五引理特殊形式"></p>
<h2 id="两个四引理及其证明"><a href="#两个四引理及其证明" class="headerlink" title="两个四引理及其证明"></a>两个四引理及其证明</h2><ol>
<li><p>若下交换图中每一行都正合且 $f$ epic，$p$ monic, $g$ monic, then $h$ is monic.<br><img src= "/img/loading.gif" data-lazy-src="fourlemma1.png" alt="四引理1"><br>$\forall c \in C$, 若 $h(c) = 0$, 则 $pw(c)＝w’h(c)=0$, 因为 $p$ monic, 因此 $w(c)=0$, 又由行正合知，$\exists b \in B$ 使得 $v(b)=c$，因此 $v’g(b)=hv(b)=h(c)=0$, 由行正合知, $ \exists a’ \in A’ $ 使得 $u’(a’)=g(b)$，由 $f$ epic 知 $\exists a \in A$ 使得 $f(a) = a’$. 因此 $gu(a) = u’f(a)=g(b)$. 又由 $g$ monic 知， $b = u(a)$. 因此 $c = vu(a) = 0$. 证毕。</p>
</li>
<li><p>若下交换图中每一行都正合且 $g$ epic，$q$ monic, $p$ epic,then $h$ is epic.<br><img src= "/img/loading.gif" data-lazy-src="fourlemma2.png" alt="四引理2"><br>$\forall c’ \in C’$, 因为 $p$ epic, 知 $\exists d \in D$ 使得 $p(d) = w’(c’)$, 所以 $qs(d) = s’p(d) = s’w’(c’) = 0$, 又 $q$ monic, 因此 $s(d) = 0$, 由行正合知, $\exists c \in C$，使得 $w(c) = d$.因此 $w’(c’-h(c))=w’(c’)-w’h(c)=p(d)-pw(c)=0$. 由行正合知，$\exists b’ \in B’$ 使得 $v’(b’) = c’ - h(c)$, 又由 $g$ epic 知 $\exists b \in B$ 使得 $g(b) = b’$ 因此 $hv(b)= v’g(b) - v’(b’)=c’-h(c)$. 即 $c’=h(v(b)+c)$. 证毕。</p>
</li>
</ol>
<p>四引理记忆方法： 左满右单，两满夹一满，两单夹一单。</p>
<blockquote>
<p>显然上述两个四引理显然可推出五引理。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>SG 函数之取石子博弈</title>
    <url>/nimSgFunction/</url>
    <content><![CDATA[<p>在 2002 年张一飞写过一篇论文 <a href="NimGame.pdf">《由感性认识到理性认识－透析一类博弈游戏的解答过程》</a> 从此开启了这类博弈问题的大门，留下学习笔记。</p>
<a id="more"></a>
<h2 id="取石子游戏"><a href="#取石子游戏" class="headerlink" title="取石子游戏"></a>取石子游戏</h2><p>$A,B$ 两人面对若干堆石子，按照如下规则取石子</p>
<ol>
<li>每步至少取一枚石子</li>
<li>每步只能在某一堆取走部分或者全部石子</li>
<li>谁无法按照规则取石子，谁就是输家</li>
</ol>
<p>首先抛开问题，我们先从一般的入手。</p>
<p>我们可以用一个 $n$ 元组 $(a_1,a_2,\cdots,a_n)$ 表示一个局面 $S$。显然 <strong>改变 $n$ 元组的顺序仍然是一个局面。</strong></p>
<p>一个局面 $n$ 元局面 $(a_1,a_2,\cdots,a_n)$ 和一个 $m$ 元局面 $(b_1,b_2,\cdots,b_m)$ 之和显然就是一个 $m + n$ 元局面 $(a_1,a_2,\cdots,a_n,b_1,b_2,\cdots,b_m)$。类似的一个局面也可以有多种分解。</p>
<p>对于局面 $S$，若先行者有必胜策略，则称 “$S$ 胜”；<br>对于局面 $S$，若后行者有必胜策略，则称 “$S$ 负”。</p>
<p>如果局面 $S$ 胜，则必然存在取子方式 $S \to T$，且 $T$ 负；<br>如果局面 $S$ 负，则对任意取子方式 $S \to T$，有 $T$ 胜。</p>
<p>局面分解理论，若 $S = A + B$ 则下面结论显然</p>
<ol>
<li>若 $A,B$ 一胜一负，则 $S$ 胜</li>
<li>若 $A,B$ 全为负，则 $S$ 负</li>
<li>若 $A,B$ 全为胜，则 $S$ 无法判断（还需要进一步信息才能确定）</li>
<li>若 $A=B$，则 $S$ 负</li>
<li>空局面是负局面</li>
</ol>
<p>因此根据上面的分解理论，可以将一个局面进行化简。例如 $(2,2,2,7,9,9)$ 可以化简成 $(2,7)$</p>
<p>而局面分解的关系，很容易让人联想到整数的位运算－异或。</p>
<p>对于上面取石子问题，每一个局面都可以分解成只有一堆石子的局面。<br>对一个局面，定义一个函数 $f$，然后把它们异或是不是，然后判断是非为 0，作为是否胜的充要条件.这样做是否可行呢？先对原始例子进行实验。</p>
<p>函数 $f$：若局面 $S$ 只有一堆石子，设 $S={a}$，则定义 $f(a) = a$。<br>设局面 $S = (a_1,a_2,\cdots,a_n)=(a_1)+(a_2)+\cdots (a_n)$，则 $f(S) = f(a_1) \oplus f(a_2) \oplus \cdots \oplus f(a_n)$<br><strong>我们断言</strong>：对于一个局面 $S$，若 $f(S) = 0$，则 $S$ 负，否则，$S$ 胜。</p>
<p>下面证明上面的结论。<br>引理：$a_1 \oplus a_2 \oplus \cdots \oplus a_n = p \neq 0$，则必存在 $1 \leq k \leq n$，使得 $a_k \oplus p &lt; a_k$。这是因为我们看 $p$ 的最高位，有奇数个$a_k$在此位置非零, 那么与 $p$ 异或后，这一位就从 $1$ 变为 $0$，证毕。</p>
<p>若 $f(S) = 0$，则无论先行者如何取子 $S \to T$，都有 $f(T) \neq 0$。<br>若 $f(S) \neq 0$，则先行者存在一种取法 $S \to T$, 使得 $f(T) = 0$。这是因为由引理 $a_1 \oplus a_2 \oplus a_n = p \neq 0$，存在 $1 \leq k \leq n$，使得 $x = a_k \oplus p &lt; a_k$。那么我们在第 $k$ 堆取走 $a_k - x$ 个石子，那么 $a_1 \oplus \cdots a_{k - 1} \oplus x \oplus a_{k + 1} \cdots \oplus a_n = p \oplus p = 0$，证毕。</p>
<h3 id="必胜策略代码"><a href="#必胜策略代码" class="headerlink" title="必胜策略代码"></a>必胜策略代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入一个正数组，以 0 结尾，输出下一步的必胜策略:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) a.emplace_back(n);</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) s ^= x;</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="number">0</span>) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"必败，随便选择一个合理策略吧，等待对手失误吧"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="keyword">if</span> (x ^ s &lt;= x) &#123;</span><br><span class="line">			x ^= s;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"以下是下一步的一个必胜策略:\n"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这说明了上述想法的可行性。下面把这种思想推广成一般的 SG（Sprague-Grundy）函数的情形</p>
<h2 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h2><p>当对石子的取法进行限制时，例如每次最多能去 $m$ 个，或每次最少取 $l$ 个等，此时再令 $f(x) = x$ 就不合适了。那么应该选择怎样的 $f$ 呢。显然 $f$ 必须满足：</p>
<ol>
<li>若 $f(S) = 0$, 则无论先行者如何取子 $S \to T$，都有 $f(T) \neq 0$</li>
<li>若 $f(S) \neq 0$, 则先行者存在一种取子 $S \to T$，使得 $f(T) = 0$。</li>
</ol>
<p>我们用 $(S) = \lbrace S_1, S_2, \cdots S_k \rbrace$ 表示 $S$ 的下一个可能的局面，定义 $g(S) = \lbrace f(S_1),f(S_2), \cdots f(S_k) \rbrace$，则它必然满足 $f(S) \doteq \text{ MEX } g(S)$</p>
<blockquote>
<p>注意上述 $f$ 的值域是整数，$g(S)$ 是整数集的子集。其中 $MEX(A \subseteq \mathbb{N})$ 为不在 $A$ 中最小正整数。</p>
</blockquote>
<p>若最多取 $m$ 个没有其它的限制条件，可以取 $f(x) = x \mod m + 1, S = (a_1, \cdots, a_n), f(S) = f(a_1) \oplus \cdots \oplus f(a_n)$</p>
<blockquote>
<p>对 SG 感性的理解为，连续最长从赢到输的步数。这样所有的例子都通了！</p>
<p>可以参考 <a href="https://codeforces.com/gym/102538/problem/E" target="_blank" rel="noopener">300iq Contest 3E Easy Win</a> 测试。</p>
<p>两人轮流取，第 $k$ 次最少取 $1$ 最多取 $k$，<a href="https://codeforces.com/blog/entry/85311#comment-730625" target="_blank" rel="noopener">我在 Codeforces 上写了解答</a>，这个可以变形。</p>
</blockquote>
<p>假设有 $n$ 堆，每堆有 $x_i$, 并且限制，每次至少取 $l_i$，最多取 $r_i$. 问先手还是后手有必胜策略</p>
<blockquote>
<p>经过一番思考，比较 $l_i = 1$ 的 case 可知，若 $l_i \leq x_i \mod (l_i + r_i)$，则此回合有必胜策略。否则必败，此时我们定义 $sg_i(x_i) = 0$，否则我们定义 $sg_i(x_i) = \lfloor \frac{x_i \mod (l_i + r_i)}{l_i} \rfloor$。然后最后答案就是 $s = sg_1(x_1) \oplus \cdots \oplus sg_n(x_n) \neq 0$。若 $s \neq 0$， 先手有必胜策略：先手可以让 s 变成 0，然后后手无论如何操作，先手让它们的和为 $l_i + r_i$, 然后所有的堆个数都小于超过 $l_i + r_i$ 然后再类似之前的讨论即可。因为如果第 i 堆必败，那么剔除这个堆不会影响最后胜负情况，反之必然满足 $l_i \leq x_i \mod (l_i + r_i) \leq r_i$</p>
</blockquote>
<p>因为每次取至少取 $l_i$，因此本质上第 i 堆现在的个数就是 $sg_i(x_i)$，根据之前的讨论，得知最后的结论。类似地，我们也可以给出代码（这个问题可以做交互题）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"欢迎来到石子游戏，请输入石子的堆数"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	std::vector&lt;int&gt; a(n), l(n), r(n);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入石子个数，最少取石子个数，最大取石子个数"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> sg = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">		sg ^= a[i] % (l[i] + r[i]) / l[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (sg != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = a[i] % (l[i] + r[i]) / l[i];</span><br><span class="line">			<span class="keyword">if</span> (sg ^ t &lt;= t) &#123;</span><br><span class="line">				a[i] -= t * l[i];</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"第 "</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" 堆中取 "</span> &lt;&lt; l[i] * t &lt;&lt; <span class="string">" 个"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"当前石子情况为："</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"当前无必胜策略，随便取一个合理的取法，等待对手失误吧"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当 <code>l[i]</code> 和 <code>r[i]</code> 可变时，也可以考虑，暂时不在此说了。</p>
</blockquote>
<h2 id="有向无环图上-SG-问题"><a href="#有向无环图上-SG-问题" class="headerlink" title="有向无环图上 SG 问题"></a>有向无环图上 SG 问题</h2><p>在一个有向无环图中，只有一个起点，上面有一个棋子，两个玩家轮流沿着有向边推动棋子，不能走的玩家判负。</p>
<blockquote>
<p>来自 <a href="https://oi-wiki.org/math/game-theory/" target="_blank" rel="noopener">OI-wiki</a></p>
</blockquote>
<p>对于状态 $x$ 和 它的 $k$ 个后继状态 $y_1, y_2, \cdots, y_k$，定义 SG 函数：</p>
<script type="math/tex; mode=display">
SG(x) = mex \{SG(y_1), SG(y_2),\cdots, SG(y_k) \}</script><p>而对于由 $n$ 个有向图游戏组成的组合游戏，设它们的起点分别为 $s_1, \cdots, s_n$，先手必胜当且仅当 $SG(s_1) \oplus \cdots \oplus SG(s_n) \neq 0$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SG</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// n 个节点，0 为起点，m 条有向边，确保无环。</span></span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		e[x].emplace_back(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sg</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (sg[u] != <span class="number">-1</span>) <span class="keyword">return</span> sg[u];</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) S.insert(dfs(v));</span><br><span class="line">		sg[u] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (S.<span class="built_in">find</span>(sg[u]) != S.<span class="built_in">end</span>()) ++sg[u];</span><br><span class="line">		<span class="keyword">return</span> sg[u];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> nroot;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; nroot;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (nroot--) &#123;</span><br><span class="line">		ans ^= SG();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (ans ? <span class="string">"先手赢"</span> : <span class="string">"后手赢"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以做到二维平面上有障碍点集，又可以做一个题目了。</p>
<p>注意到上述问题，堆与堆之间是相互独立的，如果不独立，那就很难考虑了。</p>
</blockquote>
<h2 id="不公平取石子的游戏"><a href="#不公平取石子的游戏" class="headerlink" title="不公平取石子的游戏"></a>不公平取石子的游戏</h2><p>在 <a href="https://ac.nowcoder.com/acm/contest/9753/B" target="_blank" rel="noopener">NewCoder</a> 上有个不公平的游戏：A 每次能取 <code>[1, p]</code> 个石子，B 能取 <code>[1, q]</code> 个石子，A 先。</p>
<p>显然 $p = q$ 时，就是之前的经典问题。只需考虑 <code>n % (p + q)</code> 即可。若 $p &gt; q$，那么 A 必胜，因为此时 $p &gt;= q + 1$，所以有必胜策略，若 $p &lt; q$，只有 A 取完则赢，否则必输。</p>
<p>有 <code>m</code> 堆，</p>
<ul>
<li>$p &gt; q$，若存在 $a_i$ 使得 $a_i &gt; q$ 或 $a_1 \oplus \cdots \oplus a_m \neq 0$，则 A 必赢。</li>
<li>$p &lt; q$，若存在大于一个 $a_i$ 使得 $a_i &gt; p$，$A$ 必输。若所有 $a_i \leq p$ 那么就等于无限制。所以我们只需考虑，有唯一的一个 $a_i &gt; p$ 的情形，$x = \oplus \cdots a_{i-1} \oplus a_{i + 1} \cdots \oplus a_m$，若 $x \leq p$ 且 $x + 1 \leq a_i \leq x + p$，则 $A$ 必赢。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, p, q;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; q;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> sg = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">	<span class="keyword">if</span> (p &gt; q) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (a[i] &gt; q) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first player win"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) sg ^= x;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == q) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) sg ^= x % (<span class="number">1</span> + p);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>, ai = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) <span class="keyword">if</span> (x &gt; p) &#123;</span><br><span class="line">			++cnt;</span><br><span class="line">			ai = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) sg ^= x;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : a) sg ^= x;</span><br><span class="line">			sg ^= ai;</span><br><span class="line">			sg = (sg &lt;= p &amp;&amp; ai &gt;= sg + <span class="number">1</span> &amp;&amp; ai &lt;= sg + p);</span><br><span class="line">		&#125; <span class="keyword">else</span> sg = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (sg ? <span class="string">"first player win"</span> : <span class="string">"second player win"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无限制取石子问题的反问题"><a href="#无限制取石子问题的反问题" class="headerlink" title="无限制取石子问题的反问题"></a>无限制取石子问题的反问题</h2><p>一堆石子谁先取到最后一个谁输！，该问题在  已经介绍了。做法：</p>
<p>首先剔除所有的 0，以及偶数个 1，并不会影响局面的胜负。空局面认为是胜。若此时堆的个数为 1，那么 $a_1 = 1$ 为输局面，其它为赢局面。如果堆数 $n &gt; 1$。那么 $a_1 \oplus \cdots \oplus a_n = 0$ 为输局面，否则为赢局面。（首先对 $n = 2$ 数学归纳证明，然后对一般的 n 数学归纳证明。</p>
<h2 id="有顺序堆的取石子问题"><a href="#有顺序堆的取石子问题" class="headerlink" title="有顺序堆的取石子问题"></a>有顺序堆的取石子问题</h2><p>例题：<a href="https://codeforces.com/problemset/problem/1382/B" target="_blank" rel="noopener">1382B</a>。即看那一步有必赢且必输的策略。</p>
<p>如果此题加限制条件，每次最多取 $m$ 个，那么答案就是第一个 $\mod (m + 1)$ 大于 1 的数。但是要注意 取模后为 0 的情形。</p>
<h2 id="每次可取多堆"><a href="#每次可取多堆" class="headerlink" title="每次可取多堆"></a>每次可取多堆</h2><p>例题：<a href="https://codeforces.com/contest/1451/problem/F" target="_blank" rel="noopener">1451F</a></p>
<p>更多博弈问题可见：<a href="https://codeforces.com/problemset?tags=games" target="_blank" rel="noopener">Codeforces-game</a></p>
<h2 id="sg-函数是因子个数-1"><a href="#sg-函数是因子个数-1" class="headerlink" title="sg 函数是因子个数 + 1"></a>sg 函数是因子个数 + 1</h2><p>例题：<a href="https://codeforces.com/gym/102911/problem/C" target="_blank" rel="noopener">codeforce gym 102911C</a>，从 $n$ 中取 $k$ 个满足 $k &gt; 0$ 且 $n - k$ 是 $n$ 的因子。设 $n = p_1 ^{s_1} \cdots p_r^{s_r}$， 则 $sg(n) = s_1 + \cdots s_r + 1$。</p>
<h2 id="一堆，相邻之间有限制"><a href="#一堆，相邻之间有限制" class="headerlink" title="一堆，相邻之间有限制"></a>一堆，相邻之间有限制</h2><p>$n$ 个元素，每次最少取 $1$，最多取 $m$ ($m \geq 2$)，且相邻两个的和不能为 $m + 1$。谁无法取谁输。</p>
<p>结论 <code>n % (m + 2) == 0</code> 则先手必输，反之先手必赢。</p>
<p>证明：<br>首先不难看出若 $n \leq m + 1$ 时，先手必赢，$n = m + 2$ 时，先手必输。</p>
<ul>
<li>若第一步先手取 <code>1</code>，那么后手取 <code>m - 1</code>，此时先手不能取 <code>2</code>（所以先手无法取完），若第二步先手取 <code>1</code>，那么后手取 <code>1</code>回到最初的情况（那么剩下的数为 $n - m - 2$ 又满足 <code>n % (m + 2) == 0</code>)。若第二步先手取 <code>3</code>，那么后手取 $m - 1$ （此时又回到了第一步的情况，再继续考虑第二步即可）。若 第二步先手取 $x$($x \geq 4$), 后手取 $m + 4 - x$ 就回到了最初的情况。 </li>
<li>若第一步先手取了 <code>x</code> ($x \geq 2$) 那么后手取 $m + 2 - x$ 即可。</li>
</ul>
<p>反之 <code>k = n % (m + 2)</code>, $k \neq 0$，若 $k \leq m$，那么先手取 $k$ 即可。否则 $k = m + 1$, 那先手取 $m$，此时后手不能取 $1$，因此后手取完之后，剩下的数依然满足 $n \mod (m + 2) \neq 0$。</p>
<h2 id="二分图博弈"><a href="#二分图博弈" class="headerlink" title="二分图博弈"></a>二分图博弈</h2><p><a href="https://www.cnblogs.com/LLCSBlog/p/13882635.html" target="_blank" rel="noopener">别人写的挺好</a></p>
<p>例题：<a href="https://codeforces.com/gym/102832/problem/H" target="_blank" rel="noopener">102832H</a></p>
<p>先手必胜当且仅当任何一个最大匹配方案都包含初始状态。</p>
<p>判定: 不加入初始节点，跑一遍最大流，加入初始节点，再跑一次最大流，有变化所以先手必赢。</p>
<p>另外如果先手可选择初始状态（进入算一次），那么先手输当且仅当图是完全匹配。</p>
<h2 id="位置博弈"><a href="#位置博弈" class="headerlink" title="位置博弈"></a>位置博弈</h2><p>只能朝着几个方向走，走出区域者输</p>
<p>例题：<a href="https://codeforces.com/contest/1451/problem/D" target="_blank" rel="noopener">1451D</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>运筹学</tag>
      </tags>
  </entry>
  <entry>
    <title>正约数个数 $d(n)$</title>
    <url>/numberOfdivisors/</url>
    <content><![CDATA[<p>codeforce 上有 <a href="http://codeforces.com/contest/235/problem/E" target="_blank" rel="noopener">一道题</a> 。 rng_58 用一个奇妙的公式解决了这个问题。并且给出了公式的证明，这里给出另一个比较好的证明。</p>
<a id="more"></a>
<h2 id="d-n-的一个公式"><a href="#d-n-的一个公式" class="headerlink" title="$d(n)$ 的一个公式"></a>$d(n)$ 的一个公式</h2><p>按照公式，我们有 $d(n) = \sum_{i \mid n} 1$。其实这个公式可以推广为</p>
<script type="math/tex; mode=display">
d(n_1 \cdots n_m) = \sum_{i_1 \mid n_1} \cdots \sum_{i_m \mid n_m} 1, \; \gcd(i_s,i_t)=1,1 \leq  s < t \leq m</script><p><strong>Proof</strong>： 数学归纳法证明：$m=1$ 时结论显然。<br>设结论对 $m-1$ 成立。</p>
<script type="math/tex; mode=display">
\begin{aligned}
d(n_1 \cdots n_m) &= \sum_{i \mid n_1 \cdots n_m} 1 =  \sum_{d \mid n_m} \sum_{i \mid n_1 \cdots n_m , \gcd(i,n_m)=d} 1 \\
&= \sum_{d \mid n_m} \sum_{\frac{i}{d} \mid n_1 \cdots n_{m-1} , \gcd(\frac{i}{d},\frac{n_m}{d})=1} 1 \\
&= \sum_{d \mid n_m} \sum_{i \mid n_1 \cdots n_{m-1} , \gcd(i,d)=1} 1 
\end{aligned}</script><p>由数学归纳法知，原结论成立。</p>
<h2 id="上面公式的一个应用"><a href="#上面公式的一个应用" class="headerlink" title="上面公式的一个应用"></a>上面公式的一个应用</h2><script type="math/tex; mode=display">
\sum_{i_1 = 1} ^{n_1} \cdots \sum_{i_m = 1} ^{n_m} d(n_1 \cdots n_m) = \sum_{\gcd(i_s,i_t)=1,1 \leq  s < t \leq m } \lfloor \frac{n_1}{i_1} \rfloor \cdots  \lfloor \frac{n_m}{i_m} \rfloor</script><h4 id="m-2-的另一个公式"><a href="#m-2-的另一个公式" class="headerlink" title="$m=2$ 的另一个公式"></a>$m=2$ 的另一个公式</h4><p>令 $F(n) = \sum_{i=1} ^n \lfloor \frac{n}{i} \rfloor $，则显然</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1} ^n \sum_{j=1,\gcd(i,j)=1} ^m \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{j} \rfloor &= \sum_{i=1} ^n \lfloor \frac{n}{i} \rfloor \sum_{t \mid i} \mu(t) \sum_{1 \leq j \leq m, t \mid j} \lfloor \frac{m}{j} \rfloor \\
&= \sum_{i=1} ^n \lfloor \frac{n}{i} \rfloor \sum_{t \mid i} \mu(t) F(\lfloor \frac{m}{t} \rfloor) \\
&= \sum_{t} \mu(t) F(\lfloor \frac{m}{t} \rfloor) \sum_{1 \leq i \leq n, t \mid i} \lfloor \frac{n}{i} \rfloor \\
&= \sum_{t} \mu(t) F(\lfloor \frac{m}{t} \rfloor) F(\lfloor \frac{n}{t} \rfloor)
\end{aligned}</script><p>即</p>
<script type="math/tex; mode=display">
\sum_{i=1} ^n \sum_{j=1} ^m d(ij) =  \sum_{t} \mu(t) F(\lfloor \frac{m}{t} \rfloor) F(\lfloor \frac{n}{t} \rfloor)</script><h3 id="这说明我们可以在-O-n-log-n-复杂度内计算此问题"><a href="#这说明我们可以在-O-n-log-n-复杂度内计算此问题" class="headerlink" title="这说明我们可以在 $O(n \log n)$ 复杂度内计算此问题"></a>这说明我们可以在 $O(n \log n)$ 复杂度内计算此问题</h3><p>可是 $m&gt;2$ 就比较麻烦了。</p>
<h4 id="f-n-sum-i-1-n-d-i-sum-i-1-lfloor-frac-n-i-rfloor"><a href="#f-n-sum-i-1-n-d-i-sum-i-1-lfloor-frac-n-i-rfloor" class="headerlink" title="$f(n) = \sum_{i=1} ^n d(i) = \sum_{i=1} \lfloor \frac{n}{i} \rfloor$"></a>$f(n) = \sum_{i=1} ^n d(i) = \sum_{i=1} \lfloor \frac{n}{i} \rfloor$</h4><p>上面这个公式有趣的是,若要求单个的 $f(n)$ 用后面一个可以在 $O(\sqrt{n})$ 复杂度解决，而如果要求 $f(1),\cdots,f(n)$ 则可以用前面一个公式在 $O(n \log n)$ 复杂度解决。</p>
<h3 id="codeforce-235"><a href="#codeforce-235" class="headerlink" title="codeforce 235"></a><a href="http://codeforces.com/contest/235/problem/E" target="_blank" rel="noopener">codeforce 235</a></h3><p>求解:</p>
<script type="math/tex; mode=display">
\sum_{i=1}^a \sum_{j=1}^b \sum_{k=1}^c d(ijk)</script><p>如果令 $f(n) = \sum_{i=1} ^n d(i),g(n)=\sum_{i \mid n} \mu(i) f(\lfloor \frac{c}{i} \rfloor)$<br>那么</p>
<script type="math/tex; mode=display">
\sum_{i=1}^a \sum_{j=1}^b \sum_{k=1}^c d(ijk) = \sum_{t} \mu(t) \lfloor \frac{a}{it} \rfloor \lfloor \frac{b}{it} \rfloor g(ijt^2)</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2002</span>;</span><br><span class="line"><span class="keyword">int</span> f[N],g[N*N];</span><br><span class="line"><span class="keyword">bool</span> ip[N];</span><br><span class="line"><span class="keyword">int</span> mu[N],p[N],nt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_mu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;ip[<span class="number">2</span>]=<span class="literal">true</span>;p[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i+=<span class="number">2</span>)   ip[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>,cnt = <span class="number">1</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ip[i])&#123;</span><br><span class="line">            p[cnt++] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>,t;j&lt;cnt&amp;&amp;(t= i * p[j])&lt;N;++j)&#123;</span><br><span class="line">            ip[t] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>)   <span class="keyword">break</span>;</span><br><span class="line">            mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;i+=<span class="number">4</span>)  mu[i]=-mu[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        sum += (j-i+<span class="number">1</span>)*(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)       f[i]=getsum(i);    init_mu();</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mu[i]==<span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">        nt[last]=i;</span><br><span class="line">        last = i;</span><br><span class="line">    &#125;</span><br><span class="line">    nt[last]=N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getg</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a*b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)   g[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;i&lt;=c;i=nt[i])&#123; <span class="comment">// n^2 \log n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i,t=mu[i]*f[c/i];j&lt;=n;j+=i)   g[j]+=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getf</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;++j)&#123;</span><br><span class="line">            res+=(a/i)*(b/j)*g[i*j*d];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c))&#123;</span><br><span class="line">        getg(a,b,c);</span><br><span class="line">        <span class="keyword">int</span> ab = <span class="built_in">min</span>(a,b);</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ab;i=nt[i])&#123;</span><br><span class="line">            res+=mu[i]*getf(a/i,b/i,i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">int</span>(res%(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言中函数 scanf 和 printf</title>
    <url>/scanfAndPrintInC/</url>
    <content><![CDATA[<p>在 C 语言中最常用的函数应该就是 scanf，printf 吧。对于大量输入输出时 C++ 也常用 scanf 和 print 代替 cin 和 cout。然而我们学习 C 语言最先接触的 scanf 和 printf 其实我们并不完全了解。<del>弃用</del></p>
<a id="more"></a>
<h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>按照 <a href="http://www.cplusplus.com/reference/cstdio/scanf/?kw=scanf" target="_blank" rel="noopener">C++ reference</a> 的介绍，scanf 的原型为<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * format, ... )</span></span>;</span><br><span class="line"><span class="comment">// format = %[*][width][length]specifier</span></span><br></pre></td></tr></table></figure></p>
<p>其中上面的 <code>[*]</code> 表示输入的东西被忽略，<code>[width]</code> 表示最大输入长度，而 <code>[length</code> 表示是类型的一种延伸，可以是 <code>hh, h, l, ll, j, z, t, L</code> 中的一种。例如<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%3ld"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// input : 12345</span></span><br><span class="line"><span class="comment">// output: 123</span></span><br></pre></td></tr></table></figure></p>
<p>specifier 是必选项 它可以是 <code>i,d,u,o,x,f,e,g,a,c,s,p,n,%​</code>。还有两个特殊的 <code>[characters]</code> 和 <code>[^characters]</code>。上面的参数就不过多说了。特别要强调的是这两个特殊的。<br><code>[characters]</code> 表示只接受 <code>[characters]</code> 中的字符；<code>[^characters]</code> 表示只不接受<code>[characters]</code> 中的字符。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>],a[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[1-9A-Z]"</span>,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^b]"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// input : 123AaBbCc</span></span><br><span class="line"><span class="comment">// output: 123A</span></span><br><span class="line"><span class="comment">// output: aB</span></span><br></pre></td></tr></table></figure>
<h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p>在使用下面语句进行输入时遇到空白符(whitespace)会结束输入的。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br></pre></td></tr></table></figure><br>whitespace 可以使用 <code>int isspace(int c);</code> 判断。有这些字符有：</p>
<h3 id="scanf-典型例子"><a href="#scanf-典型例子" class="headerlink" title="scanf 典型例子"></a>scanf 典型例子</h3><ol>
<li>有时我们明确知道输入为 <code>(a,b)​</code> 这种类型，我们可以这样做<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"(%d, %d)"</span>, &amp;a, &amp;b);</span><br></pre></td></tr></table></figure></li>
<li>输入字符包含除回车之外的字符<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>, str);</span><br></pre></td></tr></table></figure></li>
<li>只输入小写字母和数字<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%[0-9a-z]"</span>, str);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="scanf-返回值"><a href="#scanf-返回值" class="headerlink" title="scanf 返回值"></a>scanf 返回值</h3><ol>
<li>正整数：表示正确输入参数的个数</li>
<li>0：输入不匹配，无法正确输入任何值</li>
<li>EOF（一般为-1）为读到文件结尾或在 terminal 中输入了 <code>ctrl + z</code></li>
</ol>
<h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>print 的原型为<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * format, ... )</span></span>;</span><br><span class="line">%[flags][<span class="built_in">width</span>][.precision][length]specifier</span><br></pre></td></tr></table></figure></p>
<p>specifier 和 scanf 的类似就不多说了。<code>[length] [width]</code>同理。<code>[.precision]</code> 一看就懂<br><code>[flags]</code> 可选有 <code>\-,\+,\#,0</code>。其中</p>
<ol>
<li><code>-</code> 表示在给定宽度内向左靠齐。默认向右见下例子</li>
<li><code>+</code> 表示即使是非负数，前面也要加正号</li>
<li><code>#</code> 目前不清楚用法</li>
<li><code>0</code> 就是在不足宽度的时候补 0</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">123.45678</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%+10.4f "</span>, a);</span><br><span class="line"><span class="keyword">int</span> t =<span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%04d "</span>,t);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">printf</span>(x&amp;<span class="number">1</span>?<span class="string">"%d is odd"</span>:<span class="string">"%d is even"</span>,x);</span><br><span class="line"><span class="comment">// output: +0123.4568 0100 123 is odd</span></span><br></pre></td></tr></table></figure>
<h3 id="神器：sscanf-和-sprintf"><a href="#神器：sscanf-和-sprintf" class="headerlink" title="神器：sscanf 和 sprintf"></a>神器：sscanf 和 sprintf</h3><p>不多说了，举个例子说明问题吧<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">/* sscanf example */</span></span><br><span class="line">    <span class="keyword">char</span> sentence []=<span class="string">"Rudolph is 12 years old"</span>;</span><br><span class="line">    <span class="keyword">char</span> str [<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">sscanf</span> (sentence,<span class="string">"%s %*s %d"</span>,str,&amp;i);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%s -&gt; %d\n"</span>,str,i);</span><br><span class="line">    <span class="comment">/* sprintf example */</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span> [<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> n, a=<span class="number">5</span>, b=<span class="number">3</span>;</span><br><span class="line">    n=<span class="built_in">sprintf</span> (<span class="built_in">buffer</span>, <span class="string">"%d plus %d is %d"</span>, a, b, a+b);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"[%s] is a string %d chars long\n"</span>, <span class="built_in">buffer</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// Rudolph -&gt; 12</span></span><br><span class="line"><span class="comment">// [5 plus 3 is 8] is a string 13 chars long</span></span><br></pre></td></tr></table></figure></p>
<h3 id="最后说一个比较诡异但是可以理解的事情"><a href="#最后说一个比较诡异但是可以理解的事情" class="headerlink" title="最后说一个比较诡异但是可以理解的事情"></a>最后说一个比较诡异但是可以理解的事情</h3><blockquote>
<p>sacnf 输入 float 和 double 时分别用 <code>%f,%lf</code>。<br>printf 输出 float 和 double 时用的都是 <code>%f</code>。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>输出源代码的 C++ 代码</title>
    <url>/printSelfWithCpp/</url>
    <content><![CDATA[<p>我们可以把计算机看成一个函数，将一份代码映成一段输出，那么输出为代码本事就是数学中不动点。任意语言都有很多相应版本的这种程序，原理都是类似的，我自己写的 C++ 代码如下：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a[<span class="number">0</span>]=<span class="string">"#include&lt;iostream&gt;"</span>;</span><br><span class="line">a[<span class="number">1</span>]=<span class="string">"#include&lt;string&gt;"</span>;</span><br><span class="line">a[<span class="number">2</span>]=<span class="string">"using namespace std;"</span>;</span><br><span class="line">a[<span class="number">3</span>]=<span class="string">"string a[10];"</span>;</span><br><span class="line">a[<span class="number">4</span>]=<span class="string">"int main()&#123;"</span>;</span><br><span class="line">a[<span class="number">5</span>]=<span class="string">"for(int i=0;i&lt;5;++i) cout&lt;&lt;a[i]&lt;&lt;endl;"</span>;</span><br><span class="line">a[<span class="number">6</span>]=<span class="string">"for(int i=0;i&lt;10;++i) cout&lt;&lt;char(97)&lt;&lt;char(91)&lt;&lt;i&lt;&lt;char(93)&lt;&lt;char(61)&lt;&lt;char(34)&lt;&lt;a[i]&lt;&lt;char(34)&lt;&lt;char(59)&lt;&lt;endl;"</span>;</span><br><span class="line">a[<span class="number">7</span>]=<span class="string">"for(int i=5;i&lt;10;++i) cout&lt;&lt;a[i]&lt;&lt;endl;"</span>;</span><br><span class="line">a[<span class="number">8</span>]=<span class="string">"return 0;"</span>;</span><br><span class="line">a[<span class="number">9</span>]=<span class="string">"&#125;"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) <span class="built_in">cout</span>&lt;&lt;<span class="keyword">char</span>(<span class="number">97</span>)&lt;&lt;<span class="keyword">char</span>(<span class="number">91</span>)&lt;&lt;i&lt;&lt;<span class="keyword">char</span>(<span class="number">93</span>)&lt;&lt;<span class="keyword">char</span>(<span class="number">61</span>)&lt;&lt;<span class="keyword">char</span>(<span class="number">34</span>)&lt;&lt;a[i]&lt;&lt;<span class="keyword">char</span>(<span class="number">34</span>)&lt;&lt;<span class="keyword">char</span>(<span class="number">59</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&lt;<span class="number">10</span>;++i) <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码原理和步骤：</p>
<ol>
<li>先把头写好，定义好数组，记作头部</li>
<li>开始对数组赋值一直赋值到头部，然后空几行</li>
<li>把头用数组打印出来，再讲数组全部打印出来，再将后面的部分打印出来</li>
<li>再去空的几行，做数组赋值，赋值的时候后面的每一行</li>
</ol>
<blockquote>
<p>注意代码中特殊字符需要转义，不然就很尬了，而且代码不能用 tab 缩进</p>
<p>后来我又写了一篇：<a href="/printSelfWithPy/" title="用 Python 打印自身的代码">用 Python 打印自身的代码</a></p>
<p>文件打印就太没水平了，这里就不给出了</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>自然数方幂和快速算法</title>
    <url>/fastPowSumOfNaturalNumber/</url>
    <content><![CDATA[<p>之前写过 <a href="/formulaOfPowSumOfNaturalNumber/" title="自然数方幂和公式">自然数方幂和公式</a>， 这次写的目的是因为上次是从数学上完美的解决了这个问题，这次我们要从计算上完美的解决这个问题，当然这归功于我看到的一份 <a href="http://codeforces.com/profile/sgtlaugh" target="_blank" rel="noopener">sgtlaugh</a> 的代码。经过解读体会到其中的奥秘，特此记录。一句话，简直不敢相信。</p>
<blockquote>
<p>如果有人说他能在 $O(k)$ 时空复杂度求解 $\sum_{i=1}^n i^k$，你肯定会说这怎么可能别忽悠我了，那我只能说，因为你没看过这篇博文。</p>
</blockquote>
<a id="more"></a>
<h2 id="首先预处理，-O-k-复杂度-求-sum-i-1-n-i-k-其中-n-leq-k"><a href="#首先预处理，-O-k-复杂度-求-sum-i-1-n-i-k-其中-n-leq-k" class="headerlink" title="首先预处理，$O(k)$ 复杂度 求 $\sum_{i=1}^n i^k$ 其中 $n \leq k$"></a>首先预处理，$O(k)$ 复杂度 求 $\sum_{i=1}^n i^k$ 其中 $n \leq k$</h2><p>我之前一直以为要用 $k \log k$ 的复杂度才能解决这个问题，其实我们只需对所有素数 $p$ 计算 $p^k$ 即可。对于一般的 $i$ 我们先预处理 其最小素因子 $sp[i]$。计算 $sp[i]^k \cdot (i/sp[i])^k$ 即可（具体可见最后代码）。由于素数的阶为 $O(\frac{k}{\log k})$ 因此整个复杂度即为 $O(k)$。</p>
<h2 id="再由-Lagrange-插值多项式得出最终答案"><a href="#再由-Lagrange-插值多项式得出最终答案" class="headerlink" title="再由 Lagrange 插值多项式得出最终答案"></a>再由 Lagrange 插值多项式得出最终答案</h2><p>因为我们知道 $\sum_{i=1} ^n i^k$ 一定是一个关于 $n$ 的次数为 $k+1$ 的多项式。因此，我们只需计算其在 $0,\cdots,k+1$ 上的取值，用 Lagrange 插值多项式即可知道答案。</p>
<blockquote>
<p>对于一个次数不超过 $n$ 的多项式 $f(x)$，其在不同位置 $x_0,\cdots,x_n$ 的取值唯一决定了这个多项式:</p>
</blockquote>
<script type="math/tex; mode=display">
f(x) = \sum_{i=0} ^n f(x_i) \prod_{j=0,j \neq i} ^n \frac{x-x_j}{x_i - x_j}</script><h3 id="具体到本问题，我们取-x-n-m-k-1-x-i-i-那么"><a href="#具体到本问题，我们取-x-n-m-k-1-x-i-i-那么" class="headerlink" title="具体到本问题，我们取 $x=n, m=k+1, x_i=i$ 那么"></a>具体到本问题，我们取 $x=n, m=k+1, x_i=i$ 那么</h3><script type="math/tex; mode=display">
f(n) = \sum_{i=0} ^m (-1)^{m-i} f(x_i) {n \choose i}  {n-i-1 \choose m-i }</script><h2 id="例题：Codeforces-622F"><a href="#例题：Codeforces-622F" class="headerlink" title="例题：Codeforces 622F"></a>例题：Codeforces 622F</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> sp[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spf</span><span class="params">()</span></span>&#123; <span class="comment">// samllest prime factor</span></span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;p[cnt++]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;i+=<span class="number">2</span>)   sp[i]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i+=<span class="number">2</span>)   sp[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sp[i]==i)    p[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; cnt &amp;&amp; p[j]&lt;=sp[i] &amp;&amp; i * p[j] &lt; N; ++j) &#123;</span><br><span class="line">            sp[i * p[j]] = p[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=x*x%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">LL inv[N],AP[N],AS[N],f[N];</span><br><span class="line"><span class="function">LL <span class="title">getpowsum</span><span class="params">(LL n,<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">// mod &gt; k</span></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)    <span class="keyword">return</span> n%mod;</span><br><span class="line">    <span class="keyword">if</span>(p[<span class="number">0</span>]!=<span class="number">2</span>) spf();</span><br><span class="line">    <span class="keyword">int</span> nk=k+<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=nk;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sp[i]==i)    f[i]=pow_mod(i,k,mod);</span><br><span class="line">        <span class="keyword">else</span>    f[i]=f[sp[i]]*f[i/sp[i]]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nk;++i)&#123;</span><br><span class="line">        f[i]+=f[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;=mod)   f[i]-=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=nk)    <span class="keyword">return</span> f[n];</span><br><span class="line">    LL tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=nk;++i)    tmp=tmp*i%mod;</span><br><span class="line">    inv[nk] = pow_mod(tmp,mod<span class="number">-2</span>,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nk<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">    AP[<span class="number">0</span>]=AS[nk]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nk;++i)   AP[i]=AP[i<span class="number">-1</span>]*(n+<span class="number">1</span>-i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nk<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) AS[i]=AS[i+<span class="number">1</span>]*(n-i<span class="number">-1</span>)%mod;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nk;++i)&#123; <span class="comment">// because f(i)=0</span></span><br><span class="line">        LL x = f[i]*AP[i]%mod*AS[i]%mod*inv[i]%mod*inv[nk-i]%mod;</span><br><span class="line">        <span class="keyword">if</span>((nk-i)&amp;<span class="number">1</span>) res-=x; <span class="comment">// be careful</span></span><br><span class="line">        <span class="keyword">else</span>        res+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;getpowsum(n,k)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上我们可以不求 $\mod p$ 后的答案，利用大数类得到标准答案，但是这时因为数字实在太大，每次乘法的用时过大，因此仅适合 $k&lt;n$ 的情况</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cpp_int f[N];</span><br><span class="line"><span class="function">cpp_int <span class="title">getpowsum</span><span class="params">(LL n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)    <span class="keyword">return</span> cpp_int(n);</span><br><span class="line">    <span class="keyword">if</span>(p[<span class="number">0</span>]!=<span class="number">2</span>) spf();</span><br><span class="line">    <span class="keyword">int</span> nk=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=nk+<span class="number">1</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sp[i]==i)    f[i]=<span class="built_in">pow</span>(cpp_int(i),k);</span><br><span class="line">        <span class="keyword">else</span>    f[i]=f[sp[i]]*f[i/sp[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nk;++i)  f[i]+=f[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=nk)   <span class="keyword">return</span> f[n];</span><br><span class="line">    cpp_int res = <span class="number">0</span>,tl=<span class="number">1</span>,tr=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nk<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)    tr=tr*(n-i<span class="number">-1</span>)/(nk-i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=nk;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nk-i)&amp;<span class="number">1</span>)    res -= f[i]*tl*tr;</span><br><span class="line">        <span class="keyword">else</span>            res += f[i]*tl*tr;</span><br><span class="line">        tl = tl*(n-i)/(i+<span class="number">1</span>);</span><br><span class="line">        tr = tr*(nk-i)/(n-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实如果我们知道最终的上界，求出多个 $\mod p$ 后的答案，再用中国剩余定理貌似很不错。</p>
</blockquote>
<h3 id="该方法可以推广成求-sum-i-1-n-f-i-k-，其中-f-x-是多项式。具体分析即可"><a href="#该方法可以推广成求-sum-i-1-n-f-i-k-，其中-f-x-是多项式。具体分析即可" class="headerlink" title="该方法可以推广成求 $\sum_{i=1}^n f(i)^k$，其中 $f(x)$ 是多项式。具体分析即可"></a>该方法可以推广成求 $\sum_{i=1}^n f(i)^k$，其中 $f(x)$ 是多项式。具体分析即可</h3><p>这种情况一般很难再做到 $O(k)$ 时间复杂度，而变成了 $O(k \log k) \deg f$ 复杂度。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>最长递增子序列与连续子序列最大和</title>
    <url>/nondecraseSubsequence/</url>
    <content><![CDATA[<blockquote>
<p><strong>已被历史淘汰</strong></p>
</blockquote>
<p>最长递增子序列最常规的做法是 $O(n^2)$ 的动态规划的做法（很容易想到不多说了）。这里可以维护一个单调的数列使其复杂度降至 $O(n \log n)$。相应的最长递减、不升、不降子序列完全类似，相应修改即可。另外，这个问题让我想起另一个降低复杂度的经典例子：连续子序列最大和。从 $O(n^3)$ 到 $O(n^2)$ 再到 $O(n)$.<br><a id="more"></a></p>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>我们用数组 $a$ 表示原始数列。用 $b[k]$ 表示长度为 $k$ 的不降子序列中尾数最小值。那么显然数组 $b$ 是单调递增的。初始状态 $b[1]=a[1],k=1$</p>
<h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>若 $a[i]&gt;b[k]$，则 $k=k+1,b[k]=a[i]$；否则,找到二分最小的 $j$ 使得 $b[j] \geq a[i]$ 然后 $b[j]=a[i]$。最终答案就是 $k$。</p>
<h3 id="例题：POJ-2533"><a href="#例题：POJ-2533" class="headerlink" title="例题：POJ 2533"></a>例题：POJ 2533</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// longest increasing subsquence for 0 ~ n-1</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    b[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[k]) b[++k]=a[i];</span><br><span class="line">        <span class="keyword">else</span>    b[lower_bound(b,b+k,a[i])-b]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lower_bound(first,end,val) 表示在单增 [frist,end) 中首次大于等于 val 的位置</span></span><br><span class="line"><span class="comment">// upper_bound(first,end,val) 表示在单增 [frist,end) 中首次大于 val 的位置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N= <span class="number">1003</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,LIS(a,n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="记录子序列的做法"><a href="#记录子序列的做法" class="headerlink" title="记录子序列的做法"></a>记录子序列的做法</h3><p>由于同学的需要，这里给出加强版：记录子序列<br>首先我们定义一下变量，$a,b$ 已经说过，用 $c[i]$ 表示 $b[i]$ 元素所在的位置。$p[i]$ 表示 $i$ 前面一个元素所在位置。那么最后的子序列就是以 $b[k]$ 所在位置为结尾位置,再用 $p[i]$ 来回溯得到的序列（见代码）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N= <span class="number">1003</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],c[N],p[N],sa[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// longest increasing subsquence for 0 ~ n-1</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    b[<span class="number">0</span>]=a[<span class="number">0</span>];c[<span class="number">0</span>]=<span class="number">0</span>;p[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[k])&#123;</span><br><span class="line">            p[i]=c[k];</span><br><span class="line">            c[++k]=i;</span><br><span class="line">            b[k]=a[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="keyword">int</span>(lower_bound(b,b+k,a[i])-b);</span><br><span class="line">            b[tmp]=a[i];</span><br><span class="line">            c[tmp]=i;</span><br><span class="line">            p[i]=tmp&gt;<span class="number">0</span>?c[tmp<span class="number">-1</span>]:i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = c[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        sa[i]=a[x];</span><br><span class="line">        x=p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = LIS(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;sa[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连续子序列最大和"><a href="#连续子序列最大和" class="headerlink" title="连续子序列最大和"></a>连续子序列最大和</h2><p>$O(n^3)$ 实在不值一提。$O(n^2)$ 就是先预处理前 $m$ 项和。这里具体讲两种 $O(n)$ 的做法。</p>
<ol>
<li>遍历序列对 $s$ 进行累加，如果 $s&lt;0$，将 $s$ 重置为 $0$,每次更新 $s$ 的最大值。最后便能求出最大值(注意序列中全为负数的情况)</li>
<li>设 $dp[i]$ 表示尾为 $i$ 的最大和。那么 $dp[i]=\max (dp[i-1],a[i])$ 。</li>
</ol>
<p>上述两种做法本质上是一致的，做法 2 可能更好理解。并且其实实现的时候我们没必要去用数组标记。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MSCS</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// maximal sum of continue subsquence,mind overflow</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r=a[<span class="number">0</span>],s=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">        s = <span class="built_in">max</span>(s,<span class="number">0</span>);</span><br><span class="line">        s += a[i];</span><br><span class="line">        r = <span class="built_in">max</span>(r,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>快速数论变换（FNT）</title>
    <url>/fastNumberTranslation/</url>
    <content><![CDATA[<p>快速数论变换（FNT）是环 $\mathbb{Z}/ m \mathbb{Z}$ 上的 Fourier 变换（FFT）。<br>至于 快速 Fourier 变换是怎样的有什么用处，这里就不多说了，可参考 <a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform#i-15" target="_blank" rel="noopener">这里</a>。</p>
<a id="more"></a>
<h2 id="NFT-的核心问题"><a href="#NFT-的核心问题" class="headerlink" title="NFT 的核心问题"></a>NFT 的核心问题</h2><p>无论是 FNT 还是 FFT 其本质其关键就是寻找一个 $w$ 使得 $w^{2^n} = 1$。在复数域中这个问题是显然的，而在一个环那就不那么简单了，这里我们考虑环 $R = \mathbb{Z}/ m \mathbb{Z}$。$R$ 为域当且仅当 $m$ 为素数。我们的问题是：</p>
<ol>
<li>我们选取 $R$ 中找比较大（满足我们的需求）的 $n$ 使得 $w^{2^n} = 1$ ；</li>
<li>找出对应的“原根“；</li>
<li>类似 FFT 的处理</li>
<li>应用时各种可能出错的情形，最常见的是溢出,还有只适用于数据范围不超过 P 的非负整数。</li>
</ol>
<h2 id="NFT-问题解决"><a href="#NFT-问题解决" class="headerlink" title="NFT 问题解决"></a>NFT 问题解决</h2><p>  为使得分析问题更为简单，我们考虑在 $m = p$ 为素数的情形，此时，我们有 $2^n \mid p-1$ 即 $p = k \cdot 2^n + 1$ 为(Fermat)素数，例如：</p>
<ol>
<li>$p=479 \times 2^{21} +1 = 1004535809,g = 3$</li>
<li>$p= 13 \times 2^{20} + 1 = 13631489,g = 15$</li>
<li>$p= 17 \times 2^{27} + 1 = 2281701377,g=3$<br>更多常数选择可见 <a href="http://blog.miskcoo.com/2014/07/fft-prime-table" target="_blank" rel="noopener">这里</a>。</li>
</ol>
<p>最终我们选择了 $FM = 1004535809$ 它的优势在于,它的两倍不超过 int 它的乘积不超过 long long 很有利于我们的运算，如果使用刚好不超过 long long 的数使用时很容易出现溢出并不方便。并且它恰好比较大。避免了做完 FFT 出现溢出。另外它可以取到的最大的 $N &gt; 2e6$ 也很不错。例如现在如果我们要做 $2^k$， $k \leq 21$ 的 NFT。那么我们取 $w = g^{\frac{p-1}{2^k}}$ 即可。</p>
<h2 id="HDU-1402"><a href="#HDU-1402" class="headerlink" title="HDU 1402"></a>HDU 1402</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">132005</span>;</span><br><span class="line"><span class="keyword">char</span> sa[N&gt;&gt;<span class="number">1</span>],sb[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line">LL a[N],b[N];</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=x*x%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(LL *x,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=i,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;loglen;++j,t&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            k=(k&lt;&lt;<span class="number">1</span>)|(t&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;i) swap(x[i],x[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL FM = <span class="number">479</span>&lt;&lt;<span class="number">21</span>|<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(LL *x,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen,<span class="keyword">bool</span> isInverse)</span></span>&#123;</span><br><span class="line">    LL g = pow_mod(<span class="number">3</span>,(FM<span class="number">-1</span>)&gt;&gt;loglen,FM);</span><br><span class="line">    <span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">        g=inv(g,FM);</span><br><span class="line">        LL invlen = pow_mod(len,FM<span class="number">-2</span>,FM);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">            x[i]=x[i]*invlen%FM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    change(x,len,loglen);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">2</span>;<span class="built_in">step</span>&lt;=len;<span class="built_in">step</span>&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> half = <span class="built_in">step</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        LL wn = pow_mod(g,len/<span class="built_in">step</span>,FM);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="built_in">step</span>)&#123;</span><br><span class="line">            LL w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;i+half;++j)&#123;</span><br><span class="line">                LL t=(w*x[j+half])%FM;</span><br><span class="line">                x[j+half]=(x[j]-t+FM)%FM;</span><br><span class="line">                x[j]=(x[j]+t)%FM;</span><br><span class="line">                w = w*wn%FM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,sa,sb))&#123;</span><br><span class="line">        <span class="keyword">int</span> alen=(<span class="keyword">int</span>)<span class="built_in">strlen</span>(sa);</span><br><span class="line">        <span class="keyword">int</span> blen=(<span class="keyword">int</span>)<span class="built_in">strlen</span>(sb);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>,loglen=<span class="number">0</span>,tmp=alen+blen+<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(len&lt;tmp)&#123;</span><br><span class="line">            len&lt;&lt;=<span class="number">1</span>;++loglen;</span><br><span class="line">        &#125;</span><br><span class="line">        clr(a,<span class="number">0</span>);clr(b,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=alen;++i)    a[i]=sa[alen-i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=blen;++i)    b[i]=sb[blen-i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">        nft(a,len,loglen,<span class="number">0</span>);</span><br><span class="line">        nft(b,len,loglen,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">            a[i] = a[i]*b[i]%FM;</span><br><span class="line">        &#125;</span><br><span class="line">        nft(a,len,loglen,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;len)&#123;</span><br><span class="line">            a[cnt+<span class="number">1</span>]+=a[cnt]/<span class="number">10</span>;</span><br><span class="line">            a[cnt]%=<span class="number">10</span>;++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=alen+blen;</span><br><span class="line">        <span class="keyword">while</span>(cnt&gt;<span class="number">1</span>&amp;&amp;a[cnt<span class="number">-1</span>]==<span class="number">0</span>)    --cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>((<span class="keyword">int</span>)a[i]+<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>$\pi(x)$ 的计算</title>
    <url>/computationOfPiX/</url>
    <content><![CDATA[<p>$\pi(x)$ 表示不超过 $x$ 的素数个数。容易看出可以在 $O(N)$ 时间复杂度，$O(N)$ 空间复杂度离线预处理求出小于 $N$ 的素数全体。但是如果 $N=10^{14}$ 或者更大，这种做法必然是不现实的。因此下面给出高效的求解方法…</p>
<blockquote>
<p>再读一次还是觉得很巧妙，一步一步走向更优。</p>
</blockquote>
<a id="more"></a>
<p>理论基础: 参考潘承洞《数论基础》和 <a href="COMPUTING pix THE MEISSEL, LEHMER, LAGARIAS,MILLER, ODLYZKO METHOD.pdf">ams 上的一篇论文</a>，<a href="Computing pix the combinatorial method.pdf">另一篇论文</a></p>
<h2 id="psi-x-s"><a href="#psi-x-s" class="headerlink" title="$\psi(x,s)$"></a>$\psi(x,s)$</h2><p>$\psi(x,s)$ 表示不超过 $x$ 且能不能被前 $s$ 个素数整除的正整数个数。即</p>
<script type="math/tex; mode=display">
\psi(x,s) = \sum_{n \leq x} \sum_{d|(n,m_s)} \mu(d) = \sum_{d|m_s} u(d)\lfloor \frac{x}{d} \rfloor</script><p>其中 $m_s = p_1 \cdots p_s$ 为前 $s$ 个素数的积。</p>
<p>另一方面，显然我们有</p>
<script type="math/tex; mode=display">
\psi(x,s) = \psi(x,s-1) - \psi(\frac{x}{p_s},s-1)</script><h2 id="pi-x"><a href="#pi-x" class="headerlink" title="$\pi(x)$"></a>$\pi(x)$</h2><p>我们知道一个数 $n&gt;1$ 是素数当且仅当不存在素数 $p \leq \sqrt{n}$ 使得 $p \mid n$。因此当 $s \geq \pi(\sqrt{x})$ 时，</p>
<script type="math/tex; mode=display">
\psi(x,s) = \pi(x) - s + 1</script><h2 id="P-k-x-s"><a href="#P-k-x-s" class="headerlink" title="$P_k(x,s)$"></a>$P_k(x,s)$</h2><p>设 $P_k(x,s)$ 为 <strong>不超过 $x$ 且每个素因子都大于 $p_s$ 且素因子(按重根计)个数为 $k$</strong> 的整数个数（方法属于 Lehmer）。<br>进一步设 $P_0(x,s)=1$。则</p>
<script type="math/tex; mode=display">
\psi(x,s) = \sum_{k=0} ^{\infty} P_k(x,s)</script><p>显然 $P_1(x,s) = \pi(x)-s$。</p>
<p>若 $\pi(\sqrt[3]{x}) \leq s \leq \pi(\sqrt{x})$ 则 $P_k(x,s)=0,k \geq 3$ 此时</p>
<script type="math/tex; mode=display">
\psi(x,s) = 1 + \pi(x)-s + P_2(x,s)</script><p>其中</p>
<script type="math/tex; mode=display">
P_2(x,s) = \sum_{k=s+1}^{\pi(\sqrt{x})} \left( \pi(\frac{x}{p_k}) - k + 1 \right)</script><blockquote>
<p>注意到上式中 $\frac{x}{p_k} &lt;  x^{\frac{2}{3}}$ </p>
</blockquote>
<h2 id="pi-x-的计算公式"><a href="#pi-x-的计算公式" class="headerlink" title="$\pi(x)$ 的计算公式"></a>$\pi(x)$ 的计算公式</h2><script type="math/tex; mode=display">
\pi(x) = \psi(x,s) + \frac{(\pi(\sqrt{x})+s-2)(\pi(\sqrt{x})- s+1)}{2} - \sum_{k=s+1}^{\pi(\sqrt{x})} \pi(\frac{x}{p_k})</script><blockquote>
<p>取上面 $s = \pi(\sqrt[3]{x}) $<br>因此问题最终转化成求 $\psi(x,\pi(\sqrt[3]{x}))$。它可以利用</p>
</blockquote>
<ol>
<li>$\psi(x,0) = \lfloor x \rfloor$</li>
<li>$\psi(x,s) = \psi(x,s-1) - \psi(\frac{x}{p_s},s-1)$</li>
</ol>
<p>至此问题貌似就这么解决了。但是由于这个递归会使得程序效率大大降低，因此需要一些预处理操作。</p>
<ol>
<li>若 $x&lt;p_s$ 则 $\psi(x,s) ＝ 1$ </li>
<li>给定一个小整数 M，预处理出 $\psi(x,s)$,其中 $x &lt; q=p_1 \cdots p_s,\quad s&lt;=M$<br>则 $\psi(x,s) = \psi(x \mod q,s) + \lfloor \frac{x}{q} \rfloor \psi(q,s)$</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e8</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">1</span>;p[<span class="number">1</span>]=<span class="number">2</span>;isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)   isp[i]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isp[i])  p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>,t=(N<span class="number">-1</span>)/i + <span class="number">1</span>;j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j)&#123;</span><br><span class="line">			isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span>*<span class="number">3</span>*<span class="number">5</span>*<span class="number">7</span>*<span class="number">11</span>*<span class="number">13</span>*<span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM+<span class="number">1</span>][M+<span class="number">1</span>],sz[M+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	initprime();</span><br><span class="line">	pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isp[i])  pi[i]=pi[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>  pi[i]=pi[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	sz[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=PM;++i)  phi[i][<span class="number">0</span>]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">		sz[i]=p[i]*sz[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=PM;++j)&#123;</span><br><span class="line">			phi[j][i]=phi[j][i<span class="number">-1</span>]-phi[j/p[i]][i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s &lt;= M)  <span class="keyword">return</span> phi[x%sz[s]][s]+(x/sz[s])*phi[sz[s]][s];</span><br><span class="line">	<span class="keyword">if</span>(x/p[s] &lt;= p[s])  <span class="keyword">return</span> primepi(x)-s+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;N &amp;&amp; x/p[s]/p[s] &lt;= p[s])&#123;</span><br><span class="line">		<span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">		LL ans = pi[x]-LL(s2x+s<span class="number">-2</span>)*(s2x-s+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=s2x;++i)&#123;</span><br><span class="line">			ans+=pi[x/p[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> primephi(x,s<span class="number">-1</span>)-primephi(x/p[s],s<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> pi[x];</span><br><span class="line">	<span class="keyword">int</span> ps2x = pi[<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">	<span class="keyword">int</span> ps3x = pi[<span class="keyword">int</span>(cbrt(x+<span class="number">0.2</span>))];</span><br><span class="line">	LL ans = primephi(x,ps3x) + LL(ps2x+ps3x<span class="number">-2</span>)*(ps2x-ps3x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =ps3x+<span class="number">1</span>,ed = ps2x;i&lt;=ed;++i)&#123;</span><br><span class="line">		ans -= primepi(x/p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	LL n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n=98765432109876 = 9.8*10^13 用时 38s, N 大点，耗时会小点</span></span><br><span class="line">		<span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;primepi(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lehmer-计算公式"><a href="#lehmer-计算公式" class="headerlink" title="lehmer 计算公式"></a>lehmer 计算公式</h2><blockquote>
<p>我自己写的代码没有上面的快，两种计算各有优势</p>
</blockquote>
<p>令 $s = \pi(\sqrt[4]{x}), t= \pi(\sqrt[3]{x})$。则，对任意 $i&gt;3, P_i(x,s) = 0$,</p>
<script type="math/tex; mode=display">
\begin{array}{rl}
\psi(x,s) &= 1 + \pi(x) - s + P_2(x,s) + P_3(x,s) \\
&= 1+ \pi(x) - s  + P_2(x,s) + \sum_{k=s+1}^{t} P_2(\frac{x}{p_k},k-1) \\
\end{array}</script><p>即：</p>
<script type="math/tex; mode=display">
\pi(x) = \psi(x,s)-1+s-P_2(x,s) - \sum_{k=s+1}^{t} P_2(\frac{x}{p_k},k-1)</script><blockquote>
<p>注意到 $\frac{x}{p_k} &lt; \sqrt{x}$ ，所以最后一个式子可以用下式求，最后计算复杂度在于 $P_2(x,s)$ </p>
</blockquote>
<script type="math/tex; mode=display">
\sum_{k=s+1}^{t} P_2(\frac{x}{p_k},k-1) = \sum_{k=s+1}^{t}  \sum_{j=k}^{\pi(\sqrt{\frac{x}{p_k}})} \pi(\frac{x}{p_k p_j}) - j+1</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e8</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">1</span>;p[<span class="number">1</span>]=<span class="number">2</span>;isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)   isp[i]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isp[i])  p[++cnt] = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>,t=(N<span class="number">-1</span>)/i + <span class="number">1</span>;j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j)&#123;</span><br><span class="line">			isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span>*<span class="number">3</span>*<span class="number">5</span>*<span class="number">7</span>*<span class="number">11</span>*<span class="number">13</span>*<span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM+<span class="number">1</span>][M+<span class="number">1</span>],sz[M+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	initprime();</span><br><span class="line">	pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isp[i])    pi[i] = pi[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> pi[i]=pi[i<span class="number">-1</span>];    </span><br><span class="line">	&#125;</span><br><span class="line">	sz[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=PM;++i)  phi[i][<span class="number">0</span>]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">		sz[i]=p[i]*sz[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=PM;++j)&#123;</span><br><span class="line">			phi[j][i]=phi[j][i<span class="number">-1</span>]-phi[j/p[i]][i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lehmerpi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">P_2</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s &lt;= M)  <span class="keyword">return</span> phi[x%sz[s]][s]+(x/sz[s])*phi[sz[s]][s];</span><br><span class="line">	<span class="keyword">if</span>(x/p[s] &lt;= p[s])  <span class="keyword">return</span> lehmerpi(x)-s+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x/p[s]/p[s] &lt;= p[s] &amp;&amp; x&lt;N)&#123;</span><br><span class="line">		<span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">		LL ans = pi[x]-(s2x+s<span class="number">-2</span>)*(s2x-s+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=s2x;++i)&#123;</span><br><span class="line">			ans+=pi[x/p[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> primephi(x,s<span class="number">-1</span>)-primephi(x/p[s],s<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">P_2</span><span class="params">(LL x,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ps2x = lehmerpi(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>));</span><br><span class="line">	LL ans = LL(s-ps2x)*(ps2x+s<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=ps2x;++i)&#123;</span><br><span class="line">		ans += lehmerpi(x/p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lehmerpi</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> pi[x];</span><br><span class="line">	<span class="keyword">int</span> ps3x = lehmerpi(<span class="keyword">int</span>( cbrt(x+<span class="number">0.2</span>) ));</span><br><span class="line">	<span class="keyword">int</span> ps4x = lehmerpi(<span class="keyword">int</span>( <span class="built_in">sqrt</span>(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>)) ));</span><br><span class="line">	LL ans = primephi(x,ps4x) + ps4x<span class="number">-1</span> - P_2(x,ps4x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =ps4x+<span class="number">1</span>;i&lt;=ps3x;++i)&#123;</span><br><span class="line">		ans -= P_2(x/p[i],i<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	LL n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n=98765432109876 = 9.8*10^13 用时 42s, N 大点，耗时会小点</span></span><br><span class="line">		<span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;lehmerpi(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="稳定简洁的-DP-做法"><a href="#稳定简洁的-DP-做法" class="headerlink" title="稳定简洁的 DP 做法"></a>稳定简洁的 DP 做法</h2><p>我们令 $dp(x,s) = \psi(x,s)+s-1$ 它的意义是，$2～x$ 中被前 $s$ 个素数筛完后的伪素数个数。因此我们有 $dp(0,0)=0,dp(x,0)=x-1,x&gt;1,dp(x,\pi(\sqrt{x})) = \pi(x)$ 且有状态转移</p>
<script type="math/tex; mode=display">
dp(x,s) = dp(x,s-1)-dp(\frac{x}{p_s},s-1)+s-1</script><p>因为 $dp(p_{s-1},s-1) = s-1$，最后一项可以写成 $dp(p_{s-1},s-1)$。虽然上面需要二维数组，但是实际上我们可以优化成一维数组的情况。因为</p>
<script type="math/tex; mode=display">
dp(x,s) = dp(x,s-1)-dp(\frac{x}{p_s},s-1)+ dp(p_{s-1},s-1)</script><p>另外我们也不可能开 $O(n)$ 的数组，但是可以利用一种黑科技开 $O(\sqrt{n})$ 的数组即可达到我们的目的。<br>即我们用 $L[x]$ 表示 $dp(x,s)$ 用 $R[x]$ 表示 $dp(\frac{n}{x},s)$。</p>
<blockquote>
<p>若$L[m]!=L[m-1]$ ，则说明 $m$ 不能被前 $s$  个素数整除是第 $s+1$ 个素数。</p>
<p>我们需要的是 $R[1]$</p>
</blockquote>
<p>上述做法的时间复杂度为 $O(\frac{n}{\log n})$ 且常数特别小，代码十分简洁。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line">LL L[N],R[N];</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL n)</span></span>&#123;</span><br><span class="line">    LL rn = (LL)<span class="built_in">sqrt</span>(n+<span class="number">0.2</span>);</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=rn;++i)   R[i]=n/i<span class="number">-1</span>;</span><br><span class="line">    LL ln = n/(rn+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=ln;++i)   L[i]=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL p=<span class="number">2</span>;p&lt;=rn;++p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L[p]==L[p<span class="number">-1</span>])    <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(LL i=<span class="number">1</span>,tn=<span class="built_in">min</span>(n/(p*p),rn);i&lt;=tn;++i)&#123;</span><br><span class="line">            R[i] -= (i*p&lt;=rn?R[i*p]:L[n/(i*p)])-L[p<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(LL i=ln;i&gt;=p*p;--i)&#123;</span><br><span class="line">            L[i] -= L[i/p]-L[p<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;  <span class="comment">// n=98765432109876 = 9.8*10^13 用时 193s</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;primepi(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个骚方法还目前还没有找到其它的应用 0.0</p>
<p>主要还没法对它用树状数组</p>
</blockquote>
<h2 id="求第-n-个素数的方法"><a href="#求第-n-个素数的方法" class="headerlink" title="求第 n 个素数的方法"></a>求第 n 个素数的方法</h2><ul>
<li>根据概率分布找到大致界限</li>
<li>再牛顿梯度法（或者二分查找）使得 $\pi(m)= n$ </li>
<li>素数判断递减 $m$ 直到 $m$ 为素数</li>
<li><a href="/nthPrimeNumber/" title="参考这里">参考这里</a>
</li>
</ul>
<h2 id="psi-x-s-计算太慢了，需要优化"><a href="#psi-x-s-计算太慢了，需要优化" class="headerlink" title="$\psi(x,s)$ 计算太慢了，需要优化"></a>$\psi(x,s)$ 计算太慢了，需要优化</h2><blockquote>
<p>理论依据见此 <a href="countPrime.zip">压缩包</a></p>
</blockquote>
<p>我们知道，若 $\pi(\sqrt[3]{x}) \leq s \leq \pi(\sqrt{x})$ 则</p>
<script type="math/tex; mode=display">
\psi(x,s) = 1 + \pi(x)-s + P_2(x,s)</script><p>其中</p>
<script type="math/tex; mode=display">
P_2(x,s) = \sum_{k=s+1}^{\pi(\sqrt{x})} \left( \pi(\frac{x}{p_k}) - k + 1 \right) =  \sum_{k=s+1}^{\pi(\sqrt{x})} \left( \psi(\frac{x}{p_k},s)+ s - k \right)</script><blockquote>
<p>注意到上式中 $\frac{x}{p_k} &lt;  x^{\frac{2}{3}} $ </p>
</blockquote>
<p>我们之前的操作本质是递归让 $x,s$ 变小，通过打表预处理来加速递归使得满足一定的效率需要。</p>
<p>现在我们来直接计算得到我们的答案。</p>
<h3 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h3><p>取定整数 $\sqrt[3]{x} \leq y = x^{\frac{1}{3}+\epsilon }&lt; \sqrt{x}, z = \frac{x}{y}, s = \pi(y)$ ，约定 $p, q$ 是素数。 预处理 $y$ 以内的数组：<code>isp[], p[], mu[], pi[]</code> ，对 $[1,z]$ 内的 $\psi(x,s)$ 用树状数组（可以在我的博客网站搜索：<code>树状数组</code>）维护（注意到这需要 $O(z)$ 的内存，单次维护不现实，所以我们可以一段段的维护，保证每一段的长度为 $2^{\lfloor \log_2(y) \rfloor +1}$ 来提高效率）</p>
<blockquote>
<p>做完上面的预处理后，我们发现 $P_2(x,s)$ 可以直接计算了。</p>
</blockquote>
<h3 id="psi-x-s-直接计算"><a href="#psi-x-s-直接计算" class="headerlink" title="$\psi(x,s)$  直接计算"></a>$\psi(x,s)$  直接计算</h3><p>在本博文的最开始有：</p>
<script type="math/tex; mode=display">
\psi(x,s) = \sum_{n \leq x} \sum_{d|(n,p)} \mu(d) = \sum_{d|p} u(d)\lfloor \frac{x}{d} \rfloor</script><p>其中 $p$ 为前 $s$ 个素数的积。</p>
<blockquote>
<p>但是最右边本质上有很多项，所以直接算，其实复杂度特别高。</p>
</blockquote>
<p>我们还有递归公式：</p>
<script type="math/tex; mode=display">
\begin{array}{cl}
\psi(x,s) &= \psi(x,s-1) - \psi(\frac{x}{p_s},s-1) \\
&= \psi(x,s-2) - \psi(\frac{x}{p_{s-1}},s-2) - \psi(\frac{x}{p_s},s-2)  + \psi(\frac{x}{p_sp_{s-1}},s-2) 
\end{array}</script><p>可以一直分解下去，如果一直分解下去就可以得到最上面的公式了。</p>
<p>所以我们约定：对于节点 $\mu(n) \psi(\frac{x}{n},b)$ ，如果满足</p>
<ul>
<li>原始节点： $b = c, n \leq y$  </li>
<li>特殊节点：$n &gt; y$  </li>
</ul>
<p>就不再分解。这也等价于说 如果  $n &lt; y$ 且 $b&gt;c$  就分解。因为一开始 $n=1,b=a&gt;c$。而且 $n$ 会增大，$b$ 会减小，所以节点一定会有限步内，落入上述两种框架中的一种。并且 <strong>特殊节点的父节点 $-\mu(n) \psi(\frac{x}{\frac{n}{p_{d+1}}},b+1)$</strong> 必然满足 $\frac{n}{ p_{d+1} } \leq y <n$  且 $b+1>c$。综上：</p>
<blockquote>
<p>以前设置 $c = 7$，但是后来发现没必要，$c=0$ 就挺好。</p>
</blockquote>
<script type="math/tex; mode=display">
\psi(x,s) = \sum_{n=1} ^y \mu(n) \lfloor \frac{x}{n} \rfloor +  \sum_{\frac{n}{\delta(n)} \leq y < n} \mu(n) \psi(\frac{x}{n}, \pi(\delta(n))-1) = S_0 + S</script><p>$S_0$ 很好处理，计算 $S$： 对 $p = \delta(n)$ 一起求：</p>
<script type="math/tex; mode=display">
S = - \sum_{p \leq y} \sum_{\begin{array}{c} \delta(m) >p \\ m \leq y < mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)</script><p>注意到：$\frac{x}{mp} &lt; z$ ，所以我们已经可以把 $\psi(x,s)$ 直接计算出来了。</p>
<blockquote>
<p>但是我们可以避免很多计算来提高效率。于是我们有下列一系列的操作</p>
</blockquote>
<ul>
<li>$p \geq \sqrt{y}$，则 $m$ 为素数 ，且此时 $mp &gt; p^2 \geq y$ (若 $m$ 为合数，则 $m \geq \delta(m) ^2 &gt;p^2 \geq y$ 矛盾)</li>
<li>$\frac{x}{mp} &lt; p$ 时，$\psi(\frac{x}{mp},\pi(p)-1) = 1$</li>
<li>$\sqrt{\frac{x}{mp}} &lt; p$ 时，$\psi(\frac{x}{mp},\pi(p)-1) = \pi(\frac{x}{mp}) - \pi(p) +2$</li>
<li>$\sqrt{y} &lt; \sqrt{z} &lt;  x^{\frac{1}{4}}  &lt; x^{\frac{1}{3}} &lt; y$</li>
</ul>
<h4 id="由此对-S-分段计算"><a href="#由此对-S-分段计算" class="headerlink" title="由此对$S$分段计算"></a>由此对$S$分段计算</h4><script type="math/tex; mode=display">
S_1 = - \sum_{\sqrt[3]{x} < p \leq y} \sum_{\begin{array}{c} \delta(m) >p \\ m \leq y < mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)</script><script type="math/tex; mode=display">
S_2 = - \sum_{\sqrt{z} < p \leq \sqrt[3]{x}} \sum_{\begin{array}{c} \delta(m) >p \\ m \leq y < mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)</script><script type="math/tex; mode=display">
S_3 = - \sum_{\sqrt{y} < p \leq \sqrt{z}} \sum_{\begin{array}{c} \delta(m) >p \\ m \leq y < mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)</script><script type="math/tex; mode=display">
S_4 = - \sum_{p \leq \sqrt{y}} \sum_{\begin{array}{c} \delta(m) >p \\ m \leq y < mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)</script><p>由限制关系式，我们化简 $S_1, S_2, S_3$</p>
<script type="math/tex; mode=display">
\begin{array}{cl}
S_1 &= - \sum_{\sqrt[3]{x} < p \leq y} \sum_{p<q \leq y} \mu(q) \psi(\frac{x}{pq},\pi(p)-1) \\
&=  \sum_{\sqrt[3]{x} < p < q \leq y} 1 \\
&= {\pi(y)-\pi(\sqrt[3]{x}) \choose 2} 
\end{array}</script><script type="math/tex; mode=display">
\begin{array}{cl}
S_2 &= - \sum_{\sqrt{z} < p \leq \sqrt[3]{x}} \sum_{p<q \leq y} \mu(q) \psi(\frac{x}{pq},\pi(p)-1) \\
&=  \sum_{\sqrt{z} < p \leq \sqrt[3]{x}} \sum_{p<q \leq y} \pi(\frac{x}{pq}) - \pi(p) +2 \\
&= \sum_{\sqrt{z} < p \leq \sqrt[3]{x}} \sum_{p<q \leq y} \pi(\frac{x}{pq}) + \sum_{\sqrt{z} < p \leq \sqrt[3]{x}} (\pi(p)-\pi(y))(\pi(p)-2)
\end{array}</script><script type="math/tex; mode=display">
\begin{array}{cl}
S_3 &= - \sum_{\sqrt{y} < p \leq \sqrt{z}} \sum_{p < q \leq y} \mu(q) \psi(\frac{x}{pq},\pi(p)-1) \\
&=  \sum_{\sqrt{y} < p \leq \sqrt{z}}  \sum_{p < q \leq y} \psi(\frac{x}{pq},\pi(p)-1)
\end{array}</script><blockquote>
<p>$S_2$ 也可以用 $S_3$ 的式子求，只是效率不高。</p>
<p>$S_2$ 中 $\frac{x}{pq}, p&lt;y$，即可以直接求。</p>
</blockquote>
<p><strong>当然了还可以继续细化，但是我嫌麻烦就不想再细化了！</strong></p>
<blockquote>
<p>也就是现在的核心就是树状数组分段维护数据，然后每一段的总值要用数组存起来就好了。然后用这个数据结果计算 $S_2,S_3,S_4,P_2(x,s)$，然后就大功告成了 0.0</p>
<p>用 $\psi(x,s)$ 计算 $\pi(x)$，还是用 $\pi(x)$ 计算 $\psi(x,s)$ ，这是一个问题。</p>
<p>用树状数组维护的时候会有一个很大的问题就是：求和式中 每此动 $p$ 整个维护就要从 $1 \to p$ 重新维护一次很麻烦。这个问题没解决所以我不想写代码。 </p>
<p>想把 $\frac{x}{pq}$ 的所有可能的值单调递增排列但是又不现实。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>环的 Zariski 拓扑(素谱)</title>
    <url>/zariskiTopologyOfRing/</url>
    <content><![CDATA[<p>设 $A$ 是(交换)环。令 $X$ 为 $A$ 的素理想全体，定义 $V(E)$ 为 $A$ 中包含 $E$ 的素理想全体，则将所有 $V(E)$ 看做闭集，它满足拓扑空间三条公理，即构成了拓扑，该拓扑称作 Zariski 拓扑，这个拓扑空间叫做环 $A$ 的素谱，记作 $Spec(A)$。<br>有了拓扑，我们自然要考虑：</p>
<ol>
<li>集合的内部、闭包</li>
<li>拓扑的基，拓扑的分离性，紧性</li>
<li>空间的连通性，不可约性</li>
<li>拓扑空间的连续函数等等概念</li>
</ol>
<p>在这个具体拓扑下的样子。</p>
<a id="more"></a>
<h2 id="Zariski-拓扑"><a href="#Zariski-拓扑" class="headerlink" title="Zariski 拓扑"></a>Zariski 拓扑</h2><p>要证明 $T = \lbrace V(E),E \subset A \rbrace$ 作为闭集确实构成了一个拓扑，即证明 $\emptyset \in T,X \in T$，且 $T$ 中任意并，有限交运算是封闭的。而显然我们有</p>
<ol>
<li>$V(0)=X,V(A)=\emptyset$</li>
<li>$\cap_{i \in I} V(E_i) = V(\cup_{i \in I}E_i)$</li>
<li>为说明 $V(E_1) \cap V(E_2) \in T$ 我们需要一些准备工作。</li>
</ol>
<p>设 $I(E)$ 为由 $E$ 生成的理想，定义</p>
<script type="math/tex; mode=display">
\sqrt{\alpha} = \lbrace x\in A : x^n \in \alpha \rbrace</script><p>则显然我们有</p>
<ol>
<li>$\alpha \subset \sqrt{\alpha} = \sqrt{\sqrt{\alpha}}$</li>
<li>$\sqrt{\alpha \beta} = \sqrt{\alpha \cap \beta} = \sqrt{\alpha} \cap \sqrt{\beta}$</li>
<li>$\sqrt{\alpha}=(1) \Leftrightarrow \sqrt{\alpha}$</li>
<li>$\sqrt{\alpha+\beta} = \sqrt{ \sqrt{\alpha}+\sqrt{\beta} }$</li>
<li>若 $p$ 是素理想，$\sqrt{p} = p$。</li>
<li>$V(E)=V(I(E))=V(\sqrt{I(E)})$</li>
<li>$V(\alpha \cap \beta)=V(\alpha \beta)=V(\alpha) \cup V(\beta)$</li>
<li>$\cap_{p \in V(\alpha)} p = \sqrt{\alpha}$ </li>
<li>$V(E_1) = V(E_2) \Leftrightarrow \sqrt{I(E_1)} = \sqrt{I(E_2)}$</li>
</ol>
<p>因此，$V(E_1) \cap V(E_2) = V(I(E_1)) \cap V(I(E_2)) = V(I(E_1) \cap I(E_2)) \in T$。这说明它确实满足拓扑空间的三条公理。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>有了拓扑之后，我们自然用具体的例子来看一下，这个拓扑大致长什么样子。<br>考虑 $Spec(\mathbb{Z})$ ，此时 $X = \lbrace (p) : p\text{ is prime } \rbrace \cup (0)$。可以看出，包含 $(0)$ 闭集仅有 $X$，除 $(0)$ 外，$X$ 中的单点集全是闭集。因此 $Spec(\mathbb{Z})$ 不是 $T_1$ 空间，由此可见，一般地，$Spec(A)$ 不是 $T_1$ 空间，即此拓扑的分离性很差。</p>
<h2 id="内部和闭包"><a href="#内部和闭包" class="headerlink" title="内部和闭包"></a>内部和闭包</h2><p>因为在一般的拓扑理论中我们有 $A^{o} = \overline{A^c} ^c$，因此，我们只需搞清楚 $A^{o}$ 和 $\overline{A}$中任意一个即可，我们考虑闭包($\overline{A}$)。对于 $Y \subset X$。若 $Y \subset V(E)$ 则 $\forall \; p \in Y, E \in p$,即 $ E \in \cap_{p \in Y} p$。因此 $Y \subset V(\cap_{p \in Y}) \subset V(E)$。因此 $\overline{Y} = V(\cap_{p \in Y})$。<br>特别地，</p>
<ol>
<li>$\overline{\lbrace p_x \rbrace} = V(p_x)$</li>
<li>$\overline{\lbrace p_x \rbrace} = \lbrace p_x \rbrace \Leftrightarrow p_x$ 是极大理想。</li>
<li>$p_y \in \overline{\lbrace p_x \rbrace} \Leftrightarrow p_x \subset p_y$</li>
<li>$X$ 是 $T_0$ 空间（$p_y \notin \overline{\lbrace p_x \rbrace}$ 或者 $p_x \notin \overline{\lbrace p_y \rbrace}$）。</li>
</ol>
<p>因此，这样就很清楚为何在之前的例子$Spec(\mathbb{Z})$中除$(0)$外单点集都是闭集了。有了之前的结论我们再看一下其他的例子。<br>$Spec(\mathbb{R})$：此时 $X = \lbrace 0 \rbrace$ 只有一个元素拓扑是平凡的。<br>因为 若 $A$ 为域,则 $A[x]$ 为 ED 为 PID，其素理想为 $(f)$ 不可约多项式。且 PID 中非零素理想就是极大理想。<br>$Spec(\mathbb{C}[x])$: 此时 $X = \lbrace (x+t): t \in \mathbb{C} \rbrace \cup \lbrace (0) \rbrace$<br>$Spec(\mathbb{R}[x])$: 此时 $X = \lbrace (x+t): t \in \mathbb{R} \rbrace \cup \lbrace (x^2+ax+b): a,b \in \mathbb{R},a^2 &lt; 4b \rbrace \cup \lbrace (0) \rbrace$</p>
<h2 id="基，紧性"><a href="#基，紧性" class="headerlink" title="基，紧性"></a>基，紧性</h2><p>由于 $V(\cup_{i \in I}E_i) = \cap_{i \in I} V(E_i)$ 我们定义 $X_E = X \setminus V(E)$。则 $X_E = \cup_{f \in E} X_f$ 这说明 $X_f,f \in A$ 确实构成了 $X$ 的一组基。$X_f$ 表示不包含 $f$ 的素理想全体。</p>
<ol>
<li>$X_f \cap X_g = X_{fg}$</li>
<li>$X_f = \emptyset \Leftrightarrow f$ 是幂零的。</li>
<li>$X_f = X \Leftrightarrow f$ 是单位。</li>
<li>$X_f = X_g \Leftrightarrow \sqrt{(f)} = \sqrt{(g)}$</li>
</ol>
<h3 id="X-是拟紧的"><a href="#X-是拟紧的" class="headerlink" title="$X$ 是拟紧的"></a>$X$ 是拟紧的</h3><blockquote>
<p>这里的拟紧,实际上就是一般点集拓扑学中的紧，在代数中紧这个概念是拟紧＋Hausdorff。</p>
</blockquote>
<p>我们只需证明：若 $\cup_{f \in S} X_f = X$ 则存在有限并使上式成立。实际上，</p>
<script type="math/tex; mode=display">
\cup_{f \in S} X_f = X \Leftrightarrow V(I(S))=V(S) = \emptyset</script><p>因此 $I(S)=A$，即 $1 = \sum_{i=1}^n a_i s_i$。所以$I(s_1,\cdots,s_n) = A$，即 $\cup_{i=1}^n X_{s_i} = X$。证毕。</p>
<h3 id="X-f-是拟紧的"><a href="#X-f-是拟紧的" class="headerlink" title="$X_f$ 是拟紧的"></a>$X_f$ 是拟紧的</h3><p>我们只需证明：若 $X_f \subset \cup_{g \in S} X_g$，则存在有限并使上式成立。实际上，</p>
<script type="math/tex; mode=display">
X_f \subset \cup_{g \in S} X_g  \Leftrightarrow V(\sqrt{I(S)}) = V(S) \subset V(f)</script><p>因此 $f \in \sqrt{I(S)}$，即 $f^m = \sum_{i=1}^n a_i s_i$。所以 $f^m \in I(s_1,\cdots,s_n)$即。$X_f \subset \cup_{i=1}^n X_{s_i}$。证毕。</p>
<h3 id="任意开集-Y-subset-X-是拟紧的当且仅当-Y-可以写成有限多个-X-f-的并"><a href="#任意开集-Y-subset-X-是拟紧的当且仅当-Y-可以写成有限多个-X-f-的并" class="headerlink" title="任意开集 $Y \subset X$ 是拟紧的当且仅当 $Y$ 可以写成有限多个 $X_f$ 的并"></a>任意开集 $Y \subset X$ 是拟紧的当且仅当 $Y$ 可以写成有限多个 $X_f$ 的并</h3><p>Proof: 由 $X_f$ 是拟紧的知道，“$\Leftarrow$” 是显然的。<br>“$\Rightarrow$” 是因为存在$E \subset A$ 使得</p>
<script type="math/tex; mode=display">
Y = X_E = \cup_{f \in E} X_f</script><p>是 $Y$ 的一个开覆盖，由于是拟紧的，因此可以写成有限个 $X_f$ 的并，证毕。</p>
<blockquote>
<p>以上结论来自 Atiyah <strong>An Introduction to Coummutative Algebra</strong> 习题。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>李代数</title>
    <url>/lieAlgebra/</url>
    <content><![CDATA[<p>近期在整理 Lie Algebra 课的笔记，还是很喜欢这门课的，主要是本科时候矩阵玩的特别 6，然后 Lie Algebra 可以认为是矩阵的推广版本。里面的证明技巧性相当强。我之所以喜欢数学很大程度与数学技巧有关。但是我的导师说，这些虽然很有技巧，但是你花时间都是可以处理的，会技巧没什么了不起，脑袋稍微好一点就能做这种事，长期技巧的训练其实意义并不大，应该更关注数学内部的东西，具体说就是一个代数对象的结构，分类，不变量，对象之间的同构。一个概念有哪些等价形式，与其它概念之间的关系，搞清楚这些更为重要，它们的证明只要大致知道怎么过来的就行。我们并不要把证明的细节放在心中，因为我们已经经过了多年的训练，相信我们通过大致步骤就能给出详细的证明，只是花的时间多少罢了。当然初学一个东西，去抠它的细节是无可厚非的。<br><strong>以上纯属废话 0.0</strong></p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>交换环 $K$ 上的模 $L$，以及一个运算 $L \times L \to L,(x,y) \mapsto [x,y]$ 称为 $x,y$ 的 Lie 括号，或交换子，并称 $L$ 是 $K$ 上的 Lie Algebra，如果满足如下公理。<br>L1. $[\cdot,\cdot]$ 是双线性的；<br>L2. $[x,x]=0$ 对任意 $x \in L$ 成立；<br>L3. $[x,[y,z]]+[y,[z,x]]+[z,[x,y]]=0$ (Jacobi 恒等式)</p>
<p>若 $[L,L]=0$ 则上面结论显然成立，此时称为 Abelian Lie Algebra。</p>
<blockquote>
<p>我们通常并不考虑 Abelian Lie Algebra。并且要求交换环 $K$ 是域 $F$，很多时候还要求 $F$ 是特征为 0 的代数闭域，另外我们大多考虑 $L$ 是 $F$ 上的有限维线性空间。</p>
</blockquote>
<p>子，理想，商，同态，表示等一系列的概念和其它代数结构几乎一致。可以划入范畴中。另外单，半单，Radical 等这些概念也于环里面的类似，就不赘述了。</p>
<h2 id="样板-Lie-Algebra"><a href="#样板-Lie-Algebra" class="headerlink" title="样板 Lie Algebra"></a>样板 Lie Algebra</h2><p>若 $V$ 是 $F$ 上有限维线性空间，$End V$ 表示 $V$ 到 $V$ 的线性变换全体按照元素的复合构成了 $F$ 上的线性空间且 $\dim End V = (\dim V)^2$。也构成了 $End V$ 是一个结合 $F$-代数。而任何结合代数都可以诱导一个 Lie 代数： $[x,y]=xy - yx$ 。为了强调 Lie 结构，我们用 $\mathbb{gl}(V)$ 代替 $End V$，称为 general linear algebra。它在 Lie 代数中充当的角色很类似于置换群在群中的角色。我们知道半单 Lie 代数同构于 $\mathbb{gl}(V)$ 的一个子 Lie 代数。</p>
<h2 id="导子和伴随表示"><a href="#导子和伴随表示" class="headerlink" title="导子和伴随表示"></a>导子和伴随表示</h2><p>我们称一个 $F-$代数 $A$（可以非结合）也可以借助导子(derivation)诱导一个 Lie 代数，称一个导子是指一个线性映射 $\delta: A \to A$ 满足 $\delta(ab)=\delta(a)b+a\delta(b)$。易知导子 $Der A$ 全体构成了 $End A$ 的一个子空间，由于 $[\delta,\delta’] \in Der A$，因此 $Der A$ 构成了 $\mathbb{gl}(V)$的一个子 Lie 代数。<br>由于 Lie 代数 $L$ 也是 $F$-代数,因此我们也可以定义 $Der L$。这里的导子本质上就是 Jacobi 恒等式的变形。<br>定义 $ad_x: L \to L,y \mapsto [x,y]$，实际上 $ad_x \in Der L$。$L \to Der L,x \mapsto ad_x$ 称为 $L$ 的伴随表示(adiont representation)。</p>
<h2 id="可解和幂零"><a href="#可解和幂零" class="headerlink" title="可解和幂零"></a>可解和幂零</h2><p>对于给定 Lie 代数 $L$，我们有理想降链<br>$L^{(0)} = L,L^{(1)}=[L^{(0)},L^{(0)}],\cdots,L^{(i)}=[L^{(i-1)},L^{(i-1)}],\cdots$。若存在 $n$ 使得 $L^{(n)} = 0$ 则称 $L$ 可解(slovable)。</p>
<ol>
<li>若$L$ 可解，$L$ 的子代数和同态像可解</li>
<li>$I$ 是 $L$ 的可解理想，若 $L/I$ 可解，则 $L$ 可解。</li>
<li>$I,J$ 是 $J$ 的可解理想，则 $I+J$ 也是。</li>
</ol>
<p>由上述性质可知，$L$ 有唯一的极大可解理想。即为 $Rad L$,若 $Rad L =0$ 则称之为<strong>半单</strong>的，等价于 $L$ 无非零 Abelian 理想(充分性显然，必要性是因为 $Rad L$ 可解，考虑最后一个非 0 项必然是 Abelian 理想矛盾)。另外 我们称 $x \in End V$ 半单，若 $x$ 的极小多项式无重根。</p>
<p>对于给定 Lie 代数 $L$，我们有理想降链<br>$L^0 = L,L^1=[L, L^0],\cdots,L^i=[L, L^{i-1}],\cdots$。若存在 $n$ 使得 $L^{n} = 0$ 则称 $L$ 幂零(nilpotent)。</p>
<ol>
<li>若$L$ 幂零，$L$ 的子代数和同态像幂零。</li>
<li>若 $L/Z(L)$ 幂零。则 $L$ 幂零。</li>
<li>若 $L$ 幂零且非 0，则 $Z(L) \neq 0$。</li>
</ol>
<p>显然由于 $L^{(i)} \subset L^i$ 因此幂零一定可解，但是反之则不尽然，例如 $\mathbb{gl}(V)$ 中对应的上三角矩阵全体构成的 Lie 代数。由 Lie 定理的推论知：</p>
<blockquote>
<p>$L$ 可解的充要条件是 $[L,L]$ 幂零。 </p>
</blockquote>
<h3 id="ad-nilpotent"><a href="#ad-nilpotent" class="headerlink" title="ad-nilpotent"></a>ad-nilpotent</h3><p>$L$ 是一个 Lie 代数，$x \in L$, 称 $x$ ad-nilpotent 是指 $ad_x$ 幂零。<br>易知若 $x$ 幂零，则 $ad_x$ 幂零，但是反之不尽然。然而我们有 <strong>Engel 定理</strong>：</p>
<h3 id="L-幂零当且仅当-ad-L-幂零"><a href="#L-幂零当且仅当-ad-L-幂零" class="headerlink" title="$L$ 幂零当且仅当 $ad L$ 幂零"></a>$L$ 幂零当且仅当 $ad L$ 幂零</h3><h2 id="一些重要结果"><a href="#一些重要结果" class="headerlink" title="一些重要结果"></a>一些重要结果</h2><p>这里罗列一些定理实际上就是搞清楚 Lie 代数中的一些问题和一些好的性质。</p>
<p><strong>THM1</strong>. 设 $L$ 是 $\mathbb{gl}(V)$ 的子代数($L$ 中的元素可理解为矩阵)，$V$ 是有限维的，若 $L$ 中元素都幂零，则存在 $v \in V$ 使得 $L(v) = 0$.<br>上面结果是讲，$L$ 中元素都幂零，则 $L$ 有公共的 $0$ 特征向量。证明是很有技巧性的。构造一个 codemension 为 1 的子代数，并证明它是 $L$ 不变子空间。然后数学归纳法完成证明。上面定理还说明我们可以取定一组基使 $L$ 同时严格上三角。</p>
<p><strong>THM2</strong>. 若 $L$ 幂零，$K$ 是 $L$ 的非零理想,则 $K \cap Z(L) \neq 0$</p>
<p><strong>THM3</strong>. 设 $L$ 是 $\mathbb{gl}(V)$ 可解子代数，$V$ 是有限维的，则存在 $L$ 存在公共特征向量。</p>
<p>上面定理还说明我们可以取定一组基使得 $L$ 同时上三角。</p>
<p><strong>THM4</strong>. 若 $x \in EndV$，则存在唯一的分解 $x = x_s+x_n$，其中 $x_s$ 是半单的， $x_n$ 是幂零的，且 $x_s,x_n$ 都能表示成 $x$ 的无常数项的多项式。将其称之为 Jordan-Chevally 分解。</p>
<p><strong>THM5</strong>. 若 $x$ 半单，则 $ad_x$ 半单。若 $x=x_s+x_n$ 是 Jordan-Chevally 分解，则 $ad_x = ad_{x_s} + ad_ {x_n}$  也是。$Der A$ 包含其元素的 半单部分和幂零部分。</p>
<p><strong>THM6</strong>. $A \subset B \subset End V $，令 $M = \lbrace x \in \mathbb{gl}(V) \mid [x,B] \subset A\rbrace$。若 $x \in M$ 满足，$Tr(xy)=0$ 对任意 $y\in M$ 成立，则 $x$ 幂零。</p>
<p><strong>THM7</strong> $L \subset \mathbb{gl}(V)$，$V$ 是有限维的, 则 对任意 $x \in [L,L],\;y \in L$ 有 $Tr(xy)=0$ 当且仅当 $L$ 可解。</p>
<p><strong>THM8</strong> 设 $L$ 是 Lie 代数，对任意 $x \in [L,L],\;y \in L$ 有 $Tr(ad_x ad_y)=0$ 则 $L$ 可解。</p>
<p><strong>THM9</strong> 若 $L$ 是半单的，则 $L$ 可唯一写成单子理想的直和且 $L=[L,L],Z(L)=0$ 且 $L$ 的理想和同态像都是半单的。</p>
<p><strong>THM10</strong> $ad L$ 是 $Der L$ 的理想，且若 $L$ 是半单的，则 $ad L = Der L$。</p>
<h2 id="To-be-continue"><a href="#To-be-continue" class="headerlink" title="To be continue"></a>To be continue</h2>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵的 Jordan 分解</title>
    <url>/jordanDecompositionOfMatrix/</url>
    <content><![CDATA[<p>最近在整理李代数（Lie Algebra） 内容时，里面提到了 Jordan 分解，这里就详细介绍并证明几个相关结果。</p>
<ol>
<li>若矩阵 $A,B$ 可交换，则它们有公共特征向量。</li>
<li>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换</li>
<li>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化（半单部分），$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。</li>
</ol>
<a id="more"></a>
<p>下面证明这三个结果并给出说明其意义。</p>
<h2 id="若矩阵-A-B-可交换，则它们有公共特征向量"><a href="#若矩阵-A-B-可交换，则它们有公共特征向量" class="headerlink" title="若矩阵 $A,B$ 可交换，则它们有公共特征向量"></a>若矩阵 $A,B$ 可交换，则它们有公共特征向量</h2><p><strong>证明</strong>：我们设 $V$ 为 $n$ 阶列向量全体。设 $\lambda$ 为 $B$ 的一个特征值。设 </p>
<script type="math/tex; mode=display">
W = \lbrace x \in V \mid Bx = \lambda x \rbrace</script><p>则对任意 $x \in W$,</p>
<script type="math/tex; mode=display">
B(Ax) = A(Bx)=A(\lambda x)=\lambda(Ax)</script><p>即 $Ax \in W$。即 $W$ 是 $A$ 的不变子空间，因此，$A$ 在 $W$ 中有特征值 $\mu$ 对应的特征向量 $v$ 即为所求。</p>
<h2 id="若矩阵-A-B-可以对角化，则它们可以同时对角化，当且仅当-A-B-交换"><a href="#若矩阵-A-B-可以对角化，则它们可以同时对角化，当且仅当-A-B-交换" class="headerlink" title="若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换"></a>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换</h2><p><strong>证明</strong>：$\rightarrow$ 是显然的。现证 $\leftarrow$ 若 $A,B$ 交换。<br>由条件知，存在可逆矩阵 $P$ 使得 $P^{-1}AP = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})$。由 $A,B$ 交换知，$P^{-1}AP P^{-1}BP = P^{-1}BP P^{-1}AP$。因此</p>
<script type="math/tex; mode=display">
P^{-1}BP = \left(\begin{matrix} 
B_1 \\  & B_2 \\ & & \ddots \\ & & & B_s 
\end{matrix}\right)</script><p>因为 $B$ 可对角化，因此 $B$ 的最小多项式无重根。所以 $B_i$ 的最小多项式也无重根。因此 $B_i$ 可对角化，存在可逆矩阵 $Q_i$ 使得 $Q_i^{-1}B_iQ_i$ 为对角阵。令 $Q = diag(Q_1,\cdots,Q_s)$，$T=PQ$，则 $T^{-1}BT$ 为对角阵。</p>
<script type="math/tex; mode=display">
T^{-1}AT = diag(Q_1^{-1},\cdots,Q_s^{-1})diag(a_1 E_{n_1},\cdots,a_s E_{n_s}) diag(Q_1,\cdots,Q_s) = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})</script><h2 id="Jodan-分解"><a href="#Jodan-分解" class="headerlink" title="Jodan 分解"></a>Jodan 分解</h2><p>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化，$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。</p>
<p>证明：首先对任意矩阵，我们有 Jordan 标准型：对任意矩阵 $A$，存在可逆矩阵 $P$ 使得</p>
<script type="math/tex; mode=display">
P^{-1} A P = \left(\begin{matrix} J_1(\lambda_1) \\  & J_2(\lambda_2) \\ & & \ddots \\ & & & J_s(\lambda_s) \end{matrix}\right) = \left(\begin{matrix} \lambda_1 E_{n_1} \\  & \lambda_2 E_{n_2} \\ & & \ddots \\ & & & \lambda_s E_{n_s} \end{matrix}\right) + \left(\begin{matrix} J_1(0) \\  & J_2(0) \\ & & \ddots \\ & & & J_s(0) \end{matrix} \right)</script><p>由于 $J_i(\lambda_i)$ 的化零多项式为 $f_i(\lambda) = |\lambda I_i -  J_i(\lambda_i)|$。由中国剩余定理知。存在多项式 $f(\lambda)$ 满足 $f(\lambda) = \lambda_i (mod \; f_i),i=1,\cdots,s$ 且 $f(\lambda)= 0 (mod \lambda)$。此时</p>
<script type="math/tex; mode=display">
P^{-1} f(A) P = \left(\begin{matrix} \lambda_1 E_{n_1} \\  & \lambda_2 E_{n_2} \\ & & \ddots \\ & & & \lambda_s E_{n_s} \end{matrix}\right)</script><p>令 $B=f(A)，C=A-B$ 即为所求。上面的 $B,C$ 是唯一的，因为，若存在 $B_1,C_1$ 也满足上述条件，则 $A,B,C,B_1,C_1$彼此交换，$B-B_1 = C_1 - C$ 是幂零的，因此 $B=B_1,C=C_1$。</p>
<p>对于 Jordan 分解，我们可以将一个矩阵分为所谓的半单部分和幂零部分，而由第二条结论知道，如果 $A_1,A_2$ 可交换，那么 $A_1+A_2$ 的半单部分即为 $B_1+B_2$。或者说的更明了一点就是，如果 $A,B$ 可交换，且可以对角化，则 $A+B$ 也可以对角化。</p>
<blockquote>
<p>想到写这些完全是因为李代数忘掉 Lie 括号本身就是一个线性空间。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>有限整环是域</title>
    <url>/finiteDomainIsField/</url>
    <content><![CDATA[<p>有限整环是域，这是一个相当深刻的定理，被称为 Wedderburn’s little theorem。介绍如下。<br><a id="more"></a></p>
<h2 id="有限整环是体"><a href="#有限整环是体" class="headerlink" title="有限整环是体"></a>有限整环是体</h2><p>设 $D$ 是有限整环（不要求交换），下证 $D$ 是体。<br>证明：对任意 $0 \neq a \in D$，考虑 $a,a^2,a^3,..,a^n,…$ 由于 $D$ 是有限环，因此存在 $n,r &gt; 0$ 使得 $a^{n+r} = a^n$ 即 $a^n(a^r-1)=0$ 由于 $D$ 是整环，$a \neq 0$，因此 $a^r =1$ ，所以 $a$ 可逆，证毕。</p>
<h2 id="有限体是域"><a href="#有限体是域" class="headerlink" title="有限体是域"></a>有限体是域</h2><p>设 $K$ 是有限体。$Z$ 是它的中心，即</p>
<script type="math/tex; mode=display">
Z = \lbrace z \in K \mid \forall x \in K, xz = zx \rbrace</script><p>则，$Z$ 是域。令 $|Z|=q$，则 $K$ 是 $q$ 元域上的有限维向量空间，设维数为 $n$，则 $|K|=q^n$。我们需要证明 $K=Z$, 即证明 $n=1$。<br>对任意 $a \in K$，令 $N(a) = \lbrace x \in K \mid ax = xa \rbrace$ ，这显然是 $K$ 的一个子体。并且包含 $Z$。因此 $N(a)$ 也是 $Z$ 上的有限维向量空间。从而 $N(a)=q^{n(a)},n(a) \geq 1$。由于 $K^{\star}$ 为 $q^n-1$ 阶乘法群，$N(a)^{\star}$ 为 $K^{\star}$ 的 $q^{n(a)}-1$ 阶子群，因此 $q^{n(a)}-1 \mid q^n-1$，因此 $n(a) \mid n$。<br>将乘法群 $K^{\star}$ 中的元素分成共轭类，从群论的角度，与 $a \in K^{\star}$ 共轭的元素有 $[K^{\star} :N(a)^{\star}] = \frac{q^n-1}{q^{n(a)}-1}$，从而每个共轭类取一次，共轭类集合记作$X$，我们有</p>
<script type="math/tex; mode=display">
q^n - 1 = q-1 + \sum_{\overline{a} \in X} \frac{q^n-1}{q^{n(a)}-1}</script><p>我们需要证明的是当 $n&gt;1$ 时上式不成立。为此我们先介绍<strong>分圆多项式</strong>的知识。</p>
<script type="math/tex; mode=display">
P_n(x) = \prod_{1 \leq r \leq n,(r,n)=1} (x-e^{\frac{2 \pi i r}{n}})</script><p>即 $P_n(x)$ 是以全部 $n$ 次本原单位复根（共 $\phi(n)$ 个）为根的首一多项式。易知</p>
<script type="math/tex; mode=display">
x^n -1 = \prod_{d \mid n} P_d(n)</script><p>由数论函数的 <a href="/dirichletProduct/" title="Mobius 变换">Mobius 变换</a>，(取对数或指数来切换乘积和相加)可知</p>
<script type="math/tex; mode=display">
P_n(x) = \prod_{d \mid n} (x^d-1)^{\mu(n/d)}</script><p>于是 $P_n(x)=f(x)/g(x)$ 其中 $f(x),g(x)$ 都为 $\mathbb{Z}[x]$ 中的首一多项式。另一方面，按照定义，$P_n(x) \in \mathbb{C}[x]$ ，从而在 $\mathbb{C}[x]$ 中 $g(x) \mid f(x)$。比较系数易知，$P_n(x)$ 为 $\mathbb{Z}[x]$ 中首一多项式。</p>
<p>因为对任意 $d \mid n,0&lt;d&lt;n,P_n(x)$ 的每个根都是 $x^n-1$ 的根，但不是 $x^d-1$ 的根，从而 </p>
<script type="math/tex; mode=display">
P_n(x) \mid \frac{x^n-1}{x^d-1}</script><p>因此 $P_n(q) \mid q-1$, 但当 $n&gt;1$ 时，</p>
<script type="math/tex; mode=display">
|P_n(q))| > (q-1)^{\phi(n)} \geq q-1</script><p>矛盾，证毕。</p>
<blockquote>
<p>这个定理也可以表述为：一个有限环，如果它不是域，那么它必然存在零因子。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>华罗庚恒等式</title>
    <url>/huaIndentity/</url>
    <content><![CDATA[<p>华罗庚恒等式有两个，都看似奇怪但都有其深刻的应用(数学内部的)</p>
<ol>
<li><p>若在一个环中 $a,b,1-ab$ 都可逆，则</p>
<script type="math/tex; mode=display">
\left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a</script></li>
<li><p>若在一个环中</p>
<script type="math/tex; mode=display">
a = \left( b^{-1} - (a-1)^{-1}b^{-1}(a-1) \right) \left (a^{-1} b^{-1}a-(a-1)^{-1}b^{-1}(a-1) \right)^{-1}</script></li>
</ol>
<p>上面两个恒等式直接验算即知，可是华老当初怎么想到这两个很奇怪的恒等式呢，怎么导入的，有什么应用呢？</p>
<a id="more"></a>
<p>当然以下也只是我的个人猜测加上 Wikipedia 的一些参考。</p>
<h2 id="在环中-1-ba-可逆当且仅当-1-ab-可逆"><a href="#在环中-1-ba-可逆当且仅当-1-ab-可逆" class="headerlink" title="在环中,  1-ba 可逆当且仅当 1-ab 可逆"></a>在环中,  1-ba 可逆当且仅当 1-ab 可逆</h2><script type="math/tex; mode=display">
(1-ba)^{-1} = 1+ b(1-ab)^{-1}a</script><p>上面恒等式直接证明是显然的，应用却 666，6 到要吐。<br>问题在于为什么想到这样奇怪的式子呢？思路怎么来的呢？<br>我们知道，当 $0&lt;x&lt;1$ 时，</p>
<script type="math/tex; mode=display">
\frac{1}{1-x} = \sum_{n=0}^{\infty} {x^n}</script><p>因此，形式上我们有</p>
<p>讲上述不等式应用到矩阵形式即可得到 Sherman–Morrison 恒等式</p>
<h2 id="在环中，若-a-b-ab-1-可逆，则"><a href="#在环中，若-a-b-ab-1-可逆，则" class="headerlink" title="在环中，若 $a,b,ab-1$ 可逆，则"></a>在环中，若 $a,b,ab-1$ 可逆，则</h2><p>由上面恒等式我们知道 </p>
<script type="math/tex; mode=display">
(ab-1)^{-1} = a(ba-1)^{-1}b - 1</script><p>因此</p>
<script type="math/tex; mode=display">
\begin{aligned} (a-b^{-1})^{-1} &= \left((ab-1)b^{-1} \right)^{-1} \\
&= b\left( a(ba-1)^{-1}b - 1 \right) \\
&= ba(ba-1)^{-1}b - b  \\
&= (ba-1)^{-1}b
\end{aligned}</script><p>注意到 </p>
<script type="math/tex; mode=display">
\begin{aligned}  (ba-1)^{-1}b - a^{-1} &= (ba-1)^{-1}baa^{-1} - a^{-1} \\
&= (ba-1)^{-1}a^{-1} \\
&= (aba-a)^{-1} 
\end{aligned}</script><p>因此，华罗庚等式 1： $ \left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a$ 得证。</p>
<h2 id="一个重要恒等式"><a href="#一个重要恒等式" class="headerlink" title="一个重要恒等式"></a>一个重要恒等式</h2><script type="math/tex; mode=display">
b^{-1} - a^{-1} = ( b+b(a-b)^{-1}b )^{-1}</script><p>上面恒等式与逆算子连续性有关系。<br>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}  (b^{-1} - a^{-1})^{-1} &= (1-ba^{-1})^{-1}b \\
&=(1+b(1-a^{-1}b)^{-1}a^{-1})b \\
&= b+b(a-b)^{-1}b
\end{aligned}</script><h2 id="华罗庚恒等式-2-证明"><a href="#华罗庚恒等式-2-证明" class="headerlink" title="华罗庚恒等式 2 证明"></a>华罗庚恒等式 2 证明</h2><script type="math/tex; mode=display">
\begin{aligned} 
a \left( a^{-1}b^{-1}a - (a-1)^{-1} b^{-1}(a-1) \right) &=
(b^{-1}a- a(a-1)^{-1} b^{-1} (a-1) \\
&= ( 1-a(a-1)^{-1} )b^{-1}a + (a-1+1) (a-1)b^{-1} )^{-1} \\
&= -(a-1)^{-1}b^{-1}a + b^{-1} + (a-1)b^{-1} \\
&= b^{-1} - (a-1)^{-1} b^{-1}(a-1) 
\end{aligned}</script><h2 id="华罗庚恒等式的意义"><a href="#华罗庚恒等式的意义" class="headerlink" title="华罗庚恒等式的意义"></a>华罗庚恒等式的意义</h2><ol>
<li>华罗庚第一个恒等式可以用来证明一个 Hua’s Theorem：除环间中保持加法和幺元以及逆元的映射必然是除环间的同态或者反同态。</li>
<li>华罗庚第二个恒等式可以证明 Cartan-Brauer-Hua Theorem 即一个除环的真子除环的单位群如果是原除环的单位群的正规子群，则该子除环一定包含于除环的中心。</li>
</ol>
<h2 id="最后用一句广为流传的话结尾"><a href="#最后用一句广为流传的话结尾" class="headerlink" title="最后用一句广为流传的话结尾"></a>最后用一句广为流传的话结尾</h2><blockquote>
<p>龙生龙，凤生凤，华罗庚的学生会打洞（矩阵打洞）</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Fermat 平方和定理</title>
    <url>/fermatSqureSumTheorem/</url>
    <content><![CDATA[<p>Fermat 平方和定理的表述为：奇质数能表示为两个平方数之和的充分必要条件是该质数被 4 除余 1（必要性显然）。这个结论首次由 Euler 在 1747 年给出证明。详细叙述如下：</p>
<a id="more"></a>
<p>为方便起见,记</p>
<script type="math/tex; mode=display">
A = \lbrace a^2 + b^2 \mid a,b \in \mathbb{Z} \rbrace</script><p>证明分五步完成</p>
<ol>
<li><p>$(a^2+b^2)(c^2+d^2)=(ac \pm bd)^2 +(ad \mp bc)^2 $</p>
<p> proof: 计算即知。</p>
</li>
<li><p>若 $a^2+b^2 \mid c^2+d^2$, $a^2+b^2$ 为素数，则</p>
<script type="math/tex; mode=display">
 \frac{c^2+d^2}{a^2+b^2} \in A</script><p> <strong>proof</strong>: 由于 $(ac-bd)(ac+bd) = (a^2+b^2)c^2-(c^2+d^2)b^2$ 因此 $(a^2+b^2) \mid (ac-bd)(ac+bd)$ 而 $(a^2+b^2)$ 是素数，因此必然整除其中一个。假设 $(a^2+b^2)|(ac-bd)$，则由 1 知 $(a^2+b^2)｜(ad+bc)$ 因此</p>
<script type="math/tex; mode=display">
 \frac{c^2+d^2}{a^2+b^2}=(\frac{ac - bd}{a^2+b^2})^2 +(\frac{ad + bc}{a^2+b^2})^2</script><p> ​类似的，假设 $(a^2+b^2) \mid (ac＋bd)$ 则有</p>
<script type="math/tex; mode=display">
 \frac{c^2+d^2}{a^2+b^2}=(\frac{ac + bd}{a^2+b^2})^2 +(\frac{ad - bc}{a^2+b^2})^2</script></li>
<li><p>$x \mid a^2+b^2,x \notin A$，则 $\exists y| \frac{a^2+b^2}{x}$ 使得 $y \notin A$</p>
<p> 反证：设 $a^2+b^2 = x p_1 p_2 \cdots p_n$ 则 $\forall y| \frac{a^2+b^2}{x},y \in A$ 则由 2，经过 $n$ 次除法，最终 $x \in A$ 矛盾。</p>
</li>
<li><p>若 $(a,b)=1$ 则 $\forall x | a^2+b^2 \Rightarrow x \in A$</p>
<p> 假设 $\exists x| a^2+b^2,x \notin A$ 则，我们设 $a = mx + c,b = mx + d$,其中 $|c|,|d| \leq \frac{x}{2}$。则<br> $a^2+b^2=(mx+c)^2+(mx+d)^2=tx+(c^2+d^2)$，因此 $x \mid c^2+d^2$。又 $(a,b)=1$ ，因此 $((c,d),x)=1$。因此不妨设 $(c,d)=1$（否则，两边同除它的平方）则 $\exists z, zx = c^2+d^2 \leq \frac{x^2}{2}$。即 $z\leq \frac{x}{2}$。由引理 3 知道 $z$ 有一个因子 $w \notin A$。即我们由 $x \mid a^2+b^2,x \notin A$ 得到了 $w \mid c^2+d^2, w \notin A ,w \leq  \frac{x}{2}$ 这样一直下去必然会在有限步结束，矛盾，即必然有 $x \in A$ 。</p>
</li>
<li><p>若素数 $p=4n+1$，则 $p\in A$。</p>
<p> 由 Fermat 小定理知 $1,2^{4n},\cdots,(4n)^{4n}$ 除以 $p$ 模 1.因此 $2^{4n}－1,3^{4n}－2^{4n},\cdots,(4n)^{4n}-(4n-1)^{4n}$ 都是 $p$ 的倍数。这些差都有分解</p>
<script type="math/tex; mode=display">
 a^{4n} - b^{4n} = (a^{2n}+b^{2n})(a^{2n}-b^{2n})</script><p> 由于上述 $a,b$ 相差为 1，必然互素，因此若 $p|a^{2n}+b^{2n}$ 则由 4 命题得证。否则 $2^{2n}-1,3^{2n}-2^{2n},\cdots,(2n)^{2n}-(2n-1)^{2n}$ 都是 $p$ 的倍数。<br> 因此 1.对上面式子做 $2n$ 阶差得到 $(2n)!$ 是 $p$ 的倍数，显然是不可能的。<br> 或者 2.由于上面序列的前 $d$ 项和 $d^{2n}-1$ 是 $p$ 的倍数，因此素数 $p$ 无原根，矛盾与原根存在定理。</p>
<blockquote>
<p>$1^k,2^k, \cdots, k^k, (k+1)^k$ 的 $k$ 阶差为 $k!$</p>
</blockquote>
</li>
</ol>
<h2 id="用现代语言，Fermat-平方和定理也可以表达为"><a href="#用现代语言，Fermat-平方和定理也可以表达为" class="headerlink" title="用现代语言，Fermat 平方和定理也可以表达为"></a>用现代语言，Fermat 平方和定理也可以表达为</h2><blockquote>
<p>奇素数 $p$ 在 $\mathbb{Z}[i]$ 中不可约元当且仅当 $p  \equiv 3 \mod 4$</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>自然底数 e 的由来</title>
    <url>/naturalBase/</url>
    <content><![CDATA[<p>自然底数 $e$ 之所以重要，我想很大程度上是因为，指数函数 $f(x)=e^x$ 是“唯一”(在常数倍意义下)满足导数等于本身的函数。因此 $e$ 被叫做自然底数。</p>
<a id="more"></a>
<p>然而，$e$ 的定义可以由一个常见的重要数列极限来定义。即</p>
<script type="math/tex; mode=display">
e \doteq \lim _{n \to \infty}(1+\frac{1}{n})^n</script><p>那么为什么右边极限存在呢，我们来仔细分析。<br>令 </p>
<script type="math/tex; mode=display">
a_n = (1+\frac{1}{n})^n ,\; b_n =(1+\frac{1}{n})^{n+1}</script><p>则，由<a href="/meanInequation/" title="均值不等式">均值不等式</a>易知：</p>
<script type="math/tex; mode=display">
a_n = (1+\frac{1}{n})^n \cdot 1 \leq [\frac{n(1+\frac{1}{n})+1}{n+1}]^{n+1} =a_{n+1}</script><p>且</p>
<script type="math/tex; mode=display">
\frac{1}{b_n} = (\frac{n}{n+1})^n \cdot 1 \leq [\frac{(n+1)\frac{n}{n+1}+1}{n+2}]^{n+2} = \frac{1}{b_{n+1}}</script><p>因此 $2 = a_1 \leq a_n \leq b_n \leq b_1 = 4$。由于单调有界序列必有极限，不妨把这个极限记作 $e$ 且由上面推理知 $2 &lt; e &lt; 4$。</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><script type="math/tex; mode=display">
f_n = (1+\frac{1}{n})^{n+c},\quad g_n = (1+\frac{1}{n})^{n+d}</script><p>那么满足$f_n \leq e &lt; g_n$ 的最大的$c=\frac{1}{ln⁡2}−1$，最小的$d = \frac{1}{2}$，详细证明</p>
<p><img src= "/img/loading.gif" data-lazy-src="0.png" alt="0"></p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>均值不等式的证明</title>
    <url>/meanInequation/</url>
    <content><![CDATA[<p>初中就学过最简单的均值不等式 $\frac{a+b}{2} \geq \sqrt{ab},a ,b \geq 0$。它的证明只需配方就知道了，这里介绍一下一般的均值不等式:</p>
<script type="math/tex; mode=display">
\frac{ \sum_{i=1} ^n a_i}{n} \geq \sqrt[n]{\Pi_{i=1}^n a_i }</script><a id="more"></a>
<p><strong>Proof</strong>：当 $n=1$ 时结论是平凡的，$n=2$ 时配方即知。$n=2^k$时不难用数学归纳法知，结论成立，下面主要看 $2^{k-1} &lt;n&lt; 2^k$的情况：<br>令 $A = \frac{ \sum_{i=1} ^n a_i}{n} $ 则，应用 $2^k$ 时的结论</p>
<script type="math/tex; mode=display">
\frac{ \sum_{i=1} ^n a_i + (2^k-n)A }{2^k} \geq\sqrt[2^k]{\Pi_{i=1}^n a_i A^{2^k -n}}</script><p>化简可得到结论。</p>
<blockquote>
<p>上述证明简单优美，第一次在陈纪修《数学分析》上册看到这个优美的方法。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>最强装逼题目 0.0</title>
    <url>/zhuangbility/</url>
    <content><![CDATA[<p>数学老师想好了两个自然数 $m,n$ 满足 $2 \leq m \leq n \leq 100$ ,他把 $m,n$ 的和 $s$ 告诉了 $S$ 同学，把 $m,n$ 的积 $p$ 告诉了 $P$ 同学，他们都是聪明诚实的学生。进行了下面对话<br>$S$: 我不知道 $m,n$ 的值，但我知道你也不知道。<br>$P$: 现在我知道了。<br>$S$: 现在我也知道了。<br>请问 $m,n$ 的值。</p>
<a id="more"></a>
<ol>
<li><p>由第一句话，我们知道 $s \geq 6$,且 $p$ 中无大于或者等于 53 的质因数。但是 $S$ 是如何知道的呢，可见 $s \leq 54$。对 数 $6 \to 54$ 逐一检查发现，除了$A = \lbrace 11,17,23,27,29,35,37,41,47,51,53 \rbrace$的其他元素外，其余每个数都可以表示成两个素数的和，因此从第一句话知道，$ s \in A$。</p>
</li>
<li><p>刚刚推理 $P$ 同学当然也能完成。由于 $A$ 中的元素全是奇数，因此，若 $p = 2^k \cdot (2v+1), k \geq 0, v \geq 0$ 或者 $p = 2^k \cdot (2v+1)(2j+1), k \geq 0, v \geq 0, j \geq 0$ 则 $P$ 同学就能确定的知道答案。</p>
</li>
<li><p>$S$ 同学最后也知道了 $m,n$ 的值，说明在 $s$ 所有分解 $s = m+ n, 2 \leq m \leq n \leq 100$ 中，且有一种满足 $xy = 2^k v$。<br> 检查 $11 = 4+7 = 3+8$, $23 = 4 + 19 = 7+16$, $27 = 4+23 = 8+19$, $35=4+31=16+19$, $37 = 8+29 = 5+32$, $47= 4 + 43 = 16+31$, $51 = 4+47 = 8+43$。<br> 又因为 </p>
<script type="math/tex; mode=display">
29 = 4 + 25 = 13 +16,\; 41 = 4+37 = 16 + 25,\; 53 = 16 +37 = 21 + 32</script><p>其中 $4 \times 25 = 100 = 20 \times 5$, $20+5 =25 \notin A$, $16 \times 25 = 400 = 80 \times 5$, $80+5 =85 \notin A$, $21 \times 32 = 672 = 7 \times 96$ ,$ 7+96 =103 \notin A$。<br>因此，只可能 $s=17$</p>
<script type="math/tex; mode=display">
17 = 2+15 = 3+14 = 4+13 = 5+12 = 6+11 = 7 +10 = 8+9</script><p>其中只有 $17 =4 + 13$ 满足 $P$ 的断言，因此 $m = 4,n=13$。</p>
</li>
</ol>
<blockquote>
<p>此题是我高三（2011 年）在《奥赛金牌之路》中所见，实在很吊，一直铭记于心,特此记录。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>整数集上的一种特殊拓扑</title>
    <url>/specialTopologyOnNaturalNumber/</url>
    <content><![CDATA[<p>在《Proofs from THE BOOK》里素数无限的六种证明的第五种讲到了一种用点集拓扑学知识证明的方法，其中引入了整数集上的一种奇特拓扑。</p>
<a id="more"></a>
<h2 id="特殊拓扑的定义"><a href="#特殊拓扑的定义" class="headerlink" title="特殊拓扑的定义"></a>特殊拓扑的定义</h2><p>对 $a,b \in \mathbb{Z},b&gt;0$，令</p>
<script type="math/tex; mode=display">
N_{a,b} = \lbrace a + nb \colon n \in \mathbb{Z} \rbrace</script><p>我们称集合 $O \subset \mathbb{Z}$ 是开集，若 $O = \emptyset$，或者 $\forall a \in O,\exists b&gt;0,st. N_{a,b} \subset O$,容易验证这样定义的开集族全体构成了 $\mathbb{Z}$ 上的拓扑。</p>
<h3 id="上述拓扑的性质"><a href="#上述拓扑的性质" class="headerlink" title="上述拓扑的性质"></a>上述拓扑的性质</h3><p>每个 $N_{a,b}$ 都是既开又闭的。这是由于</p>
<script type="math/tex; mode=display">
N_{a,b} = \mathbb{Z} \setminus \cup_{i=1}^{b-1} N_{a+i,b}</script><p>又由</p>
<script type="math/tex; mode=display">
\mathbb{Z} \setminus \lbrace -1,1 \rbrace = \cup_{p \in P} N_{0,p}</script><p>其中 $P$ 是素数集。</p>
<h3 id="上述拓扑的应用"><a href="#上述拓扑的应用" class="headerlink" title="上述拓扑的应用"></a>上述拓扑的应用</h3><p>若素数只有有限个，即 $P$ 是有限集，则 $\lbrace -1,1 \rbrace$ 是开集，矛盾。</p>
<p>上述方法脑洞大，形式简洁，不愧是 <a href="0.pdf">《Proofs from THE BOOK》</a></p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>相对公平的席位分配</title>
    <url>/fairAssignment/</url>
    <content><![CDATA[<p>“公平”的席位分配首先本来就是不可能的，公平一般是无法达到的，我们只是尽量降低不公平度，那么我们怎么衡量不公平度呢。就像评价一个人，有不同的指标，不公平度也是一样，这里介绍一种相对合理易于接受，且好判断的方法。</p>
<a id="more"></a>
<h2 id="问题表述"><a href="#问题表述" class="headerlink" title="问题表述"></a>问题表述</h2><p>某学校三个系部学生共 200 名,(甲系 100,乙系 60,丙系 40)代表会议共 20 席,按比例分配三个系分别为 10、6、4 席。但是情况变为下列情况怎样分配才是最公平的,现因学生转系三系人数为 103、63、34 。</p>
<ol>
<li>问 20 席该如何分配 ? </li>
<li>若增加 21 席又如何分配 ?</li>
</ol>
<p>显然，因为无法整除无论如何分配都不公平。下面说一下几种策略。</p>
<p><strong>策略一</strong>： 按班级人数比例乘以总人数，小数点大的分得多余的一个位子。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">某校</th>
<th style="text-align:right">甲系</th>
<th style="text-align:right">乙系</th>
<th style="text-align:right">丙系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">共 200 人</td>
<td style="text-align:right">103</td>
<td style="text-align:right">63</td>
<td style="text-align:right">34</td>
</tr>
<tr>
<td style="text-align:center">人数比例</td>
<td style="text-align:right">51.3</td>
<td style="text-align:right">31.5</td>
<td style="text-align:right">17</td>
</tr>
<tr>
<td style="text-align:center">20 席位</td>
<td style="text-align:right">10.3</td>
<td style="text-align:right">6.3</td>
<td style="text-align:right">3.4</td>
</tr>
<tr>
<td style="text-align:center">实际分配</td>
<td style="text-align:right">10</td>
<td style="text-align:right">6</td>
<td style="text-align:right">4</td>
</tr>
<tr>
<td style="text-align:center">21 席位</td>
<td style="text-align:right">10.82</td>
<td style="text-align:right">6.62</td>
<td style="text-align:right">3.57</td>
</tr>
<tr>
<td style="text-align:center">实际分配</td>
<td style="text-align:right">11</td>
<td style="text-align:right">7</td>
<td style="text-align:right">3</td>
</tr>
</tbody>
</table>
</div>
<p>按照上述策略，会出现席位增多而 <strong>丙系的席位却减少了一个的不合理现象</strong>，说明此方法并不合理。</p>
<h2 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h2><p>假设只有 A、B 两个单位分配席位的情况，设两方人数 $m_1,m_2$ ,分配到的席位为 $n_1,n_2$。</p>
<ol>
<li><p>$\frac{n_1}{m_1} = \frac{n_2}{m_2}$ 公平，但是一般是不满足的。</p>
</li>
<li><p>$\frac{n_1}{m_1} &gt; \frac{n_2}{m_2}$ 对 A 不公平。</p>
</li>
<li><p>$\frac{n_1}{m_1} &lt; \frac{n_2}{m_2}$ 对 B 不公平。</p>
</li>
</ol>
<p>绝对不公平度</p>
<script type="math/tex; mode=display">
d = \left| \frac{n_1}{m_1} - \frac{n_2}{m_2} \right|</script><p>  但这样做还是有不足，例如<br>  某两个单位的人数和席位为 $n_1=n_2=10,m_1=120,m_2=100$ 算得  $d=2$.<br>  另两个单位的人数和席位为 $n_1=n_2=10,m_1=1020,m_2=1000$ 算得 $d=2$。<br>  但是显然，第二种情况更公平，但是（绝对）不公平度却是一样的不合理</p>
<p>相对不公平度</p>
<ol>
<li>若 $\frac{n_1}{m_1} &lt; \frac{n_2}{m_2}$ 则<script type="math/tex; mode=display">
r_A(n_1,n_2) = \frac{ \frac{n_2}{m_2} - \frac{n_1}{m_1} }{ \frac{n_2}{m_2} } = 1 - \frac{n_1 m_2}{m_1 n_2}</script></li>
</ol>
<ol>
<li>若 $\frac{n_1}{m_1} &gt; \frac{n_2}{m_2}$ 则<script type="math/tex; mode=display">
r_B(n_1,n_2)  = \frac{ \frac{n_1}{m_1} - \frac{n_2}{m_2} }{ \frac{n_1}{m_1} } = 1 - \frac{n_2 m_1}{m_2n_1}</script>我们的目标是让$r_A,r_B$(每种分配只会有一个)最小。</li>
</ol>
<h3 id="策略二"><a href="#策略二" class="headerlink" title="策略二"></a><strong>策略二</strong></h3><p>假设当前 $\frac{n_1}{m_1} &lt; \frac{n_2}{m_2}$ 对 A 不公平。新增了一个席位。</p>
<ol>
<li>若 $\frac{n_1 + 1}{m_1} \leq  \frac{n_2}{m_2}$ 则 A 加 1 席 </li>
<li>否则此时<ul>
<li>若分配给 A，则对 B 的不公平值(相对):<script type="math/tex; mode=display">
r_B(n_1+1,n_2) = 1 - \frac{n_2 m_1}{m_2 (n_1 + 1)}</script></li>
<li>若分配给 B，则对 A 的不公平值(相对):<script type="math/tex; mode=display">
r_A(n_1,n_2+1) = 1 - \frac{n_1 m_2}{m_1(n_2 + 1)}</script></li>
</ul>
</li>
</ol>
<p>我们定义 $Q_i = \frac{m_i ^2}{n_i(n_i+1)}$，那么分配给 B 等价于 $r_A(n_1,n_2+1)&lt;r_B(n_1+1,n_2)$ 等价于$Q_1 &lt; Q_2$。即我们应该将席位分配给 $Q$ 值较大者。</p>
<blockquote>
<p>讲 $Q_i$ 定义成 $Q_i = \frac{n_i(n_i+1)}{m_i ^2}$ ，然后找最小的比较合理，不过这样会有小数点太长，所以没这么做</p>
</blockquote>
<h3 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h3><p>先按照平均原则取整之后。分出了 19 席：$n_1=10,n_2=6,n_3=3$，第 20 席：</p>
<script type="math/tex; mode=display">
Q_1 = \frac{103^2}{10 \times 11 } \approx 96.4 \; , \;Q_2 = \frac{63^2}{6 \times 7} \approx 94.5 \; , \;Q_3 = \frac{34^2}{3 \times 4} \approx 96.3</script><p>则分配：$n_1=11,n_2=6,n_3=3$<br>第 21 席：$Q_1=80.4, Q_2 = 94.5, Q_3 = 96.3$<br>则分配：$n_1=11,n_2=6,n_3=4$.</p>
<blockquote>
<p>相对不公平度有很多变种，从而 <strong>策略二有很多变种</strong>（最后计算发现都一样）</p>
<p>莫非策略二就是天选之子 0.0</p>
</blockquote>
<h2 id="本文参考文库-1和文库-2，修改了其中的错误"><a href="#本文参考文库-1和文库-2，修改了其中的错误" class="headerlink" title="本文参考文库 1和文库 2，修改了其中的错误"></a>本文参考<a href="http://wenku.baidu.com/view/396d4f6aaf1ffc4ffe47ac52.html?re=view" target="_blank" rel="noopener">文库 1</a>和<a href="http://wenku.baidu.com/view/312ef3274b35eefdc9d33304.html?re=view" target="_blank" rel="noopener">文库 2</a>，修改了其中的错误</h2><blockquote>
<p>其实作为分配者，如果你倾向 X，那你就选择让 X 收益最多的策略，反正 <strong>策略一</strong> 看上去也挺合理的，实在不行的话，再强行找花头…</p>
</blockquote>
<p>由于席位分配问题确实是一个经典问题，故在此记录。</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>运筹学</tag>
      </tags>
  </entry>
  <entry>
    <title>二次剩余和 Gauss 互反律</title>
    <url>/quadraticResidueAndGaussReciprocity/</url>
    <content><![CDATA[<p>从二次剩余问题，引入 Legendre 符号，由此一步步导出 Gauss 互反律，最后延伸到 Jacobi 符号，整个步骤确实连贯优美，脍炙人口。<br><a id="more"></a></p>
<p>寒假回家好好调整了一下状态，回学校后感觉还不错，效率也蛮高。发现理图虽然比较破，但是还是很不错的，哈哈哈。每次读潘承洞先生的《数论基础》都觉得受益匪浅，我把自己很喜欢的部分写入到该文中。</p>
<h2 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h2><p>考虑如下形式二次同余式</p>
<script type="math/tex; mode=display">
x^2 \equiv  a \; \mod \; p</script><p>其中 $p$ 是奇素数，$a$ 是非负整数。若上述方程有解，则称 $a$ 是 $p$ 的二次剩余，记作 $a\; R \; p$，否则称 $a$ 是 $p$ 的二次非剩余，记作 $a \; \overline{R}\; p$ 。$p=2$ 时就没啥意思了，所以 <strong>仅考虑奇素数。</strong></p>
<p>经过简单推理很容易发现，在模 $p$ 的简化系中，二次剩余与二次非剩余各占一半。且容易知道，$1^2,2^2,\cdots,(\frac{p-1}{2})^2$ 都是 $p$ 二次剩余。</p>
<h2 id="Legendre-符号"><a href="#Legendre-符号" class="headerlink" title="Legendre 符号"></a>Legendre 符号</h2><script type="math/tex; mode=display">
\left( \frac{a}{p} \right) = \left\{ \begin{array}{cc} 1, & a\; R\; p \\
0, & p \mid a \\
-1, & a\; \overline{R}\; p. \end{array} \right.</script><h3 id="定理-1-quad-frac-a-p-p-1-equiv-a-frac-p-1-2-mod-p"><a href="#定理-1-quad-frac-a-p-p-1-equiv-a-frac-p-1-2-mod-p" class="headerlink" title="定理 1: $ \quad -(\frac{a}{p}) (p-1)! \equiv a^{\frac{p-1}{2}} \mod p $"></a>定理 1: $ \quad -(\frac{a}{p}) (p-1)! \equiv a^{\frac{p-1}{2}} \mod p $</h3><p><strong>Proof</strong>: 对于 $p \mid a$ 的情形，结论显然。下面考虑 $(p,a)=1$ 的情形，令</p>
<script type="math/tex; mode=display">
 S = \lbrace 1,2,\cdots,p-1 \rbrace</script><p>对任意的 $ x \in S $ 必存在唯一的 $ y \in S $ 为下面同余式的解</p>
<script type="math/tex; mode=display">
yx \equiv a \; \mod p</script><p>当 $ (\frac{a}{p}) = -1 $ 时，同余式 $ x^2 = a \; \mod p$ 无解，所以 $y \neq x $ .因此集合 $S$ 中的元素可以分成 $\frac{p-1}{2} $ 对，我们就有</p>
<script type="math/tex; mode=display">
(p-1)! \equiv a^{\frac{p-1}{2}} \;\mod p</script><p>当 $ (\frac{a}{p}) = 1 $ 时，同余式 $ x^2 = a \; \mod p $有两个解 $x_0$ 和 $p - x_0$.在$S$中去掉这两个数外剩下$p-3$个数分出 $\frac{p-3}{2}$对，则有</p>
<script type="math/tex; mode=display">
(p-1)! \equiv a^{\frac{p-3}{2}}x_0(p-x_0) \equiv - a^{\frac{p-1}{2}} \; \mod p</script><p> 证毕。</p>
<h2 id="推论-2-Wilson-定理"><a href="#推论-2-Wilson-定理" class="headerlink" title="推论 2 (Wilson 定理)"></a>推论 2 (Wilson 定理)</h2><script type="math/tex; mode=display">
(p-1)! \equiv -1 \;\mod p</script><p><strong>Proof</strong>: <strong>定理 1</strong> 中取 $a=1$ 即可。</p>
<h2 id="推论-3-Euler-判别法"><a href="#推论-3-Euler-判别法" class="headerlink" title="推论 3(Euler 判别法)"></a>推论 3(Euler 判别法)</h2><script type="math/tex; mode=display">
\left( \frac{a}{p} \right ) \equiv a^{\frac{p-1}{2}} \; \mod \;p</script><p><strong>Proof</strong>: 由 <strong>定理 1</strong> 和 <strong>推论 2</strong> 显然。Euler 判别法不仅有理论价值(下面都是推论 3 的直接推论)，由于快速幂的存在，使得 Euler 判别法在计算时有相当好的效果。</p>
<h2 id="推论-4-Format-小定理-设-a-p-1-则"><a href="#推论-4-Format-小定理-设-a-p-1-则" class="headerlink" title="推论 4(Format 小定理) 设 $(a,p)=1$ ,则"></a>推论 4(Format 小定理) 设 $(a,p)=1$ ,则</h2><script type="math/tex; mode=display">
a^{p-1} \equiv 1 \;\mod p</script><h2 id="推论-5：-frac-1-p-1-frac-p-1-2"><a href="#推论-5：-frac-1-p-1-frac-p-1-2" class="headerlink" title="推论 5：$(\frac{-1}{p}) = (-1)^{\frac{p-1}{2}}$"></a>推论 5：$(\frac{-1}{p}) = (-1)^{\frac{p-1}{2}}$</h2><h2 id="推论-6：-frac-ab-p-frac-a-p-frac-b-p"><a href="#推论-6：-frac-ab-p-frac-a-p-frac-b-p" class="headerlink" title="推论 6：$(\frac{ab}{p}) =(\frac{a}{p})(\frac{b}{p}) $"></a>推论 6：$(\frac{ab}{p}) =(\frac{a}{p})(\frac{b}{p}) $</h2><h4 id="推论-6-说明，我们求-Legendre-符号，只需求-frac-2-p-frac-q-p-即可"><a href="#推论-6-说明，我们求-Legendre-符号，只需求-frac-2-p-frac-q-p-即可" class="headerlink" title="推论 6 说明，我们求 Legendre 符号，只需求 $ (\frac{2}{p}),(\frac{q}{p}) $ 即可"></a>推论 6 说明，我们求 Legendre 符号，只需求 $ (\frac{2}{p}),(\frac{q}{p}) $ 即可</h4><h2 id="定理-7：-frac-2-p-1-frac-p-2-1-8"><a href="#定理-7：-frac-2-p-1-frac-p-2-1-8" class="headerlink" title="定理 7：$(\frac{2}{p}) = (-1)^{\frac{p^2-1}{8}}$"></a>定理 7：$(\frac{2}{p}) = (-1)^{\frac{p^2-1}{8}}$</h2><p><strong>Proof</strong>: </p>
<script type="math/tex; mode=display">
2^{\frac{p-1}{2}}(\frac{p-1}{2})! = 2 \cdot 4 \cdots (p-1) \equiv (\frac{p-1}{2})!(-1)^{1+2+\cdots+\frac{p-1}{2}}\;\mod p</script><p>其中最后一个等价是因为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
p-1 \equiv (-1)^1 \mod p \\
2 \equiv (-1)^2 \mod p \\
p-3 \equiv (-1)^3 \mod p \\
\cdots
(\frac{2}{p}) \equiv 2^{\frac{p-1}{2}} \equiv (-1)^{\frac{p^2-1}{8}} \;\mod p
\end{array}</script><p>证毕。</p>
<h2 id="定理-8：-Gauss-二次互反律-设-p-q-为不同的奇素数，则有"><a href="#定理-8：-Gauss-二次互反律-设-p-q-为不同的奇素数，则有" class="headerlink" title="定理 8：(Gauss 二次互反律) 设 $p,q$ 为不同的奇素数，则有"></a>定理 8：(Gauss 二次互反律) 设 $p,q$ 为不同的奇素数，则有</h2><script type="math/tex; mode=display">
(\frac{p}{q}) (\frac{q}{p}) = (-1)^{\frac{(p-1)(q-1)}{4}}</script><blockquote>
<p>证明太长了，下次一定吧 0.0</p>
</blockquote>
<h2 id="Jacobi-符号"><a href="#Jacobi-符号" class="headerlink" title="Jacobi 符号"></a>Jacobi 符号</h2><blockquote>
<p>Jacobi 符号的引入只是为了让计算更加简洁！</p>
</blockquote>
<p> 我们在计算用 Gauss 二次互反律求 $(\frac{a}{q})$ 时，由于 $a$ 要因式分解成很多项，所以直接用不是很方便。因此我们引入 Jacobi 符号:</p>
<p>设 $Q =  q_1 \cdots q_s$ 是正奇数，其中 $q_1 \leq \cdots \leq q_s$  是奇素数（手算时候可以保证严格小于），我们定义：</p>
<script type="math/tex; mode=display">
(\frac{a}{Q}) = (\frac{a}{q_1}) \cdots (\frac{1}{q_s})</script><ul>
<li>$Q$ 为奇素数时，Jacobi 符号就是 Legendre 符号</li>
<li>$(\frac{a}{Q}) = 1$ 并不等价于 $x^2 \equiv a \mod Q$ 有解！</li>
<li>$(\frac{a}{Q})$ 是 $a$ 的可乘函数，周期为 $Q$ 的周期函数</li>
<li>当 $(a,Q)&gt;1$ 时，$(\frac{a}{Q})=0$</li>
<li>当 $(a,Q)= 1$ 时，$(\frac{a^2}{Q})=1$；特别地，$(\frac{1}{Q}) = 1$</li>
<li>$(\frac{-1}{Q}) = (-1)^{\frac{Q-1}{2}}$</li>
<li>$(\frac{2}{Q}) = (-1)^{\frac{Q^2-1}{8}}$</li>
<li>$(\frac{P}{Q}) = (-1)^{\frac{(P-1)(Q-1)}{4}} (\frac{Q}{P})$，其中 $P,Q$ 都是正奇数。</li>
<li>写程序计算时可以避免做质因数分解！！！</li>
</ul>
<blockquote>
<p>注意到 Jacobi 符号只是为了简化 Legendre 符号的计算的！</p>
</blockquote>
<h2 id="计算例子"><a href="#计算例子" class="headerlink" title="计算例子"></a>计算例子</h2><p>判断二次同余式 $x^2 \equiv 888 \mod 1999$ 是否有解。</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\frac{888}{1999}) &= (\frac{4}{1999}) (\frac{2}{1999}) (\frac{111}{1999}) \\
&= (-1) ^{\frac{1999^2 -1}{8}}  (\frac{111}{1999}) \\
&= (-1)^{\frac{(1999-1)(111-1)}{4}} (\frac{1999}{111}) \\
&= -(\frac{1}{111}) = -1
\end{aligned}</script><blockquote>
<p>如果取模的数不是素数，那么就把它分解素因数，然后每个单独判断即可。</p>
</blockquote>
<h2 id="Jacobi-符号-Python-程序"><a href="#Jacobi-符号-Python-程序" class="headerlink" title="Jacobi 符号 Python 程序"></a>Jacobi 符号 Python 程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># a是整数，Q是正奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Jacobi</span><span class="params">(a,Q)</span>:</span></span><br><span class="line">	<span class="comment"># print(a,Q)  # 需要看过程就取消本行最前面的注释</span></span><br><span class="line">	a%=Q</span><br><span class="line">	<span class="keyword">if</span> math.gcd(a,Q) &gt; <span class="number">1</span>:  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> a%<span class="number">4</span>==<span class="number">0</span>: a//=<span class="number">4</span></span><br><span class="line">	f = <span class="keyword">lambda</span> n:<span class="number">1</span><span class="number">-2</span>*(n&amp;<span class="number">1</span>)</span><br><span class="line">	ans = <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> a%<span class="number">2</span>==<span class="number">0</span>: a//=<span class="number">2</span>;ans = f((Q**<span class="number">2</span><span class="number">-1</span>)//<span class="number">8</span>)</span><br><span class="line">	<span class="comment"># 此时a也是正奇数了</span></span><br><span class="line">	<span class="keyword">if</span> a == <span class="number">1</span>:  <span class="keyword">return</span> ans</span><br><span class="line">	<span class="keyword">return</span> ans*f((a<span class="number">-1</span>)*(Q<span class="number">-1</span>)//<span class="number">4</span>)*Jacobi(Q,a)</span><br><span class="line"></span><br><span class="line">print(Jacobi(<span class="number">888</span>,<span class="number">1999</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>自然数方幂和公式</title>
    <url>/formulaOfPowSumOfNaturalNumber/</url>
    <content><![CDATA[<p>关于自然数方幂和公式，网上的求解版本有很多种。这里介绍一种不为人知，十分简洁明了的求解方法，该公式并非原创，但是整个证明过程和方法完全原创。它的思想来源于我高中时在一本数学竞赛书中的数列例题(书名忘了…)，正因为一本本这样的书，让我大学选择了数学系，现在依然在学习数学。<br><a id="more"></a></p>
<h2 id="若-a-n-n-n-1-求其前-n-项和-S-n"><a href="#若-a-n-n-n-1-求其前-n-项和-S-n" class="headerlink" title="若 $a_n = n(n-1)$ 求其前 $n$ 项和 $S_n$"></a>若 $a_n = n(n-1)$ 求其前 $n$ 项和 $S_n$</h2><script type="math/tex; mode=display">
a_n = n(n-1) ＝ \frac{(n+1)n(n-1) -n(n-1)(n-2)}{3}</script><p>所以</p>
<script type="math/tex; mode=display">
S_n =\frac{(n+1)n(n-1)}{3}</script><blockquote>
<p>受到上面做法的启发，我们推广到一般形式：</p>
</blockquote>
<h2 id="若-a-n-A-n-p-，则其前-n-项和-S-n-＝-frac-A-n-1-p-1-p-1"><a href="#若-a-n-A-n-p-，则其前-n-项和-S-n-＝-frac-A-n-1-p-1-p-1" class="headerlink" title="若 $a_n = A_n ^p$，则其前 $n$ 项和 $S_n ＝ \frac{ A_{n+1} ^{p+1}}{p+1}$"></a>若 $a_n = A_n ^p$，则其前 $n$ 项和 $S_n ＝ \frac{ A_{n+1} ^{p+1}}{p+1}$</h2><script type="math/tex; mode=display">
a_n = A_n ^p ＝ \frac{A_{n+1} ^{p+1} -A_n ^{p+1}}{p+1}</script><p>所以</p>
<script type="math/tex; mode=display">
S_n = \frac{A_{n+1} ^{p+1}}{p+1}</script><p>由上面的结论，我们可以直奔主题了</p>
<h2 id="求-1-2-2-2-dots-n-2"><a href="#求-1-2-2-2-dots-n-2" class="headerlink" title="求 $1^2+2^2+ \dots + n^2$"></a>求 $1^2+2^2+ \dots + n^2$</h2><p>由</p>
<script type="math/tex; mode=display">
n^2 = n(n-1) + n</script><p>知</p>
<script type="math/tex; mode=display">
1^2+2^2+ \dots + n^2 = \frac{(n+1)n(n-1)}{3} + \frac{(n+1)n}{2} = \frac{n(n+1)(2n+1)}{6}</script><blockquote>
<p>同理我们可以推广上面做法</p>
</blockquote>
<h2 id="求-1-p-2-p-dots-n-p"><a href="#求-1-p-2-p-dots-n-p" class="headerlink" title="求$1^p+2^p+ \dots + n^p$"></a>求$1^p+2^p+ \dots + n^p$</h2><p>设</p>
<script type="math/tex; mode=display">
n^p = a_p A_n ^p + a_{p-1} A_n ^{p-1} + a_{p-2} A_n ^{p-2} + \cdots + a_1 A_n ^1</script><p>则</p>
<script type="math/tex; mode=display">
1^p+2^p+ \dots + n^p = \frac{a_p A_{n+1} ^{p+1}}{p+1} + \frac{a_{p-1} A_{n+1} ^{p}}{p} + \cdots + \frac{a_1 A_{n+1} ^2}{2}</script><p>因此问题的关键就转化成如何求解数组 $a_k ,k=1,2,\cdots,p$<br>我们发现当 $n＝k$ 时成立 </p>
<script type="math/tex; mode=display">
k^p = a_k A_k ^k + a_{k-1} A_k ^{k-1} + \cdots a_1 A_{k} ^1</script><p>令 $b_k = k! \cdot a_k$ 则</p>
<script type="math/tex; mode=display">
k^p = b_k + b_{k-1} C_k ^{k-1} + \cdots b_1 C_{k} ^1</script><p>即</p>
<script type="math/tex; mode=display">
k^p = \sum _{j=1} ^k b_j C _{k} ^j</script><p>应用二项式反演知（可参考：<a href="/inverseFormulaAndItsMatrixForm/" title="我的博文">我的博文</a>）</p>
<script type="math/tex; mode=display">
b_k = \sum _{j=1} ^k (-1)^{k-j} C _{k} ^j j^p</script><p>因此最终，我们有公式</p>
<script type="math/tex; mode=display">
1^p+2^p+ \dots + n^p = \sum _{k=1} ^p \; (\; \sum_{j=1} ^ {k} (-1)^{k-j} C_k^j j^p \;) \; C _{n+1} ^{k+1}</script><blockquote>
<p>妙呀，帅的呀，猛的呀，不谈了呀，哈哈哈</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>二项式反演公式及其应用</title>
    <url>/inverseFormulaAndItsMatrixForm/</url>
    <content><![CDATA[<p>在 <a href="/dirichletProduct/" title="上一篇博文">上一篇博文</a> 中，介绍过数论中的 Mobius 反演公式，让我想起了另一个经典的反演公式：<strong>二项式反演公式</strong>。本质上反演公式就是矩阵求逆的过程。</p>
<p>只是它的逆有很简单的形式，因此才有了二项式反演公式，这个公式帮助我们队伍在 2014 年 ACM－ICPC 亚洲区域赛西安站拿银，当时 <a href="2014xian.pdf">F 题</a>答案直接算需要 $O(n^3)$ 复杂度，而利用二项式反演公式后，可以在 $O(n^2)$ 复杂度内完美解决。1A 过题，感觉超爽。</p>
<blockquote>
<p>最后简单提一下：Mobius 反演公式及其矩阵形式</p>
</blockquote>
<a id="more"></a>
<h2 id="反演公式与其矩阵形式"><a href="#反演公式与其矩阵形式" class="headerlink" title="反演公式与其矩阵形式"></a>反演公式与其矩阵形式</h2><p>由</p>
<script type="math/tex; mode=display">
\sum_{r = 1} ^n a_{n,r} f(r) = g(n)</script><p>其中 $g(n)$ 已知，解出 $f(n)$</p>
<script type="math/tex; mode=display">
f(n) = \sum_{r = 1} ^n b_{n,r} g(r)</script><p>为其反演公式，也称上面两式互为反演公式。</p>
<p>令</p>
<script type="math/tex; mode=display">
A = \left( \begin{matrix} a_{11} & &  \\
a_{21} & a_{22} & \\
\cdots & \cdots & \ddots & \\
a_{n1} & a_{n2} & \cdots & a_{nn} \\
\end{matrix} \right) 
,\qquad 
B = \left( \begin{matrix} b_{11} & &  \\
b_{21} & b_{22} & \\
\cdots & \cdots & \ddots & \\
b_{n1} & b_{n2} & \cdots & b_{nn} \\
\end{matrix} \right)</script><p>则上述反演公式本质上就是求矩阵 $A$ 的逆 $B$.</p>
<h2 id="二项式反演公式"><a href="#二项式反演公式" class="headerlink" title="二项式反演公式"></a>二项式反演公式</h2><p>若</p>
<script type="math/tex; mode=display">
g(n) = \sum_{r = s} ^n {n \choose r} f(r)</script><p>其中 $s \geq 0$ 则</p>
<script type="math/tex; mode=display">
f(n) = \sum_{r = s} ^n (-1)^{n-r} {n \choose r} g(r)</script><p><strong>Proof</strong>:  要证明反演公式，只需证明，对应的矩阵 $A$ 和 $B$ 互为逆即可. 令 $C = A \star B$ 则</p>
<script type="math/tex; mode=display">
\begin{aligned}
c_{ij} = \sum_{k=1} ^n a_{ik} b_{kj} & = \sum_{k =j} ^ i {i \choose k} (-1)^{k-j}{k \choose j} = 
\sum_{k=0} ^ {i-j} {i \choose k + j} (-1)^k {k + j \choose j} \\
& = {i \choose j} \sum_{k=0} ^ {i-j} (-1)^k {i - j \choose k} = \left\{ \begin{array}{ll} 1,& i=j \\  0,& i>j \end{array} \right.
\end{aligned}</script><p>证毕。</p>
<h2 id="二项式反演写成卷积形式便于-NFT"><a href="#二项式反演写成卷积形式便于-NFT" class="headerlink" title="二项式反演写成卷积形式便于 NFT"></a>二项式反演写成卷积形式便于 NFT</h2><p>不妨取 $s = 0$</p>
<script type="math/tex; mode=display">
\frac{g(n)}{n!} = \sum_{i + j = n} \frac{f(i)}{i} \cdot \frac{1}{j!}</script><p>等价于</p>
<script type="math/tex; mode=display">
\frac{f(n)}{n!} = \sum_{i + j = n} ^n \frac{g(i)}{i!} \cdot \frac{(-1)^{j}}{j!}</script><blockquote>
<p>也就是说二项式反演公式本质上是说：$\frac{1}{n!}$ 和 $\frac{(-1)^n}{n!}$ 互为卷积逆。</p>
</blockquote>
<h2 id="二项式反演公式的应用"><a href="#二项式反演公式的应用" class="headerlink" title="二项式反演公式的应用"></a>二项式反演公式的应用</h2><p>二项式反演公式在组合数学和数论中都有诸多应用，这里简单的提两个。</p>
<h3 id="错排问题-在-n-个数字-1-2-dots-n-形成-n-个排列-a-1a-2-dots-a-n-中满足-a-i-neq-i-的排列有多少个"><a href="#错排问题-在-n-个数字-1-2-dots-n-形成-n-个排列-a-1a-2-dots-a-n-中满足-a-i-neq-i-的排列有多少个" class="headerlink" title="(错排问题) 在 $n$ 个数字 $1, 2, \dots, n$ 形成 $n!$ 个排列 $a_1a_2 \dots a_n$ 中满足 $a_i \neq i$ 的排列有多少个"></a>(错排问题) 在 $n$ 个数字 $1, 2, \dots, n$ 形成 $n!$ 个排列 $a_1a_2 \dots a_n$ 中满足 $a_i \neq i$ 的排列有多少个</h3><p>不妨设答案为 $D_n$ ,则可以看出恰好有 $r$ 个  $a_i=i$的排列数为 $\left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}$，因此</p>
<script type="math/tex; mode=display">
n! = \sum_{r = 0} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}</script><p>因此</p>
<script type="math/tex; mode=display">
D_n ＝ \sum_{r = 0} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r! = n! \sum_{r=0} ^n \frac{(-1)^r}{r!}</script><blockquote>
<p>当然 $D_n$ 还有递推关系式 $D_1=0,D_2 = 1$</p>
<script type="math/tex; mode=display">
D_n = (n-1) (D_{n-1} + D_{n-2}),\quad n \geq 2</script></blockquote>
<h3 id="满射个数-求-m-元集-A-到-n-元集-B-的满身的个数-g-m-n"><a href="#满射个数-求-m-元集-A-到-n-元集-B-的满身的个数-g-m-n" class="headerlink" title="(满射个数) 求 $m$ 元集 $A$ 到 $n$ 元集 $B$ 的满身的个数 $g(m,n)$"></a>(满射个数) 求 $m$ 元集 $A$ 到 $n$ 元集 $B$ 的满身的个数 $g(m,n)$</h3><p>类似于错排的思路，我们有</p>
<script type="math/tex; mode=display">
n^m = \sum_{r = 1} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) g(m,r)</script><p>于是</p>
<script type="math/tex; mode=display">
g(m,n) =  \sum_{r = 1} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r^m</script><h2 id="Mobius-反演公式及其矩阵形式"><a href="#Mobius-反演公式及其矩阵形式" class="headerlink" title="Mobius 反演公式及其矩阵形式"></a>Mobius 反演公式及其矩阵形式</h2><p>由 Mobius 反演公式对应的矩阵我们有,若</p>
<script type="math/tex; mode=display">
a_{ij} = \left\{ \begin{array}{cc} 1, & j \mid i \\
0, & else. \end{array} \right.</script><p>则，其逆矩阵为</p>
<script type="math/tex; mode=display">
b_{ij} = \left\{ \begin{array}{cc} \mu (\frac{i}{j}), & j \mid i \\
0, & else. \end{array} \right.</script><blockquote>
<p>本文参考了<a href="http://www.douban.com/note/480023639/?type=like" target="_blank" rel="noopener">豆瓣</a>和<a href="http://wenku.baidu.com/link?url=0m3D-588KfEUvocmKGoW5X4z5SHrEKVOaqfLoTeRtJaJcG6oDEUh2QEbJmNa1p2OTkqFLCqhfhM-RsoOI2fkutlqL9q3xgJhIAic4HumI5W" target="_blank" rel="noopener">百度文库</a>以及 许胤龙，孙淑玲《组合数学引论》。</p>
</blockquote>
<h2 id="单位根反演"><a href="#单位根反演" class="headerlink" title="单位根反演"></a>单位根反演</h2><p>DFT 的本质就是单位根反演</p>
<script type="math/tex; mode=display">
\forall k,[n \mid k] = \frac{1}{n} \sum_{i=0}^{n-1} \omega_n^{ik}</script><p>一个应用的例子</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^{[\frac{n}{k}]} [x^{ik}] f(x) 
&= \sum_{i=0}^n [k \mid i] [x^i] f(x)\\
&=\sum_{i=0}^n [x^i] f(x) \frac{1}{k} \sum_{j=0}^{k-1} \omega_{k}^{ji}\\
&=\frac{1}{k} \sum_{i=0}^n a_i \sum_{j=0}^{k-1} \omega_{k}^{ij}\\
&=\frac{1}{k} \sum_{j=0}^{k-1} \sum_{i=0}^n a_i(\omega_k^j)^i\\
&=\frac{1}{k} \sum_{j=0}^{k-1} f(\omega_{k}^j)
\end{aligned}</script><blockquote>
<p>单位根反演转自：<a href="https://www.cnblogs.com/cjyyb/p/10838495.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjyyb/p/10838495.html</a></p>
</blockquote>
<p>具体的例子求：$\sum_{i \in [0,n],k \mid i} \binom{n}{i} G^i$</p>
<p>计$f(x) = (G+x)^n$，则由上面公式</p>
<script type="math/tex; mode=display">
\sum_{i \in [0, n], k \mid i} \binom{n}{i} G^i = \frac{1}{k} \sum_{j=0}^{k-1} (G+\omega_{k}^j) ^n</script><p>即复杂度 $O(k \log n)$，如果要结果模一个 NFT friendly 的，那就更好了！</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>数论函数的 Dirichlet 积</title>
    <url>/dirichletProduct/</url>
    <content><![CDATA[<p>最近重温潘承洞老先生的《数论基础》(现代数学基础丛书 34)，确实是经典中的经典。以现代的眼光看数论函数，使得分析问题更加简洁本质，而这些都要归功于 Dirichlet 积的引入。</p>
<a id="more"></a>
<h2 id="常见数论函数"><a href="#常见数论函数" class="headerlink" title="常见数论函数"></a>常见数论函数</h2><p>为了更好的介绍 Dirichlet 积，先引入一些记号，数论函数是指定义于全体正整数集上的函数。</p>
<ol>
<li><p>$u(n) \equiv 1$</p>
</li>
<li><p>$e(n) = n$</p>
</li>
<li><p>$I(n) = \left\{\begin{array}{ll} 1, &amp; n=1, \\ 0, &amp; n&gt;1. \end{array} \right.$</p>
</li>
<li><p>$n$ 的所有正除数的个数 $d(n)$.</p>
<script type="math/tex; mode=display">
d(n)= \sum_{d|n} 1 = (a_1+1)(a_2+1) \cdots (a_n+1), \; n=p_1^{a_1} \cdots p_s^{a_s}</script></li>
<li><p>$n$ 的全部素因子的个数（按重数计）$\Omega(n)$</p>
<script type="math/tex; mode=display">
\begin{array}{ll} \Omega(1)=0 & \\
\Omega(n) = a_1 + a_2+ \cdots a_n, & n=p_1^{a_1} \cdots p_s^{a_s} \end{array}</script></li>
<li><p>$n$ 的不同素因子的个数 $\omega(n)$</p>
<script type="math/tex; mode=display">
\begin{array}{ll} \omega(1)=0 & \\
\omega(n) = s, & n=p_1^{a_1} \cdots p_s^{a_s} \end{array}</script></li>
<li><p>$n$ 的正除数的幂和函数 $\sigma_{\lambda}(n) = \sum_{d|n} d^{\lambda}$</p>
</li>
<li><p>所有不超过 $n$ 且和 $n$ 互素的正整数的个数 $\psi(n)$</p>
<script type="math/tex; mode=display">
\psi(n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } 1</script><p>$\psi(n)$ 称之为 Euler 函数。</p>
</li>
<li><p>Mobius 函数 $\mu(n)$</p>
<script type="math/tex; mode=display">
\mu(n) = \left\{\begin{array}{ll} 1, & n=1, \\ (-1)^s, & n=p_1p_2 \cdots p_s, \; p_1 < p_2< \cdots < p_s. \\
0, & else. \end{array} \right.</script></li>
<li><p>Mangoldt 函数 $\Lambda(n)$</p>
<script type="math/tex; mode=display">
\Lambda(n) = \left\{\begin{array}{ll} \log p, & n= p^k, k \geq 1\\
0, & else. \end{array} \right.</script></li>
<li><p>Liouville 函数 $\lambda(n) = (-1)^{\Omega(n)}$</p>
</li>
<li><p>Euler 函数的推广(自创 dna0.49) $\psi _{\lambda}(n)$</p>
<script type="math/tex; mode=display">
\psi _{\lambda} (n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } d^{\lambda}</script><p>当 $\lambda = 0$ 时即为 Euler 函数。</p>
</li>
<li><p>$M(n)=\sum_{i=1}^n \mu(i)$，则我们有 $\sum_{i=1} ^n M(\lfloor \frac{n}{i} \rfloor) = 1$</p>
</li>
<li><p>$N(n)=\sum_{i=1}^n \psi(i)$，我们有</p>
<script type="math/tex; mode=display">
\sum_{i=1} ^n N(\lfloor \frac{n}{i} \rfloor) = \frac{n(n+1)}{2}</script></li>
</ol>
<blockquote>
<p>上面 $M(n), N(n)$ 的计算公式见下面 <strong>广义 Dirichlet 积</strong> 以及 <a href="/algorithmsOfRootComplex/" title="这篇博文">这篇博文</a>。</p>
</blockquote>
<p>用下面的 Dirichlet 积的概念，大家就会对上面常见的数论函数有更深刻的认识。</p>
<h2 id="Dirichlet-积"><a href="#Dirichlet-积" class="headerlink" title="Dirichlet 积"></a>Dirichlet 积</h2><p>设$f(n)$,$g(n)$是两个数论函数，则</p>
<script type="math/tex; mode=display">
h(n) = \sum_{d|n} f(d)g(\frac{n}{d})</script><p>称为$f(n)$和$g(n)$的 Dirichlet 积,记作$h=f \star g$.</p>
<h3 id="定理-1-Dirichlet-积满足交换律和结合律即"><a href="#定理-1-Dirichlet-积满足交换律和结合律即" class="headerlink" title="定理 1 Dirichlet 积满足交换律和结合律即"></a>定理 1 Dirichlet 积满足交换律和结合律即</h3><ol>
<li>交换律： $f \star g = g \star f$</li>
<li>结合律： $(f\star g) \star h = f \star (g \star h)$</li>
</ol>
<h3 id="定理-2-Dirichlet-积的幺元存在为-I-n"><a href="#定理-2-Dirichlet-积的幺元存在为-I-n" class="headerlink" title="定理 2 Dirichlet 积的幺元存在为 $I(n)$"></a>定理 2 Dirichlet 积的幺元存在为 $I(n)$</h3><ul>
<li>由 <strong>定理 1</strong> 和 <strong>定理 2</strong> 知。数论函数全体关于 Dirichlet 积构成了一个含幺交换半群(Commutative Monoid)</li>
<li>由抽象代数的基本知识知道 Monoid 中的元如果存在逆元必然唯一，证明也是显然的</li>
<li>现在的问题就是这个 Monoid 那些元有逆元( Dirichlet 逆，以下简称逆)。或者说一个数论函数可逆的充要条件是什么。</li>
</ul>
<p>实际上，我们有如下结论</p>
<h3 id="定理-3-数论函数-f-可逆的充要条件是-f-1-neq-0-此时它的逆元为"><a href="#定理-3-数论函数-f-可逆的充要条件是-f-1-neq-0-此时它的逆元为" class="headerlink" title="定理 3 数论函数 $f$ 可逆的充要条件是 $f(1) \neq 0$.此时它的逆元为"></a>定理 3 数论函数 $f$ 可逆的充要条件是 $f(1) \neq 0$.此时它的逆元为</h3><script type="math/tex; mode=display">
f^{-1} (1) = \frac{1}{f(1)},\quad
f^{-1} (n) = \frac{-1}{f(1)} \sum _{d|n,\, d<n} f(\frac{n}{d})f^{-1}(d),\; n>1</script><p>证明是显然的，验算即知。</p>
<blockquote>
<p>至此从抽象的层次已经对数论函数的 Dirichlet 积有了一个清晰的认识，下面用这套语言考虑我们的常见函数</p>
</blockquote>
<h3 id="定理-4-Mobius-函数-mu-n-是-u-n-的逆，即"><a href="#定理-4-Mobius-函数-mu-n-是-u-n-的逆，即" class="headerlink" title="定理 4 Mobius 函数 $\mu(n)$ 是 $u(n)$ 的逆，即"></a>定理 4 Mobius 函数 $\mu(n)$ 是 $u(n)$ 的逆，即</h3><script type="math/tex; mode=display">
\sum_{ d|n } \mu(n) = \left\{ \begin{array}{ll}  1, & n=1, \\
0, & n>1. \end{array} \right.</script><p><strong>Proof</strong> : $n=1$ 时显然，不妨设 $n = p_1^{a_1} p_2^{a_2} \cdots p_s^{a_s} &gt; 0$ 则由 $\mu(n)$ 的定义</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\sum_{ d|n } \mu(n) & = \mu(1) + \mu(p_1) + \mu(p_2) + \cdots +\mu(p_s) + \cdots + \mu(p_1 p_2) + \cdots \\
& \quad + \mu(p_{s-1}p_s) + \cdots \mu(p_1 p_2 \cdots p_s) \\
& =  1 + {s \choose 1} (-1) + {s \choose 2} (-1)^2 + \cdots + {s \choose s} (-1)^s \\
&= (1-1)^s = 0 \end{array}</script><blockquote>
<p>由此可见，原来看上去复杂的不知所以然的 Mobius 函数本质上是恒为 1 的函数的 Dirichlet 逆元。</p>
</blockquote>
<h3 id="定义-5-若-F-f-star-u-则称-F-是-f-的-Mobius-变换，即"><a href="#定义-5-若-F-f-star-u-则称-F-是-f-的-Mobius-变换，即" class="headerlink" title="定义 5 若 $F=f \star u$ 则称 $F$ 是 $f$ 的 Mobius 变换，即"></a>定义 5 若 $F=f \star u$ 则称 $F$ 是 $f$ 的 Mobius 变换，即</h3><script type="math/tex; mode=display">
F(n) = \sum_{d|n} f(d)</script><p>显然此时我们有 $f=F * \mu$, 称 $f$ 是 $F$ 的 Mobius 反变换。<br>实际上，这就是我们常说的 Mobius 反演公式。</p>
<script type="math/tex; mode=display">
F(n) = \sum_{d|n} f(d) \Longleftrightarrow f(n) = \sum_{d|n} F(d) \mu(\frac{n}{d})</script><p>Mobius 变换的例子</p>
<ol>
<li>$I(n)$ 是 $\mu(n)$ 的 Mobius 变换</li>
<li>$d(n)$ 是 $u(n)$ 的 Mobius 变换</li>
<li>$e(n)$ 是 $\psi(n)$ 的 Mobius 变换</li>
<li>$\log n$ 是 $\Lambda(n)$ 的 Mobius 变换</li>
</ol>
<p>前两个由定义显然，后面两个证明如下。</p>
<script type="math/tex; mode=display">
n = \sum _{i=1} ^n 1 =
\sum _{d|n} \sum_{(n,i) = d} 1 =
\sum _{d|n} \sum_{(\frac{n}{d},k)=1} 1 =
\sum _{d|n} \psi(\frac{n}{d}) = \sum _{d|n} \psi(d)</script><p>因此</p>
<script type="math/tex; mode=display">
\psi(n) = \sum _{d|n} \mu(d) \frac{n}{d} = n \sum _{d|n} \frac{\mu(d)}{d}</script><p>另外我们还有一个证明方式</p>
<script type="math/tex; mode=display">
\psi(n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } 1 ＝ \sum_{1 \leq d \leq n} \sum_{l|(d,n)} \mu(l) = \sum _{l|n} \mu(l) \sum _{1 \leq d \leq n , l|d} 1 = \sum _{l|n} \mu(l) \frac{n}{l}</script><blockquote>
<p>上述两种证明都是两种常用处理数论函数的技术手段。</p>
</blockquote>
<p>至于 $\log n$ 是 $\Lambda(n)$ 的 Mobius 变换的证明只需验算即知。</p>
<p>用上面所说的技术，我们来考虑一下推广的 Euler 函数 $\psi _{\lambda}$</p>
<script type="math/tex; mode=display">
\sum _{i=1} ^n i^{\lambda} =
\sum _{d|n} \sum_{(n,i) = d} i^{\lambda}  =
\sum _{d|n} d^{\lambda} \sum_{(\frac{n}{d},k)=1} k^{\lambda}  =
\sum _{d|n} d^{\lambda} \psi _{\lambda} (\frac{n}{d}) =
n^{\lambda} * \psi _{\lambda}</script><h3 id="可乘函数"><a href="#可乘函数" class="headerlink" title="可乘函数"></a>可乘函数</h3><p>寻找不变量一直是数学关心的问题，变化中的不变量，可以大大简化运算，并且反过来刻画了变化。具体说，寻找 Dirichlet 积不变量一方面对于那些不变量，可以简化它们操作，另一方面，由于 Dirichlet 积保持这些性质也就刻画了 Dirichlet 本身。其中这样的一个不变量就是可乘函数。</p>
<p>设 $f(n)$ 是定义在全体自然数上不恒为 0 的数论函数，若它满足条件</p>
<script type="math/tex; mode=display">
f(mn) = f(m) f(n), \quad (m,n)=1</script><p>则称之为可乘函数。若对任意正整数 $m,n$ 恒有</p>
<script type="math/tex; mode=display">
f(mn) = f(m) f(n)</script><p>则称之为完全可乘函数。</p>
<p>可乘函数例子： $\mu(n)$, $d(n)$.<br>完全可乘函数例子： $n^{\lambda}$, $I(n)$.</p>
<blockquote>
<p>显然(完全)可乘函数的的积，倒数(如果有意义的话)都是(完全)可乘函数。</p>
</blockquote>
<h3 id="定理-6-可乘函数-f-n-有如下性质"><a href="#定理-6-可乘函数-f-n-有如下性质" class="headerlink" title="定理 6 可乘函数 $f(n)$ 有如下性质"></a>定理 6 可乘函数 $f(n)$ 有如下性质</h3><ol>
<li>$f(1)=1$</li>
<li>$f(n)=f(p_1^{a_1}) f(p_2)^{a_2} \cdots f(p_s)^{a_s}, \quad n = p_1^{a_1} p_2^{a_2} \cdots p_s^{a_s}$</li>
<li>$f(n)$ 为完全可乘的充要条件是对任意的 $p$ 和 $k \geq 1$ 恒有<script type="math/tex; mode=display">f(p^k) = f ^k (p)</script></li>
<li>$f((m,n)[m,n])=f(m)f(n)$</li>
<li>$f$的逆元必然存在</li>
<li>$f$的 Mobius 变换也可逆</li>
</ol>
<blockquote>
<p>上述定理的证明是显然的，结论是重要的。</p>
</blockquote>
<h3 id="定理七-Dirchlet-积-保持可乘性"><a href="#定理七-Dirchlet-积-保持可乘性" class="headerlink" title="定理七 Dirchlet 积 保持可乘性"></a>定理七 Dirchlet 积 保持可乘性</h3><ol>
<li>若 $f$ 可乘, $g$ 可乘, 则 $h=f \star g$ 可乘;</li>
<li>若 $g$ 可乘, $h=f \star g$ 可乘，则 $f$ 可乘.</li>
</ol>
<p><strong>Proof</strong>:</p>
<ol>
<li>若 $f$ 可乘, $g$ 可乘, 则对任意满足 $(m,n)=1$ 的正整数 $m,n$,对于 $mn$ 的每一个正因子 $d$ 可以分解为 $d=d_1 d_2$ 的形式, 其中 $(d_1,d_2)=1, d_1|m, d_2|n$</li>
</ol>
<script type="math/tex; mode=display">
  h(mn) = \sum _{d|mn} f(d)g(\frac{mn}{d}) = \sum _{d_1|m} f(d_1)g(\frac{m}{d_1}) \sum _{d_2|n} f(d_2)g(\frac{n}{d_2}) = h(m)h(n)</script><ol>
<li>反证，若 $f$ 不可乘，则可以推出$h$不可乘即可。若 $f$ 不可乘,则必存在 $m,n$,$(m,n)=1$ 但是</li>
</ol>
<script type="math/tex; mode=display">
  f(mn) \neq f(m)f(n)</script><p>若 $mn=1$ , 则 $f(1) \neq f(1) f(1)$ 知 $f(1) \neq 1$. 因此 $h(1)=f(1)g(1)=f(1) \neq 1$ 矛盾于 $h$ 可乘。<br>我们选取满足上述性质的最小正整数 $mn$,即当 $d_1d_2&lt;mn$ 是恒有</p>
<script type="math/tex; mode=display">
f(d_1d_2) = f(d_1)f(d_2),\quad (d_1,d_2)=1</script><p>由 $h$ 的定义</p>
<script type="math/tex; mode=display">
\begin{array}{cl}
h(mn) = \sum_{d \mid mn} f(d) g(\frac{mn}{d}) &=
\sum_{d_1 \mid m} f(d_1) g(\frac{m}{d_1}) \sum_{d_2|m} f(d_2)g(\frac{n}{d_2}) - f(m)f(n) + f(mn) \\
&= h(m)h(n) - f(m)f(n) + f(mn) \neq h(m)h(n)
\end{array}</script><p>证毕。</p>
<blockquote>
<p>Dirichlet 积一般不保持完全可乘性。</p>
</blockquote>
<p>由 <strong>定理 6</strong> 和 <strong>定理 7</strong>，我们有如下推论: 若 $F$ 是 $f$ 的 Mobius 变换，则</p>
<ol>
<li><p>$f$ 可乘 $\Longleftrightarrow$ $F$ 可乘</p>
</li>
<li><p>$f$ 可乘，则</p>
</li>
</ol>
<script type="math/tex; mode=display">
F(n) = \sum_{d|n} f(d) =
    \prod _{p^a || n} (1+ f(p)+\cdots f(p^a))</script><ol>
<li>$f$ 可乘，则</li>
</ol>
<script type="math/tex; mode=display">
\sum _{d|n} \mu(d) f(d) = \prod _{p | n} (1 - f(p))</script><blockquote>
<p>上面 1 是定理 7.1 的直接推论，2 可由定理 6.2 的直接推论，3 是 2 的直接推论。由 3 我们可以得到著名的欧拉公式：</p>
</blockquote>
<script type="math/tex; mode=display">
\psi(n) = n \sum _{d|n} \frac{\mu(d)}{d} ＝ n \prod _{p|n} (1-\frac{1}{p})</script><h3 id="完全可乘的逆"><a href="#完全可乘的逆" class="headerlink" title="完全可乘的逆"></a>完全可乘的逆</h3><p>由于可乘函数满足 $f(1)=1$ 因此可乘函数的逆相对而言更加简单，并且它的逆也是可乘函数。但是计算逆的过程仍然很复杂，但是完全可乘函数的逆却特别简单。</p>
<h3 id="定理-8-设-f-可乘，则-f-完全可乘的充要条件是"><a href="#定理-8-设-f-可乘，则-f-完全可乘的充要条件是" class="headerlink" title="定理 8 设 $f$ 可乘，则 $f$ 完全可乘的充要条件是"></a>定理 8 设 $f$ 可乘，则 $f$ 完全可乘的充要条件是</h3><script type="math/tex; mode=display">
f^{-1}(n) = \mu(n)f(n)</script><h3 id="推广的-Mobius-反演公式"><a href="#推广的-Mobius-反演公式" class="headerlink" title="推广的 Mobius 反演公式"></a>推广的 Mobius 反演公式</h3><p>设 $g$ 完全可乘, $h= f \star g$ ,则 $f= h \star \mu g$，即</p>
<script type="math/tex; mode=display">
h(n) = \sum _{d|n} f(d)g(\frac{n}{d})
\quad \Longleftrightarrow \quad f(n) = \sum _{d|n} h(d)
\mu(\frac{n}{d})g(\frac{n}{d})</script><p>另上式中 $g=u$，上式就变成了 Mobius 反演公式。<br>由推广的 Mobius 反演公式，我们由</p>
<script type="math/tex; mode=display">
\sum _{i=1} ^n i^{\lambda} = n^{\lambda} \star \psi _{\lambda}</script><p>可知</p>
<script type="math/tex; mode=display">
\psi_{\lambda}(n) = (\sum _{i=1} ^n i^{\lambda}) \star \mu(n) n^{\lambda}</script><h2 id="广义-Dirichlet-积"><a href="#广义-Dirichlet-积" class="headerlink" title="广义 Dirichlet 积"></a>广义 Dirichlet 积</h2><p>考虑和式</p>
<script type="math/tex; mode=display">
G(x) = \sum_{n \leq x} f(n)H(\frac{x}{n})</script><p>其中 $f(n)$ 是数论函数，$H(x)$ 是 $(0,\infty)$上的函数。<br>我们记 $G = f o H$。特别的若$H(x)$在所有非整数点取值为$0$，则此时就是通常的 Dirichlet 积。<br>我们有以下性质：</p>
<script type="math/tex; mode=display">
f o (g o H) = (f*g) o H</script><p>若 $G = f o H$ 则 $H = f^{-1} o G$。<br>特别的，若 $G(x) = \sum_{n \leq x} H(\frac{x}{n})$, 则我们有</p>
<script type="math/tex; mode=display">
H(x) = \sum_{n \leq x} \mu(n) G(\frac{x}{n})</script><h4 id="一个技巧相当强大的公式-Q-x-sum-n-leq-x-mu-n-，显然表示不超过-x-的无平方因子的正整数个数，则"><a href="#一个技巧相当强大的公式-Q-x-sum-n-leq-x-mu-n-，显然表示不超过-x-的无平方因子的正整数个数，则" class="headerlink" title="一个技巧相当强大的公式 $Q(x)=\sum_{n \leq x} |\mu(n)|$，显然表示不超过 $x$ 的无平方因子的正整数个数，则"></a>一个技巧相当强大的公式 $Q(x)=\sum_{n \leq x} |\mu(n)|$，显然表示不超过 $x$ 的无平方因子的正整数个数，则</h4><script type="math/tex; mode=display">
Q(x) = \frac{6}{\pi^2} x + O(\sqrt{x})</script><p><strong>Proof</strong> ：显然我们有</p>
<script type="math/tex; mode=display">
\lfloor x \rfloor = \sum_{k \leq \sqrt{x}} Q(\frac{x}{k^2})</script><p>另一方面</p>
<script type="math/tex; mode=display">
Q(x) = \sum_{n \leq \sqrt{x}} Q(\frac{x}{n^2}) \sum_{d \mid n} \mu(d) =  \sum_{d \leq \sqrt{x}} \mu(d) \sum_{ k \leq \sqrt{\frac{x}{d^2}} } Q(\frac{x}{d^2k^2})</script><p>所以</p>
<script type="math/tex; mode=display">
\sum_{n \leq x} |\mu(n)| =  Q(x) =  \sum_{d \leq \sqrt{x}} \mu(d) \lfloor \frac{x}{d^2} \rfloor</script><p>根据上式</p>
<script type="math/tex; mode=display">
Q(x) = x \sum_{d=1}^{\infty} \frac{\mu(d)}{d^2} +O(\sqrt{x}) = \frac{6}{\pi^2} x + O(\sqrt{x})</script><h2 id="三个优美公式"><a href="#三个优美公式" class="headerlink" title="三个优美公式"></a>三个优美公式</h2><p>最后我用三个我很喜欢的公式结束这篇博文。</p>
<ol>
<li>$\sum_{n \leq x} d(n) = \sum_{n \leq x} \lfloor \frac{x}{n} \rfloor$</li>
</ol>
<script type="math/tex; mode=display">
\sum_{n \leq x} \lfloor \frac{x}{n} \rfloor =
\sum_{n \leq x} \sum_{l \leq x,\; n|l} 1 =
\sum_{l \leq x} \sum_{n|l} 1 =
\sum_{l \leq x} d(l) =
\sum_{n \leq x} d(n)</script><ol>
<li>$\sum _{n \leq x} \mu(n) \lfloor \frac{x}{n} \rfloor = 1$</li>
</ol>
<script type="math/tex; mode=display">
\sum _{n \leq x} \mu(n) \lfloor \frac{x}{n} \rfloor =
\sum _{n \leq x} \mu(n) \sum _{l \leq x,\; n|l} 1 =
\sum _{l \leq x} \sum _{n|l} \mu(n) = \sum _{l \leq x} I(n) = 1</script><ol>
<li>$\sum _{n=1} ^{\infty} \frac{\mu(n)}{n^2} = \frac{6}{\pi^2} $</li>
</ol>
<p><strong>Proof</strong>:</p>
<script type="math/tex; mode=display">
\sum _{n=1} ^{\infty} \frac{1}{n^2} \sum_{n=1} ^{\infty} \frac{\mu(n)}{n^2} = \sum_{n=1} ^{\infty} \frac{a_n}{n^2}</script><p>其中 $a_n = \sum _{d|n} \mu(d) = I(n)$，又由 $\sum _{n=1} ^{\infty} \frac{1}{n^2} = \frac{\pi^2}{6}$ 结论显然。</p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex 编辑的一些文档</title>
    <url>/workWithLatex/</url>
    <content><![CDATA[<blockquote>
<p>很久之前写的，舍不得删，保持原貌吧</p>
</blockquote>
<p>This blog makes a record of my math work and will be update frequently.Click to view or download it.</p>
<a id="more"></a>
<h4 id="Here-are-PDF-version-of-my-math-work"><a href="#Here-are-PDF-version-of-my-math-work" class="headerlink" title="Here are PDF version of my math work"></a>Here are PDF version of my math work</h4><p><a href="1.pdf">Config of ACM-ICPC</a></p>
<p><a href="2.pdf">Some results about matrix</a></p>
<p><a href="3.pdf">Decomposition of 1 by 1/n</a></p>
<p><a href="4.pdf">Nowhere dense set and frist category set</a></p>
<p><a href="5.pdf">Relationship between Spectral Radius ,Numerical Radius and Spectral norm</a></p>
<p><a href="6.pdf">Some results about group</a></p>
<p><a href="7.pdf">The inverse of I-ba and I-ab</a></p>
<p><a href="8.pdf">example of function that only derivable on one point</a></p>
<p><a href="0.pdf">undergraduate graduation paper</a></p>
<h4 id="Here-are-Tex-version-of-my-math-work"><a href="#Here-are-Tex-version-of-my-math-work" class="headerlink" title="Here are Tex version of my math work"></a>Here are Tex version of my math work</h4><p><a href="1.tex">Config of ACM-ICPC.tex</a></p>
<p><a href="2.tex">Some results about matrix.tex</a></p>
<p><a href="3.tex">Decomposition of 1 by 1/n.tex</a></p>
<p><a href="4.tex">Nowhere dense set and frist category set.tex</a></p>
<p><a href="5.tex">Relationship between Spectral Radius ,Numerical Radius and Spectral norm.tex</a></p>
<p><a href="6.tex">Some results about group.tex</a></p>
<p><a href="7.tex">The inverse of I-ba and I-ab.tex</a></p>
<p><a href="8.tex">example of function that only derivable on one point.tex</a></p>
<h3 id="LaTex-is-a-wonderful-tool-for-Mathematics"><a href="#LaTex-is-a-wonderful-tool-for-Mathematics" class="headerlink" title="LaTex is a wonderful tool for Mathematics"></a>LaTex is a wonderful tool for Mathematics</h3>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>根号复杂度的算法</title>
    <url>/algorithmsOfRootComplex/</url>
    <content><![CDATA[<p>ACMer 考虑算法时总会优先考虑时间复杂度，这里介绍几个优美的根号复杂度的算法</p>
<a id="more"></a>
<h2 id="s-n-sum-i-1-n-lfloor-frac-n-i-rfloor"><a href="#s-n-sum-i-1-n-lfloor-frac-n-i-rfloor" class="headerlink" title="$s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor$"></a>$s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor$</h2><p>由于 $\lfloor \frac{n}{i} \rfloor$ 的取值个数不会超过 $2\sqrt{n}$，所以可能存在 $O(\sqrt{n})$ 的算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(LL n)</span></span>&#123; <span class="comment">// The code is simple and easy to understand</span></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123; </span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        sum += (j-i+<span class="number">1</span>)*(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上， $s(n)$ 表示图像 $xy=1$ 下方正整点的个数</p>
</blockquote>
<h2 id="sigma-k-n-sum-d-n-d-k"><a href="#sigma-k-n-sum-d-n-d-k" class="headerlink" title="$\sigma_k(n) = \sum_{d|n} d^k$"></a>$\sigma_k(n) = \sum_{d|n} d^k$</h2><ol>
<li>$\sigma_0(n)$ 表示正因子个数</li>
<li>$\sigma_1(n)$ 表示正因子之和</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mypow</span><span class="params">(LL x,LL n)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=x*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getr</span><span class="params">(LL n,LL k)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">0</span>,d;</span><br><span class="line">    <span class="keyword">for</span>(d=<span class="number">1</span>;d*d&lt;n;++d)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%d==<span class="number">0</span>)  r += mypow(d,k) + mypow(n/d,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d*d == n) r+=mypow(d,k);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="f-k-n-sum-i-1-n-sigma-k-i"><a href="#f-k-n-sum-i-1-n-sigma-k-i" class="headerlink" title="$f_k(n) = \sum_{i=1}^n \sigma_k(i)$"></a>$f_k(n) = \sum_{i=1}^n \sigma_k(i)$</h2><script type="math/tex; mode=display">
f_k(n) = \sum_{i=1}^n \sigma_k(n) =
\sum_{i=1}^n \sum_{d|i} d^k = 
\sum_{d=1} d^k \sum_i ^n[d|i] =
\sum_{d=1} ^n d^k \lfloor \frac{n}{d} \rfloor</script><p>如果我们已经得到 $ts[n] = \sum_{i=1}^n i^k$ 类似问题一，我们有以下 C++ 代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getf</span><span class="params">(LL n)</span></span>&#123;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123; </span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        sum += (ts[j]-ts[i<span class="number">-1</span>])*(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上我们有：</p>
<script type="math/tex; mode=display">
ts[n] = \left \lbrace 
\begin{array}{ll}
\frac{n(n+1)}{2} & k=1 \\
\frac{n(n+1)(2n+1)}{6} & k=2 \\
\frac{n^2(n+1)^2}{4} & k=3 \\ 
\end{array} \right.</script><p>更一般的我们有</p>
<script type="math/tex; mode=display">
1^p+2^p+ \dots + n^p = \sum _{k=1} ^p \; (\; \sum_{j=1} ^ {k} (-1)^{k-j} C_k^j j^p \;) \; C _{n+1} ^{k+1}</script><a href="/formulaOfPowSumOfNaturalNumber/" title="参考我的这篇博文">参考我的这篇博文</a>
<h2 id="g-n-sum-i-1-n-psi-i"><a href="#g-n-sum-i-1-n-psi-i" class="headerlink" title="$g(n) = \sum_{i=1}^n\psi(i)$"></a>$g(n) = \sum_{i=1}^n\psi(i)$</h2><p>这里 $\psi(n)$  是欧拉函数表示小于 $n$ 且和 $n$ 互素的数的个数。<br>Euler’s 乘积公式: </p>
<script type="math/tex; mode=display">
\psi(n) = n \prod _{p|n}( 1-\frac{1}{p} )</script><p>我们现在开始计算 $g(n)$</p>
<script type="math/tex; mode=display">
g(n) = \sum_{i=1}^n \psi(i) = \sum_{1 \leq x \leq y \leq n , \gcd(x,y)=1} 1</script><p>我们定义</p>
<script type="math/tex; mode=display">
g_k(n) = \sum_{i=1}^n \psi(i) = \sum_{1 \leq x \leq y \leq n , \gcd(x,y)=k} 1 = f_0(\lfloor \frac{n}{k} \rfloor)</script><p>并且 $\sum_{i=1}^n g_k(i) = \sum_{1 \leq x \leq y \leq n} 1 = \frac{n(n+1)}{2}$ ，于是我们知道</p>
<script type="math/tex; mode=display">
g(n) = \frac{n(n+1)}{2} - \sum_{k=2}^n f_0(\lfloor \frac{n}{k} \rfloor)</script><blockquote>
<p>其实这个算法复杂了，$g(n) = \sum_{i=1}^n \psi(i)= \frac{n \psi(n)}{2}$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000006</span>;</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">-1</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;ans[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;N&amp;&amp;ans[n]!=<span class="number">-1</span>) <span class="keyword">return</span> ans[n];</span><br><span class="line">    LL r = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        r -= (j-i+<span class="number">1</span>)*getans(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;N) ans[n]=r;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-hdu5608"><a href="#Problem-hdu5608" class="headerlink" title="Problem hdu5608"></a>Problem hdu5608</h2><p>已知 $n^2 -3n+2 = \sum_{d|n} f(d)$ 计算 $h(n) = \sum_{i=1}^n f(i) \mod 10^9+7$</p>
<p>由于</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{d|i} f(d) = \sum_{i=1}^n f(i) \lfloor \frac{n}{i} \rfloor =  \sum_{i=1}^n h(\lfloor \frac{n}{i} \rfloor)</script><p>我们知道</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{d|i} f(d) = \sum_{i=1}^n i^2-3i+2 = \sum_{i=1}^n (i-1)(i-2) = \frac{n(n-1)(n-2)}{3}</script><p>所以</p>
<script type="math/tex; mode=display">
h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m+1,r,rrt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000006</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv3 = (M+<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        ans[i] = LL(i<span class="number">-1</span>)*(i<span class="number">-2</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;  <span class="comment">// Pretreatment acceleration</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i&lt;&lt;<span class="number">1</span>;j&lt;N;j+=i)&#123;</span><br><span class="line">            ans[j] -= ans[i];</span><br><span class="line">            <span class="keyword">if</span>(ans[j] &lt; <span class="number">0</span>) ans[j] += M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        ans[i] += ans[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(ans[i] &gt; M)  ans[i] -= M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(n&lt;N) <span class="keyword">return</span> ans[n];</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(n); <span class="comment">//Memory search</span></span><br><span class="line">    <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>())  <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">int</span> r = LL(n)*(n<span class="number">-1</span>)%M*(n<span class="number">-2</span>)%M*inv3%M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        r -= LL(j-i+<span class="number">1</span>)*getans(n/i)%M;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) r+=M;</span><br><span class="line">    &#125;</span><br><span class="line">    mp.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(n,r));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;getans(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>感谢 <a href="http://zimpha.github.io" target="_blank" rel="noopener">Zimpha</a> 提出上述算法</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 年厦门马拉松</title>
    <url>/xiamenMarathon2016/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">日常表白 zly</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="ed129bf858d5e1657069cf592a7eababd7136305adabde97956142894a3144f9">a4417ccd9839412bfc6235b630b90e51e61d31baac8e539a84c553ae86cbb1014c7f7cd9443aff65abe0deebb457ef7a72353ba3afe7d0f0371e485008f5ca52125e77246bd9d0db08d5f9d4689483841e1d4df1ffd65fbb638504aa0806490c3e47cd36b9bfedd2da3874366f46b452bdc06d0319d3ae5497d5d74e4f9cbdae197e07b54bb48f181bfc6996143f136069c8552b645873a4329e3d65a9d0ef26a3f2500728a9156b9f3cb1ae382cfc2cc2a3598ef54c9fc070f5332ab28d5d1cdff8c6776e9265be2cbdc04923f61ae028242952adadb685d003a63533ebdb9e251e46686e1a640c278f6d5f168f6869ed6e793c189d8678c4717a0d1c958d64ab772982496d72d3125877cdb9e3a6d68c2a9292fb6bb2f9fa1428c0951eb4332994d9d8c08f32189fc501734f4d862ffd8ddeb77a516279d2298b31237ca93c93014884baa729018515760cdcfe262d82753d18558ada126f56849d0cc6565a8b8f97f8e33b3153d411e35a2d977752abf2f04c5a1a4085c9ecc00928a8b4582123fdb35ba1c3d325041ad6fbaa30bf33d37cc99754bcd0d8b80a8d8d58b9552e404d50944ff3ab8fe6c8079cc34d9d9af3dfa61b04c935d496080add1971dc8abe652588b7fc8b8c8343f8af7103df2865be28cb5ce40ffd2fcd613e101b0fc64e43b09d79434340d97aedfd56a547052a60312581d5af4c8b1f215f37c5bf0a63edc974353638234e230180ea9d27f5c8c033100c8eee83adba05f24dc9f8349e725656725834685767afcbc5a5c279c24c2e41f07d58ed550ba9666b4f96044cddf2ee59bc5196b91a9e0bfbd3e4ec12ad10e3572a4f2fda35670961ac3a5f777fd8cd3059fa94d2eb8cfd78a3e7263862bf2190eaa927e64e526afe0c1c5c12884c95d5fcf4b91e1d81e2f6a0dc6129db7bd6fc60fa9d5b883c0a58d9280a30367f8d8018d77be616c2542c67b7389a64973d3f713b2fa87d3cfb2e285f9145796c5f14b6449e9464913461b680da525a1247aa40a6ecfb0e222f2d30834ce5c7a63b40bdca83efb6dd9d8c561a4cd05dab443aafc2299d6718162ac637ac8354631da2ced5f2202153f21e96f7f75e15de40ee4d99a07195d1071db0bb6c887fcb152aec16546ce9dd6d1a3fc0a0473be86a114c9231b725532c418b73d9820c62b1e8882c6d49cc3662a39dabbcca1df61c12ac87269546d6c5cb8f38791c55454377bc37e1012eb749a2799271c4de44e001694516156b27bbca685b041ac6544bde34f3ae74ba9d50c7e907662769d7cf5c799a83e48b5d1536234bb5332e8c29387c449af81e88eb450a3049434ba3df50f9f4f7216525968732452ace0e923c8aa074b5702a123426d858cc8154103bbdd92b4883ca2e12663d56002be5be50f529edb5e2f74eaa45b46dd5df30ba35ebc01012bf3093543d80284e98a80a51cc8520167ce485d478dd3c8e09c723b13ff54383f6a5421ea97b55dfa5e176677694669316f107cbef2cb4f6ebb6d4f44c286f006ce13207e85729ea543fa7ecf85802e35c4307dcaed3cfb8fea24f5e4eeb6ba841f2707ca46210ad032e79f7dc882e2c7fc6ee9fb70e6c7f5328d4b54808651e96ab23aeaa26b7bd08b0f9f42752ea3a4324bb4904c803edf3023efed9f69895c0e67900c6666733210d0ff22f2edbd8ec885f128e26deb59b02d39e48effbe2128189aea77f4c44d06948a7f5775c0a652f1f1a4e5c4b5df78d2e5074dc9f0298cab06854e30ddfbda842487952ae737dbc9db7bec72d04596e91abfaa6af16403cbdcac3b5a6e3739f4ea9769489691ec55ed08f6637c80ea57655cc2cac0d229e6624a2d5846948188e514c8e6291c952de279de4aaa561fd3b66623742a66fd842ebb01bb319e9ea8a8a090b899a835f33df11cff36e1d325131cea14af056f677da89e22ed3732d7fdf9b324f79fc5610a0c3fad3a635a37d1ec4277da2f3ff9a05ee4562836aaaa7faee52d132eb919fbc9f8ce68cbfb2b8fcf78a65f2900668ddbacde127f16afe4869252a1a617ecfb9795b6b2331eae18a97152f0fab235dcf10d6a2687a7c31847b49eda081b368290329bafb9a219fa788b65c8b825ca40647a2e4f5351e083127f578bc4e815d1684adecae6b97b8ed74bd37ff80903f5423a49d4a67f43d8ab98bfa4a9e7f3d408ea858b2fc453cf11dd0d52ffc9d65a64c264547245cbf26e988573b30599571cd0d6a09c09baf91fa64cea4cbbf72c6502680935fd164f15c72ed27653335afdd45f470fec3e9ecda63ef54077d83cfa76b2e4b32bc8e642ced2edb77dfe2dfbc55440376b37ad6f99af21dc79641ce0029e5fc179700a24828ab87ab0ef0a075da9a24a6c94f6e32d18d8efbf7687f5076b1aa97ff65e838ca8fa464cb4b6a0edb0c76a7a0dfc154358749485091bae542fd2589f81e384f7e04097f741b3f5e1950002531a8849f5508fe403db1b99c6d218bfed5a0cbea661d15ef1cc970c6ead786e374758311b2955d4fed7a7b057953494f9b1f1cbb0d0cfc1151d15a5d2a3e8079634d8a517aedd88ee5d761bf18e6bf65b24bfc36fe8559c2346b102431cc38f44e8f86c00ed3c8dc1f7a39b61864b87e94da89ee4ab7c08c46bbd7bd12b7b51ff13fa0ae1df8cab3dceb823107a2673a95b238793d548e0fa3f9134ed8032e2202981ea541a67dcc1baa9d386f98b2500e83f35feb74a5897ab04a8fb1210fe269bc7b7e2b44d50af37bb78715903d5e4600763f18d8070c0c2254705d6b91af955012139b7fd5f3f61d1b9839509070143c1866afc082457e9d45979347abd854eee105d4543d775b5bf913280ccc77604913f6c7e384d00cca804cbf7b5b31114d129fbe13431bc549f981c605cbfe638e6a129975fcbcff5ede60c3f53e6cefa5afd8878bb5360120e015cd99df039bd9903e90d90cf773dfd85a7b8f66fc96ab14dcef40a740fc80a47eb715eef331869aaec80e3e377266bd49ca10e25f641f683b877b53ab159f634432a24aebdcfe1316ce207929aaff83a589b453925fc8f1d48d3900d3f6ae8abdc492c9f7fb058a245f0636971b7bb7124759d2afcad48dc0596f79cc1a3bb9eb7a7344b9eab29a5b59cb9d7db14504396db1e65863b895949865e03a362c738d24c72cc76c46adf889907fef0a169d0fb8e1fa046f109b97e24810cffc8e7a65e87795ca137135777ba8131abd089a6b66358576fe6862d3b5a866f516ad36695cc2fb7fca129131db6d7406f1d76a2ba90bea14ad4f1425a55b756460df1e0b328bd9814f7c65380edfce53128e70562693ac060e37d59e4d0fb106e3245fefa076c4f822acbf4b1e60939b4727de5af6cb243c55942628780a425616a2c84aea948996e2de8fdf0fdbd1c7c4453a1a5f997ba92d33b4429e35e03fa562da1bf935f68cb1ee542935b2446202bcbb3efcd2d0c125ccfc5dcca5d26f958c3ef0d075698e8a531c29f812d009fe9094a2ee8c91a6f38fdd2e3012579a2429e97b22f13d3be4947462133065eaef31ab3b4e2fa60795121bf9a4fcf1388fbafd47ead0c655cdddb3ffebcd7dd4ad03cd0fea25bf455c2561bdea83ae23fa48e51cbe08999b8738411ddeb192cfb125d517605f864a56caa99d46612cbe69a9c5f9872d96eae1586b7fc7d41a56212dc063a93c60a6f264bff99c714562505625508591675cebc9713d1c22e8498ec3dde55968ff8937ebfadf72eeccdb84afe282c1301ce3d8b1923ad52b8886c38d9580571efc99d03506a120311f9177bfc9f0c5837dee1bbb44b184d0ff534984dfb907b1d798aebb6dcba97b64e4a69a2c0544fe44899afec198ae8ad58df739952f76f40102ad468394112863914b8304ee2c967f98d60b1b7392e3e4fb767b2317a0809028ca8d31665d09aefe66de1ec32a58f7afadc301c20c8e31715162313a3b4e3569e14bfa076c996735a20171fb045a835c0e7f6c5733bc05169ce74b5d67b6e9d4acf2a7978d17b91136e2720724e5fbd047006d68297a59919b9dbd291ff089e34dbde924542d4efa5e8c0f88d9956d9622084adbfbd88e54940fe1c44ead8a127b2952d1f01e465dd256ede6d15a22c63225b8007f156284aead33869ea39ee87b9ace594116c7bb3351df0c9a18d0f563317357f958e46b2005fd8bcf84c43af10f85970131c4bf28decae809fbd394bd961eb149aa5d6ea5d97bccf789ddf50ed2014ed507834f13ce44a0af032b516b3185950c4d83bafee18f2fdcca5bf43e4917cbfbcf0cb77256bc1606494977f6333ce36ea70f89dfb2020038326e3cd15a435655822082afdfc2ea67888c0214342cefce01290fc2b552940a93c99e5ea2e3ca209277f93328b4cb08767a0943b9effa77e4054d2fb5790917cfe460ae5bd1201508dda15b45ae7b53786c7f4308d872654552406b23273af72951120dc6a760671c5df8e060bd8167616c0111bb977618e65863a2bb29e03ea8848b3f800daca9ad29403c71934f295c63c18ba14d540d638bf380739822017b16b8f3e9f10d4d49b4ed9a9aeb4135770792ee1642e6d1011597904ecaad879957c3f14bfc156dc9bcb2f16c7d77de28e5629b94eb75835998968ea5decb32fa5be5ba08d3545351c7fb1d1772975c5ca858403461e905f8494d2d4c069b500c482a3c5b23c1b079e75d499252f831ccc0e88f2a1c6e78e7ac5ed9605babd8f928cfd01023e3eb4ddb0fbe4d6893188f784a5a44091114361d9112546200c69958acdc5066bfb5b9c8b9f8f3d12632d8185b9edf51820f04d5e35cbdb94e671c2de1830a31b85f9c82e259fdbba682033cd2b32ca07e7edbec372b3ac9e0e0b5d4f51c04eec720d5d016d386f0f14ecda67430fcbcfea6381462d2bca9406562de2602ae49c6f8f26bed5f68f231f6ef1abdbe42547e3028b9dfa8a82205c8e3b693eb1d14e9bf94b63419c0b50e0019392965e71feb8805aeb779af6a58115d7d1f1d6e16ca80b979131e5423658d242cbf0c138f33b039d428959a39a6a26a178252cb72e3e7fd57561969d82b5976e8fbf0e373b8fe1f60cde1cb1d7e281de32d312f2cbbc0474a61efda0f3ccb1f64f0fb4692f72da2a4d6b43d3b88b5063e168b6050df007ab1ed3b8fa5cefd50f4963978ba2ac585fb209b06b81734cdb71d7628fa17a5a1e966fb101b5f05019034506fdb5d99210bd4f5148bdc46611618169f880d65d5df628afed53a71b3b13fd86d4891dd54987ef8a99c48f5df79043a70b8734f2014fa1ba21af375e569d0a7b9be98fe91572ffb0c264cf7a66c80ad10f810bfbbd8e0efc49ec9889e8bf1193b5b94ac4dc92108ad30123743a35b03ca38992d0a812c8eaee0d967c8dd9e918405b022d6a554f39664cf68bd</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Encrypt</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Perron-Frobenius 理论</title>
    <url>/perronFrobeniusTheory/</url>
    <content><![CDATA[<p>1907 年 O.Perron 发现正矩阵的谱有特别有趣的性质。G.Frobenius 在 1908-1912 年间将 Perron 的工作推广到不可约非负矩阵的情形，并得到了新的进一步结果。Ferron-Frobenius 理论有很多证明方式，下面介绍 H.Wielandt 的优美证明。（一步步的读下去会发现很清晰明了简单）</p>
<blockquote>
<p>非负矩阵的谱半径（下面有定义）是它的一个特征值，并且这个特征值对应着非负特征向量。</p>
</blockquote>
<a id="more"></a>
<p>两个矩阵 $X$ 和 $Y$ 称为置换相似的，若存在一个置换矩阵 $P$ 满足 $P^TXP=Y$。设$A\in M_n$.称$A$为可约的，若 $A$ 置换相似于一个形如$\left( \begin{matrix}<br>B &amp; 0\\<br>C &amp; D<br>\end{matrix} \right)$ 其中 $B,D$ 是方阵，否则称 $A$ 不可约。</p>
<blockquote>
<p>$X \geq 0$ 表示矩阵的每个元素 $\geq 0$, （对向量，或者 $&gt;0$ 等情形类似定义即可）。</p>
<p>以下矩阵除非特别说明都是 $n \times n$ 矩阵 $n&gt;1$</p>
</blockquote>
<h2 id="引理-1-设-A-是不可约非负矩阵，-y-in-mathbf-R-n-backslash-lbrace-0-rbrace-且至少有一个分量为-0-则-I-A-y-的正分量的个数大于-y-的正分量个数"><a href="#引理-1-设-A-是不可约非负矩阵，-y-in-mathbf-R-n-backslash-lbrace-0-rbrace-且至少有一个分量为-0-则-I-A-y-的正分量的个数大于-y-的正分量个数" class="headerlink" title="引理 1 设 $A$ 是不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 且至少有一个分量为 0, 则 $(I+A)y$ 的正分量的个数大于 $y$ 的正分量个数"></a>引理 1 设 $A$ 是不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 且至少有一个分量为 0, 则 $(I+A)y$ 的正分量的个数大于 $y$ 的正分量个数</h2><p><strong>Proof</strong>： 设 $y$ 恰好有 $k$ 个正分量，$1 \leq k \leq n-1$。设 $P$ 是置换矩阵，使得$x=Py$的前$k$个分量为正，其它为 0，因为 $A$ 是非负矩阵，所以 $(I+A)y$的零分量个数不会超过 $n-k$。假设这个个数等于 $n-k$，则有 $y_i = 0 \Rightarrow (Ay)_i = 0$。即 $(PAP^Tx)_i = (PAy)_i = 0,\quad i=k+1,\cdots,n$，设 $B=PAP^T$. 则当 $k+1 \leq i \leq n$ 时，</p>
<script type="math/tex; mode=display">
(Bx)_i = \sum _{j=1} ^{n} b _{ij} x _j = 
\sum _{j=1} ^{k} b _{ij} x _j = 0</script><p>但当 $1 \leq j \leq k$ 时，$x_j &gt;0$。所以 $b_{ij}=0$, 其中 $k+1 \leq i \leq n,1 \leq j \leq k$ 矛盾于 $A$ 不可约，证毕。</p>
<h2 id="引理-2-设-A-是-n-阶不可约非负矩阵，-y-in-mathbf-R-n-backslash-lbrace-0-rbrace-则-I-A-n-1-y-gt-0"><a href="#引理-2-设-A-是-n-阶不可约非负矩阵，-y-in-mathbf-R-n-backslash-lbrace-0-rbrace-则-I-A-n-1-y-gt-0" class="headerlink" title="引理 2 设 $A$ 是 $n$ 阶不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 则 $(I+A)^{n-1}y&gt;0$"></a>引理 2 设 $A$ 是 $n$ 阶不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 则 $(I+A)^{n-1}y&gt;0$</h2><h2 id="引理-3-设-n-gt-1-，则-n-阶非负矩阵-A-不可约当且仅当-I-A-n-1-gt-0"><a href="#引理-3-设-n-gt-1-，则-n-阶非负矩阵-A-不可约当且仅当-I-A-n-1-gt-0" class="headerlink" title="引理 3 设 $n&gt;1$，则 $n$ 阶非负矩阵 $A$ 不可约当且仅当 $(I+A)^{n-1}&gt;0$"></a>引理 3 设 $n&gt;1$，则 $n$ 阶非负矩阵 $A$ 不可约当且仅当 $(I+A)^{n-1}&gt;0$</h2><p><strong>Proof</strong>: 应用<strong>引理 2</strong>，考虑 $(I+A)^{n-1}e_j$ 即可。</p>
<h2 id="引理-4-一个不可约非负矩阵的非负特征向量是正特征向量"><a href="#引理-4-一个不可约非负矩阵的非负特征向量是正特征向量" class="headerlink" title="引理 4 一个不可约非负矩阵的非负特征向量是正特征向量"></a>引理 4 一个不可约非负矩阵的非负特征向量是正特征向量</h2><p><strong>Proof</strong>：设 $A$ 是不可约非负矩阵，$Ax=\lambda x, x \geq 0,x \neq 0$。显然 $\lambda \geq 0$ 我们有 $(I+A)x = (1 + \lambda)x$ ，因此$(1+A)x$与$x$有相同个数的正分量，有 <strong>引理 1</strong> 知 $x&gt;0$。</p>
<h3 id="Collatz-Wielandt-函数"><a href="#Collatz-Wielandt-函数" class="headerlink" title="Collatz-Wielandt 函数"></a>Collatz-Wielandt 函数</h3><p>设 $A$ 是一个非负矩阵。$A$ 的 Collatz－Wielandt 函数 $f_A \colon \mathbf{R}_+ ^n \backslash \lbrace 0 \rbrace  \to \mathbf{R}_+$ 定义为：</p>
<script type="math/tex; mode=display">
f_A(x) = \min _{ x _i \neq 0 } \frac{(Ax) _i }{x _i}</script><h2 id="引理-5-设-A-为非负不可约矩阵，则"><a href="#引理-5-设-A-为非负不可约矩阵，则" class="headerlink" title="引理 5 设 $A$ 为非负不可约矩阵，则"></a>引理 5 设 $A$ 为非负不可约矩阵，则</h2><ol>
<li>$f_A(tx) = f_A(x), \forall t &gt; 0$</li>
<li>$f_A(x) = \max \lbrace \rho | Ax-\rho x \geq 0 \rbrace$</li>
<li>设 $x \in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace$，记 $y = (I+A)^{n-1} x$ ,则 $f_A(y) \geq f_A(x)$。</li>
</ol>
<p><strong>Proof</strong>：(1),(2)显然。下证明(3)： 我们有$Ax- f_A(x)x \geq 0$，在等式两边左乘以$(I+A)^{n-1}$并利用$A$和$(I+A)^{n-1}$乘法可交换的性质，得到$A(I+A)^{n-1}x - f_A(x)(I+A)^{n-1}x \geq 0$ 即 $Ay - f_A(x)y\geq 0$ 再由（2）证毕。</p>
<blockquote>
<p>容易证明：$f_A$ 是有界函数，实际上，$f_A$ 非负且不超过 $A$ 的最大行和。</p>
<p>记$\Omega _n = \lbrace x \in \mathbf{R} _+ ^n | \sum _{i=1} ^n = 1 \rbrace$ 引理 5.1 说明，我们只需要在 $\Omega_n$ 上研究 $f_A$ 即可。显然$\Omega_n$是一个紧集，但是 $f_A$ 可能在 $\Omega _n$ 的边界不连续。</p>
<p>但是我们仍然有下面 <strong>引理 6</strong>。</p>
</blockquote>
<h2 id="引理-6-设-A-是非负不可约矩阵，则-f-A-在-mathbf-R-n-backslash-lbrace-0-rbrace-上可以取到最大值"><a href="#引理-6-设-A-是非负不可约矩阵，则-f-A-在-mathbf-R-n-backslash-lbrace-0-rbrace-上可以取到最大值" class="headerlink" title="引理 6 设 $A$ 是非负不可约矩阵，则 $f_A$ 在 $\mathbf{R}_{+} ^n \backslash \lbrace 0 \rbrace $上可以取到最大值"></a>引理 6 设 $A$ 是非负不可约矩阵，则 $f_A$ 在 $\mathbf{R}_{+} ^n \backslash \lbrace 0 \rbrace $上可以取到最大值</h2><p><strong>Proof</strong>: 记$\Delta = (I+A)^{n-1} \Omega _n = \lbrace y \mid y=(I+A)^{n-1} x ,x \in \Omega _n \rbrace$ 则 $\Delta$ 是一个紧集， 且有 <strong>引理 2</strong> 知 $\Delta$ 中向量都是正向量，因此 $f_A$ 在 $\Delta$ 上连续，由 Weierstrass 定理，$f_A$ 在某一点 $y^0 \in \Delta$ 取得 $f_A$ 在 $\Delta$ 上的最大值。记 $z^0 = y^0/ \sum_{i=1} ^n y_i ^0 \in \Omega_ n$。$\forall x \in \Omega_n$，记 $y=(I+A)^{n-1}x$ 利用 <strong>引理 5</strong> 可知</p>
<script type="math/tex; mode=display">
f_A(x) \leq f_A(y) \leq f_A(y^0) = f_A(z^0)</script><p>这就证明了 $f_A$ 在 $z^0$ 上取到它在 $\Omega_n$ 上的最大值。利用对$ \forall z \in R _+ ^n \backslash \lbrace 0 \rbrace $ 和 <strong>引理 6.1</strong> 有</p>
<script type="math/tex; mode=display">
f_A(z) = f_A(\frac{z}{\sum_{i=1}^n z_i}) \leq f_A(z^0)</script><p>可见 $f_A$ 在 $z^0$ 处取到它在 $R _+ ^n \backslash \lbrace 0 \rbrace$ 上的最大值。</p>
<h2 id="Perron-Frobenius-定理"><a href="#Perron-Frobenius-定理" class="headerlink" title="Perron-Frobenius 定理"></a>Perron-Frobenius 定理</h2><p><strong>矩阵 $A$ 的谱半径 $\rho(A)$ 定义成矩阵 $A$ 的所有特征值的绝对值的最大值。</strong></p>
<p>现在万事俱备了，下面开始介绍著名的 Perron-Frobenius 定理</p>
<h3 id="定理-7-Perron-Frobenius-设-A-是非负不可约矩阵，则下面结论成立"><a href="#定理-7-Perron-Frobenius-设-A-是非负不可约矩阵，则下面结论成立" class="headerlink" title="定理 7(Perron-Frobenius) 设$A$是非负不可约矩阵，则下面结论成立"></a>定理 7(Perron-Frobenius) 设$A$是非负不可约矩阵，则下面结论成立</h3><ol>
<li>$\rho(A)&gt;0$ 且 $\rho(A)$ 是矩阵 $A$ 的一个单特征值</li>
<li>$A$ 有一个对应于 $\rho(A)$ 的正特征向量</li>
<li>$A$ 的每个非负特征向量都对应于特征值 $\rho(A)$</li>
</ol>
<p><strong>Proof</strong>：由 <strong>引理 6</strong> 存在 $x^0 \in R _+ ^n \backslash \lbrace 0 \rbrace$ 满足 $f_A(x^0) \geq f_A(x), \forall x \in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace$ 记 $r=f_A(x^0)$，取 $u=(1,\cdots,1)^T$。因为 $A$ 不可约，没有零行，所以 $r \geq f_A(u) = \min \sum_ {i=1} ^n a _{ij} &gt; 0$</p>
<p>下面证明 $r$ 是 $A$ 的一个特征值，我们有: $Ax^0 - rx^0 \geq 0$，假设 $Ax^0 - rx^0 \neq 0$。由 <strong>引理 5.2</strong> 知 $(I+A)^{n-1}(Ax^0 - rx^0) &gt; 0$ 即 $Ay^0 - ry^0&gt; 0$ 其中，$y_0 = (I+A)^{n-1}x^0 &gt;0$。因此存在 $\epsilon &gt; 0$ 使得 $Ay^0 - (r+\epsilon)y^0&gt; 0$. 由<strong>引理 5.2</strong>，$f_A(y^0) \geq r+\epsilon &gt; r$ 这就与 $r=f_A(x^0)$ 的最大性矛盾。所以 $Ax^0=rx^0$。从而$r$是$A$的一个特征值，$x^0$ 是 $A$ 的一个特征向量。有 <strong>引理 4</strong> 知，$x^0$ 是正向量。<br>设 $\lambda$ 是 $A$ 的任何一个特征向量：$Ax=\lambda x$ 则 $|\lambda||x| \leq A|x|$，于是 $|\lambda| \leq f _ A(|x|) \leq r$ 这表明 $r = \rho(A)$。</p>
<blockquote>
<p>以下关于证明 $\rho(A)$ 是单特征值的部分可以不看</p>
</blockquote>
<hr>
<p>现证明 $\rho(A)$ 是单特征值，我们先证明 $\rho(A)$ 的几何重数是 1，设 $Ay = \rho(A) y,0 \neq y \in \mathbf{C}^n$ 则 $A|y|  \geq \rho(A)|y|$ 上面证明过程表明上式是等式（细品，走一遍没毛病）且 $|y|&gt;0$。可见 $A$ 的对应于 $\rho(A)$ 的特征向量不含零分量。设 $y$ 和 $z$ 是对应 $\rho(A)$ 的特征向量。则 $|y|&gt;0,|z|&gt;0.z_ 1 y-y_ 1 z$ 属于 $\rho(A)$ 的特征子空间，但 $z_ 1 y-y_ 1 z$ 的第一个分量为 0，所以它不可能是 $\rho(A)$ 的特征值，因此，$z_ 1 y-y_ 1 z＝0$，$y$ 和 $z$ 线性相关，所以 $\rho(A)$ 的几何重数为 1.</p>
<p>为了证明 $r=\rho(A)$ 是特征多项式 $\phi(\lambda) = det(\lambda I - A)$ 的单根，只需证明，导数 $\phi’(r) \neq 0$</p>
<p>用 $adj(X)$ 表示矩阵 $X$ 的 <a href="https://baike.baidu.com/item/%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5/10034983?fr=aladdin" target="_blank" rel="noopener">伴随矩阵</a>。我们有</p>
<script type="math/tex; mode=display">
\phi'(\lambda) = \sum_{i=1}^n det[(\lambda I - A)(i|i)]
=tr[adj(\lambda I - A)]</script><blockquote>
<p>$X(i|j)$ 表示矩阵去掉第 $i$ 行和第 $j$ 列所剩下的矩阵</p>
</blockquote>
<p>记 $B(r)=adj(rI-A)$ 则 $\phi’(r) = tr B(r)$</p>
<script type="math/tex; mode=display">
(rI-A)B(r) = det(rI-A)I</script><p>因为 $r$ 的几何重数为 1，所以 $rank(rI-A)=n-1$，于是 $B(r) \neq 0$。设 $b$ 是$B(r)$的任意一个非零列，则$(rI-A)b=0$,因此 $b$ 是 $A$ 的对应于 $r$ 的特征向量，但是 $A$ 有一个对应于 $r$ 的特征向量 $x^0$，且因为 $r$ 的几何重数为 1，因此 $b$ 是 $x^0$ 的一个常数倍，从而 $b&gt;0$ 或者 $b<0$。这就证明了 $B(r)$ 的每一列要么是零列，要么是正向量，要么是负向量。考虑 $[B(r)]^T = adj(rI-A^T),r=\rho(A)=\rho(A^T)$。上面结论应用于 $[B(r)]^T$ 的列，所以 $B(r)>0$ 或者 $B(r)&lt;0$，从而 $\phi’(r)=tr[B(r)] \neq 0$，这就证明了 $\rho(A)$ 是单特征值。</p>
<hr>
<p>我们已经证明了(1),(2)。现在来证明(3)。设 $y&gt;0$ 是 $A^T$ 对应于 $\rho(A)$ 的特征向量，设 $x$ 是 $A$ 的任意一个非负特征向量：$Ax = \mu x$。则 $\mu y^T x = y^T Ax = \rho(A)y^Tx$, 因为 $y^Tx&gt;0$, 我们有 $\mu = \rho(A)$，证毕。</p>
<blockquote>
<p>由<strong>引理 4</strong>，$A$ 的非负特征向量实际上都是正向量，因此结论 3 可叙述成：在$A$ 的所有特征向量中，只有 $\rho(A)$ 有非负特征向量。上述证明还确定了以下结果：</p>
</blockquote>
<h2 id="定理-8-设-A-是不可约非负矩阵，则-rho-A-max-lbrace-f-A-x-x-in-mathbf-R-n-backslash-lbrace-0-rbrace-rbrace-gt-0-若-x-in-mathbf-R-n-backslash-lbrace-0-rbrace-f-A-x-rho-A-则-x-gt-0-是对应于-rho-A-的一个特征向量"><a href="#定理-8-设-A-是不可约非负矩阵，则-rho-A-max-lbrace-f-A-x-x-in-mathbf-R-n-backslash-lbrace-0-rbrace-rbrace-gt-0-若-x-in-mathbf-R-n-backslash-lbrace-0-rbrace-f-A-x-rho-A-则-x-gt-0-是对应于-rho-A-的一个特征向量" class="headerlink" title="定理 8. 设 $A$ 是不可约非负矩阵，则 $\rho(A) = \max \lbrace f_A(x)|x\in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace \rbrace &gt; 0$ , 若$ x \in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace ,f_A(x) = \rho(A)$ 则$x&gt;0$ 是对应于$\rho(A)$的一个特征向量"></a>定理 8. 设 $A$ 是不可约非负矩阵，则 $\rho(A) = \max \lbrace f_A(x)|x\in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace \rbrace &gt; 0$ , 若$ x \in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace ,f_A(x) = \rho(A)$ 则$x&gt;0$ 是对应于$\rho(A)$的一个特征向量</h2><h2 id="定理-9-设-A-是一个非负矩阵，则-rho-A-是-A-的特征值，且-A-有一个对应于-rho-A-的非负特征向量"><a href="#定理-9-设-A-是一个非负矩阵，则-rho-A-是-A-的特征值，且-A-有一个对应于-rho-A-的非负特征向量" class="headerlink" title="定理 9. 设 $A$ 是一个非负矩阵，则 $\rho(A)$ 是 $A$ 的特征值，且 $A$ 有一个对应于$\rho(A)$的非负特征向量"></a>定理 9. 设 $A$ 是一个非负矩阵，则 $\rho(A)$ 是 $A$ 的特征值，且 $A$ 有一个对应于$\rho(A)$的非负特征向量</h2><p><strong>Proof</strong>：设$A$的阶数为$n$，定理对$n=1$是平凡地成立。下面设$n=2$，用$J$表示元素全为 1 的矩阵。<br>对于正整数 $k$，记 $A_k = A + \frac{1}{k} J$ 是一个正矩阵，由 Perron-Frobenius 定理，$A_k$ 在 $\Omega _n = \lbrace x \in \mathbf{R} _+ ^n | \sum _{i=1} ^n = 1 \rbrace$ 中有唯一一个对应于 $\rho(A_k)$ 的特征向量 $x^k$。</p>
<p>因为向量序列 $\lbrace x^k \rbrace$ 有界因此，由 Bolzano-Weierstrass 定理,$\lbrace x^k \rbrace $ 有收敛子列 $\lbrace x^{k_i} \rbrace: \lim _{i \to \infty } x^{k_i} = x$。显然 $x \in \Omega _n$ 因此</p>
<script type="math/tex; mode=display">
A _{k_i}x^{k _i} = \rho(A _{k _i}) x^{k _i}</script><p>注意到当 $i \to \infty$ 时， $A _{k_i} \to A , \rho(A _{k _i}) \to \rho(A)$ 从而得到 $Ax = \rho(A)x$，证毕。</p>
<blockquote>
<p>至此，Prron-Frobenius 定理介绍完毕。下面介绍一个非负矩阵特征值的界。</p>
</blockquote>
<h2 id="定理-10-设-A-是非负矩阵，则"><a href="#定理-10-设-A-是非负矩阵，则" class="headerlink" title="定理 10 设 $A$ 是非负矩阵，则"></a>定理 10 设 $A$ 是非负矩阵，则</h2><script type="math/tex; mode=display">
\min_{1 \leq i \leq n} r_i \leq \rho(A) \leq \max_{1 \leq i \leq n} r_i</script><script type="math/tex; mode=display">
\min_{1 \leq i \leq n} c_i \leq \rho(A) \leq \max_{1 \leq i \leq n} c_i</script><p>其中 $r_i, c_i$ 分别为 $A$ 的第 $i$ 行之和以及第 $i$ 列之和。</p>
<p><strong>Proof</strong>：设 $x$ 是 $A^T$ 的一个 Perron 向量(对应于谱半径的非负特征向量)。因为 $\rho(A^T)=\rho(A)$， 从而 $A^Tx=\rho(A)x$ 得到</p>
<script type="math/tex; mode=display">
\rho(A)x_i = \sum_{k=1}^n a_{ki}x_k \qquad i = 1,\cdots,n.</script><p>将这些等式相加得到 $\rho(A) \sum_{i=1}^n x_i =\sum_{k=1}^n r_k x_k$ 即</p>
<script type="math/tex; mode=display">
\rho(A)= \frac{\sum_{k=1}^n r_k x_k }{\sum_{i=1}^n x_i}</script><p>证毕。</p>
<h2 id="定理-11-Wielandt-设-A-是不可约非负矩阵，且-B-leq-A-则对于-B-的任何特征值-lambda-有"><a href="#定理-11-Wielandt-设-A-是不可约非负矩阵，且-B-leq-A-则对于-B-的任何特征值-lambda-有" class="headerlink" title="定理 11(Wielandt) 设$A$是不可约非负矩阵，且$|B| \leq A$ 则对于 $B$ 的任何特征值 $\lambda$有"></a>定理 11(Wielandt) 设$A$是不可约非负矩阵，且$|B| \leq A$ 则对于 $B$ 的任何特征值 $\lambda$有</h2><script type="math/tex; mode=display">
|\lambda| \leq \rho(A)</script><p><strong>Proof</strong>：设$Bx=\lambda x$ 则 $|B||x| \geq |\lambda||x|$，但是 $|B| \leq A$，所以 $|\lambda| |x| \leq |B||x| \leq A |x|$，由 <strong>引理 5.2</strong> 和 <strong>引理 8</strong> 知</p>
<script type="math/tex; mode=display">
|\lambda| \leq f_A(|x|) \leq \rho(A)</script><p>证毕。</p>
<p>根据谱半径的连续性，我们马上有如下推论</p>
<ol>
<li>若矩阵 $A$ 非负，且$|B| \leq A$，则 $\rho(B) \leq \rho(A)$</li>
<li>对任意矩阵$A$，$\rho(A) \leq \rho(|A|)$.(这个直接证明也可以)</li>
</ol>
<blockquote>
<p>本文源自詹兴致所著的《矩阵论》第六章。</p>
</blockquote>
<p>定理虽然很长但是整个过程十分优美，思路十分清晰，仔细分析每一步还是很容易看懂的，并且在证明的过程中就能体会为什么一开始要提出“非负不可约矩阵”的概念了，然后应用连续性把一些结果推广到非负矩阵。</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Schur 定理</title>
    <url>/schurTheorem/</url>
    <content><![CDATA[<p>在研究一个数学对象时，我们经常会对它进行分类。比如我们通常把数分为：实数，虚数；实数又分成有理数，无理数；当然也有按照正负来分的。还有整数分成素数（也叫质数）和合数，等等。现在我们谈谈矩阵的分类，以下默认矩阵是方的。<br><a id="more"></a></p>
<h2 id="数学中分类一般是按照等价关系划分等价类的"><a href="#数学中分类一般是按照等价关系划分等价类的" class="headerlink" title="数学中分类一般是按照等价关系划分等价类的"></a>数学中分类一般是按照等价关系划分等价类的</h2><p>所谓等价关系其实就是满足反身性，对称性，传递性的二元关系（总结一下我们等于号的全部性质就知道了）<br>矩阵中最常见的三种等价关系分别是</p>
<ol>
<li>相抵等价—-初等变换</li>
<li>合同等价—-合同变换</li>
<li>相似等价—-相似变换</li>
</ol>
<p>相抵等价完全由秩确定，合同变换我们一般只针对实对称矩阵处理。相似变化是我们讨论最多的也是最复杂的，我们总想把复杂的东西变简单，对于一个矩阵我们总想做变换把它变成最简单形式（称为标准型），相抵等价的标准型和对称矩阵合同等价的标准型都十分简单，但是很不幸的也是最幸运的是，并非所有的矩阵都可以相似于对角阵，相似变换标准型称为若尔当标准型，以纪念若尔当对矩阵相似变换所做的贡献。</p>
<p>然而今天主题并不是上面的任何一种，而是由伟大的数学家 Issai Schur 提出的酉相似，酉变换的概念和相应定理。</p>
<h2 id="任意复方阵酉相似于上三角矩阵"><a href="#任意复方阵酉相似于上三角矩阵" class="headerlink" title="任意复方阵酉相似于上三角矩阵"></a>任意复方阵酉相似于上三角矩阵</h2><h3 id="酉矩阵和酉相似"><a href="#酉矩阵和酉相似" class="headerlink" title="酉矩阵和酉相似"></a>酉矩阵和酉相似</h3><p>一个矩阵称为酉矩阵，如果它的共轭转置是它的逆。复矩阵 $A$ 与 $B$ 称为酉相似的，如果存在酉矩阵 $U$ 使得 $B=U^ \star AU$ ，这里$U^ \star$ 表示 $U$ 的共轭转置。</p>
<h3 id="定理-1-对任意复方阵-A-，存在酉矩阵-U-使得"><a href="#定理-1-对任意复方阵-A-，存在酉矩阵-U-使得" class="headerlink" title="定理 1.  对任意复方阵 $A$，存在酉矩阵 $U$ 使得"></a>定理 1.  <strong>对任意复方阵 $A$，存在酉矩阵 $U$ 使得</strong></h3><script type="math/tex; mode=display">
A = U \left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)U^\star</script><p>其中$\lambda_1,\lambda_2,\cdots,\lambda_n$ 为$A$的全部特征值。</p>
<p><strong>Proof</strong>：设 $\alpha_1$ 是$A$的特征值 $\lambda_1$ 对应的特征向量，将 $\alpha_1$ 扩充为$\mathbf{C}^n$的一组标准正交基 $P=(\alpha_1,\alpha_2,\cdots,\alpha_n)$ ，则 $A = P \left( \begin{matrix} \lambda_1 &amp; \star \\ \mathbf{0} &amp; B \end{matrix} \right)P^\star$ 。对复矩阵的阶数应用数学归纳法，存在$n-1$ 阶酉矩阵 $Q$ 使得</p>
<script type="math/tex; mode=display">
B = Q \left( \begin{matrix} \lambda_2 & \star & \star  \\
 & \ddots & \star \\
 & & \lambda_n \end{matrix} \right) Q^ \star</script><p>因此 </p>
<script type="math/tex; mode=display">
A = U \left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)U^\star</script><p>其中 $U = P \left( \begin{matrix} 1 &amp;  \\ &amp; Q \end{matrix} \right)$ 是 $n$ 阶酉矩阵，证毕。</p>
<h3 id="矩阵酉相似于对角阵当且仅当它是正规矩阵"><a href="#矩阵酉相似于对角阵当且仅当它是正规矩阵" class="headerlink" title="矩阵酉相似于对角阵当且仅当它是正规矩阵"></a>矩阵酉相似于对角阵当且仅当它是正规矩阵</h3><p>矩阵 $A$ 称为正规矩阵(<strong>normal matrix</strong>)，如果$ A^ \star A=AA^ \star $。显然酉矩阵，Hermite 阵，反 Hermite 阵都是正规矩阵。</p>
<h3 id="定理-2（Issai-Schur）矩阵-A-酉相似于对角阵的充分必要条件是-A-是正规矩阵"><a href="#定理-2（Issai-Schur）矩阵-A-酉相似于对角阵的充分必要条件是-A-是正规矩阵" class="headerlink" title="定理 2（Issai Schur）矩阵 $A$ 酉相似于对角阵的充分必要条件是 $A$ 是正规矩阵"></a>定理 2（Issai Schur）矩阵 $A$ 酉相似于对角阵的充分必要条件是 $A$ 是正规矩阵</h3><p><strong>Proof</strong>：必要性显然，下证明充分性：</p>
<p>由定理 1 知，存在酉矩阵 $U$ 使得：</p>
<script type="math/tex; mode=display">
A = U \left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)U^\star</script><p>若 $A$ 是正规矩阵，则有</p>
<script type="math/tex; mode=display">
\left( \begin{matrix} 
\overline{\lambda_1} &  &  &  \\
* & \overline{\lambda_2} &  &  \\
* & * & \ddots & \\
* & * & * &  \overline{\lambda_n}
\end{matrix} \right)

\left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)
=
\left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)
\left( \begin{matrix} 
\overline{\lambda_1} &  &  &  \\
\star & \overline{\lambda_2} &  &  \\
\star & \star & \ddots & \\
\star & \star & \star &  \overline{\lambda_n}
\end{matrix} \right)</script><p>考虑矩阵两端$(1,1)$位置得到:</p>
<script type="math/tex; mode=display">
\overline{\lambda_1}\lambda_1 ＝ \lambda_1 \overline{\lambda_1}+\sigma^2</script><p>其中$ \sigma^2 $是上三角矩阵</p>
<script type="math/tex; mode=display">
\left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)</script><p>的第一行的非对角元绝对值之平方和，因此由 $\sigma^2$ 可知上三角矩阵的第一行非对角元全为 0，类似的考察矩阵两端 $(2,2)$ 的位置，一直到 $(n,n)$ 的位置即可知道上面矩阵是对角阵，证毕。</p>
<p>上述定理给出了酉相似于对角型的充分必要条件，而且条件十分易于判断。整个过程简洁优美。另外由于酉矩阵条件数恒定为 1，有其数值稳定性，因此经常用于实际计算中，例如 QR 方法涉及的两个矩阵变换 Househoulder 变换和 Givens 变换都是酉变换。</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Cayley-Hamilton 定理</title>
    <url>/cayleyHamiltonTheorem/</url>
    <content><![CDATA[<p>大一学了矩阵之后，一直很喜欢它，因为它形式简洁优美，又不缺乏技巧，是抽象和具体的桥梁，又有其实用性，成为现代数学最基础的工具之一。个人认为，矩阵中最优美的定理非 Cayley-Hamilton 定理（矩阵的特征多项式是它的一个化零多项式）莫属了。</p>
<blockquote>
<p>交换环上的矩阵都有 Cayley-Hamilton 定理成立</p>
</blockquote>
<a id="more"></a>
<p>详细表述和证明如下：</p>
<script type="math/tex; mode=display">
\phi(\lambda)=det(\lambda I - A) = a_n \lambda^n + \cdots + a_1 \lambda + a_0</script><p>设$\lambda I - A$的 <a href="https://baike.baidu.com/item/%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5/10034983?fr=aladdin" target="_blank" rel="noopener">伴随矩阵</a> 为 $B$，则$B$中元素为关于 $\lambda$ 的次数小于 $n$ 的多项式，不妨设</p>
<script type="math/tex; mode=display">
B = \lambda^{n-1} B_ {n-1} + \cdots + \lambda B_1 + B_0</script><p>所以</p>
<script type="math/tex; mode=display">
(\lambda I - A)B = \lambda^n B_ {n-1} + \lambda^{n-1} (B_ {n-2} - AB_ {n-1})
+ \cdots + \lambda (B_0 - AB_1) - AB_0</script><p>又因为 $B$ 是 $A$ 的伴随矩阵，我们有 $(\lambda I - A)B = det(\lambda I - A) I$</p>
<p>比较系数得到：</p>
<script type="math/tex; mode=display">
\left\{ 
\begin{array}{l} 
B_ {n-1} = a_n I \\
B_ {n-2} - AB_ {n-1} = a_{n-1} I \\
\cdots \\
B_0 - AB_1 = a_1 I \\
-AB_0 = a_0 I
\end{array} \right.</script><p>对上式分别左乘$ A^n,A^{n-1},\cdots,A,I$得到：</p>
<script type="math/tex; mode=display">
\left\{ 
\begin{array}{l} 
A^n B_ {n-1} = a_n A^n \\
A^{n-1} B_ {n-2} - A^n B_ {n-1} = a_{n-1} A^{n-1} \\
\cdots \\
A B_0 - A^2 B_1 = a_1 A \\
-AB_0 = a_0 I
\end{array} \right.</script><p>再将上式相加得到最终结果</p>
<script type="math/tex; mode=display">
\phi(A)= a_ n A^n + a_{n-1} A^{n-1} + \cdots + a_1 A +
a_0 I = \mathbf{0}</script><p>上述定理优美在于从形式上，$\phi(\lambda)=det(\lambda I - A)$ 取 $\lambda = A$ 带入恰好也是 0（注意数字 0 和零矩阵的差别）<strong>虽然说这样做是完全没有道理</strong>。作为直接推论我们知道，一个 $n$ 阶方阵的任何次方都可以被它的不超过 $n$ 次的幂线性表出。</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
        <tag>特征多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>仅在一点连续的函数例子</title>
    <url>/exampleOfFunctionOnlyContinueAtOnePoint/</url>
    <content><![CDATA[<p>在一元微积分中，有一个广为人知的结论：一元函数在一点可导，必在该点连续，即可导必连续。那么自然会有这样一个问题：</p>
<blockquote>
<p>一元函数在一点可导能否推出它在该点的一个小邻域连续呢？</p>
</blockquote>
<p>这个想法是很自然的，不严格的思考可能会认为应该是对的,但是它并不成立。下面给出一个反例：</p>
<script type="math/tex; mode=display">
f(x) = x^2 D(x) = \left\{ 
\begin{array}{ll} 
x^2 & x \in \mathbb{Q} \\
0 & x \notin \mathbb{Q} 
\end{array} \right.</script><p>其中 $D(x)$ 为 Dirichlet 函数。</p>
<a id="more"></a>
<p>容易验证函数 $f(x)$ 在 $x=0$ 处可导，但在 $x \neq 0$ 处不连续，从而否定了上述问题。</p>
<p>最后，类似地，我们还可以通过 Dirichlet 函数构造 $\mathbb{R}$ 上一些仅在有限个点连续的函数。也可以通过周期函数构造仅在所有整数点连续的函数。但是由 Baire 纲定理可以证明，不存在在所有有理数点连续，无理点间断的函数。最后 Riemann 函数给出了一个在所有有理数点间断，无理点连续的函数。这些反例使得人们对函数连续的概念有了更感性的认识。</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>计算器程序</title>
    <url>/calculatorWithC/</url>
    <content><![CDATA[<h2 id="计算器到处都有，有啥好写的呢"><a href="#计算器到处都有，有啥好写的呢" class="headerlink" title="计算器到处都有，有啥好写的呢"></a>计算器到处都有，有啥好写的呢</h2><p>我们在写程序时，对于长串计算，我们通常直接输入了，让计算机高级语言（例如 C++）给我们算就行了。但是，仔细想想这件事其实并不简单。</p>
<blockquote>
<p>最初想做这件事的原因是：我在大学想写一个带 GUI 界面的计算器，就在这里被卡住了。</p>
</blockquote>
<p>其实这是一个很有名的问题，大家有兴趣可以搜一下 <a href="http://baike.baidu.com/link?url=K67J7hWFkpdwOzjAA-nalFK4JqnnLI5TPtK1Dx7dOBn0P5WhAsq09j0e4qBI590vomEWc0w2gtCFWreeta0gr_" target="_blank" rel="noopener">逆波兰式</a></p>
<a id="more"></a>
<h2 id="逆波兰式"><a href="#逆波兰式" class="headerlink" title="逆波兰式"></a>逆波兰式</h2><p>逆波兰式即为后缀表达式，我们生活中算数表达式一般都是中序表达式。人类易于理解中序表达式，但计算机更容易处理后缀表达式。</p>
<h3 id="直奔解决方案"><a href="#直奔解决方案" class="headerlink" title="直奔解决方案"></a>直奔解决方案</h3><p>我们的做法基本分</p>
<ol>
<li>确定好符号集和它们的优先级</li>
<li>中序表达式转化成后缀表达式</li>
<li>根据后缀表达式得到最终结果</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7fffffff</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;    <span class="comment">//set priority level  </span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'='</span>||a==<span class="string">'('</span>)  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'+'</span>||a==<span class="string">'-'</span>)  <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'*'</span>||a==<span class="string">'/'</span>)  <span class="keyword">return</span> <span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getsuffixexpression</span><span class="params">(<span class="built_in">string</span> a)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ope;  </span><br><span class="line">    ope.push(<span class="string">'='</span>);  </span><br><span class="line">    <span class="built_in">string</span> ans;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=a.<span class="built_in">size</span>();++i)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=<span class="string">'0'</span>&amp;&amp;a[i]&lt;=<span class="string">'9'</span>)&#123;  </span><br><span class="line">            ans.push_back(a[i]);  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'('</span>)&#123;  </span><br><span class="line">            ope.push(<span class="string">'('</span>);  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">')'</span>)&#123;  </span><br><span class="line">            <span class="keyword">while</span>(!ope.empty()&amp;&amp;ope.top()!=<span class="string">'('</span>)&#123;  </span><br><span class="line">                ans.push_back(ope.top());  </span><br><span class="line">                ope.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            ope.pop();<span class="comment">// push left bracket  </span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]!=<span class="string">'+'</span>&amp;&amp;a[i]!=<span class="string">'-'</span>&amp;&amp;a[i]!=<span class="string">'*'</span>&amp;&amp;a[i]!=<span class="string">'/'</span>)&#123;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre(a[i])&gt;pre(ope.top()))&#123;  </span><br><span class="line">            ope.push(a[i]);  </span><br><span class="line">            ans.push_back(<span class="string">' '</span>);  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">while</span>(pre(a[i])&lt;=pre(ope.top()))&#123;  </span><br><span class="line">                ans.push_back(ope.top());  </span><br><span class="line">                ope.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            ope.push(a[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(ope.top()!=<span class="string">'='</span>)&#123;  </span><br><span class="line">        ans.push_back(ope.top());  </span><br><span class="line">        ope.pop();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="built_in">string</span> a)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> b=getsuffixexpression(a);  </span><br><span class="line">    <span class="keyword">if</span>(b.empty())   <span class="keyword">return</span> INF;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=b.<span class="built_in">size</span>();++i)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(b[i]==<span class="string">' '</span>)   <span class="keyword">continue</span>;  </span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=<span class="string">'0'</span>&amp;&amp;b[i]&lt;=<span class="string">'9'</span>)&#123;  </span><br><span class="line">            <span class="keyword">int</span> t=<span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">while</span>(i!=b.<span class="built_in">size</span>()&amp;&amp;b[i]&gt;=<span class="string">'0'</span>&amp;&amp;b[i]&lt;=<span class="string">'9'</span>)&#123;  </span><br><span class="line">                t=t*<span class="number">10</span>+b[i++]-<span class="string">'0'</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            --i;  </span><br><span class="line">            s.push(t);  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">int</span> x,y;  </span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;  </span><br><span class="line">                y=s.top();  </span><br><span class="line">                s.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;  </span><br><span class="line">                x=s.top();  </span><br><span class="line">                s.pop();  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">                <span class="keyword">return</span> INF;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">switch</span>(b[i])&#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:  </span><br><span class="line">                s.push(x+y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:  </span><br><span class="line">                s.push(x-y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:  </span><br><span class="line">                s.push(x*y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:  </span><br><span class="line">                s.push(x/y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> ans=s.top();  </span><br><span class="line">    s.pop();  </span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> ans;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> INF;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> a;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(getans(a)!=INF)&#123;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;getans(a)&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Calculator</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到 Hexo</title>
    <url>/helloHexo/</url>
    <content><![CDATA[<p>首先要感谢给我们免费提供二级域名和云服务器的 <a href="https://github.com/" target="_blank" rel="noopener">github</a> 还有提供框架 <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>和主题 next（再见 next，你好 Butterfly：<a href="https://demo.jerryc.me/" target="_blank" rel="noopener">官方demo</a>或者 <a href="https://www.antmoe.com/posts/75a6347a/index.html" target="_blank" rel="noopener">官方配置方法</a>, <a href="https://blog.lete114.top/article/Butterfly-config.html" target="_blank" rel="noopener">魔性修改</a>）。在最后还有一些小技巧的汇总方便查阅，其中包括 mathjax，git 的配置，pip 和 npm的国内镜像加速设置。（将 win10 下 WSL Ubuntu20.04 作为唯一开发环境，将 VScode 作为唯一开发工具。） <strong>换主题了不再更新</strong>, 请移步到: <a href="/butterfly/" title="butterfly 主题配置">butterfly 主题配置</a></p>
<a id="more"></a>
<blockquote>
<p>本站 .com 域名不用备案，只需实名制即可</p>
<p>每次迁移都要处理 Github SSL，deploy Save，mathjax渲染, Nunjucks报错处理(对应修改local Search, feed)</p>
</blockquote>
<h2 id="Hexo环境搭建"><a href="#Hexo环境搭建" class="headerlink" title="Hexo环境搭建"></a>Hexo环境搭建</h2><ol>
<li><a href="https://tding.top/archives/7f189df5.html" target="_blank" rel="noopener">小丁教程：</a>安装 Hexo 并上传到 git 上(<a href="https://blog.csdn.net/grave2015/article/details/79961843" target="_blank" rel="noopener">这里超详细</a>）</li>
<li>注意 <strong>一定要把github上Pages功能打开</strong> 才行（最后enable HTTPs）</li>
<li>主题 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a>安装</li>
<li>安装 nmp 和 pip 的 post_link note 国内加速</li>
<li><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">mathjax渲染</a></li>
<li>Windows 下安装 markdown IDE: sublime3 + <a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> </li>
<li>Typora 写公式快捷键 <code>ctrl + shift + m</code></li>
<li>hexo文章加密 <a href="https://blog.csdn.net/qq_24495287/article/details/89025371" target="_blank" rel="noopener">方式1</a> 和 <a href="https://blog.csdn.net/cungudafa/article/details/104346521" target="_blank" rel="noopener">方式2</a></li>
<li><a href="https://www.itrhx.com/2019/09/16/A47-hexo-deployed-to-github-and-coding/" target="_blank" rel="noopener">部署代码到 Coding</a> 并把源代码提交到Coding（账号是手机号）</li>
<li><a href="https://www.bing.com/webmasters/sitescan?siteUrl=http://dna049.com/" target="_blank" rel="noopener">Bing 提交链接</a></li>
</ol>
<h3 id="这次大更新的说明-（2020-3-12）"><a href="#这次大更新的说明-（2020-3-12）" class="headerlink" title="这次大更新的说明 （2020/3/12）"></a>这次大更新的说明 （2020/3/12）</h3><p>因为我之前的失误，导致 markdown 源文件丢失，又因为备份更新的时间比较久，导致了我两年没有更新博客，所以这次我配置 hexo 的时候，有讲源码提交到 github 上去。可是最后我还是选择了 next5.1.4 主题，而没有更新到 next7.7.2</p>
<blockquote>
<p>老博客地址：<a href="https://dna049.github.io/" target="_blank" rel="noopener">https://dna049.github.io/</a> （绑定账号：<a href="https://github.com/dna049" target="_blank" rel="noopener">FDU校邮</a>）</p>
</blockquote>
<h4 id="这次迁移的工作量是巨大，但是很有意义的："><a href="#这次迁移的工作量是巨大，但是很有意义的：" class="headerlink" title="这次迁移的工作量是巨大，但是很有意义的："></a>这次迁移的工作量是巨大，但是很有意义的：</h4><ol>
<li>我把博文中个人生活部分加密了</li>
<li>http 升级到 https（超级简单）</li>
<li>域名 dna049.com 到 2022 年过期，记得到时候续费</li>
<li>加了百度统计，<del>leanCould 文章数量统计</del>，打赏，不蒜子统计博客访问量</li>
<li>加了 <a href="https://tding.top/archives/761b6f4d.html" target="_blank" rel="noopener">背景</a>， <a href="https://tding.top/archives/2bd6d82.html" target="_blank" rel="noopener">圆角设置</a>(<del>sidebar不是圆角很难受</del>，被 <a href="https://blog.maplesugar.space/" target="_blank" rel="noopener">枫糖</a>帮助解决)，<a href="https://github.com/MikeCoder/hexo-tag-cloud" target="_blank" rel="noopener">标签云</a>，<a href="https://www.liaofuzhan.com/posts/2114475547.html" target="_blank" rel="noopener">彩色 Tags 和 logo</a></li>
<li>加了 <a href="https://tding.top/archives/73ce4e7.html" target="_blank" rel="noopener">友链</a> 方式一（方式二容易出问题）</li>
<li>复习一下之前写的博文，熟练一下语法(markdown, C++, Python, Latex)，顺带查错</li>
<li>删除了一点现在看来没什么意思的博文</li>
<li>知道保存好自己修改过的 next 主题。</li>
<li>增加 <a href="https://tding.top/archives/567debe0.html" target="_blank" rel="noopener">RSS 功能</a>，<a href="https://zhuanlan.zhihu.com/p/64457116" target="_blank" rel="noopener">RSS 使用说明</a></li>
</ol>
<h3 id="Hexo功能介绍"><a href="#Hexo功能介绍" class="headerlink" title="Hexo功能介绍"></a>Hexo功能介绍</h3><ol>
<li>内部引用：<code></code></li>
<li>创建新文件夹： hexo new page newdir</li>
<li>hexo 中渲染 mathjax： <a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">看这里</a></li>
<li>设置 <a href="https://blog.csdn.net/qwerty200696/article/details/79010629" target="_blank" rel="noopener">文章置顶</a></li>
<li>安装主题next更新到稳定的 <a href="https://github.com/iissnan/hexo-theme-next/releases/tag/v5.1.4" target="_blank" rel="noopener">版本 5.1.4</a> 并 <a href="https://blog.csdn.net/loze/article/details/94210320" target="_blank" rel="noopener">配置</a> （不用看教程就能配置），不建议更新到最新版本很不稳定</li>
<li>显示更新时间： 找到 next 主题的 <code>_config.yml</code>在里面查找 <code>update</code> 会找到一个 <code>updated_at</code> 的属性改为 <code>true</code> 即可看到更新时间</li>
<li><a href="https://www.jianshu.com/p/d4a7daebfff7" target="_blank" rel="noopener">next中添加爱心</a></li>
<li>next主题记得设置tags文件夹下的index.md</li>
<li><a href="https://www.jianshu.com/p/79fe9fb9dfa0" target="_blank" rel="noopener"><del>next隐藏部分博文</del></a> </li>
<li><a href="https://blog.csdn.net/shuiyunxc/article/details/104150894" target="_blank" rel="noopener">next5.1.4 的问题</a></li>
<li><a href="https://www.dazhuanlan.com/2020/01/30/5e322259a87e5/" target="_blank" rel="noopener">Nunjucks 报错处理</a></li>
</ol>
<h3 id="mathjax-示例"><a href="#mathjax-示例" class="headerlink" title="mathjax 示例"></a>mathjax 示例</h3><h4 id="The-Quadratic-Formula"><a href="#The-Quadratic-Formula" class="headerlink" title="The Quadratic Formula"></a>The Quadratic Formula</h4><script type="math/tex; mode=display">
x = {-b \pm \sqrt{b^2-4ac} \over 2a}</script><h4 id="The-Lorenz-Equations"><a href="#The-Lorenz-Equations" class="headerlink" title="The Lorenz Equations"></a>The Lorenz Equations</h4><script type="math/tex; mode=display">
\begin{aligned}
\dot{x} & = \sigma(y-x) \\
\dot{y} & = \rho x - y - xz \\
\dot{z} & = -\beta z + xy
\end{aligned}</script><h4 id="The-Cauchy-Schwarz-Inequality"><a href="#The-Cauchy-Schwarz-Inequality" class="headerlink" title="The Cauchy-Schwarz Inequality"></a>The Cauchy-Schwarz Inequality</h4><script type="math/tex; mode=display">
\left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)</script><h4 id="A-Cross-Product-Formula"><a href="#A-Cross-Product-Formula" class="headerlink" title="A Cross Product Formula"></a>A Cross Product Formula</h4><script type="math/tex; mode=display">
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}
\mathbf{i} & \mathbf{j} & \mathbf{k} \\
\frac{\partial X}{\partial u} &  \frac{\partial Y}{\partial u} & 0 \\
\frac{\partial X}{\partial v} &  \frac{\partial Y}{\partial v} & 0
\end{vmatrix}</script><blockquote>
<p><code>\displaystyle</code> 可以让行内公式有行间公式的视觉效果</p>
</blockquote>
<h3 id="git-上传源代码到私有仓库"><a href="#git-上传源代码到私有仓库" class="headerlink" title="git 上传源代码到私有仓库"></a>git 上传源代码到私有仓库</h3><p>在博客所用的 github 账号下再建立一个私有仓库，然后，在 blog 目录下相应修改 <code>.gitignore</code> 的内容，并在 blog 目录下执行下面git命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># git remote rm origin</span></span><br><span class="line">git remote add origin https://github.com/dna049/dna049Source.git  <span class="comment"># 只需添加一次</span></span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git push -u origin master <span class="comment"># -u 一次之后就可以直接用 git push提交了</span></span><br></pre></td></tr></table></figure>
<h3 id="一键提交源代码"><a href="#一键提交源代码" class="headerlink" title="一键提交源代码"></a>一键提交源代码</h3><p>可以正常更新后，在 blog 目录下新建一个 <code>updateSourceCode.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># update source code</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#os.system('git init')</span></span><br><span class="line">os.system(<span class="string">'git add .'</span>)</span><br><span class="line"><span class="comment">#os.system('git remote add origin https://github.com/dna049/dna049Source.git')</span></span><br><span class="line"><span class="comment"># 上面是github 下面是 Coding</span></span><br><span class="line"><span class="comment">#os.system('git remote add origin https://e.coding.net/dna049/dna049Source.git') </span></span><br><span class="line">os.system(<span class="string">'git commit -m "update"'</span>)</span><br><span class="line">os.system(<span class="string">'git push origin master'</span>)</span><br></pre></td></tr></table></figure>
<p>以后每次在 blog 目录下执行 <code>py update.py</code> 就可以了。 </p>
<p><a href="https://shuiyunxc.gitee.io/2020/03/03/download/index/" target="_blank" rel="noopener">如何快速从GitHub下载文件</a></p>
<h3 id="nmp-安装国内镜像"><a href="#nmp-安装国内镜像" class="headerlink" title="nmp 安装国内镜像:"></a>nmp 安装国内镜像:</h3><p><code>npm config set registry https://registry.npm.taobao.org</code></p>
<h4 id="pip-安装的国内镜像在后面加-也可以一劳永逸，就是麻烦了点-："><a href="#pip-安装的国内镜像在后面加-也可以一劳永逸，就是麻烦了点-：" class="headerlink" title="pip 安装的国内镜像在后面加(也可以一劳永逸，就是麻烦了点)："></a>pip 安装的国内镜像在后面加(也可以<a href="https://www.cnblogs.com/cqliu/p/11131092.html" target="_blank" rel="noopener">一劳永逸</a>，就是麻烦了点)：</h4><p><code>-i https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<p>pip 本地安装</p>
<ul>
<li>tar.gz 文件： <code>pip install *.tar.gz</code></li>
<li>解压好的source 文件：<code>pip install -e filePath -i ...</code>，加 <code>-i</code> 是防止要安装依赖包</li>
</ul>
<h3 id="Windows-文件比较：-FC-A-py-B-py"><a href="#Windows-文件比较：-FC-A-py-B-py" class="headerlink" title="Windows 文件比较： FC A.py B.py"></a>Windows 文件比较： <code>FC A.py B.py</code></h3><h2 id="Hexo-git-教程："><a href="#Hexo-git-教程：" class="headerlink" title="Hexo + git 教程："></a>Hexo + git 教程：</h2><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><ul>
<li><p>安装<a href="https://git-scm.com/download" target="_blank" rel="noopener">git</a></p>
</li>
<li><p>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> （选择自动安装依赖包）</p>
</li>
<li><p>nmp添加国内镜像源： <code>npm config set registry https://registry.npm.taobao.org</code></p>
</li>
<li><p>安装<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a> ： <code>npm install -g hexo-cli</code></p>
</li>
</ul>
<blockquote>
<p>以下所有跟 github 相关的内容都建议<strong>早上</strong>操作</p>
</blockquote>
<h3 id="搭建hexo："><a href="#搭建hexo：" class="headerlink" title="搭建hexo："></a>搭建hexo：</h3><p>新建一个blog文件夹，进入blog目录，依次输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">nmp install</span><br><span class="line">hexo clean <span class="comment">#可选</span></span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>在浏览器输入网址： <code>localhost:4000</code> 看到 HelloWorld 说明成功了。</p>
<h3 id="部署到-github"><a href="#部署到-github" class="headerlink" title="部署到 github"></a>部署到 github</h3><p>登录 <a href="https://github.com" target="_blank" rel="noopener">github</a> ，创建 yourname/yourname.github.io 仓库， 进入该仓库 setting，下拉到 Github Page</p>
<p>设置 master branch，Custom domain（可选），Enforce HTTPS</p>
<p>git 命令行进入 blog 目录，执行下面操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C yourmail@example.com <span class="comment">#建议不设置密码，按回车</span></span><br><span class="line">clip &lt; ~/.ssh/id_rsa.pub <span class="comment"># 复制公钥到系统粘贴板</span></span><br></pre></td></tr></table></figure>
<p>去 github 账号的 setting 中添加 ssh key（复制到 key 就可以了）</p>
<p>检测是否成功： <code>ssh -T git@github.com</code></p>
<p>设置全局用户信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name yourname</span><br><span class="line">git config --<span class="keyword">global</span> user.email  yourmail@example.com</span><br></pre></td></tr></table></figure>
<p>在 <code>_config.yml</code> （最后一行）设置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yourname/yourname.github.io.git</span><br></pre></td></tr></table></figure>
<p>执行：<code>npm install hexo-deployer-git --save</code></p>
<p>然后执行： <code>hexo g -d</code> 就可以去 <code>http(s)://yourname.github.io</code> 看到自己的博客了。</p>
<h4 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置 _config.yml"></a>配置 <code>_config.yml</code></h4><p>填写 site 信息， 设置 url ， 建议 permalink 改为 ：<code>title/</code>，设置 <code># Pagination</code> 下的 <code>per_page: 0</code>。</p>
<h4 id="配置主题，配好了修改-config-yml-的-theme-为当前主题"><a href="#配置主题，配好了修改-config-yml-的-theme-为当前主题" class="headerlink" title="配置主题，配好了修改 _config.yml 的 theme 为当前主题"></a>配置主题，配好了修改 <code>_config.yml</code> 的 theme 为当前主题</h4><blockquote>
<p>2022 年 2 月把主题更新到最新版本</p>
</blockquote>
]]></content>
      <tags>
        <tag>Theme</tag>
        <tag>Hexo</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
</search>

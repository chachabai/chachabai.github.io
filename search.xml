<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python 自动输入</title>
    <url>/autoInputWithPy/</url>
    <content><![CDATA[<p>在知乎上看到 <a href="https://zhuanlan.zhihu.com/p/115563930" target="_blank" rel="noopener">使用 Python 控制自己的电脑和键盘是一种什么样的体验？</a> 里面介绍的 pyautogui，于是在 <a href="https://pyautogui.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">pyautogui 官网</a> 上查了一下，因为挺有趣的特此记录：</p>
<blockquote>
<p>可以用来写一个 LOL 打人机拿首胜的脚本 0.0</p>
</blockquote>
<a id="more"></a>
<h2 id="安装-pyautogui"><a href="#安装-pyautogui" class="headerlink" title="安装 pyautogui"></a>安装 pyautogui</h2><p> <code>pip install pyautogui -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<h2 id="持续获取鼠标位置的示例"><a href="#持续获取鼠标位置的示例" class="headerlink" title="持续获取鼠标位置的示例"></a>持续获取鼠标位置的示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># getMousePosition.py</span></span><br><span class="line"><span class="keyword">import</span> pyautogui <span class="keyword">as</span> pg</span><br><span class="line">print(<span class="string">'Press Ctrl+C to quit.'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x,y = pg.position() </span><br><span class="line">        positionStr = <span class="string">'X: '</span>+str(x).rjust(<span class="number">4</span>)+ <span class="string">' Y: '</span>+str(y).rjust(<span class="number">4</span>)</span><br><span class="line">        print(positionStr, end = <span class="string">''</span>)</span><br><span class="line">        print(<span class="string">'\b'</span>* len(positionStr), end =<span class="string">''</span>, flush = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>退格 <code>\b</code> 也太好玩了</p>
<p>唯一新的东西就是 <code>pg.position()</code> 来获取鼠标位置</p>
</blockquote>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pg <span class="keyword">as</span> pg</span><br><span class="line">pg.PAUSE = <span class="number">1</span> <span class="comment"># 每条语句相隔1s执行</span></span><br><span class="line"><span class="comment"># 鼠标操作</span></span><br><span class="line">pg.move(x,y,duration = num_seconds)   <span class="comment">#相对移动</span></span><br><span class="line">pg.moveTo(x, y, duration=num_seconds) <span class="comment">#数秒内鼠标移动到(x,y)位置</span></span><br><span class="line">pg.click(x=moveToX, y=moveToY, clicks=num_of_clicks, interval=secs_between_clicks, button=<span class="string">'left'</span>) <span class="comment"># 鼠标（默认左键）单击</span></span><br><span class="line">pg.doubleClick(x=moveToX, y=moveToY) <span class="comment"># 鼠标双击（可以用上面的）</span></span><br><span class="line">pg.mouseDown(x=moveToX, y=moveToY, button=<span class="string">'left'</span>) <span class="comment"># 鼠标按住</span></span><br><span class="line">pg.mouseUp(x=moveToX, y=moveToY, button=<span class="string">'left'</span>) <span class="comment">#鼠标抬起 </span></span><br><span class="line">pg.dragTo(x, y, duration=num_seconds) <span class="comment"># 拖拽</span></span><br><span class="line">pg.drag(x,, duration=num_seconds) <span class="comment">#相对拖拽</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 键盘操作</span></span><br><span class="line"><span class="comment"># 切屏</span></span><br><span class="line">pg.keyDown(<span class="string">'alt'</span>)</span><br><span class="line">pg.press(<span class="string">'tab'</span>)</span><br><span class="line">pg.press(<span class="string">'tab'</span>)</span><br><span class="line">pg.keyUp(<span class="string">'alt'</span>)</span><br><span class="line"><span class="comment"># 复制粘贴</span></span><br><span class="line">pg.keyDown(<span class="string">'shift'</span>)</span><br><span class="line">pg.press([<span class="string">'left'</span>]*<span class="number">3</span>)</span><br><span class="line">pg.keyUp(<span class="string">'shift'</span>) </span><br><span class="line">pg.hotkey(<span class="string">'ctrl'</span>,<span class="string">'c'</span>)</span><br><span class="line">pg.hotkey(<span class="string">'ctrl'</span>,<span class="string">'v'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全屏浏览器中 写入 网址并前往</span></span><br><span class="line">pg.moveTo(<span class="number">360</span>,<span class="number">52</span>)</span><br><span class="line">pg.click()</span><br><span class="line">pg.write(<span class="string">'dna049.com'</span>,interval = <span class="number">0.2</span>)</span><br><span class="line">pg.press(<span class="string">'enter'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># messageBox</span></span><br><span class="line">pg.alert(text=<span class="string">''</span>, title=<span class="string">''</span>, button=<span class="string">'OK'</span>) <span class="comment"># 提示消息小窗口</span></span><br><span class="line">pg.confirm(text=<span class="string">''</span>, title=<span class="string">''</span>, buttons=[<span class="string">'OK'</span>, <span class="string">'Cancel'</span>]) <span class="comment"># 选择窗口，返回选择的内容</span></span><br><span class="line">pg.prompt(text=<span class="string">''</span>, title=<span class="string">''</span> , default=<span class="string">''</span>) <span class="comment"># 输入消息窗口</span></span><br><span class="line">pg.password(text=<span class="string">''</span>, title=<span class="string">''</span>, default=<span class="string">''</span>, mask=<span class="string">'*'</span>) <span class="comment"># 输入密码窗口</span></span><br></pre></td></tr></table></figure>
<h2 id="挂机玩-LOL-上述-pyautogui-被弃用了"><a href="#挂机玩-LOL-上述-pyautogui-被弃用了" class="headerlink" title="挂机玩 LOL (上述 pyautogui 被弃用了)"></a>挂机玩 LOL (上述 pyautogui 被弃用了)</h2><p>很遗憾，LOL 拦截了虚拟键盘操作（包括 <code>pyautogui pywin32</code>）</p>
<p>~~ <strong>按键盒子</strong>貌似可以解决（没试过）。最后我们需要驱动级的模拟按键： <a href="https://github.com/starofrainnight/pywinio" target="_blank" rel="noopener">pywinio</a> ~~</p>
<blockquote>
<p>键盘操作  <strong>用<code>pip install keyboard</code></strong> ： <a href="https://github.com/boppreh/keyboard" target="_blank" rel="noopener">keyboard 示例</a>。</p>
<p>鼠标操作  <strong>用<code>pip install mouse</code></strong> ： <a href="https://github.com/boppreh/mouse" target="_blank" rel="noopener">mouse 示例</a> </p>
</blockquote>
<p><code>mouse keyboard</code> 两个项目是同一个人创建的，并且带有按键监听功能，持续更新，十分推荐。它的使用 github 上有，直接下面代码也能看懂。</p>
<h3 id="设计者需要考虑"><a href="#设计者需要考虑" class="headerlink" title="设计者需要考虑"></a>设计者需要考虑</h3><ul>
<li>买装备 （装备栏要注意固定）     </li>
<li>选择路线 （上中下随机，根据时间去具体的点）</li>
<li>如何攻击 （乱打）</li>
<li>何时回城 </li>
</ul>
<h3 id="使用者操作步骤"><a href="#使用者操作步骤" class="headerlink" title="使用者操作步骤"></a>使用者操作步骤</h3><ol>
<li>打开英雄联盟 训练模式或简单人机，选好英雄（建议寒冰）</li>
<li>所有的东西恢复默认设置，装备栏<strong>左上角对齐</strong></li>
<li>在命令行执行 <code>py lolAuto.py</code></li>
<li>切到游戏界面</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lolAuto.py</span></span><br><span class="line"><span class="keyword">import</span> keyboard <span class="keyword">as</span> kb </span><br><span class="line"><span class="keyword">import</span> mouse <span class="keyword">as</span> ms</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buyequipment</span><span class="params">(flag = True)</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    kb.send(<span class="string">'p'</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">if</span>(flag):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                ms.move(<span class="number">196</span><span class="number">-65</span>*j,<span class="number">695</span><span class="number">-125</span>*i)</span><br><span class="line">                ms.double_click()</span><br><span class="line">                sleep(<span class="number">0.12</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ms.move(<span class="number">64</span>,<span class="number">192</span>)</span><br><span class="line">        ms.double_click()</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    kb.send(<span class="string">'p'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span><span class="params">()</span>:</span></span><br><span class="line">    kb.send(<span class="string">'a'</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    ms.click()</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skill</span><span class="params">()</span>:</span></span><br><span class="line">    kb.send(choice(<span class="string">'qwer'</span>))</span><br><span class="line">    ms.click()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upgradeskill</span><span class="params">()</span>:</span></span><br><span class="line">    kb.press(<span class="string">'ctrl'</span>)</span><br><span class="line">    skill()</span><br><span class="line">    kb.release(<span class="string">'ctrl'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infield</span><span class="params">(road, direc)</span>:</span></span><br><span class="line">    x,y = road[<span class="number">0</span>][direc]</span><br><span class="line">    ms.move(x,y,<span class="literal">True</span>,<span class="number">0.2</span>)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    ms.click(<span class="string">'right'</span>)</span><br><span class="line">    kb.press(<span class="string">'space'</span>)</span><br><span class="line">    sleep(<span class="number">28</span>)</span><br><span class="line">    <span class="keyword">if</span>(direc != <span class="string">'mid'</span>): sleep(<span class="number">6</span>)</span><br><span class="line">    kb.release(<span class="string">'space'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myexit</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(event.name == <span class="string">'k'</span>): os._exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'Welcome lolAuto designed by dna049'</span>)</span><br><span class="line">    print(<span class="string">'请先打开LOL进入游戏，恢复默认设置，\n 然后把买装备的界面左上角对齐\n 再打开次应用'</span>)</span><br><span class="line">    print(<span class="string">'按 k 键 结束！'</span>)</span><br><span class="line">    kb.hook(myexit)</span><br><span class="line">    sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># road应该随着时间改变的！</span></span><br><span class="line">    road = [&#123;<span class="string">'top'</span>:[<span class="number">1687</span>,<span class="number">857</span>],<span class="string">'mid'</span>:[<span class="number">1776</span>,<span class="number">944</span>],<span class="string">'ad'</span>:[<span class="number">1864</span>,<span class="number">1034</span>]&#125;]</span><br><span class="line">    ms.click(<span class="string">'right'</span>)</span><br><span class="line">    kb.send(<span class="string">'space'</span>)</span><br><span class="line">    ms.move(<span class="number">960</span>,<span class="number">540</span>)</span><br><span class="line">    ms.click(<span class="string">'right'</span>)</span><br><span class="line">    buyequipment(<span class="literal">False</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    direc = choice([<span class="string">'top'</span>,<span class="string">'mid'</span>,<span class="string">'ad'</span>])</span><br><span class="line">    infield(road,direc)</span><br><span class="line">    start = timeB = timeE = timeS = datetime.now()</span><br><span class="line">    sleep(<span class="number">50</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        kb.press(<span class="string">'space'</span>)</span><br><span class="line">        x = <span class="number">1920</span> + randint(<span class="number">-150</span>,<span class="number">150</span>)</span><br><span class="line">        y = <span class="number">1080</span> + randint(<span class="number">-80</span>,<span class="number">80</span>)</span><br><span class="line">        ms.move(x//<span class="number">2</span>,y//<span class="number">2</span>,<span class="literal">True</span>,<span class="number">0.2</span>)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        kb.release(<span class="string">'space'</span>)</span><br><span class="line">        attack()</span><br><span class="line">        <span class="keyword">if</span>((datetime.now()-timeS).seconds &gt; <span class="number">5</span>):</span><br><span class="line">            skill()</span><br><span class="line">            timeS = datetime.now()</span><br><span class="line">            sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">if</span>((datetime.now()-timeE).seconds &gt; <span class="number">30</span>):</span><br><span class="line">            upgradeskill();upgradeskill()</span><br><span class="line">            timeE = datetime.now()</span><br><span class="line">            ms.move(road[<span class="number">0</span>][direc][<span class="number">0</span>],road[<span class="number">0</span>][direc][<span class="number">1</span>])</span><br><span class="line">            sleep(<span class="number">0.2</span>)</span><br><span class="line">            ms.click(<span class="string">'right'</span>)</span><br><span class="line">            sleep(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span>((datetime.now()-timeB).seconds &gt; <span class="number">240</span>):</span><br><span class="line">            kb.send(<span class="string">'s'</span>)</span><br><span class="line">            kb.send(<span class="string">'b'</span>)</span><br><span class="line">            kb.sleep(<span class="number">8</span>)</span><br><span class="line">            buyequipment()</span><br><span class="line">            timeB = datetime.now()</span><br><span class="line">            infield(road,direc)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Bye lolAuto designed by dna049'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为没法知道自己在哪，所以写的很捞。还有就是这是全局的鼠标键盘操作，而不是针对 LOL 的，哎就这样吧。</p>
</blockquote>
<h3 id="pywinio-安装和使用"><a href="#pywinio-安装和使用" class="headerlink" title="pywinio 安装和使用"></a>pywinio 安装和使用</h3><p>由于 pywinio 安装和使用贼搞人，在此写一下教程，先去 <a href="https://github.com/starofrainnight/pywinio" target="_blank" rel="noopener">这里</a> 下载源码，然后解压到：</p>
<p><code>C:\Users\Administrator\AppData\Local\Programs\Python\Python38\Lib\site-packages</code></p>
<p>打开 cmd 进入上述目录，依次安装 <a href="https://github.com/starofrainnight/pywinio/blob/master/requirements_dev.txt" target="_blank" rel="noopener">requirements_dev.txt</a> 中的依赖包，然后 <code>pip install -e ./pywinio-master</code> 就安装成功了。</p>
<p><strong>使用</strong>： 如果是 64 位操作系统（基本都是吧），管理员身份输入：</p>
<p><code>bcdedit.exe /set TESTSIGNING ON</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pywinio</span><br><span class="line">g_winio = pywinio.WinIO()</span><br><span class="line">print(g_winio.get_port_byte(<span class="number">0xA07</span>))</span><br></pre></td></tr></table></figure>
<p>运行上述代码，如果报错，可参考<a href="https://blog.csdn.net/bkk854762363/article/details/95319962" target="_blank" rel="noopener">这里</a></p>
<blockquote>
<p>好不容易安装好了，然后我也不会用，后来也没用了，辣鸡…</p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>butterfly 主题</title>
    <url>/butterfly/</url>
    <content><![CDATA[<p>再次换主题，一个月前（2020/7/20）看到了 Butterfly 主题，十分心动，知道前两天才开始换从 next 换到 Butterfly。Butterfly 主题真的太美了，现在看唯一的缺点就是不支持 <code>&lt;!-- more --&gt;</code> 标签。</p>
<p>一不小心又把 blog 文件夹删了，我吐了，正好写一下重新步骤</p>
<ol>
<li>安装 Hexo 并上传到 git 上 <a href="https://blog.csdn.net/grave2015/article/details/79961843" target="_blank" rel="noopener">这里超详细</a></li>
<li>拉取源代码</li>
<li><code>npm install</code> 更新依赖（配置国内镜像：<code>npm config set registry https://registry.npm.taobao.org</code>）</li>
<li>使用<a href="https://www.dazhuanlan.com/2020/01/30/5e322259a87e5/" target="_blank" rel="noopener">方案 2</a> 修改 <code>node_modules/nunjucks</code>，并且 搜索、RSS 插件同步修改。</li>
<li><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">mathjax 和 Hexo 的完美冲突解决方案</a></li>
<li>拉取自己 fork 的主题 <a href="https://github.com/chachabai/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a>，并复制 <code>_config.yml</code> 到 <code>source/_data/</code> 进行主题配置：<a href="https://www.antmoe.com/posts/75a6347a/index.html" target="_blank" rel="noopener">官方配置方法</a></li>
</ol>
<p>以下内容仅需配置一次（与主题无关，最多是在主题配置文件中填写一点数值）：</p>
<ol>
<li><a href="https://tab.leancloud.cn/data.html?appid=TkSRiW6UjDGmsxqmjPiPRjHV-9Nh9j0Va#/" target="_blank" rel="noopener">LeanCloud 管理数据</a> 并配置 Valine 和 Gitalk 双评论系统，<a href="https://blog.csdn.net/qq_33384402/article/details/107200465" target="_blank" rel="noopener">Gitalk 配置</a>， <a href="https://www.louxiaohui.com/2018/05/15/get-file-from-git-server-automatically/" target="_blank" rel="noopener">注意事项</a>，每一篇都要初始化一次。</li>
<li>添加文章加密功能，增加<a href="https://tding.top/archives/567debe0.html" target="_blank" rel="noopener">RSS 功能</a>，<a href="https://zhuanlan.zhihu.com/p/64457116" target="_blank" rel="noopener">RSS 使用说明</a>，文章置顶功能 </li>
</ol>
<h2 id="部署到-github"><a href="#部署到-github" class="headerlink" title="部署到 github"></a>部署到 github</h2><p>登录 <a href="https://github.com" target="_blank" rel="noopener">github</a> ，创建 yourname/yourname.github.io 仓库， 进入该仓库 setting，下拉到 Github Page</p>
<p>设置 master branch，Custom domain（可选），Enforce HTTPS</p>
<p>git 命令行进入 blog 目录，执行下面操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C yourmail@example.com <span class="comment">#建议不设置密码，按回车</span></span><br><span class="line">clip &lt; ~/.ssh/id_rsa.pub <span class="comment"># 复制公钥到系统粘贴板</span></span><br></pre></td></tr></table></figure>
<p>去 github 账号的 setting 中添加 ssh key（复制到 key 就可以了）</p>
<p>检测是否成功： <code>ssh -T git@github.com</code></p>
<p>设置全局用户信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name yourname</span><br><span class="line">git config --<span class="keyword">global</span> user.email  yourmail@example.com</span><br></pre></td></tr></table></figure>
<p>在 <code>_config.yml</code> （最后一行）设置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yourname/yourname.github.io.git</span><br></pre></td></tr></table></figure>
<p>执行：<code>npm install hexo-deployer-git --save</code></p>
<p>然后执行： <code>hexo g -d</code> 就可以去 <code>http(s)://yourname.github.io</code> 看到自己的博客了。</p>
<h3 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置 _config.yml"></a>配置 <code>_config.yml</code></h3><p>填写 site 信息， 设置 url ， 建议 permalink 改为 ：<code>title/</code>，设置 <code># Pagination</code> 下的 <code>per_page: 0</code>。</p>
<h3 id="配置主题，配好了修改-config-yml-的-theme-为当前主题"><a href="#配置主题，配好了修改-config-yml-的-theme-为当前主题" class="headerlink" title="配置主题，配好了修改 _config.yml 的 theme 为当前主题"></a>配置主题，配好了修改 <code>_config.yml</code> 的 theme 为当前主题</h3><h2 id="以下内容被作为源代码保存"><a href="#以下内容被作为源代码保存" class="headerlink" title="以下内容被作为源代码保存"></a>以下内容被作为源代码保存</h2><ul>
<li>源码：<code>./source</code></li>
<li>环境配置文件：<code>_config.yml</code>, <code>.gitignore</code>, <code>package.json</code>, <code>package-lock.json</code>, <code>README.md</code></li>
<li>更新源码脚本：<code>updateSourceCode.py</code></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>考虑代码的可迁移性，代码规范，多平台是一个好习惯。自己 fork 主题自己用，不把主题当作源码保存也是个好习惯。</p>
]]></content>
      <tags>
        <tag>Theme</tag>
      </tags>
  </entry>
  <entry>
    <title>计算器程序</title>
    <url>/calculatorWithC/</url>
    <content><![CDATA[<h2 id="计算器到处都有，有啥好写的呢"><a href="#计算器到处都有，有啥好写的呢" class="headerlink" title="计算器到处都有，有啥好写的呢"></a>计算器到处都有，有啥好写的呢</h2><p>我们在写程序时，对于长串计算，我们通常直接输入了，让计算机高级语言（例如 C++）给我们算就行了。但是，仔细想想这件事其实并不简单。</p>
<blockquote>
<p>最初想做这件事的原因是：我在大学想写一个带 GUI 界面的计算器，就在这里被卡住了。</p>
</blockquote>
<p>其实这是一个很有名的问题，大家有兴趣可以搜一下 <a href="http://baike.baidu.com/link?url=K67J7hWFkpdwOzjAA-nalFK4JqnnLI5TPtK1Dx7dOBn0P5WhAsq09j0e4qBI590vomEWc0w2gtCFWreeta0gr_" target="_blank" rel="noopener">逆波兰式</a></p>
<a id="more"></a>
<h2 id="逆波兰式"><a href="#逆波兰式" class="headerlink" title="逆波兰式"></a>逆波兰式</h2><p>逆波兰式即为后缀表达式，我们生活中算数表达式一般都是中序表达式。人类易于理解中序表达式，但计算机更容易处理后缀表达式。</p>
<h3 id="直奔解决方案"><a href="#直奔解决方案" class="headerlink" title="直奔解决方案"></a>直奔解决方案</h3><p>我们的做法基本分</p>
<ol>
<li>确定好符号集和它们的优先级</li>
<li>中序表达式转化成后缀表达式</li>
<li>根据后缀表达式得到最终结果</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7fffffff</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;    <span class="comment">//set priority level  </span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'='</span>||a==<span class="string">'('</span>)  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'+'</span>||a==<span class="string">'-'</span>)  <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'*'</span>||a==<span class="string">'/'</span>)  <span class="keyword">return</span> <span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getsuffixexpression</span><span class="params">(<span class="built_in">string</span> a)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ope;  </span><br><span class="line">    ope.push(<span class="string">'='</span>);  </span><br><span class="line">    <span class="built_in">string</span> ans;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=a.<span class="built_in">size</span>();++i)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=<span class="string">'0'</span>&amp;&amp;a[i]&lt;=<span class="string">'9'</span>)&#123;  </span><br><span class="line">            ans.push_back(a[i]);  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'('</span>)&#123;  </span><br><span class="line">            ope.push(<span class="string">'('</span>);  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">')'</span>)&#123;  </span><br><span class="line">            <span class="keyword">while</span>(!ope.empty()&amp;&amp;ope.top()!=<span class="string">'('</span>)&#123;  </span><br><span class="line">                ans.push_back(ope.top());  </span><br><span class="line">                ope.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            ope.pop();<span class="comment">// push left bracket  </span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]!=<span class="string">'+'</span>&amp;&amp;a[i]!=<span class="string">'-'</span>&amp;&amp;a[i]!=<span class="string">'*'</span>&amp;&amp;a[i]!=<span class="string">'/'</span>)&#123;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre(a[i])&gt;pre(ope.top()))&#123;  </span><br><span class="line">            ope.push(a[i]);  </span><br><span class="line">            ans.push_back(<span class="string">' '</span>);  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">while</span>(pre(a[i])&lt;=pre(ope.top()))&#123;  </span><br><span class="line">                ans.push_back(ope.top());  </span><br><span class="line">                ope.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            ope.push(a[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(ope.top()!=<span class="string">'='</span>)&#123;  </span><br><span class="line">        ans.push_back(ope.top());  </span><br><span class="line">        ope.pop();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="built_in">string</span> a)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> b=getsuffixexpression(a);  </span><br><span class="line">    <span class="keyword">if</span>(b.empty())   <span class="keyword">return</span> INF;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=b.<span class="built_in">size</span>();++i)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(b[i]==<span class="string">' '</span>)   <span class="keyword">continue</span>;  </span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=<span class="string">'0'</span>&amp;&amp;b[i]&lt;=<span class="string">'9'</span>)&#123;  </span><br><span class="line">            <span class="keyword">int</span> t=<span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">while</span>(i!=b.<span class="built_in">size</span>()&amp;&amp;b[i]&gt;=<span class="string">'0'</span>&amp;&amp;b[i]&lt;=<span class="string">'9'</span>)&#123;  </span><br><span class="line">                t=t*<span class="number">10</span>+b[i++]-<span class="string">'0'</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            --i;  </span><br><span class="line">            s.push(t);  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">int</span> x,y;  </span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;  </span><br><span class="line">                y=s.top();  </span><br><span class="line">                s.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;  </span><br><span class="line">                x=s.top();  </span><br><span class="line">                s.pop();  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">                <span class="keyword">return</span> INF;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">switch</span>(b[i])&#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:  </span><br><span class="line">                s.push(x+y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:  </span><br><span class="line">                s.push(x-y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:  </span><br><span class="line">                s.push(x*y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:  </span><br><span class="line">                s.push(x/y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> ans=s.top();  </span><br><span class="line">    s.pop();  </span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> ans;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> INF;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> a;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(getans(a)!=INF)&#123;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;getans(a)&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Calculator</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 计算 LOL 中猫咪状态数</title>
    <url>/catWithPy/</url>
    <content><![CDATA[<p>我们知道在 LOL（英雄联盟）中，猫咪是可以进入队友身体的，如果 LOL 再出 5V5 克隆模式（<del>我猜不可能</del>），如果某一方选了猫咪这个英雄，场面上会有多少种状态呢（不考虑死亡）？</p>
<blockquote>
<p>这个问题在 2019 年 5 月猫咪刚出来的时候就在 <strong>好好做人群</strong> 讨论并给出了结论，只是没写成程序</p>
</blockquote>
<a id="more"></a>
<p>答案是：1296 （可以先拉到最后）</p>
<h2 id="问题数学化"><a href="#问题数学化" class="headerlink" title="问题数学化"></a>问题数学化</h2><p>每只猫可以进入其他猫咪的身体，求（我们更关心 $a_n$）：</p>
<ul>
<li><p>$n$ 只不同的猫咪，会有 $a_n$ 种状态</p>
</li>
<li><p>$n$ 只相同的猫咪，会有 $b_n$ 种状态</p>
</li>
</ul>
<p>我们想要得到 $a_n$ 和 $b_n$ 的表达式或者递推公式，然后写程序求 $a_n, b_n$ </p>
<blockquote>
<p>为了方便，我们约定 $a_0 = b_0 = 1$</p>
</blockquote>
<h2 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h2><p>我们可以根据能看到的猫咪数量 $r$ ，来分情况讨论，</p>
<blockquote>
<p>我们先考虑相同猫咪的情况，<del>简单一点</del>  <strong>下面分析全错！！！</strong></p>
</blockquote>
<p>例如，如果 $r=1$，那么其它猫咪都进入了某一只猫咪的身体，有 $b_{n-1}$ 种情况，类似的我们其实可以得到如下公式：</p>
<script type="math/tex; mode=display">
b_n = \sum_{r = 1} ^n \sum _{\begin{array}{c}x_1 + x_2 + \cdots + x_r = n \\ 1 \leq x_1 \leq x_2 \leq \cdots \leq x_r \end{array}} b_{x_1 -1} \cdots b_{x_r -1}</script><blockquote>
<p>$r$ 只可见的猫，分别真实包含了 $x_1, \cdots, x_r$ 只猫，而这 $x_i$ 只猫有一个在最外面，所以它的内部有 $b_{x_i - 1}$ 种可能。</p>
</blockquote>
<p>$b_1 = 1, b_2 = 2$ 是显然的。我们来计算$b_3, b_4, b_5$</p>
<p>$3 = 1+2 = 1 \times 3$，所以 </p>
<script type="math/tex; mode=display">
b_3 = b_2 + b_1 + 1= 4</script><p>$4 = 1+3 = 2+2 = 1+1+2 = 1 \times 4$, 所以</p>
<script type="math/tex; mode=display">
b_4 = b_3 + b_2 + b_1 \times b_1 + b_1 +1 = 9</script><p>类似的对 5 做分解可知：</p>
<script type="math/tex; mode=display">
b_5 = b_4 + b_3 + b_1 \times b_2 + b_2 + b_1 ^2 + b_1 + 1 =20</script><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正整数拆分 n = x_1 + x_2 + ... + x_r, 且 x_i &gt;= low</span></span><br><span class="line"><span class="comment">#low 表示递归的时候最小取值</span></span><br><span class="line"><span class="comment">#ans 保存递归得到的前部分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naturalcut</span><span class="params">(n, r, low, ans = [])</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> r &lt;= <span class="number">1</span>: </span><br><span class="line">        <span class="keyword">yield</span> ans+[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(low, <span class="number">1</span> + n//r):</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> naturalcut(n-i, r<span class="number">-1</span>, i, ans +[i])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allcut</span><span class="params">(n)</span>:</span></span><br><span class="line">    b = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">        b += list(naturalcut(n,i,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面两个函数和后面代码出现两个类似的函数完全是一致的，只是表现形式不一样</span></span><br><span class="line"><span class="comment"># 上面的简单明了，后面的效率更高一点，所以两个都保存了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbn</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    bn=[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">        bn.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> allcut(t):</span><br><span class="line">            product = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">                product *= bn[i<span class="number">-1</span>]</span><br><span class="line">            bn[<span class="number">-1</span>] += product</span><br><span class="line">    <span class="keyword">return</span> bn</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,x <span class="keyword">in</span> enumerate(getbn(<span class="number">8</span>)):</span><br><span class="line">    print(str(i)+<span class="string">'只相同猫咪有 '</span>+ str(x)+<span class="string">'种状态'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们现在考虑不同猫咪的情况</p>
</blockquote>
<p>我们依然根据猫咪在场上的数量 $p_1 + \cdots +p_r$ ，对猫咪进行讨论，则有</p>
<script type="math/tex; mode=display">
a_n = \sum _{r = 1} ^ n \sum _{\begin{array}{c} x_1 p_1 + \cdots + x_r p_r = n \\ 0 < x_1  < \cdots < x_r\end{array}} n! \prod _{i=1}^r  \frac{x_i ^{p_i} a_{x_i -1}^{p_i}}{ (x_i !)^{p_i} p_i!}</script><blockquote>
<p>真实包含了 $x_i$ 只猫的猫有 $p_i$ 只 (这也是为什么$x_i$ 严格递增)，</p>
<p>$x_i^{p_i}$  ：每只猫都要选择一个出来当最外面的猫</p>
<p>$a_{x_i - 1}^{p_i}$ ： 去掉最外面的猫，里面有 $x_i - 1$ 只猫</p>
<p>最后一个式子，经典排位组合问题就不提了。</p>
</blockquote>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正整数拆分 n = x_1p_1 + ... + x_rp_r, 且 low&lt;=x_1&lt;...&lt;x_r</span></span><br><span class="line"><span class="comment">#low 表示递归的时候最小取值</span></span><br><span class="line"><span class="comment">#ans 保存递归得到的前部分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naturalcuts</span><span class="params">(n, r, low, ans = [])</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> r == <span class="number">1</span>: </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n//low):</span><br><span class="line">            <span class="keyword">if</span> n%i == <span class="number">0</span>:	<span class="keyword">yield</span> ans + [(n//i,i)]</span><br><span class="line">    <span class="keyword">elif</span> r &gt;<span class="number">1</span>:</span><br><span class="line">        x = n - r*(r<span class="number">-1</span>)//<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(low, <span class="number">1</span> + x//r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, x//i - r +<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> naturalcuts(n-i*j,r<span class="number">-1</span>,i+<span class="number">1</span>,ans + [(i,j)])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allcuts</span><span class="params">(n)</span>:</span></span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">        a += list(naturalcuts(n,i,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getan</span><span class="params">(n)</span>:</span></span><br><span class="line">    an = [<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">        an.append(<span class="number">0</span>)</span><br><span class="line">        factn = math.factorial(t)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> allcuts(t):</span><br><span class="line">            product = factn</span><br><span class="line">            <span class="keyword">for</span> x,p <span class="keyword">in</span> item:</span><br><span class="line">                product //= math.factorial(x)**p</span><br><span class="line">                product //= math.factorial(p)</span><br><span class="line">                product *= an[x<span class="number">-1</span>]**p</span><br><span class="line">                product *= x**p</span><br><span class="line">            an[<span class="number">-1</span>] += product</span><br><span class="line">    <span class="keyword">return</span> an</span><br><span class="line"></span><br><span class="line">print(getan(<span class="number">10</span>))	<span class="comment">#9只不同猫咪状态数是 100000000（正好一亿）!!! 这也太整了吧</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码能如此简洁多亏了，Python 的这个生成器写法太优美了！！！</p>
</blockquote>
<p>当然了，如果只是 5 只猫咪，那我们其实也可以枚举出所有情况得到 $a_n = 1296, b_n = 20$：</p>
<p><img src= "/img/loading.gif" data-lazy-src="0.png" alt="0"></p>
<h2 id="以下内容更新于-2020-3-17"><a href="#以下内容更新于-2020-3-17" class="headerlink" title="以下内容更新于 2020/3/17"></a>以下内容更新于 2020/3/17</h2><p>在和我大学同学 <strong>祺祺</strong> 讨论之后，他猜测 $a_n = (n+1)^{n-1}$，一开始我是不相信的，不过数据对比之后发现，卧槽，秀啊。所以说明有一种更优美的理解：</p>
<p>假定 LOL 峡谷地图实际上在一只超大的$0$ 号猫咪肚子里面，那么这些猫咪就构成了以$0$为根的树，我们求得这$n+1$个（有编号）节点无根树个数，然后我们把$0$号节点变成根，就得到了我们所有的状态。</p>
<blockquote>
<p><a href="http://oeis.org/A000273" target="_blank" rel="noopener">$n$ 个节点的无根树个数是$n^{n-2}$</a>，最早于 A.Cayley 在 1889 年首先公布并证明（现在看来不算严谨的证明），后来有了树的 Prufer 编码，就可以漂亮的解决证明这个问题了。可参考 <a href="http://www.matrix67.com/blog/archives/682" target="_blank" rel="noopener">Matrix67 的博客</a> 或下面说明</p>
</blockquote>
<h3 id="Prufer-编码"><a href="#Prufer-编码" class="headerlink" title="Prufer 编码"></a><a href="https://baike.baidu.com/item/prufer数列/2182091?fr=aladdin" target="_blank" rel="noopener">Prufer 编码</a></h3><p>$n$ 个节点的无根树（也就是简单无向图），可以唯一的给出一个长度为 $n-2$ 的编码，同样每一个长为 $n-2$ 的编码都可以唯一的产生一棵 $n$ 个节点的无根树 （这就证明了上面结论）</p>
<p>给定一颗 $n&gt;2$ 个节点的无根树，每次找出无根树中，度数为 $1$ 的节点中编号最小的节点 $A$，记录节点 $A$ 的邻接点，然后删除节点 $A$ 和它的边。这样一直继续下去，直到只剩下两个节点。</p>
<blockquote>
<p>度数为 $i$ 的节点恰好在 Prufer 编码中出现 $i-1$ 次</p>
</blockquote>
<p>给你一个长度为 $n-2$ 的 Prufer 编码，我们只要找出 <strong>没有在当前编码中最小的</strong> 跟编码中第一个节点相连即可。重复下去即可得到无根树。</p>
<h3 id="后来我发现，我-b-n-算错了！！！，因为很多情况算重复了，为了算-b-n"><a href="#后来我发现，我-b-n-算错了！！！，因为很多情况算重复了，为了算-b-n" class="headerlink" title="后来我发现，我$b_n$ 算错了！！！，因为很多情况算重复了，为了算$b_n$"></a>后来我发现，我$b_n$ 算错了！！！，因为很多情况算重复了，为了算$b_n$</h3><script type="math/tex; mode=display">
b_n = \sum _{r = 1} ^ n \sum _{\begin{array}{c} x_1 p_1 + \cdots + x_r p_r = n \\ 0 < x_1  < \cdots < x_r\end{array}} \prod_{i = 1} ^ r {b_{x_i - 1}+p_i -1 \choose p_i}</script><p>上述公式包括 <strong>正整数拆分</strong> 和 <strong>给相同的球染色问题</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#正整数拆分 n = x_1p_1 + ... + x_rp_r, 且 low&lt;=x_1&lt;...&lt;x_r</span></span><br><span class="line"><span class="comment">#low 表示递归的时候最小取值</span></span><br><span class="line"><span class="comment">#ans 保存递归得到的前部分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naturalcuts</span><span class="params">(n, r, low, ans = [])</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> r == <span class="number">1</span>: </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n//low):</span><br><span class="line">            <span class="keyword">if</span> n%i == <span class="number">0</span>:	<span class="keyword">yield</span> ans + [(n//i,i)]</span><br><span class="line">    <span class="keyword">elif</span> r &gt;<span class="number">1</span>:</span><br><span class="line">        x = n - r*(r<span class="number">-1</span>)//<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(low, <span class="number">1</span> + x//r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, x//i - r +<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> naturalcuts(n-i*j,r<span class="number">-1</span>,i+<span class="number">1</span>,ans + [(i,j)])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allcuts</span><span class="params">(n)</span>:</span></span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">        a += list(naturalcuts(n,i,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbn</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    bn=[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+n):</span><br><span class="line">        bn.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> allcuts(t):</span><br><span class="line">            product = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x,p <span class="keyword">in</span> item:</span><br><span class="line">                product *= math.comb(bn[x<span class="number">-1</span>]+p<span class="number">-1</span>,p)</span><br><span class="line">            bn[<span class="number">-1</span>] += product</span><br><span class="line">    <span class="keyword">return</span> bn</span><br><span class="line"></span><br><span class="line">print(getbn(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://oeis.org/A000081" target="_blank" rel="noopener">这正好是 $n+1$ 个无编号的有根树个数</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Math</tag>
        <tag>LOL</tag>
      </tags>
  </entry>
  <entry>
    <title>Cayley-Hamilton 定理</title>
    <url>/cayleyHamiltonTheorem/</url>
    <content><![CDATA[<p>大一学了矩阵之后，一直很喜欢它，因为它形式简洁优美，又不缺乏技巧，是抽象和具体的桥梁，又有其实用性，成为现代数学最基础的工具之一。个人认为，矩阵中最优美的定理非 Cayley-Hamilton 定理（矩阵的特征多项式是它的一个化零多项式）莫属了。</p>
<blockquote>
<p>交换环上的矩阵都有 Cayley-Hamilton 定理成立</p>
</blockquote>
<a id="more"></a>
<p>详细表述和证明如下：</p>
<script type="math/tex; mode=display">
\phi(\lambda)=det(\lambda I - A) = a_n \lambda^n + \cdots + a_1 \lambda + a_0</script><p>设$\lambda I - A$的 <a href="https://baike.baidu.com/item/%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5/10034983?fr=aladdin" target="_blank" rel="noopener">伴随矩阵</a> 为 $B$，则$B$中元素为关于 $\lambda$ 的次数小于 $n$ 的多项式，不妨设</p>
<script type="math/tex; mode=display">
B = \lambda^{n-1} B_ {n-1} + \cdots + \lambda B_1 + B_0</script><p>所以</p>
<script type="math/tex; mode=display">
(\lambda I - A)B = \lambda^n B_ {n-1} + \lambda^{n-1} (B_ {n-2} - AB_ {n-1})
+ \cdots + \lambda (B_0 - AB_1) - AB_0</script><p>又因为 $B$ 是 $A$ 的伴随矩阵，我们有 $(\lambda I - A)B = det(\lambda I - A) I$</p>
<p>比较系数得到：</p>
<script type="math/tex; mode=display">
\left\{ 
\begin{array}{l} 
B_ {n-1} = a_n I \\
B_ {n-2} - AB_ {n-1} = a_{n-1} I \\
\cdots \\
B_0 - AB_1 = a_1 I \\
-AB_0 = a_0 I
\end{array} \right.</script><p>对上式分别左乘$ A^n,A^{n-1},\cdots,A,I$得到：</p>
<script type="math/tex; mode=display">
\left\{ 
\begin{array}{l} 
A^n B_ {n-1} = a_n A^n \\
A^{n-1} B_ {n-2} - A^n B_ {n-1} = a_{n-1} A^{n-1} \\
\cdots \\
A B_0 - A^2 B_1 = a_1 A \\
-AB_0 = a_0 I
\end{array} \right.</script><p>再将上式相加得到最终结果</p>
<script type="math/tex; mode=display">
\phi(A)= a_ n A^n + a_{n-1} A^{n-1} + \cdots + a_1 A +
a_0 I = \mathbf{0}</script><p>上述定理优美在于从形式上，$\phi(\lambda)=det(\lambda I - A)$ 取 $\lambda = A$ 带入恰好也是 0（注意数字 0 和零矩阵的差别）<strong>虽然说这样做是完全没有道理</strong>。作为直接推论我们知道，一个 $n$ 阶方阵的任何次方都可以被它的不超过 $n$ 次的幂线性表出。</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
        <tag>特征多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理</title>
    <url>/chineseRemainTheorem/</url>
    <content><![CDATA[<p>仅以此博文，感谢知乎好友 <a href="https://www.zhihu.com/people/li-yong-xiang-38" target="_blank" rel="noopener">Vivr0</a> </p>
<p>中国剩余定理也称孙子定理，是中国古代求解一次同余方程组的方法。</p>
<a id="more"></a>
<p>用现代的语言来说就是：</p>
<script type="math/tex; mode=display">
x \equiv
\left\{ 
\begin{array}{cc}
a_1 \mod m_1 \\
a_2 \mod m_2 \\
\vdots \\
a_n \mod m_n
\end{array}
\right.</script><p>且正整数组 $m_i$ 两两互素，则对任意整数组 $a_i$，上述方程有解，解可以写成 $x \equiv a \mod m$</p>
<p>我们不要求 $m_i$ 两两互素也能求解，只是不一定有解，下面详细给出做法。</p>
<p>我们先考虑 $n=2$ 的情形。即 </p>
<script type="math/tex; mode=display">
x \equiv
\left\{
\begin{array}{cc}
a_1 \mod m_1 \\
a_2 \mod m_2
\end{array}
\right.</script><p>我们可以把方程写成</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{lll}
x - a_1 & \equiv \; 0  & \mod m_1 \\
x - a_1 & \equiv \; a_2-a_1 & \mod m_2
\end{array}
\right.</script><p>我们设 $d = \gcd(m_1,m_2)$，则 $d| x-a_1$ 又 $d|m_2$，所以  $d|a_2-a_1$。</p>
<blockquote>
<p>我们知道对任意正整数 $a,b$,  存在整数 $x, y$ 使得 $xa + yb = \gcd(a,b)$。</p>
<p>(最后 Python 代码注释中有给出 $x, y$ 的详细操作)</p>
</blockquote>
<p>存在 $t_1, t_2$ 使得 $m_1 t_1 + m_2 t_2 = gcd(m_1, m_2) = d$，所以</p>
<script type="math/tex; mode=display">
x-a_1 \equiv \frac{a_2-a_1}{d} (m_1t_1 + m_2t_2) \equiv \frac{a_2-a_1}{d} t_1 m_1 \mod m_2</script><p>即 $x \equiv a \mod m$，其中 $a=  a_1 + \frac{a_2-a_1}{d} t_1m_1 = \frac{t_2m_2a_1+t_1m_1a_2}{d}$，$m = lcm(m_1,m_2) = \frac{m_1m_2}{d}$ </p>
<blockquote>
<p>$n-1$ 次上述操作，就处理了一般情况</p>
</blockquote>
<h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a>C++ 代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL&amp; x,LL&amp; y)</span></span>&#123;  <span class="comment">// ax + by = gcd(a,b)</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL d=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;LL,LL&gt; crt2(LL a1,LL m1,LL a2,LL m2)&#123; // x = ai mod mi, m_i &gt;0</span><br><span class="line">    LL t1,t2,ans = a2-a1;</span><br><span class="line">    LL d = exgcd(m1,m2,t1,t2);</span><br><span class="line">    assert(ans%d == <span class="number">0</span>);</span><br><span class="line">    LL m = m1/d*m2;</span><br><span class="line">    ans = (a1+ans/d*t1%m2*m1)%m; <span class="comment">// %m2 是避免溢出</span></span><br><span class="line">    <span class="keyword">return</span> make_pair(ans&gt;<span class="number">0</span>?ans:ans+m,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span>;</span><br><span class="line">LL a[N],m[N];</span><br><span class="line">pair&lt;LL,LL&gt; crt(int n)&#123; // x = a[i] mod m[i], m[i] &gt;0</span><br><span class="line">    pair&lt;LL,LL&gt; ans = make_pair(a[<span class="number">0</span>]%m[<span class="number">0</span>],m[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        ans = crt2(ans.first,ans.second,a[i],m[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL a1,m1,a2,m2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a1&gt;&gt;m1&gt;&gt;a2&gt;&gt;m2)&#123;</span><br><span class="line">        LL ans = crt2(a1,m1,a2,m2).first;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>((ans-a1)%m1 || (ans-a2)%m2)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"something wrong"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># input : a,b natural number</span></span><br><span class="line"><span class="comment"># output: [gcd(a,b), x, y]</span></span><br><span class="line"><span class="comment"># ax + by = gcd(a,b)</span></span><br><span class="line"><span class="comment"># Algorithm: b(a//bx+y) + a%bx = gcd(b,a%b) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exgcd</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>): <span class="keyword">return</span> [a,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    [d,y,x] = exgcd(b,a%b)</span><br><span class="line">    <span class="keyword">return</span> [d,x,y-a//b*x]</span><br><span class="line"></span><br><span class="line"><span class="comment"># input:  x = ai mod m_i, mi&gt;0, i=1,2</span></span><br><span class="line"><span class="comment"># output: x = a mod m</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crt2</span><span class="params">(a1,m1,a2,m2)</span>:</span></span><br><span class="line">    [d,t1,t2] = exgcd(m1,m2)</span><br><span class="line">    a,m = a2-a1,m1//d*m2</span><br><span class="line">    <span class="keyword">if</span>(a%d):  <span class="keyword">raise</span> ValueError(<span class="string">'No solution to crt problem'</span>)</span><br><span class="line">    <span class="keyword">return</span> [(a1+a//d*t1*m1)%m,m]</span><br><span class="line"></span><br><span class="line"><span class="comment"># input:  x = ai mod m_i, mi&gt;0</span></span><br><span class="line"><span class="comment"># output: x = a mod m</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crt</span><span class="params">(a,m)</span>:</span></span><br><span class="line">    n = len(a)</span><br><span class="line">    <span class="keyword">if</span>(len(m)!=n):  <span class="keyword">raise</span> ValueError(<span class="string">'a and m must have equal length'</span>)</span><br><span class="line">    aa,mm = a[<span class="number">0</span>],m[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        [aa,mm] = crt2(aa,mm,a[i],m[i])</span><br><span class="line">    <span class="keyword">return</span> [aa,mm]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    [a,m]=crt([<span class="number">2</span>,<span class="number">-4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>])</span><br><span class="line">    print(a,m)</span><br><span class="line">    [a,m]=crt([<span class="number">2</span>,<span class="number">-4</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>])</span><br><span class="line">    print(a,m)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>根号复杂度的算法</title>
    <url>/algorithmsOfRootComplex/</url>
    <content><![CDATA[<p>ACMer 考虑算法时总会优先考虑时间复杂度，这里介绍几个优美的根号复杂度的算法</p>
<a id="more"></a>
<h2 id="s-n-sum-i-1-n-lfloor-frac-n-i-rfloor"><a href="#s-n-sum-i-1-n-lfloor-frac-n-i-rfloor" class="headerlink" title="$s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor$"></a>$s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor$</h2><p>由于 $\lfloor \frac{n}{i} \rfloor$ 的取值个数不会超过 $2\sqrt{n}$，所以可能存在 $O(\sqrt{n})$ 的算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(LL n)</span></span>&#123; <span class="comment">// The code is simple and easy to understand</span></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123; </span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        sum += (j-i+<span class="number">1</span>)*(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上， $s(n)$ 表示图像 $xy=1$ 下方正整点的个数</p>
</blockquote>
<h2 id="sigma-k-n-sum-d-n-d-k"><a href="#sigma-k-n-sum-d-n-d-k" class="headerlink" title="$\sigma_k(n) = \sum_{d|n} d^k$"></a>$\sigma_k(n) = \sum_{d|n} d^k$</h2><ol>
<li>$\sigma_0(n)$ 表示正因子个数</li>
<li>$\sigma_1(n)$ 表示正因子之和</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mypow</span><span class="params">(LL x,LL n)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=x*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getr</span><span class="params">(LL n,LL k)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">0</span>,d;</span><br><span class="line">    <span class="keyword">for</span>(d=<span class="number">1</span>;d*d&lt;n;++d)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%d==<span class="number">0</span>)  r += mypow(d,k) + mypow(n/d,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d*d == n) r+=mypow(d,k);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="f-k-n-sum-i-1-n-sigma-k-i"><a href="#f-k-n-sum-i-1-n-sigma-k-i" class="headerlink" title="$f_k(n) = \sum_{i=1}^n \sigma_k(i)$"></a>$f_k(n) = \sum_{i=1}^n \sigma_k(i)$</h2><script type="math/tex; mode=display">
f_k(n) = \sum_{i=1}^n \sigma_k(n) =
\sum_{i=1}^n \sum_{d|i} d^k = 
\sum_{d=1} d^k \sum_i ^n[d|i] =
\sum_{d=1} ^n d^k \lfloor \frac{n}{d} \rfloor</script><p>如果我们已经得到 $ts[n] = \sum_{i=1}^n i^k$ 类似问题一，我们有以下 C++ 代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getf</span><span class="params">(LL n)</span></span>&#123;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123; </span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        sum += (ts[j]-ts[i<span class="number">-1</span>])*(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上我们有：</p>
<script type="math/tex; mode=display">
ts[n] = \left \lbrace 
\begin{array}{ll}
\frac{n(n+1)}{2} & k=1 \\
\frac{n(n+1)(2n+1)}{6} & k=2 \\
\frac{n^2(n+1)^2}{4} & k=3 \\ 
\end{array} \right.</script><p>更一般的我们有</p>
<script type="math/tex; mode=display">
1^p+2^p+ \dots + n^p = \sum _{k=1} ^p \; (\; \sum_{j=1} ^ {k} (-1)^{k-j} C_k^j j^p \;) \; C _{n+1} ^{k+1}</script><a href="/formulaOfPowSumOfNaturalNumber/" title="参考我的这篇博文">参考我的这篇博文</a>
<h2 id="g-n-sum-i-1-n-psi-i"><a href="#g-n-sum-i-1-n-psi-i" class="headerlink" title="$g(n) = \sum_{i=1}^n\psi(i)$"></a>$g(n) = \sum_{i=1}^n\psi(i)$</h2><p>这里 $\psi(n)$  是欧拉函数表示小于 $n$ 且和 $n$ 互素的数的个数。<br>Euler’s 乘积公式: </p>
<script type="math/tex; mode=display">
\psi(n) = n \prod _{p|n}( 1-\frac{1}{p} )</script><p>我们现在开始计算 $g(n)$</p>
<script type="math/tex; mode=display">
g(n) = \sum_{i=1}^n \psi(i) = \sum_{1 \leq x \leq y \leq n , \gcd(x,y)=1} 1</script><p>我们定义</p>
<script type="math/tex; mode=display">
g_k(n) = \sum_{i=1}^n \psi(i) = \sum_{1 \leq x \leq y \leq n , \gcd(x,y)=k} 1 = f_0(\lfloor \frac{n}{k} \rfloor)</script><p>并且 $\sum_{i=1}^n g_k(i) = \sum_{1 \leq x \leq y \leq n} 1 = \frac{n(n+1)}{2}$ ，于是我们知道</p>
<script type="math/tex; mode=display">
g(n) = \frac{n(n+1)}{2} - \sum_{k=2}^n f_0(\lfloor \frac{n}{k} \rfloor)</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000006</span>;</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">-1</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;ans[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;N&amp;&amp;ans[n]!=<span class="number">-1</span>) <span class="keyword">return</span> ans[n];</span><br><span class="line">    LL r = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        r -= (j-i+<span class="number">1</span>)*getans(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;N) ans[n]=r;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Problem-hdu5608"><a href="#Problem-hdu5608" class="headerlink" title="Problem hdu5608"></a>Problem hdu5608</h2><p>已知 $n^2 -3n+2 = \sum_{d|n} f(d) $ 计算 $ h(n) = \sum_{i=1}^n f(i) \; mod \; 10^9+7$</p>
<p>由于</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{d|i} f(d) = \sum_{i=1}^n f(i) \lfloor \frac{n}{i} \rfloor =  \sum_{i=1}^n h(\lfloor \frac{n}{i} \rfloor)</script><p>我们知道</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \sum_{d|i} f(d) = \sum_{i=1}^n i^2-3i+2 = \sum_{i=1}^n (i-1)(i-2) = \frac{n(n-1)(n-2)}{3}</script><p>所以</p>
<script type="math/tex; mode=display">
h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m+1,r,rrt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000006</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv3 = (M+<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        ans[i] = LL(i<span class="number">-1</span>)*(i<span class="number">-2</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;  <span class="comment">// Pretreatment acceleration</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i&lt;&lt;<span class="number">1</span>;j&lt;N;j+=i)&#123;</span><br><span class="line">            ans[j] -= ans[i];</span><br><span class="line">            <span class="keyword">if</span>(ans[j] &lt; <span class="number">0</span>) ans[j] += M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        ans[i] += ans[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(ans[i] &gt; M)  ans[i] -= M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(n&lt;N) <span class="keyword">return</span> ans[n];</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(n); <span class="comment">//Memory search</span></span><br><span class="line">    <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>())  <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">int</span> r = LL(n)*(n<span class="number">-1</span>)%M*(n<span class="number">-2</span>)%M*inv3%M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        r -= LL(j-i+<span class="number">1</span>)*getans(n/i)%M;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) r+=M;</span><br><span class="line">    &#125;</span><br><span class="line">    mp.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(n,r));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;getans(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>感谢 <a href="http://zimpha.github.io" target="_blank" rel="noopener">Zimpha</a> 提出上述算法</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>经典组合问题</title>
    <url>/classicalCombination/</url>
    <content><![CDATA[<p>在此记录一些经典的组合问题，方便日后查阅。</p>
<blockquote>
<p>卡特兰数，斯特林数，放球问题</p>
</blockquote>
<a id="more"></a>
<h2 id="卡特兰（Catalan-）数"><a href="#卡特兰（Catalan-）数" class="headerlink" title="卡特兰（Catalan ）数"></a><a href="https://baike.baidu.com/item/卡特兰数/6125746?fr=aladdin" target="_blank" rel="noopener">卡特兰（Catalan ）数</a></h2><p>$n$ 个 0 和 $n$ 个 1 组成的序列中始终要保持 <strong>任意前缀中</strong> 0 的个多不超过 1 的个数的序列个数为 $\frac{1}{n+1} {2n \choose n }$</p>
<blockquote>
<p>这个问题跟括号合理性等一系列问题合理性有关。</p>
</blockquote>
<p>$n$ 个 0 和 $m$ 个 1 组成的序列（$n \leq m$) 保持 <strong>任意前缀中</strong> 0 的个数不超过 1 的个数的序列个数为：</p>
<script type="math/tex; mode=display">
{n+m \choose n} - {n+m \choose n-1}</script><blockquote>
<p>把 0 当 $x$-轴，1 当 $y$-轴，不合理的情况必然经过 $y = x+1$, 在第一次不合理时，后面的路径就开始与 $y = x +1$ 对称，最终结束点为 $(n-1, m+1)$</p>
</blockquote>
<h2 id="斯特林（Stirling）数"><a href="#斯特林（Stirling）数" class="headerlink" title="斯特林（Stirling）数"></a><a href="https://baike.baidu.com/item/斯特林数" target="_blank" rel="noopener">斯特林（Stirling）数</a></h2><p>关于这个问题可以参考 <a href="https://www.cnblogs.com/gzy-cjoier/p/8426987.html" target="_blank" rel="noopener">这篇博客</a></p>
<blockquote>
<p>第一类斯特林数等到以后用到了再写吧</p>
</blockquote>
<p>第二类斯特林数： 将 $n$ 个不同的元素拆分成 $m$ 个非空集合的方案数 $S(n,m)$。显然有递推关系式：</p>
<script type="math/tex; mode=display">
S(n,m) = S(n-1,m-1)+mS(n-1,m)</script><p>又我们知道：</p>
<script type="math/tex; mode=display">
m^n = \sum _{i=0} ^ m S(n,i) \times i! \times {n \choose i}</script><p>将 $n$ 个任意的放在 $m$ 个不同盒子中。右边的枚举非空盒子数量 $i$，$i$ 个盒子因为是不同的所以要乘 $i!$ （不用担心算多了，因为一旦分配好了，盒子本身即使无区别，放了东西就有区别了）<br><a href="/inverseFormulaAndItsMatrixForm/" title="从我的这篇博文">从我的这篇博文</a> 直接可知 (把 $n$ 看作常数）：</p>
<script type="math/tex; mode=display">
S(n,m) m! = \sum_{i=0}^m (-1)^{m-i} {n \choose i} i^n</script><p>改写成大家通常见到的形式也就是：</p>
<script type="math/tex; mode=display">
S(n,m)  = \frac{1}{m!} \sum_{i=0}^m (-1)^{i} {n \choose i} (m-i)^n</script><blockquote>
<p>补充：知乎上 <a href="https://www.zhihu.com/people/hzy-46-50" target="_blank" rel="noopener">Hongzy</a> 写了一篇 <a href="https://zhuanlan.zhihu.com/p/150779987" target="_blank" rel="noopener">斯特林数入门</a> 的文章，写的甚好。</p>
</blockquote>
<h2 id="正整数分拆数"><a href="#正整数分拆数" class="headerlink" title="正整数分拆数"></a>正整数分拆数</h2><p>将正整数 $n$ 拆分成 $m$ 个非负整数之和的方案数 $f(n,m)$：</p>
<script type="math/tex; mode=display">
f(n,m) = \left\{ \begin{array}{lr} 
1 & n=m=1 \\
f(n,n) & n<m \\
1+f(n,n-1) & n=m \\
f(n,m-1)+f(n-m,m) & n>m>1 
\end{array} \right.</script><h2 id="正整数分拆成乘积数"><a href="#正整数分拆成乘积数" class="headerlink" title="正整数分拆成乘积数"></a><a href="https://oeis.org/A001055" target="_blank" rel="noopener">正整数分拆成乘积数</a></h2><p>记 $fcnt(n,m)$ 表示 $n$ 的乘法分解都不超过 $m$ 的数</p>
<script type="math/tex; mode=display">
fcnt(n,m) = \sum_{d|n} [d<=m] fcnt(\frac{n}{d},d)</script><ul>
<li>打表时间复杂度 $O(n^{\frac{5}{2})}$，空间复杂度 $O(n^2)$ 不推荐！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10004</span>;</span><br><span class="line"><span class="keyword">int</span> fcnt[N][N]; <span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFcnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)  fcnt[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> sn = <span class="built_in">sqrt</span>(i+<span class="number">0.2</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>;d&lt;=sn;++d)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = N<span class="number">-1</span>;j&gt;=d;--j)  fcnt[i][j]+=fcnt[i/d][d];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=N<span class="number">-1</span>;j&gt;=i/d;--j)  fcnt[i][j]+=fcnt[d][i/d];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sn*sn == i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = N<span class="number">-1</span>;j&gt;=sn;--j)  fcnt[i][j]-=fcnt[sn][sn];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFcnt</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fcnt[<span class="number">1</span>][<span class="number">1</span>] != <span class="number">1</span>) initFcnt();</span><br><span class="line">    <span class="keyword">return</span> fcnt[n][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;getFcnt(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归 （推荐复杂度不好分析）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcnt</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sn = <span class="built_in">sqrt</span>(n+<span class="number">0.2</span>),ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>;d&lt;=sn;++d)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%d)  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(d&lt;=m &amp;&amp; d&gt;<span class="number">1</span>)  ans += fcnt(n/d,d);</span><br><span class="line">        <span class="keyword">if</span>(n/d&lt;=m) ans+= fcnt(d,n/d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sn*sn == n &amp;&amp; sn&lt;=m) ans-=fcnt(sn,sn);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n=98765432109876 = 9.8*10^13 用时 42s, N 大点，耗时会小点</span></span><br><span class="line">        <span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;fcnt(n,n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="n-个球放在-m-个盒子中"><a href="#n-个球放在-m-个盒子中" class="headerlink" title="$n$ 个球放在 $m$ 个盒子中"></a><a href="https://blog.csdn.net/qq_39942341/article/details/80246780" target="_blank" rel="noopener">$n$ 个球放在 $m$ 个盒子中</a></h2><p>球有相同和不同两种情况，盒子也是，还有盒子能空和不能空，一共八种情况：</p>
<ul>
<li><p>球同，盒同，非空</p>
<p>正整数拆分数之和 $f(n,m) - f(n,m-1)$</p>
</li>
<li><p>球同，盒同，能空</p>
<p>正整数拆分数 $f(n,m)$</p>
</li>
<li><p>球同，盒异，非空</p>
<p>等价于 $x_1 + \cdots + x_m = n$ 的正整数解，插空法知道 $n-1 \choose m-1$</p>
</li>
<li><p>球同，盒异，能空</p>
<p>同上，$n+m-1 \choose m-1$</p>
</li>
<li><p>球异，盒同，非空</p>
<p>第二类斯特林数： $S(n,m)$</p>
</li>
<li><p>球异，盒同，能空</p>
<p>同上， $\sum_{i=1} ^m S(n,i)$</p>
</li>
<li><p>球异，盒异，非空： $m!S(n,m)$</p>
</li>
<li><p>球异，盒异，能空： $m^n$</p>
</li>
</ul>
<h2 id="有限制的线性方程组的解"><a href="#有限制的线性方程组的解" class="headerlink" title="有限制的线性方程组的解"></a>有限制的线性方程组的解</h2><p>$x_1+⋯+x_n=m, c_i &lt; x_i \leq d_i$ 的正整数解的个数 ?</p>
<h3 id="动态规划直接做复杂度-O-m-2-n"><a href="#动态规划直接做复杂度-O-m-2-n" class="headerlink" title="动态规划直接做复杂度 O(m^2 n)"></a>动态规划直接做复杂度 O(m^2 n)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = d[i];x&gt;c[i];--x)&#123;</span><br><span class="line">    dp[i][m] += dp[i<span class="number">-1</span>][m-x]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不妨设 $c_i = 0, d_i = k$</p>
</blockquote>
<h3 id="包容排斥原理做"><a href="#包容排斥原理做" class="headerlink" title="包容排斥原理做"></a>包容排斥原理做</h3><script type="math/tex; mode=display">
{m-1 \choose n-1} - {n \choose 1} {m-k-1 \choose n-1} + \cdots (-1)^n {n \choose n} {m-nk-1 \choose n-1} = \sum_{i=0} ^ n (-1)^i {n \choose i} {m-ik-1 \choose n-1}</script>]]></content>
      <tags>
        <tag>Math</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>转义字符</title>
    <url>/convertChar/</url>
    <content><![CDATA[<p>转义字符在任何一种编程语言中都会提到（正则表达式也是）。写这篇博客的原因是，在 <a href="https://raycoder.me/p/Python-special-characters/" target="_blank" rel="noopener">友链 Ray 的博客</a> 中无意发现：</p>
<blockquote>
<p>Python 自带的 shell 以及 SublimeText3 配置的环境 不支持 <code>\b</code> 和 <code>\r</code></p>
<p>但是 C++ IDE 就支持，例如：Codeblocks</p>
</blockquote>
<a id="more"></a>
<p>以下图表来自 <a href="https://baike.baidu.com/item/转义字符/86397?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">转义字符</th>
<th style="text-align:left">意义</th>
<th style="text-align:center">ASCII 码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\a</code></td>
<td style="text-align:left">响铃(BEL)</td>
<td style="text-align:center">007</td>
</tr>
<tr>
<td style="text-align:left"><code>\b</code></td>
<td style="text-align:left">退格(BS) ，将当前位置移到前一列</td>
<td style="text-align:center">008</td>
</tr>
<tr>
<td style="text-align:left"><code>\f</code></td>
<td style="text-align:left">换页(FF)，将当前位置移到下页开头</td>
<td style="text-align:center">012</td>
</tr>
<tr>
<td style="text-align:left"><code>\n</code></td>
<td style="text-align:left">换行(LF) ，将当前位置移到下一行开头</td>
<td style="text-align:center">010</td>
</tr>
<tr>
<td style="text-align:left"><code>\r</code></td>
<td style="text-align:left">回车(CR) ，将当前位置移到本行开头</td>
<td style="text-align:center">013</td>
</tr>
<tr>
<td style="text-align:left"><code>\t</code></td>
<td style="text-align:left">水平制表(HT) （跳到下一个 TAB 位置）</td>
<td style="text-align:center">009</td>
</tr>
<tr>
<td style="text-align:left"><code>\v</code></td>
<td style="text-align:left">垂直制表(VT)</td>
<td style="text-align:center">011</td>
</tr>
<tr>
<td style="text-align:left"><code>\\</code></td>
<td style="text-align:left">代表一个反斜线字符’’\’</td>
<td style="text-align:center">092</td>
</tr>
<tr>
<td style="text-align:left"><code>\’</code></td>
<td style="text-align:left">代表一个单引号（撇号）字符</td>
<td style="text-align:center">039</td>
</tr>
<tr>
<td style="text-align:left"><code>\”</code></td>
<td style="text-align:left">代表一个双引号字符</td>
<td style="text-align:center">034</td>
</tr>
<tr>
<td style="text-align:left"><code>\?</code></td>
<td style="text-align:left">代表一个问号</td>
<td style="text-align:center">063</td>
</tr>
<tr>
<td style="text-align:left"><code>\0</code></td>
<td style="text-align:left">空字符(NUL)</td>
<td style="text-align:center">000</td>
</tr>
<tr>
<td style="text-align:left"><code>\ddd</code></td>
<td style="text-align:left">1 到 3 位八进制数所代表的任意字符</td>
<td style="text-align:center">三位八进制</td>
</tr>
<tr>
<td style="text-align:left"><code>\xhh</code></td>
<td style="text-align:left">十六进制所代表的任意字符</td>
<td style="text-align:center">十六进制</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意： 转义字符与操作系统无关！</p>
<p>Python Shell 和无视 <code>\r</code> ,而 <code>\b</code> 会报错。</p>
<p>Sublime 的插件无视 <code>\r</code> ，<code>\b</code> 会被输出为: <code>&lt;0x08&gt;</code></p>
</blockquote>
<p>下面内容摘自<a href="https://baike.baidu.com/item/换行符/1410821?fr=aladdin" target="_blank" rel="noopener">百度百科</a>：</p>
<p>回车 (<code>\r</code>) 本义是光标重新回到本行开头，r 代表 <code>return</code> ，控制字符可以写成 CR，即 <code>Carriage Return</code>；<br>换行 (<code>\n</code>) 本义是光标往下一行（不一定到下一行行首），n 代表 <code>newline</code>，控制字符可以写成 LF，即 <code>Line Feed</code>。<br>在不同的操作系统这几个字符表现不同：<br>比如在 WIN 系统下，这两个字符就是表现的本义，<br>在 UNIX 类系统，换行 <code>\n</code> 就表现为光标下一行并回到行首，<br>在 MAC 上，<code>\r</code>就表现为回到本行开头并往下一行，至于 ENTER 键的定义是与操作系统有关的。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>仅在一点连续的函数例子</title>
    <url>/exampleOfFunctionOnlyContinueAtOnePoint/</url>
    <content><![CDATA[<p>在一元微积分中，有一个广为人知的结论：一元函数在一点可导，必在该点连续，即可导必连续。那么自然会有这样一个问题：</p>
<blockquote>
<p>一元函数在一点可导能否推出它在该点的一个小邻域连续呢？</p>
</blockquote>
<p>这个想法是很自然的，不严格的思考可能会认为应该是对的,但是它并不成立。下面给出一个反例：</p>
<script type="math/tex; mode=display">
f(x) = x^2 D(x) = \left\{ 
\begin{array}{ll} 
0 & x \in \mathbb{Q} \\
x^2 & x \notin \mathbb{Q} 
\end{array} \right.</script><p>其中 $D(x)$ 为 Dirichlet 函数。</p>
<a id="more"></a>
<p>容易验证函数 $f(x)$ 在 $x=0$ 处可导，但在 $x \neq 0$ 处不连续，从而否定了上述问题。</p>
<p>最后，类似地，我们还可以通过 Dirichlet 函数构造 $\mathbb{R}$ 上一些仅在有限个点连续的函数。也可以通过周期函数构造仅在所有整数点连续的函数。但是由 Baire 纲定理可以证明，不存在在所有有理数点连续，无理点间断的函数。最后 Riemann 函数给出了一个在所有有理数点间断，无理点连续的函数。这些反例使得人们对函数连续的概念有了更感性的认识。</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>自然数方幂和快速算法</title>
    <url>/fastPowSumOfNaturalNumber/</url>
    <content><![CDATA[<p>之前写过<a href="/formulaOfPowSumOfNaturalNumber/" title="自然数方幂和公式">自然数方幂和公式</a>， 这次写的目的是因为上次是从数学上完美的解决了这个问题，这次我们要从计算上完美的解决这个问题，当然这归功于我看到的一份<a href="http://codeforces.com/profile/sgtlaugh" target="_blank" rel="noopener">sgtlaugh</a>的代码。经过解读体会到其中的奥秘，特此记录。一句话，简直不敢相信。</p>
<blockquote>
<p>如果有人说他能在 $O(k)$ 时空复杂度求解 $\sum_{i=1}^n i^k$，你肯定会说这怎么可能别忽悠我了，那我只能说，因为你没看过这篇博文。</p>
</blockquote>
<a id="more"></a>
<h2 id="首先预处理，-O-k-复杂度-求-sum-i-1-n-i-k-其中-n-leq-k"><a href="#首先预处理，-O-k-复杂度-求-sum-i-1-n-i-k-其中-n-leq-k" class="headerlink" title="首先预处理，$O(k)$ 复杂度 求 $\sum_{i=1}^n i^k$ 其中 $n \leq k$"></a>首先预处理，$O(k)$ 复杂度 求 $\sum_{i=1}^n i^k$ 其中 $n \leq k$</h2><p>我之前一直以为要用 $ k \log k $ 的复杂度才能解决这个问题，其实我们只需对所有素数 $p$ 计算 $p^k$ 即可。对于一般的 $i$ 我们先预处理 其最小素因子$sp[i]$。计算 $sp[i]^k \cdot (i/sp[i])^k$ 即可（具体可见最后代码）。由于素数的阶为 $O(\frac{k}{\log k})$ 因此整个复杂度即为 $O(k)$。</p>
<h2 id="再由-Lagrange-插值多项式得出最终答案"><a href="#再由-Lagrange-插值多项式得出最终答案" class="headerlink" title="再由 Lagrange 插值多项式得出最终答案"></a>再由 Lagrange 插值多项式得出最终答案</h2><p>因为我们知道 $\sum_{i=1} ^n i^k$ 一定是一个关于$n$的次数为 $k+1$ 的多项式。因此，我们只需计算其在$0,\cdots,k+1$ 上的取值，用 Lagrange 插值多项式即可知道答案。</p>
<blockquote>
<p>对于一个次数不超过 $n$ 的多项式 $f(x)$，其在不同位置 $x_0,\cdots,x_n$ 的取值唯一决定了这个多项式:</p>
</blockquote>
<script type="math/tex; mode=display">
f(x) = \sum_{i=0} ^n f(x_i) \prod_{j=0,j \neq i} ^n \frac{x-x_j}{x_i - x_j}</script><h4 id="具体到本问题，我们取-x-n-m-k-1-x-i-i-那么"><a href="#具体到本问题，我们取-x-n-m-k-1-x-i-i-那么" class="headerlink" title="具体到本问题，我们取 $x=n,m=k+1,x_i=i$ 那么"></a>具体到本问题，我们取 $x=n,m=k+1,x_i=i$ 那么</h4><script type="math/tex; mode=display">
f(n) = \sum_{i=0} ^m (-1)^{m-i} f(x_i) {n \choose i}  {n-i-1 \choose m-i }</script><h2 id="例题：Codeforces-622F"><a href="#例题：Codeforces-622F" class="headerlink" title="例题：Codeforces 622F"></a>例题：Codeforces 622F</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> sp[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spf</span><span class="params">()</span></span>&#123; <span class="comment">// samllest prime factor</span></span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;p[cnt++]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;i+=<span class="number">2</span>)   sp[i]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i+=<span class="number">2</span>)   sp[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sp[i]==i)    p[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; cnt &amp;&amp; p[j]&lt;=sp[i] &amp;&amp; i * p[j] &lt; N; ++j) &#123;</span><br><span class="line">            sp[i * p[j]] = p[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=x*x%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">LL inv[N],AP[N],AS[N],f[N];</span><br><span class="line"><span class="function">LL <span class="title">getpowsum</span><span class="params">(LL n,<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">// mod &gt; k</span></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)    <span class="keyword">return</span> n%mod;</span><br><span class="line">    <span class="keyword">if</span>(p[<span class="number">0</span>]!=<span class="number">2</span>) spf();</span><br><span class="line">    <span class="keyword">int</span> nk=k+<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=nk;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sp[i]==i)    f[i]=pow_mod(i,k,mod);</span><br><span class="line">        <span class="keyword">else</span>    f[i]=f[sp[i]]*f[i/sp[i]]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nk;++i)&#123;</span><br><span class="line">        f[i]+=f[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;=mod)   f[i]-=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=nk)    <span class="keyword">return</span> f[n];</span><br><span class="line">    LL tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=nk;++i)    tmp=tmp*i%mod;</span><br><span class="line">    inv[nk] = pow_mod(tmp,mod<span class="number">-2</span>,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nk<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">    AP[<span class="number">0</span>]=AS[nk]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nk;++i)   AP[i]=AP[i<span class="number">-1</span>]*(n+<span class="number">1</span>-i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nk<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) AS[i]=AS[i+<span class="number">1</span>]*(n-i<span class="number">-1</span>)%mod;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nk;++i)&#123; <span class="comment">// because f(i)=0</span></span><br><span class="line">        LL x = f[i]*AP[i]%mod*AS[i]%mod*inv[i]%mod*inv[nk-i]%mod;</span><br><span class="line">        <span class="keyword">if</span>((nk-i)&amp;<span class="number">1</span>) res-=x; <span class="comment">// be careful</span></span><br><span class="line">        <span class="keyword">else</span>        res+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;getpowsum(n,k)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实际上我们可以不求-mod-p-后的答案，利用大数类得到标准答案，但是这时因为数字实在太大，每次乘法的用时过大，因此仅适合-k-lt-n-的情况"><a href="#实际上我们可以不求-mod-p-后的答案，利用大数类得到标准答案，但是这时因为数字实在太大，每次乘法的用时过大，因此仅适合-k-lt-n-的情况" class="headerlink" title="实际上我们可以不求 $\mod p$ 后的答案，利用大数类得到标准答案，但是这时因为数字实在太大，每次乘法的用时过大，因此仅适合 $k&lt;n$ 的情况"></a>实际上我们可以不求 $\mod p$ 后的答案，利用大数类得到标准答案，但是这时因为数字实在太大，每次乘法的用时过大，因此仅适合 $k&lt;n$ 的情况</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cpp_int f[N];</span><br><span class="line"><span class="function">cpp_int <span class="title">getpowsum</span><span class="params">(LL n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)    <span class="keyword">return</span> cpp_int(n);</span><br><span class="line">    <span class="keyword">if</span>(p[<span class="number">0</span>]!=<span class="number">2</span>) spf();</span><br><span class="line">    <span class="keyword">int</span> nk=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=nk+<span class="number">1</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sp[i]==i)    f[i]=<span class="built_in">pow</span>(cpp_int(i),k);</span><br><span class="line">        <span class="keyword">else</span>    f[i]=f[sp[i]]*f[i/sp[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nk;++i)  f[i]+=f[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=nk)   <span class="keyword">return</span> f[n];</span><br><span class="line">    cpp_int res = <span class="number">0</span>,tl=<span class="number">1</span>,tr=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nk<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)    tr=tr*(n-i<span class="number">-1</span>)/(nk-i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=nk;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((nk-i)&amp;<span class="number">1</span>)    res -= f[i]*tl*tr;</span><br><span class="line">        <span class="keyword">else</span>            res += f[i]*tl*tr;</span><br><span class="line">        tl = tl*(n-i)/(i+<span class="number">1</span>);</span><br><span class="line">        tr = tr*(nk-i)/(n-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实如果我们知道最终的上界，求出多个 $\mod p$ 后的答案，再用中国剩余定理貌似很不错。</p>
</blockquote>
<h4 id="该方法可以推广成求-sum-i-1-n-f-i-k-，其中-f-x-是多项式。具体分析即可"><a href="#该方法可以推广成求-sum-i-1-n-f-i-k-，其中-f-x-是多项式。具体分析即可" class="headerlink" title="该方法可以推广成求 $\sum_{i=1}^n f(i)^k$，其中$f(x)$是多项式。具体分析即可"></a>该方法可以推广成求 $\sum_{i=1}^n f(i)^k$，其中$f(x)$是多项式。具体分析即可</h4><p>这种情况一般很难再做到 $O(k)$ 时间复杂度，而变成了 $O(k \log k) \deg f$ 复杂度。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>相对公平的席位分配</title>
    <url>/fairAssignment/</url>
    <content><![CDATA[<p>“公平”的席位分配首先本来就是不可能的，公平一般是无法达到的，我们只是尽量降低不公平度，那么我们怎么衡量不公平度呢。就像评价一个人，有不同的指标，不公平度也是一样，这里介绍一种相对合理易于接受，且好判断的方法。</p>
<a id="more"></a>
<h2 id="问题表述"><a href="#问题表述" class="headerlink" title="问题表述"></a>问题表述</h2><p>某学校三个系部学生共 200 名,(甲系 100,乙系 60,丙系 40)代表会议共 20 席,按比例分配三个系分别为 10、6、4 席。但是情况变为下列情况怎样分配才是最公平的,现因学生转系三系人数为 103、63、34 。</p>
<ol>
<li>问 20 席该如何分配 ? </li>
<li>若增加 21 席又如何分配 ?</li>
</ol>
<p>显然，因为无法整除无论如何分配都不公平。下面说一下几种策略。</p>
<p><strong>策略一</strong>： 按班级人数比例乘以总人数，小数点大的分得多余的一个位子。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">某校</th>
<th style="text-align:right">甲系</th>
<th style="text-align:right">乙系</th>
<th style="text-align:right">丙系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">共 200 人</td>
<td style="text-align:right">103</td>
<td style="text-align:right">63</td>
<td style="text-align:right">34</td>
</tr>
<tr>
<td style="text-align:center">人数比例</td>
<td style="text-align:right">51.3</td>
<td style="text-align:right">31.5</td>
<td style="text-align:right">17</td>
</tr>
<tr>
<td style="text-align:center">20 席位</td>
<td style="text-align:right">10.3</td>
<td style="text-align:right">6.3</td>
<td style="text-align:right">3.4</td>
</tr>
<tr>
<td style="text-align:center">实际分配</td>
<td style="text-align:right">10</td>
<td style="text-align:right">6</td>
<td style="text-align:right">4</td>
</tr>
<tr>
<td style="text-align:center">21 席位</td>
<td style="text-align:right">10.82</td>
<td style="text-align:right">6.62</td>
<td style="text-align:right">3.57</td>
</tr>
<tr>
<td style="text-align:center">实际分配</td>
<td style="text-align:right">11</td>
<td style="text-align:right">7</td>
<td style="text-align:right">3</td>
</tr>
</tbody>
</table>
</div>
<p>按照上述策略，会出现席位增多而 <strong>丙系的席位却减少了一个的不合理现象</strong>，说明此方法并不合理。</p>
<h2 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h2><p>假设只有 A、B 两个单位分配席位的情况，设两方人数 $m_1,m_2$ ,分配到的席位为 $n_1,n_2$。</p>
<ol>
<li><p>$\frac{n_1}{m_1} = \frac{n_2}{m_2}$ 公平，但是一般是不满足的。</p>
</li>
<li><p>$\frac{n_1}{m_1} &gt; \frac{n_2}{m_2}$ 对 A 不公平。</p>
</li>
<li><p>$\frac{n_1}{m_1} &lt; \frac{n_2}{m_2}$ 对 B 不公平。</p>
</li>
</ol>
<p>绝对不公平度</p>
<script type="math/tex; mode=display">
d = \left| \frac{n_1}{m_1} - \frac{n_2}{m_2} \right|</script><p>  但这样做还是有不足，例如<br>  某两个单位的人数和席位为 $n_1=n_2=10,m_1=120,m_2=100$ 算得  $d=2$.<br>  另两个单位的人数和席位为 $n_1=n_2=10,m_1=1020,m_2=1000$ 算得 $d=2$。<br>  但是显然，第二种情况更公平，但是（绝对）不公平度却是一样的不合理</p>
<p>相对不公平度</p>
<ol>
<li>若 $\frac{n_1}{m_1} &lt; \frac{n_2}{m_2}$ 则<script type="math/tex; mode=display">
r_A(n_1,n_2) = \frac{ \frac{n_2}{m_2} - \frac{n_1}{m_1} }{ \frac{n_2}{m_2} } = 1 - \frac{n_1 m_2}{m_1 n_2}</script></li>
</ol>
<ol>
<li>若 $\frac{n_1}{m_1} &gt; \frac{n_2}{m_2}$ 则<script type="math/tex; mode=display">
r_B(n_1,n_2)  = \frac{ \frac{n_1}{m_1} - \frac{n_2}{m_2} }{ \frac{n_1}{m_1} } = 1 - \frac{n_2 m_1}{m_2n_1}</script>我们的目标是让$r_A,r_B$(每种分配只会有一个)最小。</li>
</ol>
<h3 id="策略二"><a href="#策略二" class="headerlink" title="策略二"></a><strong>策略二</strong></h3><p>假设当前 $\frac{n_1}{m_1} &lt; \frac{n_2}{m_2}$ 对 A 不公平。新增了一个席位。</p>
<ol>
<li>若 $\frac{n_1 + 1}{m_1} \leq  \frac{n_2}{m_2}$ 则 A 加 1 席 </li>
<li>否则此时<ul>
<li>若分配给 A，则对 B 的不公平值(相对):<script type="math/tex; mode=display">
r_B(n_1+1,n_2) = 1 - \frac{n_2 m_1}{m_2 (n_1 + 1)}</script></li>
<li>若分配给 B，则对 A 的不公平值(相对):<script type="math/tex; mode=display">
r_A(n_1,n_2+1) = 1 - \frac{n_1 m_2}{m_1(n_2 + 1)}</script></li>
</ul>
</li>
</ol>
<p>我们定义 $Q_i = \frac{m_i ^2}{n_i(n_i+1)}$，那么分配给 B 等价于 $r_A(n_1,n_2+1)&lt;r_B(n_1+1,n_2)$ 等价于$Q_1 &lt; Q_2$。即我们应该将席位分配给 $Q$ 值较大者。</p>
<blockquote>
<p>讲 $Q_i$ 定义成 $Q_i = \frac{n_i(n_i+1)}{m_i ^2}$ ，然后找最小的比较合理，不过这样会有小数点太长，所以没这么做</p>
</blockquote>
<h3 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h3><p>先按照平均原则取整之后。分出了 19 席：$n_1=10,n_2=6,n_3=3$，第 20 席：</p>
<script type="math/tex; mode=display">
Q_1 = \frac{103^2}{10 \times 11 } \approx 96.4 \; , \;Q_2 = \frac{63^2}{6 \times 7} \approx 94.5 \; , \;Q_3 = \frac{34^2}{3 \times 4} \approx 96.3</script><p>则分配：$n_1=11,n_2=6,n_3=3$<br>第 21 席：$Q_1=80.4, Q_2 = 94.5, Q_3 = 96.3$<br>则分配：$n_1=11,n_2=6,n_3=4$.</p>
<blockquote>
<p>相对不公平度有很多变种，从而 <strong>策略二有很多变种</strong>（最后计算发现都一样）</p>
<p>莫非策略二就是天选之子 0.0</p>
</blockquote>
<h2 id="本文参考文库-1和文库-2，修改了其中的错误"><a href="#本文参考文库-1和文库-2，修改了其中的错误" class="headerlink" title="本文参考文库 1和文库 2，修改了其中的错误"></a>本文参考<a href="http://wenku.baidu.com/view/396d4f6aaf1ffc4ffe47ac52.html?re=view" target="_blank" rel="noopener">文库 1</a>和<a href="http://wenku.baidu.com/view/312ef3274b35eefdc9d33304.html?re=view" target="_blank" rel="noopener">文库 2</a>，修改了其中的错误</h2><blockquote>
<p>其实作为分配者，如果你倾向 X，那你就选择让 X 收益最多的策略，反正 <strong>策略一</strong> 看上去也挺合理的，实在不行的话，再强行找花头…</p>
</blockquote>
<p>由于席位分配问题确实是一个经典问题，故在此记录。</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>运筹学</tag>
      </tags>
  </entry>
  <entry>
    <title>有限整环是域</title>
    <url>/finiteDomainIsField/</url>
    <content><![CDATA[<p>有限整环是域，这是一个相当深刻的定理，被称为 Wedderburn’s little theorem。介绍如下。<br><a id="more"></a></p>
<h2 id="有限整环是体"><a href="#有限整环是体" class="headerlink" title="有限整环是体"></a>有限整环是体</h2><p>设 $D$ 是有限整环（不要求交换），下证 $D$ 是体。<br>证明：对任意 $0 \neq a \in D$，考虑 $a,a^2,a^3,..,a^n,…$ 由于 $D$ 是有限环，因此存在 $n,r &gt; 0$ 使得 $a^{n+r} = a^n$ 即 $a^n(a^r-1)=0$ 由于 $D$ 是整环，$a \neq 0$，因此 $a^r =1$ ，所以 $a$ 可逆，证毕。</p>
<h2 id="有限体是域"><a href="#有限体是域" class="headerlink" title="有限体是域"></a>有限体是域</h2><p>设 $K$ 是有限体。$Z$ 是它的中心，即</p>
<script type="math/tex; mode=display">
Z = \lbrace z \in K \mid \forall x \in K, xz = zx \rbrace</script><p>则，$Z$ 是域。令 $|Z|=q$，则 $K$ 是 $q$ 元域上的有限维向量空间，设维数为 $n$，则 $|K|=q^n$。我们需要证明 $K=Z$, 即证明 $n=1$。<br>对任意 $a \in K$，令 $N(a) = \lbrace x \in K \mid ax = xa \rbrace$ ，这显然是 $K$ 的一个子体。并且包含 $Z$。因此 $N(a)$ 也是 $Z$ 上的有限维向量空间。从而 $N(a)=q^{n(a)},n(a) \geq 1$。由于 $K^{\star}$ 为 $q^n-1$ 阶乘法群，$N(a)^{\star}$ 为 $K^{\star}$ 的 $q^{n(a)}-1$ 阶子群，因此 $q^{n(a)}-1 \mid q^n-1$，因此 $n(a) \mid n$。<br>将乘法群 $K^{\star}$ 中的元素分成共轭类，从群论的角度，与 $a \in K^{\star}$ 共轭的元素有 $[K^{\star} :N(a)^{\star}] = \frac{q^n-1}{q^{n(a)}-1}$，从而每个共轭类取一次，共轭类集合记作$X$，我们有</p>
<script type="math/tex; mode=display">
q^n - 1 = q-1 + \sum_{\overline{a} \in X} \frac{q^n-1}{q^{n(a)}-1}</script><p>我们需要证明的是当 $n&gt;1$ 时上式不成立。为此我们先介绍<strong>分圆多项式</strong>的知识。</p>
<script type="math/tex; mode=display">
P_n(x) = \prod_{1 \leq r \leq n,(r,n)=1} (x-e^{\frac{2 \pi i r}{n}})</script><p>即 $P_n(x)$ 是以全部 $n$ 次本原单位复根（共 $\phi(n)$ 个）为根的首一多项式。易知</p>
<script type="math/tex; mode=display">
x^n -1 = \prod_{d \mid n} P_d(n)</script><p>由数论函数的 <a href="/dirichletProduct/" title="Mobius 变换">Mobius 变换</a>，(取对数或指数来切换乘积和相加)可知</p>
<script type="math/tex; mode=display">
P_n(x) = \prod_{d \mid n} (x^d-1)^{\mu(n/d)}</script><p>于是 $P_n(x)=f(x)/g(x)$ 其中 $f(x),g(x)$ 都为 $\mathbb{Z}[x]$ 中的首一多项式。另一方面，按照定义，$P_n(x) \in \mathbb{C}[x]$ ，从而在 $\mathbb{C}[x]$ 中 $g(x) \mid f(x)$。比较系数易知，$P_n(x)$ 为 $\mathbb{Z}[x]$ 中首一多项式。</p>
<p>因为对任意 $d \mid n,0&lt;d&lt;n,P_n(x)$ 的每个根都是 $x^n-1$ 的根，但不是 $x^d-1$ 的根，从而 </p>
<script type="math/tex; mode=display">
P_n(x) \mid \frac{x^n-1}{x^d-1}</script><p>因此 $P_n(q) \mid q-1$, 但当 $n&gt;1$ 时，</p>
<script type="math/tex; mode=display">
|P_n(q))| > (q-1)^{\phi(n)} \geq q-1</script><p>矛盾，证毕。</p>
<blockquote>
<p>这个定理也可以表述为：一个有限环，如果它不是域，那么它必然存在零因子。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Fermat 平方和定理</title>
    <url>/fermatSqureSumTheorem/</url>
    <content><![CDATA[<p>Fermat 平方和定理的表述为：奇质数能表示为两个平方数之和的充分必要条件是该质数被 4 除余 1(必要性显然）。这个结论首次由 Euler 在 1747 年给出证明。详细叙述如下：</p>
<a id="more"></a>
<p>为方便起见,记</p>
<script type="math/tex; mode=display">
A = \lbrace a^2 + b^2 \mid a,b \in \mathbb{Z} \rbrace</script><p>证明分五步完成</p>
<ol>
<li><p>$(a^2+b^2)(c^2+d^2)=(ac \pm bd)^2 +(ad \mp bc)^2 $</p>
<p> proof: 计算即知。</p>
</li>
<li><p>若 $a^2+b^2 \mid c^2+d^2$, $a^2+b^2$ 为素数，则</p>
<script type="math/tex; mode=display">
 \frac{c^2+d^2}{a^2+b^2} \in A</script><p> <strong>proof</strong>: 由于 $(ac-bd)(ac+bd) = (a^2+b^2)c^2-(c^2+d^2)b^2$ 因此 $(a^2+b^2) \mid (ac-bd)(ac+bd)$ 而 $(a^2+b^2)$ 是素数，因此必然整除其中一个。假设 $(a^2+b^2)|(ac-bd)$，则由 1 知 $(a^2+b^2)｜(ad+bc)$ 因此</p>
<script type="math/tex; mode=display">
 \frac{c^2+d^2}{a^2+b^2}=(\frac{ac - bd}{a^2+b^2})^2 +(\frac{ad + bc}{a^2+b^2})^2</script><p> ​类似的，假设 $(a^2+b^2) \mid (ac＋bd)$ 则有</p>
<script type="math/tex; mode=display">
 \frac{c^2+d^2}{a^2+b^2}=(\frac{ac + bd}{a^2+b^2})^2 +(\frac{ad - bc}{a^2+b^2})^2</script></li>
<li><p>$x \mid a^2+b^2,x \notin A$，则 $\exists y| \frac{a^2+b^2}{x}$ 使得 $y \notin A$</p>
<p> 反证：设 $a^2+b^2 = x p_1 p_2 \cdots p_n$ 则 $\forall y| \frac{a^2+b^2}{x},y \in A$ 则由 2，经过 $n$ 次除法，最终 $x \in A$ 矛盾。</p>
</li>
<li><p>若 $(a,b)=1$ 则 $\forall x | a^2+b^2 \Rightarrow x \in A$</p>
<p> 假设 $\exists x| a^2+b^2,x \notin A$ 则，我们设 $a = mx + c,b = mx + d$,其中 $|c|,|d| \leq \frac{x}{2}$。则<br> $a^2+b^2=(mx+c)^2+(mx+d)^2=tx+(c^2+d^2)$，因此 $x \mid c^2+d^2$。又 $(a,b)=1$ ，因此 $((c,d),x)=1$。因此不妨设 $(c,d)=1$（否则，两边同除它的平方）则 $\exists z, zx = c^2+d^2 \leq \frac{x^2}{2}$。即 $z\leq \frac{x}{2}$。由引理 3 知道 $z$ 有一个因子 $w \notin A$。即我们由 $x \mid a^2+b^2,x \notin A$ 得到了 $w \mid c^2+d^2, w \notin A ,w \leq  \frac{x}{2}$ 这样一直下去必然会在有限步结束，矛盾，即必然有 $x \in A$ 。</p>
</li>
<li><p>若素数 $p=4n+1$，则 $p\in A$。</p>
<p> 由 Fermat 小定理知 $1,2^{4n},\cdots,(4n)^{4n}$ 除以 $p$ 模 1.因此 $2^{4n}－1,3^{4n}－2^{4n},\cdots,(4n)^{4n}-(4n-1)^{4n}$ 都是 $p$ 的倍数。这些差都有分解</p>
<script type="math/tex; mode=display">
 a^{4n} - b^{4n} = (a^{2n}+b^{2n})(a^{2n}-b^{2n})</script><p> 由于上述 $a,b$ 相差为 1，必然互素，因此若 $p|a^{2n}+b^{2n}$ 则由 4 命题得证。否则 $2^{2n}-1,3^{2n}-2^{2n},\cdots,(2n)^{2n}-(2n-1)^{2n}$ 都是 $p$ 的倍数。<br> 因此 1.对上面式子做 $2n$ 阶差得到 $(2n)!$ 是 $p$ 的倍数，显然是不可能的。<br> 或者 2.由于上面序列的前 $d$ 项和 $d^{2n}-1$ 是 $p$ 的倍数，因此素数 $p$ 无原根，矛盾与原根存在定理。</p>
<blockquote>
<p>$1^k,2^k, \cdots, k^k, (k+1)^k$ 的 $k$ 阶差为 $k!$</p>
</blockquote>
</li>
</ol>
<h2 id="用现代语言，Fermat-平方和定理也可以表达为"><a href="#用现代语言，Fermat-平方和定理也可以表达为" class="headerlink" title="用现代语言，Fermat 平方和定理也可以表达为"></a>用现代语言，Fermat 平方和定理也可以表达为</h2><blockquote>
<p>奇素数 $p$ 在 $\mathbb{Z}[i]$ 中不可约元当且仅当 $p  \equiv 3 \mod 4$</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>自然数方幂和公式</title>
    <url>/formulaOfPowSumOfNaturalNumber/</url>
    <content><![CDATA[<p>关于自然数方幂和公式，网上的求解版本有很多种。这里介绍一种不为人知，十分简洁明了的求解方法，该公式并非原创，但是整个证明过程和方法完全原创。它的思想来源于我高中时在一本数学竞赛书中的数列例题(书名忘了…)，正因为一本本这样的书，让我大学选择了数学系，现在依然在学习数学。<br><a id="more"></a></p>
<h2 id="若-a-n-n-n-1-求其前-n-项和-S-n"><a href="#若-a-n-n-n-1-求其前-n-项和-S-n" class="headerlink" title="若 $a_n = n(n-1)$ 求其前 $n$ 项和 $S_n$"></a>若 $a_n = n(n-1)$ 求其前 $n$ 项和 $S_n$</h2><script type="math/tex; mode=display">
a_n = n(n-1) ＝ \frac{(n+1)n(n-1) -n(n-1)(n-2)}{3}</script><p>所以</p>
<script type="math/tex; mode=display">
S_n =\frac{(n+1)n(n-1)}{3}</script><blockquote>
<p>受到上面做法的启发，我们推广到一般形式：</p>
</blockquote>
<h2 id="若-a-n-A-n-p-，则其前-n-项和-S-n-＝-frac-A-n-1-p-1-p-1"><a href="#若-a-n-A-n-p-，则其前-n-项和-S-n-＝-frac-A-n-1-p-1-p-1" class="headerlink" title="若 $a_n = A_n ^p$，则其前 $n$ 项和 $S_n ＝ \frac{ A_{n+1} ^{p+1}}{p+1}$"></a>若 $a_n = A_n ^p$，则其前 $n$ 项和 $S_n ＝ \frac{ A_{n+1} ^{p+1}}{p+1}$</h2><script type="math/tex; mode=display">
a_n = A_n ^p ＝ \frac{A_{n+1} ^{p+1} -A_n ^{p+1}}{p+1}</script><p>所以</p>
<script type="math/tex; mode=display">
S_n = \frac{A_{n+1} ^{p+1}}{p+1}</script><p>由上面的结论，我们可以直奔主题了</p>
<h2 id="求-1-2-2-2-dots-n-2"><a href="#求-1-2-2-2-dots-n-2" class="headerlink" title="求 $1^2+2^2+ \dots + n^2$"></a>求 $1^2+2^2+ \dots + n^2$</h2><p>由</p>
<script type="math/tex; mode=display">
n^2 = n(n-1) + n</script><p>知</p>
<script type="math/tex; mode=display">
1^2+2^2+ \dots + n^2 = \frac{(n+1)n(n-1)}{3} + \frac{(n+1)n}{2} = \frac{n(n+1)(2n+1)}{6}</script><blockquote>
<p>同理我们可以推广上面做法</p>
</blockquote>
<h2 id="求-1-p-2-p-dots-n-p"><a href="#求-1-p-2-p-dots-n-p" class="headerlink" title="求$1^p+2^p+ \dots + n^p$"></a>求$1^p+2^p+ \dots + n^p$</h2><p>设</p>
<script type="math/tex; mode=display">
n^p = a_p A_n ^p + a_{p-1} A_n ^{p-1} + a_{p-2} A_n ^{p-2} + \cdots + a_1 A_n ^1</script><p>则</p>
<script type="math/tex; mode=display">
1^p+2^p+ \dots + n^p = \frac{a_p A_{n+1} ^{p+1}}{p+1} + \frac{a_{p-1} A_{n+1} ^{p}}{p} + \cdots + \frac{a_1 A_{n+1} ^2}{2}</script><p>因此问题的关键就转化成如何求解数组 $a_k ,k=1,2,\cdots,p$<br>我们发现当 $n＝k$ 时成立 </p>
<script type="math/tex; mode=display">
k^p = a_k A_k ^k + a_{k-1} A_k ^{k-1} + \cdots a_1 A_{k} ^1</script><p>令 $b_k = k! \cdot a_k$ 则</p>
<script type="math/tex; mode=display">
k^p = b_k + b_{k-1} C_k ^{k-1} + \cdots b_1 C_{k} ^1</script><p>即</p>
<script type="math/tex; mode=display">
k^p = \sum _{j=1} ^k b_j C _{k} ^j</script><p>应用二项式反演知（可参考：<a href="/inverseFormulaAndItsMatrixForm/" title="我的博文">我的博文</a>）</p>
<script type="math/tex; mode=display">
b_k = \sum _{j=1} ^k (-1)^{k-j} C _{k} ^j j^p</script><p>因此最终，我们有公式</p>
<script type="math/tex; mode=display">
1^p+2^p+ \dots + n^p = \sum _{k=1} ^p \; (\; \sum_{j=1} ^ {k} (-1)^{k-j} C_k^j j^p \;) \; C _{n+1} ^{k+1}</script><blockquote>
<p>妙呀，帅的呀，猛的呀，不谈了呀，哈哈哈</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>五引理</title>
    <url>/fiveLemma/</url>
    <content><![CDATA[<p>在同调代数中，Five lemma，Snake lemma，Nine lemma （五引理，蛇形引理，马蹄引理）都是重要的引理。这里介绍一下 五引理。其实它的一般形式是有两个四引理得出的。</p>
<a id="more"></a>
<p>以下范畴为：Abel 范畴(这里仅在模范畴中考虑，此时 monic 即为单同态，epic 即为满同态)。</p>
<h2 id="五引理"><a href="#五引理" class="headerlink" title="五引理"></a>五引理</h2><p>若下交换图中每一行都正合且 $f$ epic，$q$ monic, $g,p$ isomorphism,then $h$ is isomorphism.<br><img src= "/img/loading.gif" data-lazy-src="fivelemma.png" alt="五引理"></p>
<h2 id="五引理的特殊形式"><a href="#五引理的特殊形式" class="headerlink" title="五引理的特殊形式"></a>五引理的特殊形式</h2><p>若下交换图中每一行都正合且 $f,h$ isomorphism,then $g$ is isomorphism.<br><img src= "/img/loading.gif" data-lazy-src="fivelemmaS.png" alt="五引理特殊形式"></p>
<h2 id="两个四引理及其证明"><a href="#两个四引理及其证明" class="headerlink" title="两个四引理及其证明"></a>两个四引理及其证明</h2><ol>
<li><p>若下交换图中每一行都正合且 $f$ epic，$p$ monic, $g$ monic,then $h$ is monic.<br><img src= "/img/loading.gif" data-lazy-src="fourlemma1.png" alt="四引理1"><br>$\forall c \in C$, 若 $h(c) = 0$, 则 $pw(c)＝w’h(c)=0$, 因为 $p$ monic, 因此 $w(c)=0$, 又由行正合知，$\exists b \in B$ 使得 $v(b)=c$，因此 $v’g(b)=hv(b)=h(c)=0$, 由行正合知, $ \exists a’ \in A’ $ 使得 $u’(a’)=g(b)$，由 $f$ epic 知 $\exists a \in A$ 使得 $f(a) = a’$. 因此 $gu(a) = u’f(a)=g(b)$. 又由 $g$ monic 知， $b = u(a)$. 因此 $c = vu(a) = 0$. 证毕。</p>
</li>
<li><p>若下交换图中每一行都正合且 $g$ epic，$q$ monic, $p$ epic,then $h$ is epic.<br><img src= "/img/loading.gif" data-lazy-src="fourlemma2.png" alt="四引理2"><br>$\forall c’ \in C’$, 因为 $p$ epic, 知 $\exists d \in D$ 使得 $p(d) = w’(c’)$, 所以 $qs(d) = s’p(d) = s’w’(c’) = 0$, 又 $q$ monic, 因此 $s(d) = 0$, 由行正合知, $\exists c \in C$，使得 $w(c) = d$.因此 $w’(c’-h(c))=w’(c’)-w’h(c)=p(d)-pw(c)=0$. 由行正合知，$\exists b’ \in B’$ 使得 $v’(b’) = c’ - h(c)$, 又由 $g$ epic 知 $\exists b \in B$ 使得 $g(b) = b’$ 因此 $hv(b)= v’g(b) - v’(b’)=c’-h(c)$. 即 $c’=h(v(b)+c)$. 证毕。</p>
</li>
</ol>
<p>四引理记忆方法： 左满右单，两满夹一满，两单夹一单。</p>
<blockquote>
<p>显然上述两个四引理显然可推出五引理。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>点灯问题之高斯消元法</title>
    <url>/gaussianElimination/</url>
    <content><![CDATA[<p>在知乎的 <a href="https://zhuanlan.zhihu.com/skymath" target="_blank" rel="noopener">数学&amp;算法</a>专栏里看到 <a href="https://zhuanlan.zhihu.com/p/53646257" target="_blank" rel="noopener">点灯游戏的$O(n^3)$算法</a>，觉得挺有意思，特此记录，并且补充代码</p>
<a id="more"></a>
<h2 id="点灯游戏简介"><a href="#点灯游戏简介" class="headerlink" title="点灯游戏简介"></a>点灯游戏简介</h2><p>一层大楼共有 $n \times n$ 个房间，每个房间都有一盏灯和一个按钮。按动一个房间的按钮后，这个房间和周围四个相邻的房间的灯的状态全部都会改变（由暗变为亮或者亮变为暗）。目标是通过按按钮把所有的灯都点亮（默认情况下全暗）。求点灯方案。</p>
<ol>
<li>全局枚举，复杂度 $O(2^{n^2})$</li>
<li>首行枚举，复杂度 $O(2^n)$ ，由于第一行的方案就决定了下一行的方案</li>
<li>线性方程组求解，复杂度 $O(n^6)$</li>
<li>上述线性方程组求解可以转化成 $n$ 个变量的线性方程组，复杂度 $O(n^3)$</li>
</ol>
<p>以上内容取自 <a href="https://zhuanlan.zhihu.com/p/53646257" target="_blank" rel="noopener">点灯游戏的$O(n^3)$算法</a> </p>
<blockquote>
<p>最终方案做法概括：$n^2$ 个方程 $n^2$ 个未知数的线性方程组，由于用第$i$行的方程可以将第$i+1$行的未知数表示成前 i 行的线性组合，从而是第一行的现行组合，这样到最后一行。最后一行的方程还未使用，从而变成了$n$个方程$n$个未知数的线性方程组。</p>
</blockquote>
<p>由于方案可能不唯一，所以用 Python 自带的 numpy 以及 scipy 都不计算奇异矩阵。所以就自己写了高斯消元法来求解。</p>
<blockquote>
<p>注意 numpy 数据越界的问题！</p>
</blockquote>
<h2 id="高斯消元法普通版本"><a href="#高斯消元法普通版本" class="headerlink" title="高斯消元法普通版本"></a>高斯消元法普通版本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># numpy 是用C写的，所以本质是强类型的，需要注意</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tri</span><span class="params">(A, b, eps = <span class="number">1e-6</span>)</span>:</span></span><br><span class="line"><span class="comment"># 使A上三角，并返回A的秩 和 列变换px</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    px = list(range(n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        j,k = i,i</span><br><span class="line">        <span class="keyword">while</span>(k&lt;n):</span><br><span class="line">            j=i</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n <span class="keyword">and</span> np.fabs(A[j,k])&lt;eps): j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(j != n): <span class="keyword">break</span></span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(k == n): <span class="keyword">return</span> i,px</span><br><span class="line">        <span class="keyword">if</span>(i!=k):</span><br><span class="line">            px[i],px[k] = px[k],px[i]</span><br><span class="line">            A[:,[i,k]] = A[:,[k,i]]</span><br><span class="line">        <span class="keyword">if</span>(j != i):</span><br><span class="line">            b[[i,j]] = b[[j,i]]</span><br><span class="line">            A[[i,j]] = A[[j,i]]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            ratio = A[j,i]/A[i,i]</span><br><span class="line">            b[j] -= b[i]*ratio</span><br><span class="line">            A[j,i:n] -= A[i,i:n]*ratio</span><br><span class="line">    <span class="keyword">return</span> n,px</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trisolve</span><span class="params">(A, b)</span>:</span></span><br><span class="line">    ans = b.copy()</span><br><span class="line">    n = len(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        ans[i] = ans[i]/A[i,i]</span><br><span class="line">        ans[:i] -= A[:i,i]*ans[i]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(AA, bb, eps = <span class="number">1e-6</span>)</span>:</span></span><br><span class="line"><span class="comment"># 求解 Ax = b ，其中A是矩阵，b是列向量</span></span><br><span class="line"><span class="comment"># 答案是 ans[:,0] + k[1] ans[:,1] + ... + k[n-r] ans[n-r]</span></span><br><span class="line">    <span class="comment">#一定要类型转化，不然会很惨！</span></span><br><span class="line">    A = AA.copy()</span><br><span class="line">    b = bb.copy()</span><br><span class="line">    A = A.astype(np.float) </span><br><span class="line">    b = b.astype(np.float)</span><br><span class="line">    n = len(A)</span><br><span class="line">    r,px = tri(A,b,eps)</span><br><span class="line">    py = list(range(n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n): py[px[i]] = i</span><br><span class="line">    <span class="keyword">if</span>(r == n): <span class="keyword">return</span> trisolve(A,b)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(r,n):</span><br><span class="line">        <span class="keyword">if</span>(np.fabs(b[i,<span class="number">0</span>])&gt;eps): <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    ans = np.matrix(np.zeros([n,n-r+<span class="number">1</span>]))</span><br><span class="line">    ans[:r,<span class="number">0</span>] = trisolve(A[:r,:r],b[:r])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(r,n):</span><br><span class="line">        ans[:r,i-r+<span class="number">1</span>] = trisolve(A[:r][:r],-A[:r,i])</span><br><span class="line">        ans[i,i-r+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans[py]</span><br><span class="line"></span><br><span class="line">A = np.matrix(<span class="string">'1,2;3,4'</span>)</span><br><span class="line">b = np.matrix(<span class="string">'2;4'</span>)</span><br><span class="line">ans = solve(A,b)</span><br><span class="line">print(ans)</span><br><span class="line">print((b-A*ans[:,<span class="number">0</span>]))</span><br><span class="line">print(A*ans[:,<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<h2 id="高斯消元法模素数版本之点灯问题-O-n-3-求解"><a href="#高斯消元法模素数版本之点灯问题-O-n-3-求解" class="headerlink" title="高斯消元法模素数版本之点灯问题$O(n^3)$求解"></a>高斯消元法模素数版本之点灯问题$O(n^3)$求解</h2><p>解的个数取 $\log_2$ 就是 <a href="http://oeis.org/search?q=A159257&amp;sort=&amp;language=&amp;go=Search" target="_blank" rel="noopener">A159257</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="comment"># numpy 是用C写的，所以本质是强类型的，需要注意</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv</span><span class="params">(a,p)</span>:</span> <span class="comment"># 0&lt;a&lt;p and gcd(a,p)=1</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> (p-p//a)*inv(p%a,p)%p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trip</span><span class="params">(A, b, p = <span class="number">2</span>)</span>:</span> <span class="comment"># 0 &lt;= A[i,j] &lt; p</span></span><br><span class="line"><span class="comment"># 使A上三角，并返回A的秩 和 列变换px</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    px = list(range(n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        j,k = i,i</span><br><span class="line">        <span class="keyword">while</span>(k&lt;n):</span><br><span class="line">            j=i</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n <span class="keyword">and</span> A[j,k]==<span class="number">0</span>): j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(j != n): <span class="keyword">break</span></span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(k == n): <span class="keyword">return</span> i,px</span><br><span class="line">        <span class="keyword">if</span>(i!=k):</span><br><span class="line">            px[i],px[k] = px[k],px[i]</span><br><span class="line">            A[:,[i,k]] = A[:,[k,i]]</span><br><span class="line">        <span class="keyword">if</span>(j!=i):</span><br><span class="line">            b[[i,j]] = b[[j,i]]</span><br><span class="line">            A[[i,j]] = A[[j,i]]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">            ratio = A[j,i]*inv(A[i,i],p)%p</span><br><span class="line">            b[j] = (b[j]-b[i]*ratio)%p</span><br><span class="line">            A[j,i:n] = (A[j,i:n]-A[i,i:n]*ratio)%p</span><br><span class="line">    <span class="keyword">return</span> n,px</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trisolvep</span><span class="params">(A, b, p=<span class="number">2</span>)</span>:</span> <span class="comment"># 0 &lt;= A[i,j] &lt; p and 0&lt;A[i,i]&lt;p</span></span><br><span class="line">    ans = b.copy()</span><br><span class="line">    n = len(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        ans[i] = ans[i]*inv(A[i,i],p)%p</span><br><span class="line">        ans[:i] = (ans[:i] - A[:i,i]*ans[i])%p</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solvep</span><span class="params">(A, b, p=<span class="number">2</span>)</span>:</span></span><br><span class="line"><span class="comment"># 求解 Ax = b ，其中A是矩阵，b是列向量</span></span><br><span class="line"><span class="comment"># 答案是 a[0] + k[1] a[1] + ... + k[n-r] a[n-r]</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            A[i,j]%=p</span><br><span class="line">        b[i]%=p</span><br><span class="line">    r,px = trip(A,b,p)</span><br><span class="line">    py = list(range(n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n): py[px[i]] = i</span><br><span class="line">    <span class="keyword">if</span>(r == n): <span class="keyword">return</span> trisolvep(A,b,p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(r,n):</span><br><span class="line">        <span class="keyword">if</span>(b[i,<span class="number">0</span>] != <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    ans = np.matrix(np.zeros([n,n-r+<span class="number">1</span>], dtype=np.int))</span><br><span class="line">    ans[:r,<span class="number">0</span>] = trisolvep(A[:r,:r],b[:r])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(r,n):</span><br><span class="line">        ans[:r,i-r+<span class="number">1</span>] = trisolvep(A[:r,:r],(-A[:r,i])%p)</span><br><span class="line">        ans[i,i-r+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans[py]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lighton</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="comment"># x 是行向量</span></span><br><span class="line">    n = x.size</span><br><span class="line">    ans = np.matrix(np.ones([n,n]),dtype = np.int)</span><br><span class="line">    ans[<span class="number">0</span>,:] = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span>): ans[i,j] ^= ans[i<span class="number">-2</span>,j]</span><br><span class="line">            ans[i,j] ^= ans[i<span class="number">-1</span>,j]</span><br><span class="line">            <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>): ans[i,j] ^= ans[i<span class="number">-1</span>,j<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n): ans[i,j] ^= ans[i<span class="number">-1</span>,j+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">light</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="comment"># n 是整数</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>): <span class="keyword">return</span> [np.matrix(<span class="string">'1'</span>)]</span><br><span class="line">    x = np.matrix(np.zeros([n,n+<span class="number">1</span>]),dtype = np.int)</span><br><span class="line">    y = np.matrix(np.zeros([n,n+<span class="number">1</span>]),dtype = np.int)</span><br><span class="line">    <span class="comment"># 先处理好第一二行</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        x[i,i] = <span class="number">1</span></span><br><span class="line">        y[i,<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        y[i,:] -= x[i,:]</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>): y[i,:] -= x[i<span class="number">-1</span>,:]</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n):  y[i,:] -= x[i+<span class="number">1</span>,:]</span><br><span class="line">    <span class="comment"># 第i行由它的前两行决定</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        last = np.matrix(np.zeros([n,n+<span class="number">1</span>]),dtype = np.int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n): last[i,<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            last[i,:] -= x[i,:]</span><br><span class="line">            last[i,:] -= y[i,:]</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>): last[i,:] -= y[i<span class="number">-1</span>,:]</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n):  last[i,:] -= y[i+<span class="number">1</span>,:]</span><br><span class="line">        x = y</span><br><span class="line">        y = last</span><br><span class="line">    <span class="comment"># 此时 x为倒数第二行，y为倒数第一行，根据最后一行灯的情况列方程</span></span><br><span class="line">    A = np.matrix(np.zeros([n,<span class="number">2</span>*n]),dtype = np.int)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        A[i,i] = A[i,i+n]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>): A[i,i<span class="number">-1</span>+n] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n):  A[i,i+<span class="number">1</span>+n] = <span class="number">1</span></span><br><span class="line">    A = A*np.vstack((x,y))</span><br><span class="line">    b = np.matrix(np.ones([n,<span class="number">1</span>]),dtype = np.int)</span><br><span class="line">    ans = np.matrix(np.zeros([n,n]),dtype = np.int)</span><br><span class="line">    x = solvep(A[:,:n],b - A[:,<span class="number">-1</span>]).T</span><br><span class="line">    <span class="comment"># x 是方程的解，也就是首行的点灯情况</span></span><br><span class="line">    cnt = <span class="number">2</span>**(len(x)<span class="number">-1</span>)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt):</span><br><span class="line">        <span class="comment"># 这里一定要用copy而不能直接等于</span></span><br><span class="line">        x0 = np.copy(x[<span class="number">0</span>,:]) </span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(i):</span><br><span class="line">            index+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>): x0+=x[index,:]</span><br><span class="line">            i&gt;&gt;=<span class="number">1</span></span><br><span class="line">        ans.append(lighton(x0&amp;<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):  <span class="comment"># n = 19 时方案数 2^16 = 65536，所以会比较慢</span></span><br><span class="line">    n = int(input(<span class="string">'输入n：'</span>)) </span><br><span class="line">    m = light(n)</span><br><span class="line">    print(<span class="string">'方案数：'</span>+str(len(m)))</span><br><span class="line">    print(m)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没学 Python 之前这个操作我肯定是用 Matlab 做了。</p>
<p>不用 C 是因为操作矩阵的话用 C 还要写矩阵乘法。矩阵加法等操作，代码量大大提升。</p>
<p>不过没想到 Python 代码量也这么大，主要还是问题复杂或者说优化代码不可避免带来代码量的提高</p>
<p>高斯消元法对于行不满秩的情况也太繁琐了吧！怪不得它们都不实现。。。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>非交换环概念框架图</title>
    <url>/graphOfNoncommutativeRing/</url>
    <content><![CDATA[<p>最近在看 T.Y.Lam（林节玄）的书，深知非交换环的小技巧深不见底，不过仔细品味了一番之后也觉得十分有趣。最后给一张各种概念之间的关系，每一种概念都有很多等价定义，概念之间关系的推导也十分微妙，充满了技巧性。</p>
<a id="more"></a>
<p><img src= "/img/loading.gif" data-lazy-src="0.png" alt="noncommutaiveRings"></p>
<p>上面带 <code>=</code> 号的条件是说在此条件下，两个概念等价。<br>推理的细节，以及各个概念的定义为这里就不写了。</p>
<blockquote>
<p>有兴趣可以查阅 GTM 131 T.Y.Lam《A First Course in Noncommutative Rings》</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/heapWithPy/</url>
    <content><![CDATA[<p>堆（heap ）是一种经典的数据结构，C++ STL 中优先队列<code>priority_queue</code> 和 Python 中的 <code>heapq</code>  都是堆的一种实现。这里说明一下堆的原理和 heapq 的使用：</p>
<blockquote>
<p>中搜索 <code>优先队列</code>  可以看到堆的简单介绍。</p>
</blockquote>
<a id="more"></a>
<h2 id="（最小）堆是满足下面条件的二叉树"><a href="#（最小）堆是满足下面条件的二叉树" class="headerlink" title="（最小）堆是满足下面条件的二叉树"></a>（最小）堆是满足下面条件的二叉树</h2><ul>
<li>父节点小于等于子节点</li>
<li>用列表或者数组保存（这个也不是必须的，但一般都是这样做的）</li>
</ul>
<blockquote>
<p>堆根节点是最小的节点，堆的深度永远是$\log n$, 即是平衡的</p>
</blockquote>
<h3 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h3><ul>
<li>插入一个元素： 将它放在最后面，向上更新 $O(\log n)$</li>
<li>删除最小的元素： 将最后的元素放在根节点，向下更新  $O(\log n)$</li>
<li>查看最小的元素（根节点）</li>
<li>将一个列表初始化： 将列表从根更新，然后依次递归更新  $O(n)$</li>
</ul>
<blockquote>
<p>从上述操作可知，堆可以用于<strong>堆排序</strong>，整体复杂度 $O(n \log n)$</p>
</blockquote>
<h3 id="实现一个堆还是挺简单的，不过我们没必要再造轮子了。-下面用例子看一下-Python-堆的使用"><a href="#实现一个堆还是挺简单的，不过我们没必要再造轮子了。-下面用例子看一下-Python-堆的使用" class="headerlink" title="实现一个堆还是挺简单的，不过我们没必要再造轮子了。 下面用例子看一下 Python 堆的使用"></a><strong>实现一个堆还是挺简单的，不过我们没必要再造轮子了。</strong> 下面用例子看一下 Python 堆的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="comment"># from heapq import *</span></span><br><span class="line">x= list(range(<span class="number">10</span>))</span><br><span class="line">random.shuffle(x)</span><br><span class="line">heapq.heapify(x)</span><br><span class="line">print(x)</span><br><span class="line">heapq.heappop()</span><br><span class="line">heapq.heappush(x,<span class="number">3</span>)</span><br><span class="line">heapq.heapreplace(x,<span class="number">-1</span>)</span><br><span class="line">heapq.heappushpop(x,<span class="number">-2</span>) <span class="comment">#先push后pop，效率自然更快</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>快速数论变换（FNT）</title>
    <url>/fastNumberTranslation/</url>
    <content><![CDATA[<p>快速数论变换（FNT）是环 $\mathbb{Z}/ m \mathbb{Z}$ 上的 Fourier 变换（FFT）。<br>至于 快速 Fourier 变换是怎样的有什么用处，这里就不多说了，可参考 <a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform#i-15" target="_blank" rel="noopener">这里</a>。</p>
<a id="more"></a>
<h2 id="NFT-的核心问题"><a href="#NFT-的核心问题" class="headerlink" title="NFT 的核心问题"></a>NFT 的核心问题</h2><p>无论是 FNT 还是 FFT 其本质其关键就是寻找一个 $w$ 使得 $w^{2^n} = 1$。在复数域中这个问题是显然的，而在一个环那就不那么简单了，这里我们考虑环 $R = \mathbb{Z}/ m \mathbb{Z}$。$R$ 为域当且仅当 $m$ 为素数。我们的问题是：</p>
<ol>
<li>我们选取 $R$ 中找比较大（满足我们的需求）的 $n$ 使得 $w^{2^n} = 1$ ；</li>
<li>找出对应的“原根“；</li>
<li>类似 FFT 的处理</li>
<li>应用时各种可能出错的情形，最常见的是溢出,还有只适用于数据范围不超过 P 的非负整数。</li>
</ol>
<h2 id="NFT-问题解决"><a href="#NFT-问题解决" class="headerlink" title="NFT 问题解决"></a>NFT 问题解决</h2><p>  为使得分析问题更为简单，我们考虑在$m = p$ 为素数的情形，此时，我们有 $2^n \mid p-1$ 即 $p=k 2^n+1$ 为(Fermat)素数，例如：</p>
<ol>
<li>$p=479 \times 2^{21} +1 = 1004535809,g = 3$</li>
<li>$p= 13 \times 2^{20} + 1 = 13631489,g = 15$</li>
<li>$p= 17 \times 2^{27} + 1 = 2281701377,g=3$<br>更多常数选择可见<a href="http://blog.miskcoo.com/2014/07/fft-prime-table" target="_blank" rel="noopener">这里</a>。</li>
</ol>
<p>最终我们选择了 $FM = 1004535809$ 它的优势在于,它的两倍不超过 int 它的乘积不超过 long long 很有利于我们的运算，如果使用刚好不超过 long long 的数使用时很容易出现溢出并不方便。并且它恰好比较大。避免了做完 FFT 出现溢出。另外它可以取到的最大的 $N&gt;2e6$ 也很不错。例如现在如果我们要做 $2^k,k \leq 21$ 的 NFT。那么我们取 $w = g^{\frac{p-1}{2^k}}$ 即可。</p>
<h2 id="HDU-1402"><a href="#HDU-1402" class="headerlink" title="HDU 1402"></a>HDU 1402</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">132005</span>;</span><br><span class="line"><span class="keyword">char</span> sa[N&gt;&gt;<span class="number">1</span>],sb[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line">LL a[N],b[N];</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=x*x%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(LL *x,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=i,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;loglen;++j,t&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            k=(k&lt;&lt;<span class="number">1</span>)|(t&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;i) swap(x[i],x[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL FM = <span class="number">479</span>&lt;&lt;<span class="number">21</span>|<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(LL *x,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen,<span class="keyword">bool</span> isInverse)</span></span>&#123;</span><br><span class="line">    LL g = pow_mod(<span class="number">3</span>,(FM<span class="number">-1</span>)&gt;&gt;loglen,FM);</span><br><span class="line">    <span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">        g=inv(g,FM);</span><br><span class="line">        LL invlen = pow_mod(len,FM<span class="number">-2</span>,FM);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">            x[i]=x[i]*invlen%FM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    change(x,len,loglen);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">2</span>;<span class="built_in">step</span>&lt;=len;<span class="built_in">step</span>&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> half = <span class="built_in">step</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        LL wn = pow_mod(g,len/<span class="built_in">step</span>,FM);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="built_in">step</span>)&#123;</span><br><span class="line">            LL w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;i+half;++j)&#123;</span><br><span class="line">                LL t=(w*x[j+half])%FM;</span><br><span class="line">                x[j+half]=(x[j]-t+FM)%FM;</span><br><span class="line">                x[j]=(x[j]+t)%FM;</span><br><span class="line">                w = w*wn%FM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,sa,sb))&#123;</span><br><span class="line">        <span class="keyword">int</span> alen=(<span class="keyword">int</span>)<span class="built_in">strlen</span>(sa);</span><br><span class="line">        <span class="keyword">int</span> blen=(<span class="keyword">int</span>)<span class="built_in">strlen</span>(sb);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>,loglen=<span class="number">0</span>,tmp=alen+blen+<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(len&lt;tmp)&#123;</span><br><span class="line">            len&lt;&lt;=<span class="number">1</span>;++loglen;</span><br><span class="line">        &#125;</span><br><span class="line">        clr(a,<span class="number">0</span>);clr(b,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=alen;++i)    a[i]=sa[alen-i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=blen;++i)    b[i]=sb[blen-i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">        nft(a,len,loglen,<span class="number">0</span>);</span><br><span class="line">        nft(b,len,loglen,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">            a[i] = a[i]*b[i]%FM;</span><br><span class="line">        &#125;</span><br><span class="line">        nft(a,len,loglen,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;len)&#123;</span><br><span class="line">            a[cnt+<span class="number">1</span>]+=a[cnt]/<span class="number">10</span>;</span><br><span class="line">            a[cnt]%=<span class="number">10</span>;++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=alen+blen;</span><br><span class="line">        <span class="keyword">while</span>(cnt&gt;<span class="number">1</span>&amp;&amp;a[cnt<span class="number">-1</span>]==<span class="number">0</span>)    --cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>((<span class="keyword">int</span>)a[i]+<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>2017 横店马拉松</title>
    <url>/hengDianMarathon2017/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">日常表白 zly</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="f23ac8c1235d88f0476c7a3b36b424664b2bcd8fa71cb253588c1aa9ef98f7c6">f4647356fba07bf28b4b6a3e7b03b38f4628766f98ae0424ccbd481648acbe8d8e1a1a201c2ee8266a97cd27c77d0c7ae8343e85c556bc585af85269b33afbc2a1b9f85c50484bd25d762aa292c3e67a1a1e0d6b0eae21d996a3ba75104199754f52cd4fdb5ea7354b80a3f21b708e4072509d0c0737413c01b3b7e6715bd3bc4b4a938c6354736f246d21daa1e82838e1e3dbf36d43a9b90ceff1eb11e6966db9f3e694537b41fc46555bd4523491be08cb99295c142442ef0982d91f96ce75543494d7ebfade9e020b9284a6ccde05891807db3913bb3442b1f2ad9a5b7271956b0bfd6325db5e4c63348a53203fc6129fb5574cce3061b7ed41c9357582966e615c2f17ba12376ad721c011e9f926906c193fc0fb2bb6fb5e32c923be676ffa83cb51223d88b860c139c4bfec42599c652f1047665dcf11499e0b4f3f5ea75921d73423a7f487fba61ac3ab276da1d532716aa72118646326780caea5d8359342120dddae58da865754729b9d0e39f9dcb568dcf606c224efee88660ac99f53f550fc0257d2b86571dfbafdf8bbd04b2998deb1a67bb0a2394eb60e71a0ba187909c5e7e41cd60239e2dd617174fe2017224c5ef2248f54032175205851693f5ce06232dfc98a6113b2ca128417133883e459c5f02711073345000581f83466fa927bcb54222dda8c569f8ae5916f58374c751dcd17ab303f455ab93bafb69408c9ae6ad3611615ad4b054951eed1352d10614250677d16219fb80823334c10f14238d9bdc2caa52b009be35f496ef1c995b69543c6c4550714e9e30bc357dee92212c874a6812a1160ceb9ca2099e43492bbd212d3c1251b46e2e7ccbbf6128a31c4f040b2c1889ee4aa386b4f14c83f1d6ffa541ca36006b62b354e7acf5d55e84ee8beadd9937316c868d70f6da46509a2c7d7413afea4d614da7a6ba9bf3e30fc5210b67f5395947860d719f48d49061234eaf6ed43f9478f426fedb4a3810b938f189da27b8b76769fb1c7f785275679cde0daabd7b3da613edeba650be3a8b7b01068b7707f009402b92961e94f1529f8766d66416e47000a15482129f16c79d7f5b60b69dc9bbc5384c8364410021f28f9a47630cabf344d2b8bdf30e785cc238565530358b776fd78a329975cfcd9fc5f71c001577b9897c3b05ecd0fb890637b46857682b6b99d83ff16581f003c8603190d1f80292970620b33cbac80a7d80f2f28a4a383e654624ec53ca5e32dcb7b834f152d0ad1d75679ed4e428efee34bf48f85cca17ca680bedde196427f1a1d3abb9793ccbe10e478b7577b2ad0bcd1d166f30491f8764fa9511c4cfe93673f4d5629b31ebc27666024a115ba60deba08cb9d1dd1f79fc168f0011fb4fc9c87e0c22f4bbb9a676ad750c042d22f71714a6cdd8c96a7dcf484657769eac71ba120e560138d8be47f82f0afb4d7b64177136c9cedc3a06642b90ae72f50a0dd004dcb6421305f0963b93670018e2e9c7bacd8e979d8f713603b52722e9680758e0866fcd13a964aef9118525e089e5536af69f96cc31495a1d7b053385b735f2ce2048ce301e414d14b2c2e3183252029620e5d85e3a5a038140b308f20ffc8acae3f9ff03a189bf0f645a261c204ab710ecce3e7e68e7b1970688e04bc9757ec71fcfabe7cb3b9706dbd8145b8f1d68a2cd77d5dcdf8588564709ed5894ff0ed3ab2a5b7d905aa0ddd13840ffb3e807b11125e7d00653339de0d8305b391247847bdfba872609528e2784b4f6283920b650ca0f625d3cbe3a2325e1f31fef03b45d0c6649f3ab2e66a3f91ac4554bfae5ed8847954f3f8728abdf237d1c748ace0cef18bd5ad32eb35430357c8a16be38a4f54b17ceb2eb3a720e3a7d206c5e9ebb7cb1e94444f6e2547fb3082bab2b76fd641f7f4553f730133608c709fb9e5a86322384026c9d381c0f79138f1427cfd773a7782075f64b0eaf7bb11aaa2c29b5544a3746ccf11fa7bc04cf33dc417d6369f8330e27c2248e454abd8efe0067851022d5ce0aeae5a4046132ed033f1bef723c476cb974141a224ebb2556a6d0dbe45d0027b688525d37c48d21859fb5b0275428139d52d0cade210f149fcedca838e20d8c0f7d6633eca25a2052a21d712ef70d9548c08adf0b817346cb22cdd23c27d95170bed2e80a46b2117052b9689780e76d6f865fec29b30f66d2b7fbf771da9ab944c0d772d6c5429305e030cbbb0dc8b613069a16f2e8ded597f88b959134d39bdfc398d4333ed35f3f3fc8326d1a07d5be4610df74ff190ffc32b2dca09bbe262f7b4f0abf788bfa6e001dff1e45d5fd4ab666ffd501b181e3d0791960cd1025d2d174adda1041d1558530c582a17a7b2959b631a383f801e7bd30d1312bbe04b0dd63aead6652725530d9dcbe6f3d41f1a6375e8bc4e86e852082ea73e90063c30587a4cb5ef592714dee050ed8d2fa324eab921c84bf73335bc0da8c3f62e4e02e30e6ae391764fbc4f28f7c3e778caa08c8eada0c51b25724bd452a9729bcf6c562dfa94bab98d0cc4420e5cd0448c637935fbf8eab434e1c767c587c474f7e09bec01458416eb18b3511f917dda8fb4ae8a7a00e2b59af88b9a4412dbaa9b8530ba6140b2f5c527137d3b693f968630493a07f7d9749ade7dea1aa774ccfd1803ec6dea06591b9679b628c5e3431fa3ce612b022a016eacf40837bca0c418758987bc5a8e539087c4c92dc92a14aab72ce3690737a21f67bf63fe9297d954bd1a842cfd038cd7d0d812104ebc49e385848eeb74295181c6e3d39c38f9e80bcb426646e1fe94ad69847a5540a557cea96a6dad7ac62e35dea7dc92db075d0cdbd2139c3653128d66bdd89427cacaa3d0e42ec4bdad83a72bc19a7881e029a3485b6a0f6c2899d800fbf3dc71cabb66857afa887c3a795fe4af2453fc95676d497fe21b5ad205fd4eef5440419294a3a660062dcd962667da541d02fbc2f3fd00468a596972afc00223c5b8bea33a52d8c0db0384b659840883dacd6e5b6f610890d496cc67a357ab966a5e7a62b00c5817f18f4072d897b8363018a35ca7eb07caa826449ae4541550b3502d74c09d8b92075f88c9c9a467ca00e3ecc8a3e5095531a87a7f290a1540d2aa6a4292e2385da8b007bd89e9dac231a53eb03dcaeb863a262067d40b2d34fc1d5a54f0a579dcba1275848c279fcb64f326caa738b16a88afc18d9573c78b92a9a4ddaacf82aef7379e2961e267817fd6673db46d868e406c593d1be830bc80f6a68e512026952609be28d79acd30c768456d66d8d24839ed92b4907dda0516d349f4ddeef8a2250cd192ee948147036a76ac3716a8672cfcb84e84e423300989601377e388a5d5fb2d287c8487d1deff3102ea307ad2e512b946401060c9d44573fe94a5ef1b9f91477ca6952767e6368ca22268f1d7de61c4f318b53310971336040f006f3e01727e54606305cda2bc7dd3be96d536142a07754d1b93099cd23748c33fea09142b48d30b0e1d0e17771ac3a5cd0f84094e7b939b8fcc804bc1cc6761ec2d44c953b37b65126b3a4d4ac7326fd0db6d039f4ce533f515e48fa1ddc624f0e1ce658a890e593fda448281e3adf01690bb3b2b3b50dbcd29346d1b0d4f51ff7544231547631dce7e20508135ce5d6265fc414614c9d875447a2f40e2deb4ac7c8cc23b03db0b6a92a5fa3957be549b86010c01f7b346ddcc0b9fa4495dc67434585d5e6f8589efaad5eb6aae76af76428d95bf6834223c29494fe34514d5c4efab0e0d851f11d5547a34add0b0d56f8bb488ffaa2ba5810b623781609e5d46cf596c0f1dbfbd890778a1b78e921f0e3f002c7e890015805ce662f810687c30f8c743cba22d9ade687ccb356b5e5f5603eed66fc520c5de53cba5e0fe825085570d31b231f64edfd6f7d15ed49a167d1c57401617a9b29d1fca7845d7890e4f12582d4b882932608a6fff54b205421fbc6d66dd1b183cc3ff08baf67831b6f0531f583eb66ceb8a09c0a1eeea55860432f02308bc380076cadde0f4dc15b065cc2da35ac589f54baf4149745e773101eed709a4821fde73453790760841136e72c58f4393a45e88e01f13212578e7a828a3984e4a2b90a56cffb36bb353116b45551bd16f624efb80b0dc3ec6a1a75ed46eecd1a5710046de618751bcaed877fe1d484cbc4a7840194eb884fd555031f3312251c9b6656af0ac2cbd2a96034aa694053ca4c72b8819ccb9881a38100184c22f9f7d7f2de92457430fd32f74c31e16ce969fb571597240d380d39d82ab6f31535f6e4b537a757255b69bf011c99b4a938d4347d11e981e8990db6410a082a52a5fdd38d4e27642d3abead5509b0e6c9543df00f0765425bbf9bf2d44f830e8f0d09bd2442dcaedd0781acebac3e76c2159ed07f7318bfd0948c78fda776bd892a60dc292c31c6e829fe6fef8b1484fbd1117fcf7abeae43dc7f518b97efd6a9b0278b2b703447be1d9f730a421e8da19fc6310030729b38468cfc99ed1b1cb863059c6e846f203b3b1da912ea94a6901af</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>图片转化成位数据</title>
    <url>/imageToByte/</url>
    <content><![CDATA[<h2 id="把图片变成数据"><a href="#把图片变成数据" class="headerlink" title="把图片变成数据"></a>把图片变成数据</h2><p>有时程序需要加载本地图片，然后打包的时候就很不方便，所以 wxPython 支持 img2png.py、img2py.py、img2xpm.py 等工具来支持这种操作，但是我调用的时候一直出错，在网上查了很多方式最后找到了解决方案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># imageToBite.py</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dna049.png'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    bData = base64.b64encode(f.read())</span><br><span class="line">    pData = bData.decode()</span><br><span class="line">    print(pData)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这段代码就是把图片变成数据 bite。 相应的修改图片就可以换着用了，如果很多就批处理自己照样写。</p>
<p>然后在命令行执行</p>
<p><code>py imageToBite.py &gt; a.txt</code></p>
<p>就可以把数据存下来，然后复制到下面程序的 data 中就行了。</p>
<p><strong>然后在 wxPython 框架下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wx.lib.embeddedimage <span class="keyword">import</span> PyEmbeddedImage</span><br><span class="line">bitmap = PyEmbeddedImage(data).GetBitmap()</span><br></pre></td></tr></table></figure>
<p>就可以咯</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 将图片换成字符</title>
    <url>/imageToChar/</url>
    <content><![CDATA[<p>我知乎上看到 <a href="https://zhuanlan.zhihu.com/p/126669800" target="_blank" rel="noopener">怎么用 Python 把图片转化为字符？</a> 挺有趣的，自己也尝试了一下，当然他也是参考<a href="https://github.com/RameshAditya/asciify/blob/master/asciify.py" target="_blank" rel="noopener">这里</a>。</p>
<p>原理就是：将图片（位图）转化成灰度图，即 0~255 的数值，然后将这些数值换成特殊符号（自定义）</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># imageToChar.py 使用说明：</span></span><br><span class="line"><span class="comment"># 把图片(例如xx.png)和这个文件放在同一文件夹中</span></span><br><span class="line"><span class="comment"># 命令行进入上面的文件夹路径输入</span></span><br><span class="line"><span class="comment"># py imageTochar.py xx.png (自选宽度：78，可不填)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">chars = [<span class="string">'z'</span>, <span class="string">'l'</span>, <span class="string">'y'</span>, <span class="string">'#'</span>, <span class="string">'?'</span>, <span class="string">'*'</span>, <span class="string">'+'</span>, <span class="string">';'</span>, <span class="string">':'</span>, <span class="string">','</span>, <span class="string">'.'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(image, newW)</span>:</span></span><br><span class="line">    (w, h) = image.size</span><br><span class="line">    <span class="comment"># 0.58 大致是单个字符在DOS界面的宽高比</span></span><br><span class="line">    newDim = (newW, int(<span class="number">0.58</span>*h*newW/w))</span><br><span class="line">    newImg = image.resize(newDim)</span><br><span class="line">    <span class="keyword">return</span> newImg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">garytochar</span><span class="params">(grayImg,newW)</span>:</span></span><br><span class="line">    newPix = [];step=<span class="number">256</span>//len(chars) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i,data <span class="keyword">in</span> enumerate(grayImg.getdata()):</span><br><span class="line">        <span class="keyword">if</span>(i%newW == <span class="number">0</span>): newPix.append(<span class="string">'\n'</span>)</span><br><span class="line">        newPix.append(chars[data//step])  <span class="comment">#也可以用 data%len(chars)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(newPix)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imagetochar</span><span class="params">(imgPath, newW = <span class="number">78</span>)</span>:</span></span><br><span class="line">    img = Image.open(imgPath)</span><br><span class="line">    newImg = resize(img,newW)</span><br><span class="line">    grayImg = newImg.convert(<span class="string">'L'</span>)</span><br><span class="line">    <span class="keyword">return</span> garytochar(grayImg,newW)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    imgPath, newW, *tmp = sys.argv[<span class="number">1</span>:<span class="number">3</span>]+ [<span class="number">78</span>]</span><br><span class="line">    charPix = imagetochar(imgPath,int(newW))</span><br><span class="line">    print(charPix)</span><br></pre></td></tr></table></figure>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">原始图片</th>
<th style="text-align:center">字符图片</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src= "/img/loading.gif" data-lazy-src="dna049.png" alt="dna049"></td>
<td style="text-align:center"><img src= "/img/loading.gif" data-lazy-src="dna049char.png" alt="dna049"></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>华罗庚恒等式</title>
    <url>/huaIndentity/</url>
    <content><![CDATA[<p>华罗庚恒等式有两个，都看似奇怪但都有其深刻的应用(数学内部的)</p>
<ol>
<li><p>若在一个环中 $a,b,1-ab$ 都可逆，则</p>
<script type="math/tex; mode=display">
\left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a</script></li>
<li><p>若在一个环中</p>
<script type="math/tex; mode=display">
a = \left( b^{-1} - (a-1)^{-1}b^{-1}(a-1) \right) \left (a^{-1} b^{-1}a-(a-1)^{-1}b^{-1}(a-1) \right)^{-1}</script></li>
</ol>
<p>上面两个恒等式直接验算即知，可是华老当初怎么想到这两个很奇怪的恒等式呢，怎么导入的，有什么应用呢？</p>
<a id="more"></a>
<p>当然以下也只是我的个人猜测加上 Wikipedia 的一些参考。</p>
<h2 id="在环中-1-ba-可逆当且仅当-1-ab-可逆"><a href="#在环中-1-ba-可逆当且仅当-1-ab-可逆" class="headerlink" title="在环中,  1-ba 可逆当且仅当 1-ab 可逆"></a>在环中,  1-ba 可逆当且仅当 1-ab 可逆</h2><script type="math/tex; mode=display">
(1-ba)^{-1} = 1+ b(1-ab)^{-1}a</script><p>上面恒等式直接证明是显然的，应用却 666，6 到要吐。<br>问题在于为什么想到这样奇怪的式子呢？思路怎么来的呢？<br>我们知道，当 $0&lt;x&lt;1$ 时，</p>
<script type="math/tex; mode=display">
\frac{1}{1-x} = \sum_{n=0}^{\infty} {x^n}</script><p>因此，形式上我们有</p>
<p>讲上述不等式应用到矩阵形式即可得到 Sherman–Morrison 恒等式</p>
<h2 id="在环中，若-a-b-ab-1-可逆，则"><a href="#在环中，若-a-b-ab-1-可逆，则" class="headerlink" title="在环中，若 $a,b,ab-1$ 可逆，则"></a>在环中，若 $a,b,ab-1$ 可逆，则</h2><p>由上面恒等式我们知道 </p>
<script type="math/tex; mode=display">
(ab-1)^{-1} = a(ba-1)^{-1}b - 1</script><p>因此</p>
<script type="math/tex; mode=display">
\begin{aligned} (a-b^{-1})^{-1} &= \left((ab-1)b^{-1} \right)^{-1} \\
&= b\left( a(ba-1)^{-1}b - 1 \right) \\
&= ba(ba-1)^{-1}b - b  \\
&= (ba-1)^{-1}b
\end{aligned}</script><p>注意到 </p>
<script type="math/tex; mode=display">
\begin{aligned}  (ba-1)^{-1}b - a^{-1} &= (ba-1)^{-1}baa^{-1} - a^{-1} \\
&= (ba-1)^{-1}a^{-1} \\
&= (aba-a)^{-1} 
\end{aligned}</script><p>因此，华罗庚等式 1： $ \left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a$ 得证。</p>
<h2 id="一个重要恒等式"><a href="#一个重要恒等式" class="headerlink" title="一个重要恒等式"></a>一个重要恒等式</h2><script type="math/tex; mode=display">
b^{-1} - a^{-1} = ( b+b(a-b)^{-1}b )^{-1}</script><p>上面恒等式与逆算子连续性有关系。<br>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}  (b^{-1} - a^{-1})^{-1} &= (1-ba^{-1})^{-1}b \\
&=(1+b(1-a^{-1}b)^{-1}a^{-1})b \\
&= b+b(a-b)^{-1}b
\end{aligned}</script><h2 id="华罗庚恒等式-2-证明"><a href="#华罗庚恒等式-2-证明" class="headerlink" title="华罗庚恒等式 2 证明"></a>华罗庚恒等式 2 证明</h2><script type="math/tex; mode=display">
\begin{aligned} 
a \left( a^{-1}b^{-1}a - (a-1)^{-1} b^{-1}(a-1) \right) &=
(b^{-1}a- a(a-1)^{-1} b^{-1} (a-1) \\
&= ( 1-a(a-1)^{-1} )b^{-1}a + (a-1+1) (a-1)b^{-1} )^{-1} \\
&= -(a-1)^{-1}b^{-1}a + b^{-1} + (a-1)b^{-1} \\
&= b^{-1} - (a-1)^{-1} b^{-1}(a-1) 
\end{aligned}</script><h2 id="华罗庚恒等式的意义"><a href="#华罗庚恒等式的意义" class="headerlink" title="华罗庚恒等式的意义"></a>华罗庚恒等式的意义</h2><ol>
<li>华罗庚第一个恒等式可以用来证明一个 Hua’s Theorem：除环间中保持加法和幺元以及逆元的映射必然是除环间的同态或者反同态。</li>
<li>华罗庚第二个恒等式可以证明 Cartan-Brauer-Hua Theorem 即一个除环的真子除环的单位群如果是原除环的单位群的正规子群，则该子除环一定包含于除环的中心。</li>
</ol>
<h2 id="最后用一句广为流传的话结尾"><a href="#最后用一句广为流传的话结尾" class="headerlink" title="最后用一句广为流传的话结尾"></a>最后用一句广为流传的话结尾</h2><blockquote>
<p>龙生龙，凤生凤，华罗庚的学生会打洞（矩阵打洞）</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵的 Jordan 分解</title>
    <url>/jordanDecompositionOfMatrix/</url>
    <content><![CDATA[<p>最近在整理李代数（Lie Algebra） 内容时，里面提到了 Jordan 分解，这里就详细介绍并证明几个相关结果。</p>
<ol>
<li>若矩阵 $A,B$ 可交换，则它们有公共特征向量。</li>
<li>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换</li>
<li>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化（半单部分），$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。</li>
</ol>
<a id="more"></a>
<p>下面证明这三个结果并给出说明其意义。</p>
<h2 id="若矩阵-A-B-可交换，则它们有公共特征向量"><a href="#若矩阵-A-B-可交换，则它们有公共特征向量" class="headerlink" title="若矩阵 $A,B$ 可交换，则它们有公共特征向量"></a>若矩阵 $A,B$ 可交换，则它们有公共特征向量</h2><p><strong>证明</strong>：我们设 $V$ 为 $n$ 阶列向量全体。设 $\lambda$ 为 $B$ 的一个特征值。设 </p>
<script type="math/tex; mode=display">
W = \lbrace x \in V \mid Bx = \lambda x \rbrace</script><p>则对任意 $x \in W$,</p>
<script type="math/tex; mode=display">
B(Ax) = A(Bx)=A(\lambda x)=\lambda(Ax)</script><p>即 $Ax \in W$。即 $W$ 是 $A$ 的不变子空间，因此，$A$ 在 $W$ 中有特征值 $\mu$ 对应的特征向量 $v$ 即为所求。</p>
<h2 id="若矩阵-A-B-可以对角化，则它们可以同时对角化，当且仅当-A-B-交换"><a href="#若矩阵-A-B-可以对角化，则它们可以同时对角化，当且仅当-A-B-交换" class="headerlink" title="若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换"></a>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换</h2><p><strong>证明</strong>：$\rightarrow$ 是显然的。现证 $\leftarrow$ 若 $A,B$ 交换。<br>由条件知，存在可逆矩阵 $P$ 使得 $P^{-1}AP = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})$。由 $A,B$ 交换知，$P^{-1}AP P^{-1}BP = P^{-1}BP P^{-1}AP$。因此</p>
<script type="math/tex; mode=display">
P^{-1}BP = \left(\begin{matrix} 
B_1 \\  & B_2 \\ & & \ddots \\ & & & B_s 
\end{matrix}\right)</script><p>因为 $B$ 可对角化，因此 $B$ 的最小多项式无重根。所以 $B_i$ 的最小多项式也无重根。因此 $B_i$ 可对角化，存在可逆矩阵 $Q_i$ 使得 $Q_i^{-1}B_iQ_i$ 为对角阵。令 $Q = diag(Q_1,\cdots,Q_s)$,$T=PQ$，则 $T^{-1}BT$ 为对角阵。$T^{-1}AT = diag(Q_1^{-1},\cdots,Q_s^{-1})diag(a_1 E_{n_1},\cdots,a_s E_{n_s}) diag(Q_1,\cdots,Q_s) = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})$<br>$T$ 即为所求。</p>
<h2 id="Jodan-分解"><a href="#Jodan-分解" class="headerlink" title="Jodan 分解"></a>Jodan 分解</h2><p>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化，$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。</p>
<p>证明：首先对任意矩阵，我们有 Jordan 标准型：对任意矩阵 $A$，存在可逆矩阵 $P$ 使得</p>
<script type="math/tex; mode=display">
P^{-1} A P = \left(\begin{matrix} J_1(\lambda_1) \\  & J_2(\lambda_2) \\ & & \ddots \\ & & & J_s(\lambda_s) \end{matrix}\right) = \left(\begin{matrix} \lambda_1 E_{n_1} \\  & \lambda_2 E_{n_2} \\ & & \ddots \\ & & & \lambda_s E_{n_s} \end{matrix}\right) + \left(\begin{matrix} J_1(0) \\  & J_2(0) \\ & & \ddots \\ & & & J_s(0) \end{matrix} \right)</script><p>由于 $ J_i(\lambda_i) $ 的化零多项式为 $f_i(\lambda) = |\lambda I_i -  J_i(\lambda_i)|$。由中国剩余定理知。存在多项式 $f(\lambda)$ 满足 $f(\lambda) = \lambda_i (mod \; f_i),i=1,\cdots,s$ 且 $f(\lambda)= 0 (mod \lambda)$。此时</p>
<script type="math/tex; mode=display">
P^{-1} f(A) P = \left(\begin{matrix} \lambda_1 E_{n_1} \\  & \lambda_2 E_{n_2} \\ & & \ddots \\ & & & \lambda_s E_{n_s} \end{matrix}\right)</script><p>令$B=f(A)，C=A-B$ 即为所求。上面的$B,C$ 是唯一的，因为，若存在$B_1,C_1$ 也满足上述条件，则 $A,B,C,B_1,C_1$彼此交换，$B-B_1 = C_1 - C$ 是幂零的，因此 $B=B_1,C=C_1$。</p>
<p>对于 Jordan 分解，我们可以将一个矩阵分为所谓的半单部分和幂零部分，而由第二条结论知道，如果 $A_1,A_2$ 可交换，那么$A_1+A_2$ 的半单部分即为 $B_1+B_2$。或者说的更明了一点就是，如果 $A,B$ 可交换，且可以对角化，则$A+B$ 也可以对角化。</p>
<blockquote>
<p>想到写这些完全是因为李代数忘掉 Lie 括号本身就是一个线性空间。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>二项式反演公式及其应用</title>
    <url>/inverseFormulaAndItsMatrixForm/</url>
    <content><![CDATA[<p>在<a href="/dirichletProduct/" title="上一篇博文">上一篇博文</a>中，介绍过数论中的 Mobius 反演公式，让我想起了另一个经典的反演公式： <strong>二项式反演公式</strong>。本质上反演公式就是矩阵求逆的过程。</p>
<p>只是它的逆有很简单的形式，因此才有了二项式反演公式，这个公式帮助我们队伍在 2014 年 ACM－ICPC 亚洲区域赛西安站拿银，当时<a href="2014xian.pdf">F 题</a>答案直接算需要$n^3$复杂度，而利用二项式反演公式后，可以在$n^2$复杂度内完美解决。1A 过题，感觉超爽。</p>
<blockquote>
<p>最后简单提一下：Mobius 反演公式及其矩阵形式</p>
</blockquote>
<a id="more"></a>
<h2 id="反演公式与其矩阵形式"><a href="#反演公式与其矩阵形式" class="headerlink" title="反演公式与其矩阵形式"></a>反演公式与其矩阵形式</h2><p>由</p>
<script type="math/tex; mode=display">
\sum _{r = 1} ^n a _{n,r} f(r) = g(n)</script><p>其中$g(n)$已知，解出$f(n)$</p>
<script type="math/tex; mode=display">
f(n) = \sum _{r = 1} ^n b _{n,r} g(r)</script><p>为其反演公式，也称上面两式互为反演公式。</p>
<p>令</p>
<script type="math/tex; mode=display">
A = \left( \begin{matrix} a _{11} & &  \\
a _{21} & a _{22} & \\
\cdots & \cdots & \ddots & \\
a _{n1} & a _{n2} & \cdots & a _{nn} \\
\end{matrix} \right) 
,\qquad 
B = \left( \begin{matrix} b _{11} & &  \\
b _{21} & b _{22} & \\
\cdots & \cdots & \ddots & \\
b _{n1} & b _{n2} & \cdots & b _{nn} \\
\end{matrix} \right)</script><p>则上述反演公式本质上就是求矩阵 $A$ 的逆 $B$.</p>
<h2 id="二项式反演公式"><a href="#二项式反演公式" class="headerlink" title="二项式反演公式"></a>二项式反演公式</h2><p>若</p>
<script type="math/tex; mode=display">
g(n) = \sum _{r = s} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) f(r)</script><p>其中 $s \geq 0$ 则</p>
<script type="math/tex; mode=display">
f(n) = \sum _{r = s} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) g(r)</script><p><strong>Proof</strong>:  要证明反演公式，只需证明，对应的矩阵 $A$ 和 $B$ 互为逆即可. 令 $C = A \star B$ 则</p>
<script type="math/tex; mode=display">
\begin{aligned}
c _{ij} = \sum _{k=1} ^n a _{ik} b _{kj} & = \sum _{k =j} ^ i \left(\begin{matrix} i \\ k\end{matrix}\right) (-1)^{k-j} \left(\begin{matrix} k \\ j\end{matrix}\right) = 
\sum _{k=0} ^ {i-j} \left(\begin{matrix} i \\ k+j\end{matrix}\right) (-1)^k \left(\begin{matrix} k+j \\ j\end{matrix}\right) \\
& = \left(\begin{matrix} i \\ j\end{matrix}\right) \sum _{k=0} ^ {i-j} (-1)^k \left(\begin{matrix} i-j \\ k\end{matrix}\right) = \left\{ \begin{array}{ll} 1,& i=j \\  0,& i>j\end{array} \right.
\end{aligned}</script><p>证毕。</p>
<h2 id="二项式反演公式的应用"><a href="#二项式反演公式的应用" class="headerlink" title="二项式反演公式的应用"></a>二项式反演公式的应用</h2><p>二项式反演公式在组合数学和数论中都有诸多应用，这里简单的提两个。</p>
<h3 id="错排问题-在-n-个数字-1-2-dots-n-形成-n-个排列-a-1a-2-dots-a-n-中满足-a-i-neq-i-的排列有多少个"><a href="#错排问题-在-n-个数字-1-2-dots-n-形成-n-个排列-a-1a-2-dots-a-n-中满足-a-i-neq-i-的排列有多少个" class="headerlink" title="(错排问题) 在 $n$ 个数字 $1, 2, \dots, n$ 形成 $n!$ 个排列 $a_1a_2 \dots a_n$ 中满足 $a_i \neq i$ 的排列有多少个"></a>(错排问题) 在 $n$ 个数字 $1, 2, \dots, n$ 形成 $n!$ 个排列 $a_1a_2 \dots a_n$ 中满足 $a_i \neq i$ 的排列有多少个</h3><p>不妨设答案为 $D_n$ ,则可以看出恰好有 $r$ 个  $a_i=i$的排列数为 $\left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}$，因此</p>
<script type="math/tex; mode=display">
n! = \sum _{r = 0} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}</script><p>因此</p>
<script type="math/tex; mode=display">
D_n ＝ \sum _{r = 0} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r! = n! \sum _{r=0} ^n \frac{(-1)^r}{r!}</script><blockquote>
<p>当然 $D_n$ 还有递推关系式 $D_1=0,D_2 = 1$</p>
<script type="math/tex; mode=display">
D_n = (n-1) (D_{n-1} + D_{n-2}),\quad n \geq 2</script></blockquote>
<h3 id="满射个数-求-m-元集-A-到-n-元集-B-的满身的个数-g-m-n"><a href="#满射个数-求-m-元集-A-到-n-元集-B-的满身的个数-g-m-n" class="headerlink" title="(满射个数) 求$m$元集$A$到$n$元集$B$的满身的个数$g(m,n)$"></a>(满射个数) 求$m$元集$A$到$n$元集$B$的满身的个数$g(m,n)$</h3><p>类似于错排的思路，我们有</p>
<script type="math/tex; mode=display">
n^m = \sum _{r = 1} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) g(m,r)</script><p>于是</p>
<script type="math/tex; mode=display">
g(m,n) =  \sum _{r = 1} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r^m</script><h2 id="Mobius-反演公式及其矩阵形式"><a href="#Mobius-反演公式及其矩阵形式" class="headerlink" title="Mobius 反演公式及其矩阵形式"></a>Mobius 反演公式及其矩阵形式</h2><p>由 Mobius 反演公式对应的矩阵我们有,若</p>
<script type="math/tex; mode=display">
a _{ij} = \left\{ \begin{array}{cc} 1, & j|i \\
0, & else. \end{array} \right.</script><p>则，其逆矩阵为</p>
<script type="math/tex; mode=display">
b _{ij} = \left\{ \begin{array}{cc} \mu (\frac{i}{j}), & j|i \\
0, & else. \end{array} \right.</script><blockquote>
<p>本文参考了<a href="http://www.douban.com/note/480023639/?type=like" target="_blank" rel="noopener">豆瓣</a>和<a href="http://wenku.baidu.com/link?url=0m3D-588KfEUvocmKGoW5X4z5SHrEKVOaqfLoTeRtJaJcG6oDEUh2QEbJmNa1p2OTkqFLCqhfhM-RsoOI2fkutlqL9q3xgJhIAic4HumI5W" target="_blank" rel="noopener">百度文库</a>以及 许胤龙，孙淑玲《组合数学引论》。</p>
</blockquote>
<h2 id="单位根反演"><a href="#单位根反演" class="headerlink" title="单位根反演"></a>单位根反演</h2><p>DFT 的本质就是单位根反演</p>
<script type="math/tex; mode=display">
\forall k,[n|k]=\frac{1}{n}\sum_{i=0}^{n-1}\omega_n^{ik}</script><p>一个应用的例子</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^{[\frac{n}{k}]}[x^{ik}]f(x)&=\sum_{i=0}^n[k|i][x^i]f(x)\\
&=\sum_{i=0}^n [x^i]f(x)\frac{1}{k}\sum_{j=0}^{k-1}\omega_{k}^{ji}\\
&=\frac{1}{k}\sum_{i=0}^n a_i\sum_{j=0}^{k-1}\omega_{k}^{ij}\\
&=\frac{1}{k}\sum_{j=0}^{k-1}\sum_{i=0}^n a_i(\omega_k^j)^i\\
&=\frac{1}{k}\sum_{j=0}^{k-1}f(\omega_{k}^j)
\end{aligned}</script><blockquote>
<p>单位根反演转自：<a href="https://www.cnblogs.com/cjyyb/p/10838495.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjyyb/p/10838495.html</a></p>
</blockquote>
<p>具体的例子求：$\sum_{i \in [0,n],k \mid i} \binom{n}{i}G^i$</p>
<p>计$f(x) = (G+x)^n$，则由上面公式</p>
<script type="math/tex; mode=display">
\sum_{i \in [0,n],k \mid i} \binom{n}{i}G^i = \frac{1}{k}\sum_{j=0}^{k-1} (G+\omega_{k}^j) ^n</script><p>即复杂度 $O(k \log n)$，如果要结果模一个 NFT friendly 的，那就更好了！</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 调用 C/C++ 之 ctypes</title>
    <url>/ctypes/</url>
    <content><![CDATA[<p>放弃 Julia 之后，我开始想要用 Python + ctypes 满足自己的需求。由于 Windows 搞这个很麻烦，就在 Ubuntu 上搞了，不过我是在 WSL 上做的哈哈。</p>
<a id="more"></a>
<h2 id="Python-调用-C-示例"><a href="#Python-调用-C-示例" class="headerlink" title="Python 调用 C 示例"></a>Python 调用 C 示例</h2><p><a href="https://docs.Python.org/zh-cn/3.8/library/ctypes.html" target="_blank" rel="noopener">ctypes 官方中文文档</a>中选择自己 Python 对应版本的文档。有很清晰的描述，然后在 <a href="https://docs.Pythontab.com/interpy/c_extensions/ctypes/" target="_blank" rel="noopener">Pythonlab.com</a> 中很直观的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>; <span class="comment">// 这样就不用改之前的代码了！</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于 C++ 支持函数重载功能，在编译时会更改函数名。</p>
<p>所以在函数声明时，前缀 <code>extern &quot;C&quot;</code> 则确保按 C 的方式编译。</p>
</blockquote>
<p>然后把上面 <code>add.c/add.cpp</code> 编译成 <code>.so</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#For Linux</span></span><br><span class="line">$ gcc -fPIC -shared -o libadder.so add.c</span><br><span class="line">$ g++ -fPIC -shared -o libadder.so add.cpp</span><br></pre></td></tr></table></figure>
<p>再调用就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#load the shared object file</span></span><br><span class="line">adder = CDLL(<span class="string">'./libadder.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find sum of integers</span></span><br><span class="line">res_int = adder.add_int(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">print(<span class="string">"Sum of 4 and 5 = "</span>, res_int)</span><br></pre></td></tr></table></figure>
<h2 id="Python-调用自己写的-primepi-C-函数"><a href="#Python-调用自己写的-primepi-C-函数" class="headerlink" title="Python 调用自己写的 primepi C++ 函数"></a>Python 调用自己写的 primepi C++ 函数</h2><blockquote>
<p>Python 调用自己写的 PrimePI 岂不美哉</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">// 仅对要用的做extern操作</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isp[i]) p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j) &#123;</span><br><span class="line">            isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span> * <span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">11</span> * <span class="number">13</span> * <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM + <span class="number">1</span>][M + <span class="number">1</span>], sz[M + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initprime();</span><br><span class="line">    pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isp[i]) pi[i] = pi[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> pi[i] = pi[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sz[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= PM; ++i) phi[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        sz[i] = p[i] * sz[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= PM; ++j) &#123;</span><br><span class="line">            phi[j][i] = phi[j][i - <span class="number">1</span>] - phi[j / p[i]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= M) <span class="keyword">return</span> phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];</span><br><span class="line">    <span class="keyword">if</span> (x / p[s] &lt;= p[s]) <span class="keyword">return</span> primepi(x) - s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; N &amp;&amp; x / p[s] / p[s] &lt;= p[s]) &#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>))];</span><br><span class="line">        LL ans = pi[x] - LL(s2x + s - <span class="number">2</span>) * (s2x - s + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt;= s2x; ++i) &#123;</span><br><span class="line">            ans += pi[x / p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primephi(x, s - <span class="number">1</span>) - primephi(x / p[s], s - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; N) <span class="keyword">return</span> pi[x];</span><br><span class="line">    <span class="keyword">int</span> ps2x = pi[<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>))];</span><br><span class="line">    <span class="keyword">int</span> ps3x = pi[<span class="keyword">int</span>(cbrt(x + <span class="number">0.2</span>))];</span><br><span class="line">    LL ans = primephi(x, ps3x) + LL(ps2x + ps3x - <span class="number">2</span>) * (ps2x - ps3x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ps3x + <span class="number">1</span>, ed = ps2x; i &lt;= ed; ++i) &#123;</span><br><span class="line">        ans -= primepi(x / p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行 <code>g++ -fPIC -shared -o libprimepi.so primepi.cpp</code> 后运行下面 Python 程序</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">c = CDLL(<span class="string">'./libprimepi.so'</span>)</span><br><span class="line">c.init()</span><br><span class="line"><span class="comment"># 再大就崩了，Segmentation fault (core dumped)</span></span><br><span class="line">print(c.primepi(<span class="number">9876543210</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C 中用 Python 老是提醒没有 <code>Python.h</code>，试了网上的方法，各种系统都不行服了。不过无所谓最在 C 中用 Python 啊</p>
</blockquote>
<h2 id="SageMath-调用-C-的方法"><a href="#SageMath-调用-C-的方法" class="headerlink" title="SageMath 调用 C 的方法"></a><a href="https://doc.sagemath.org/html/en/thematic_tutorials/cython_interface.html#cython-interface" target="_blank" rel="noopener">SageMath 调用 C 的方法</a></h2><h2 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a><a href="https://www.cnblogs.com/skynet/p/3372855.html" target="_blank" rel="noopener">动态库和静态库</a></h2><h2 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h2><p>既然要混合编程了，哪必然要涉及到 makefile 了，于是我去 <a href="https://www.zhihu.com/question/23792247/answer/600773044" target="_blank" rel="noopener">知乎</a></p>
<p>示例源代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    fun1();</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun1.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is fun1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fun2.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is fun2\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 Makefile（注意 Makefile 一定要 Tab 缩进)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># makefile1</span></span><br><span class="line"><span class="section">app: main.c fun1.c fun2.c  </span></span><br><span class="line">    gcc main.c fun1.c fun2.c -o app</span><br><span class="line"></span><br><span class="line"><span class="comment"># makefile2</span></span><br><span class="line"><span class="section">app: main.o fun1.o fun2.o  </span></span><br><span class="line">    gcc main.o fun1.o fun2.o -o app</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    gcc -c main.c -o main.o</span><br><span class="line"><span class="section">fun1.o: fun1.c</span></span><br><span class="line">    gcc -c fun1.c -o fun1.o</span><br><span class="line"><span class="section">fun2.o: fun2.c</span></span><br><span class="line">    gcc -c fun2.c -o fun2.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># makefile3</span></span><br><span class="line">obj = main.o fun1.o fun2.o  </span><br><span class="line">target = app  </span><br><span class="line">CC = gcc</span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(obj)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># makefile</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span>  </span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span> <span class="comment"># obj = $(src:%.c=%.o)  </span></span><br><span class="line">target = app  </span><br><span class="line">CC = gcc</span><br><span class="line"><span class="variable">$(target)</span>: <span class="variable">$(obj)</span>  </span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o: %.c  </span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean  </span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(obj)</span> <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 <code>$</code> 自然是取值操作 <code>%</code> 是未定元的感觉，然后 <code>wildcard, patsubst</code> 从版本中就能看出。</p>
<p><code>$&lt;</code>：第一个依赖文件；<code>$@</code>：目标文件；<code>$^</code>：所有不重复的依赖文件，以空格分开。</p>
</blockquote>
<p>依次执行 <code>make -f makefilei</code> 即可，最后 <code>make (-f makefile 可省略), make clean</code> 是最终版本</p>
<h2 id="Make-规则"><a href="#Make-规则" class="headerlink" title="Make 规则"></a><a href="https://zhuanlan.zhihu.com/p/44267123" target="_blank" rel="noopener">Make 规则</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">目标: 预置条件</span></span><br><span class="line">&lt;TAB&gt; 步骤</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/127335903" target="_blank" rel="noopener">这里写的很详细</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>Make</tag>
      </tags>
  </entry>
  <entry>
    <title>李代数</title>
    <url>/lieAlgebra/</url>
    <content><![CDATA[<p>近期在整理 Lie Algebra 课的笔记，还是很喜欢这门课的，主要是本科时候矩阵玩的特别 6，然后 Lie Algebra 可以认为是矩阵的推广版本。里面的证明技巧性相当强。我之所以喜欢数学很大程度与数学技巧有关。但是我的导师说，这些虽然很有技巧，但是你花时间都是可以处理的，会技巧没什么了不起，脑袋稍微好一点就能做这种事，长期技巧的训练其实意义并不大，应该更关注数学内部的东西，具体说就是一个代数对象的结构，分类，不变量，对象之间的同构。一个概念有哪些等价形式，与其它概念之间的关系，搞清楚这些更为重要，它们的证明只要大致知道怎么过来的就行。我们并不要把证明的细节放在心中，因为我们已经经过了多年的训练，相信我们通过大致步骤就能给出详细的证明，只是花的时间多少罢了。当然初学一个东西，去抠它的细节是无可厚非的。<br><strong>以上纯属废话 0.0</strong></p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>交换环 $K$ 上的模 $L$，以及一个运算 $L \times L \to L,(x,y) \mapsto [x,y]$ 称为 $x,y$ 的 Lie 括号，或交换子，并称 $L$ 是 $K$ 上的 Lie Algebra，如果满足如下公理。<br>L1. $[\cdot,\cdot]$ 是双线性的；<br>L2. $[x,x]=0$ 对任意 $x \in L$ 成立；<br>L3. $[x,[y,z]]+[y,[z,x]]+[z,[x,y]]=0$ (Jacobi 恒等式)</p>
<p>若 $[L,L]=0$ 则上面结论显然成立，此时称为 Abelian Lie Algebra。</p>
<blockquote>
<p>我们通常并不考虑 Abelian Lie Algebra。并且要求交换环 $K$ 是域 $F$，很多时候还要求 $F$ 是特征为 0 的代数闭域，另外我们大多考虑 $L$ 是 $F$ 上的有限维线性空间。</p>
</blockquote>
<p>子，理想，商，同态，表示等一系列的概念和其它代数结构几乎一致。可以划入范畴中。另外单，半单，Radical 等这些概念也于环里面的类似，就不赘述了。</p>
<h2 id="样板-Lie-Algebra"><a href="#样板-Lie-Algebra" class="headerlink" title="样板 Lie Algebra"></a>样板 Lie Algebra</h2><p>若 $V$ 是 $F$ 上有限维线性空间，$End V$ 表示 $V$ 到 $V$ 的线性变换全体按照元素的复合构成了 $F$ 上的线性空间且$\dim End V = (\dim V)^2$。也构成了 $ End V$ 是一个结合$F$-代数。而任何结合代数都可以诱导一个 Lie 代数： $[x,y]=xy-yx$ 。为了强调 Lie 结构，我们用 $\mathbb{gl}(V)$ 代替 $End V$，称为 general linear algebra。它在 Lie 代数中充当的角色很类似于置换群在群中的角色。我们知道半单 Lie 代数同构于 $\mathbb{gl}(V)$ 的一个子 Lie 代数。</p>
<h2 id="导子和伴随表示"><a href="#导子和伴随表示" class="headerlink" title="导子和伴随表示"></a>导子和伴随表示</h2><p>我们称一个 $F-$代数 $A$（可以非结合）也可以借助导子(derivation)诱导一个 Lie 代数，称一个导子是指一个线性映射 $\delta: A \to A$ 满足 $\delta(ab)=\delta(a)b+a\delta(b)$。易知导子 $Der A$ 全体构成了 $End A$ 的一个子空间，由于 $[\delta,\delta’] \in Der A$，因此 $Der A$ 构成了 $\mathbb{gl}(V)$的一个子 Lie 代数。<br>由于 Lie 代数 $L$ 也是 $F$-代数,因此我们也可以定义 $Der L$。这里的导子本质上就是 Jacobi 恒等式的变形。<br>定义 $ad_x: L \to L,y \mapsto [x,y]$，实际上 $ad_x \in Der L$。$L \to Der L,x \mapsto ad_x$ 称为 $L$ 的伴随表示(adiont representation)。</p>
<h2 id="可解和幂零"><a href="#可解和幂零" class="headerlink" title="可解和幂零"></a>可解和幂零</h2><p>对于给定 Lie 代数 $L$，我们有理想降链<br>$L^{(0)} = L,L^{(1)}=[L^{(0)},L^{(0)}],\cdots,L^{(i)}=[L^{(i-1)},L^{(i-1)}],\cdots$。若存在 $n$ 使得 $L^{(n)} = 0$ 则称 $L$ 可解(slovable)。</p>
<ol>
<li>若$L$ 可解，$L$ 的子代数和同态像可解</li>
<li>$I$ 是 $L$ 的可解理想，若 $L/I$ 可解，则 $L$ 可解。</li>
<li>$I,J$ 是 $J$ 的可解理想，则 $I+J$ 也是。</li>
</ol>
<p>由上述性质可知，$L$ 有唯一的极大可解理想。即为 $Rad L$,若 $Rad L =0$ 则称之为<strong>半单</strong>的，等价于 $L$ 无非零 Abelian 理想(充分性显然，必要性是因为 $Rad L$ 可解，考虑最后一个非 0 项必然是 Abelian 理想矛盾)。另外 我们称 $x \in End V$ 半单，若 $x$ 的极小多项式无重根。</p>
<p>对于给定 Lie 代数 $L$，我们有理想降链<br>$L^0 = L,L^1=[L,L^0],\cdots,L^i=[L,L^{i-1}],\cdots $。若存在 $n$ 使得 $L^{n} = 0$ 则称 $L$ 幂零(nilpotent)。</p>
<ol>
<li>若$L$ 幂零，$L$ 的子代数和同态像幂零。</li>
<li>若 $L/Z(L)$ 幂零。则 $L$ 幂零。</li>
<li>若 $L$ 幂零且非 0，则 $Z(L) \neq 0$。</li>
</ol>
<p>显然由于 $L^{(i)} \subset L^i$ 因此幂零一定可解，但是反之则不尽然，例如 $\mathbb{gl}(V)$ 中对应的上三角矩阵全体构成的 Lie 代数。由 Lie 定理的推论知：</p>
<blockquote>
<p>$L$ 可解的充要条件是 $[L,L]$ 幂零。 </p>
</blockquote>
<h3 id="ad-nilpotent"><a href="#ad-nilpotent" class="headerlink" title="ad-nilpotent"></a>ad-nilpotent</h3><p>$L$ 是一个 Lie 代数，$x \in L$, 称 $x$ ad-nilpotent 是指 $ad_x$ 幂零。<br>易知若 $x$ 幂零，则 $ad_x$ 幂零，但是反之不尽然。然而我们有 <strong>Engel 定理</strong>：</p>
<h3 id="L-幂零当且仅当-ad-L-幂零"><a href="#L-幂零当且仅当-ad-L-幂零" class="headerlink" title="$L$幂零当且仅当$ad L$ 幂零"></a>$L$幂零当且仅当$ad L$ 幂零</h3><h2 id="一些重要结果"><a href="#一些重要结果" class="headerlink" title="一些重要结果"></a>一些重要结果</h2><p>这里罗列一些定理实际上就是搞清楚 Lie 代数中的一些问题和一些好的性质。</p>
<p><strong>THM1</strong>. 设 $L$ 是 $\mathbb{gl}(V)$ 的子代数($L$ 中的元素可理解为矩阵)，$V$ 是有限维的，若 $L$ 中元素都幂零，则存在 $v \in V$ 使得 $L(v) = 0$.<br>上面结果是讲，$L$ 中元素都幂零，则 $L$ 有公共的 $0$ 特征向量。证明是很有技巧性的。构造一个 codemension 为 1 的子代数，并证明它是 $L$ 不变子空间。然后数学归纳法完成证明。上面定理还说明我们可以取定一组基使 $L$ 同时严格上三角。</p>
<p><strong>THM2</strong>. 若 $L$ 幂零，$K$ 是 $L$ 的非零理想,则 $K \cap Z(L) \neq 0$</p>
<p><strong>THM3</strong>. 设 $L$ 是 $\mathbb{gl}(V)$ 可解子代数，$V$ 是有限维的，则存在 $L$ 存在公共特征向量。</p>
<p>上面定理还说明我们可以取定一组基使得 $L$ 同时上三角。</p>
<p><strong>THM4</strong>. 若 $x \in EndV$，则存在唯一的分解 $x = x_s+x_n$，其中 $x_s$ 是半单的， $x_n$ 是幂零的，且 $x_s,x_n$ 都能表示成 $x$ 的无常数项的多项式。将其称之为 Jordan-Chevally 分解。</p>
<p><strong>THM5</strong>. 若 $x$ 半单，则 $ad_x$ 半单。若 $x=x_s+x_n$ 是 Jordan-Chevally 分解，则 $ad_x = ad_{x_s} + ad_ {x_n}$  也是。$Der A$ 包含其元素的 半单部分和幂零部分。</p>
<p><strong>THM6</strong>. $A \subset B \subset End V $，令 $M = \lbrace x \in \mathbb{gl}(V) \mid [x,B] \subset A\rbrace$。若 $x \in M$ 满足，$Tr(xy)=0$ 对任意 $y\in M$ 成立，则 $x$ 幂零。</p>
<p><strong>THM7</strong> $L \subset \mathbb{gl}(V)$，$V$ 是有限维的, 则 对任意 $x \in [L,L],\;y \in L$ 有 $Tr(xy)=0$ 当且仅当 $L$ 可解。</p>
<p><strong>THM8</strong> 设 $L$ 是 Lie 代数，对任意 $x \in [L,L],\;y \in L$ 有 $Tr(ad_x ad_y)=0$ 则 $L$ 可解。</p>
<p><strong>THM9</strong> 若 $L$ 是半单的，则 $L$ 可唯一写成单子理想的直和且$L=[L,L],Z(L)=0$ 且 $L$ 的理想和同态像都是半单的。</p>
<p><strong>THM10</strong> $ad L$ 是 $Der L$ 的理想，且若 $L$ 是半单的，则 $ad L = Der L$。</p>
<h2 id="To-be-continue"><a href="#To-be-continue" class="headerlink" title="To be continue"></a>To be continue</h2>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次校运动会 + 山地半程马拉松</title>
    <url>/maoshanMarathon2017/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">日常表白 zly</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="18bf13e2bec1fd13f57b7ab4cd97f91ecdf1586962894b4aa487517dd480ee6d">010b98dc5bd6c4293af1e30087aa0bbd2c8f23083857701b8012ad7103bda0c7c5cb1b450020ec279a5b5292f15e6295091639c3627acebd29896ea0ca446b3ad0a913d216973768a62825eac708c3bd0e06088135a26e0b0eb55907f3861ce8537c1062f7dc9f0862b3b302b8f5548f50074d24e8d9b292b90ca057b48e29e5ae00f312177967b017c0b4615515b8fcfc942a09eca7fa6957a7a5d6b7a07d008d2a00a5fa22dd84b38bba070a301ad4e3f88a9f2e3157b6900d4052a8ecd17be280870b04d3f471cc8e9f704d55966fe3212474f46b90efcf052ff86ae0a757bb223f5d3eadb197d237b838445b93a072d52b639eab6f616be5e3913ae26ab9240297664ed963f2035f1f28c9c0473259c04b6b8586fb6bc635dcafac5ae0079fcbe901199d9e755cfe771665ccfc02f0b6022e385cc97cdc080be564c32539ea00ae98eb8ac4a61afa9ce5bd2c2926825b083ffe802bb94b41cc8199cb5cddb80c19b4e12bd8796472b15af3535fd0d9e6e74b20ee163db26d91f17891297f0480c0cf287941c926e648f62265f72e04fc0e69c35437f0b0972f88435c7514882305ab8e98ff9dfa532431bb047db47e246093d3c54326949fce3fbbca35b17ecc0907b0562bcaf89bc1cd624ea6c75ab54b61366929615e298fba71f25ebb9129df1059f3db9e7063f0f2013d3176277172d5ec1717aa0d33c16685017c9c78e843afe47cea9477eef4e4028033d21628b6dee0c8926c16303d8c8537468713a67c5e1ca965169c21020ec722cbf0e4dae43bb7eec44c8500ee224cabb3db782cdb30968a420befae390aaef066a1065f6c1e31bd14a6491075501e488be3dd64f0d95c6c4c0addcee02fa818ad34e852243ff08b66fd73a3cd2bf5ad6a9ebdd41968f9c297e59eb06b275cb2d2f4c778ecd346251ce40c3e4128cdaf3b57dbab435f34e9e834a00e9a6a49a99748d3f2b338b5ec67e231d3e4ef57e984143b1c2bc63eb1e91b97df0ad1299c2467eb7f86a9c8d7c07eecbb6fdf8349b4c1729ddc1568beb7dd4ec3731fea76306c464800c06c007c651327b8077c3566c76ce2fff57bf617a67992a89b0cb62e08a8b0b60304796c5e60bd909e23a948ddd9f02af243d545de3878f2230ad8e45df564af31458ed41e15739835e6552edfc056a54d2595aef7e5a696cb9299c10eb26d65e0d3b6b545fc0366ee540f5676e1a17efe18be39f08a4f38f4ee75ed9b6d98aeed8e8ffabafd38d5e16d75bf3de040775fa66dcfe4716964b1b506adbfdfca585ed9f409da9f0d0726fb21fb8388cc49112c9af637d8bf06875ee8b9b2ba64152e7d3b748d6cca6d33dafdf07aab09325c2c13b8a2fb9e4ef4e786847b77b7a5be8bfdb288c17ef4d821fc4739bd0f30203bbefba3cf189e20678704a5a9eab94adceef83f36d299eeedcde4185381cfd2447b5f4f552b1dd2bd6386b430266498c04e813d03388bcd2a9912cd473bc796daa1c177b3f6285d3f82c767ddb7c1793c6579cfbb5ada799d819b387c291a068ad70966e430a30624f227a4cd716d6f483c2c476642b83821a525a006a082959ca256b3a7df07d6a7c77d9ce4b37f07db2d6ccce277aad991d32b6a6edd27a75012ca938bcfd9a1f618c47e6f5224bccd29507f2ec357d95e82ccbf8fd9b81f82aa069a4d54391086e7dc2d994fc1e90de34719907245e1cf504f5f1d8254bd8ca975357dd789dae3d7cf86d4f3d080e3a91005acf3a59c844ad4a8b152461b5933837b7f25ee57bd7a29c14ece6b94d9904db63d0489bf7715d0f513b7b7fc0027895f1394dfde8cb84d0702f8a857f22bd1d75bb1e274fb1de9a607193dcebe6fe7b843e3af900b7c97d24cd02c4721d61e3bd2f45b4e163309551b733323c4f03e57236ee5208fff563553a19b1bc6e9b45cb9f425a8f2a3a67e707b58ee3003e56850074d2694eddc4fba86760c9c85a7c64eabc984cf0b1adb60556df22daedd0435f3d47e2521fd43017a5243fdcec82834d915471e1ed4f80a8828fd90ced230f21e5e5a0db0b094b530a6e0bcdb78abe0e4fa4adb1ca7271460db2670840190a0b5fa2d5840d8f781b0dad21e55744c0af767d71784681e81d4f79fa783e67baebcc32fe6dcdd1d5b61364e8d51f38362483bbf5a72a53e725f85cc9aa2243b0677d1cad9223c2496b3ed82f3917b1f6a248b577de90b51f1c5630d11f5f73f67b201336a43f522bb14921056213bca3dd2644510481b027bf545e6071a64ac613f88d657bb6a4f6d1297a057859383da522c5114977928e9a6415e9611f37e0dbf923d9af0d9d218cfeb69deeae3a8815e9d947e31cefa4b25ce7885d261ae2964fe488f6456b7eeb0d936273c00112122a41908c47f7efcf391b7f8dd063843698b0f4262a2e31e6c3fb651031a0b83eb3d279ca7149250a0c931a40ff4e5afa8a0644ddbe5dd3faa60148bde4684fa8a10928246e4157d686743be905841433c39f7711a8fde4c6c28544f0e898ed04ae7bc67f888689d1d4c4e16b29c7d528f3336bfb52f826e73c275baccdfb25a62b7a2d345cbe943abace97953a3042b424a043021446cafd4ba697b8f98cdcbe35424dde989e54ce5794fbdb6b0eb63a1b070a3a66f12ce43d919ce1640e653b0fd937054de2db48ad12984f200d8e142e184d8d7d1da1e98194358502fc9d98595ba2c90df90df436cc6457abf37e8c3cecdd32d9af58058d9c98c2597f5985780e2f02e6531b6bce94f9e6176c310afeb4cfe6c41a80861a6ff4f0226b39712823cbc57ba983844bc0d6cf3294ec1c7fce34903a4e41fd75d4b06c0ad6bfd7bc3497757dc24e4fa9d1a255c641910fd12be17c3238276d0b2f652dc7d28b605e78160e9b2ebf25363be7c394e24e114887aecc5fab629717dd39b3b446c44e061c7d3765050d17fed96ccf653df097a98f77a014e67081513da4969e7ec2e7bb1527e088dc2f9401bdceae214dea998cce0026a01e0d461a2238d7f629fa2abadb1d8daef26dc7c0edb506f9ac5e7347c916eb1f93e755cf5146c9339df57760ae6338b8344bd18612c0099def5bc68b34b436f85b70a3a3a67d8b1b42ace70a968cc221d9c3faf8542c39544fc683ba6b556014a8b79cdf49acc8cd5e8a616b64ac724c15c1211159979cb0ce8fe16a2cf5cbbc83d1aeb6611e9193779df3af4d0ad559c61b6a0ffdf29707efd73b82fc7ada4f2be537d1830d8dd2ecc0d178d16a5c20877b9ebdac4b99744594d352d2962c5b74584f7e36cede5d84fd65411b832bc87816f9a1d69b1fceddf0af814ae20a8514fbcaeeeebce773b7e6498c9979ba039225c63ff2e22e61e23d50fa88ce1849c45944a7307ce974d613e63cbba0c5a16906b2117c03bd3dbd72d25b91f2ed7c8e820405e3bb04d9c0b74035bad09b62d1a6f1ad9d71756b2232e5a149a5a368c9411753f9959bb6f744b67bbddd390b5b359c7d26540122147acb1cc3e502c2a7129a04491369f94c406d35c34b6ca931d020886712add9b0d215ec636675a7d120885d71cba1a7a989bc61010b84f0ecc08a6080161532d1d578aa99d8a811aea47eb4404be93a254f564157d8ee091422e2d1c1e4e91a3c3f2d6da0cb32fe73a9cde18b50bcb70c2794692bb36f707ed4d5eae6ac37b1fe0dff2e6fe6271969b81f553e1986c05d66437fffcf442445a3a61c5a22538c3e26092e57109b842f25d27abc6b3b772a6c7eb3c723ec2dd97760642edb654e8fe9b9e802e797839e544d3c6dfc68a139ecd9c03c62639908343f353f68375702dd1b01356d0a2b74bd45b3521f718421669c2d93e1c7ba2fe80ebd0c2a29bd250b5dc867e5413f0387d63aa5dcbf76c2f41886c0e33fb0b01</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>与单个矩阵交换的矩阵全体</title>
    <url>/matrixCommuteWithOne/</url>
    <content><![CDATA[<p>这个结果还是有些重要的所以记录一下，但是呢？我太懒了，直接截图吧 0.0</p>
<a id="more"></a>
<p><img src= "/img/loading.gif" data-lazy-src="m1.png" alt="m1"></p>
<p><img src= "/img/loading.gif" data-lazy-src="m2.png" alt="m2"></p>
<p><img src= "/img/loading.gif" data-lazy-src="m3.png" alt="m3"></p>
<p><img src= "/img/loading.gif" data-lazy-src="m4.png" alt="m4"></p>
<p><img src= "/img/loading.gif" data-lazy-src="m5.png" alt="m5"></p>
<p>总体问题还是很复杂，但是特殊情形十分简单：</p>
<blockquote>
<p>若方阵的特征多项式是最小多项式，那么与它交换的矩阵必然是 它的多项式。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>均值不等式的证明</title>
    <url>/meanInequation/</url>
    <content><![CDATA[<p>初中就学过最简单的均值不等式 $\frac{a+b}{2} \geq \sqrt{ab},a ,b \geq 0$。它的证明只需配方就知道了，这里介绍一下一般的均值不等式:</p>
<script type="math/tex; mode=display">
\frac{ \sum_{i=1} ^n a_i}{n} \geq \sqrt[n]{\Pi_{i=1}^n a_i }</script><a id="more"></a>
<p><strong>Proof</strong>：当 $n=1$ 时结论是平凡的，$n=2$ 时配方即知。$n=2^k$时不难用数学归纳法知，结论成立，下面主要看 $2^{k-1} &lt;n&lt; 2^k$的情况：<br>令 $A = \frac{ \sum_{i=1} ^n a_i}{n} $ 则，应用 $2^k$ 时的结论</p>
<script type="math/tex; mode=display">
\frac{ \sum_{i=1} ^n a_i + (2^k-n)A }{2^k} \geq\sqrt[2^k]{\Pi_{i=1}^n a_i A^{2^k -n}}</script><p>化简可得到结论。</p>
<blockquote>
<p>上述证明简单优美，第一次在陈纪修《数学分析》上册看到这个优美的方法。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>自然底数 e 的由来</title>
    <url>/naturalBase/</url>
    <content><![CDATA[<p>自然底数 $e$ 之所以重要，我想很大程度上是因为，指数函数 $f(x)=e^x$ 是“唯一”(在常数倍意义下)满足导数等于本身的函数。因此 $e$ 被叫做自然底数。</p>
<a id="more"></a>
<p>然而，$e$ 的定义可以由一个常见的重要数列极限来定义。即</p>
<script type="math/tex; mode=display">
e \doteq \lim _{n \to \infty}(1+\frac{1}{n})^n</script><p>那么为什么右边极限存在呢，我们来仔细分析。<br>令 </p>
<script type="math/tex; mode=display">
a_n = (1+\frac{1}{n})^n ,\; b_n =(1+\frac{1}{n})^{n+1}</script><p>则，由<a href="/meanInequation/" title="均值不等式">均值不等式</a>易知：</p>
<script type="math/tex; mode=display">
a_n = (1+\frac{1}{n})^n \cdot 1 \leq [\frac{n(1+\frac{1}{n})+1}{n+1}]^{n+1} =a_{n+1}</script><p>且</p>
<script type="math/tex; mode=display">
\frac{1}{b_n} = (\frac{n}{n+1})^n \cdot 1 \leq [\frac{(n+1)\frac{n}{n+1}+1}{n+2}]^{n+2} = \frac{1}{b_{n+1}}</script><p>因此 $2 = a_1 \leq a_n \leq b_n \leq b_1 = 4$。由于单调有界序列必有极限，不妨把这个极限记作 $e$ 且由上面推理知 $2 &lt; e &lt; 4$。</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><script type="math/tex; mode=display">
f_n = (1+\frac{1}{n})^{n+c},\quad g_n = (1+\frac{1}{n})^{n+d}</script><p>那么满足$f_n \leq e &lt; g_n$ 的最大的$c=\frac{1}{ln⁡2}−1$，最小的$d = \frac{1}{2}$，详细证明</p>
<p><img src= "/img/loading.gif" data-lazy-src="0.png" alt="0"></p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Julia 入门到放弃</title>
    <url>/juliaLearning/</url>
    <content><![CDATA[<blockquote>
<p>和 Julia 的一夜情结束了 0.0 ，渣男 dna049 拥抱 SageMath 咯</p>
</blockquote>
<p>学完 Python 之后，觉得 Python 更像一个工具箱，啥都能干，但是我真的需要一个（轻量级）科学计算的工具，而不是像 Matlab 一样的付费巨无霸（我不想再用盗版软件了，学校正版 Matlab 2020 20G 吃不消！）而 C/C++ 在科学计算中因为原生精度问题，又没有特别权威的高精度包，所以也不太行。我甚至有自己学着去开发一种新型语言来打破当前尴尬的局面，直到我知道了<a href="https://docs.juliacn.com/latest/" target="_blank" rel="noopener">Julia</a> ，已分手，理由：</p>
<blockquote>
<p>有 C 快吗？没有！有 Python 方便吗？没有！安装个包就跟求它借 100w 一样（国内源安装不了）</p>
<p>免费是取代 MATLAB，Mathematics 的理由吗？不是，收费是一件好事！！！</p>
<p>学术界的高性能计算的人员，它们学校至少买了 MATLAB 或者 Mathematics 好吧！</p>
<p>非上述人员，真的需要高性能计算吗？？？再说了真的性能高吗？向量化计算竟然还没有循环快，我吐了好吧</p>
</blockquote>
<a id="more"></a>
<h2 id="我会的语言"><a href="#我会的语言" class="headerlink" title="我会的语言"></a>我会的语言</h2><p>我已经会写，C/C++，Matlab，Python 了，接触过 Java, Swift, Lua(现在全忘了)。又要新学一门语言其实我是抵触的，并且 Julia 的语法简直就像 <code>没有分号的Matlab</code> ，我是很不喜欢的，依然想着某天我也能设计一个仅用于科学计算和 OI/ICPC 的语言! </p>
<ul>
<li>用 C/C++ 写高效小巧的功能</li>
<li>用 Python 处理日常小功能，计算器，模拟鼠标键盘控制，图片处理，视频处理，小游戏开发。</li>
<li>用 ~~Julia ~~ SageMath 写复杂的科学计算用以取代 Matlab。VSCode 一定要选择一个工作区文件夹</li>
<li>用 Matlab（学校版）做演示和交互，Wolfram Mathematics（网页版）做验算。</li>
</ul>
<h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>Julia 设计理念竟然是传承各种语言的优势，丢弃各个语言的不足的一种动态编程语言，可是这不是既要马儿跑，又要马儿不吃草吗？它借助 LLVM 和 JIT 技术。</p>
<p>Julia 有交互界面，现在语言感觉都能像 Python，Matlab 一样支持交互界面，<em>REPL</em> <em>REPL</em> : Read Eval Print Loop : 交互式解释器。</p>
<blockquote>
<p>高精度，支持向量，矩阵，传值而非传引用，速度快是我向往的</p>
</blockquote>
<h2 id="Julia-入门"><a href="#Julia-入门" class="headerlink" title="Julia 入门"></a>Julia 入门</h2><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><blockquote>
<p>太接近数学符号了！不亏是 MIT 出来的。</p>
</blockquote>
<ul>
<li><p>支持非 ASCII 码当运算符我是接受不了的</p>
</li>
<li><p>typeof 查看类型</p>
</li>
<li><p>Bool 类型： <code>true, false</code></p>
</li>
<li><p>整数有 Int8,16,32,64,128, 和 U 版本（越界取模），还有高精度 BigInt（都会自动向这个转化）</p>
</li>
<li><p>浮点数有 Int16，Int32，Int64，有 Inf，-Inf，NaN，eps，还有高精度 BigFloat（当然了不可能是精确值）</p>
</li>
<li><p>有理数和复数自带（<code>//</code>表示有理数，im 表示虚数 i）</p>
</li>
<li><p>从 1 开头索引，我有点接受不了</p>
</li>
<li><p>整除: <code>÷</code> (或者用 div)  异或：<code>⊻</code>(或者用 xor)</p>
<blockquote>
<p>div 向 0 近似，fld 向 -inf 近似，cld 向 +inf 近似</p>
</blockquote>
</li>
<li><p>Base.operator_precedence 看运算符优先级，Base.operator_associativity 看是左结合还是右结合</p>
</li>
<li><p>math 包内建</p>
</li>
<li><p>养成运算符之间加空格的好习惯</p>
</li>
<li><p>短路求值是个好东西</p>
</li>
<li><p>dot 运算，竟然比 for 循环慢？？？搞笑？这玩什么</p>
</li>
<li><p>好像要 Python 一样有 Yield 目前没找到</p>
</li>
<li><p>!放在函数名后面表示输入参数会被改变（但是不一定要这么做）</p>
</li>
<li><p>Copy 跟 Python 一样是浅 Copy</p>
</li>
</ul>
<h3 id="包的国内镜像"><a href="#包的国内镜像" class="headerlink" title="包的国内镜像"></a>包的国内镜像</h3><p>装个包，人装傻了！</p>
<p>USTC 的用不了，所以用 ZJU 的了</p>
<blockquote>
<p>先把<a href="https://mirrors.zju.edu.cn/julia/registries/General/Registry.toml" target="_blank" rel="noopener">Registry.toml</a> 文件下载下来，放在 <code>C:\\Users\\Administrator\\.julia\\registries\\General\\</code></p>
</blockquote>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">(v1<span class="number">.4</span>) pkg&gt; registry add https://mirrors.zju.edu.cn/julia/registries/General.git/</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Julia</tag>
      </tags>
  </entry>
  <entry>
    <title>幂零矩阵的一个充要条件</title>
    <url>/nilpotentMatrix/</url>
    <content><![CDATA[<p>前几天一个学弟告诉我，关于复数域上幂零矩阵 $A$ 的一个充要条件：</p>
<script type="math/tex; mode=display">
A = AB-BA, \quad \exists B \in M_n(\mathbb{C})</script><p>特此记录。</p>
<a id="more"></a>
<p>证明分几个小步骤：</p>
<ol>
<li><p>必要性对若当块成立，若$A$为（上三角）若当块，那么取 $B=diag \lbrace 0,1,⋯,n−1 \rbrace$ 即可，若 $A$ 为分块若当块（若当标准型），那么取对应的分块 $B$ 即可。又由于</p>
<script type="math/tex; mode=display">
P^{-1}AP = P^{-1}APP^{-1}BP - P^{-1}BP P^{-1}AP</script><p>因此，由对若当标准型成立,可知道对一般形式成立。</p>
</li>
<li><p>$tr(A^k) = 0, 1 \leq k \leq n$ ，则$A$ 幂零。</p>
<p>由若当标准型可知，只需证明：</p>
<script type="math/tex; mode=display">
\begin{cases} x_1 + x_2 + \cdots + x_n = 0 \\ 
x_1 ^ 2 + x_2 ^ 2 + \cdots + x_n ^2 = 0 \\ 
\cdots  \\ 
x_1 ^ n + x_2 ^n + \cdots + x_n ^n  = 0 
\end{cases}</script><p>推出，$x_1 = x_2 = \cdots x_n = 0$ ，不妨设</p>
<script type="math/tex; mode=display">
\begin{cases} x_1 t_1 + x_2 t_2 + \cdots + x_r t_r = 0 \\ 
x_1 ^ 2 t_1  + x_2 ^ 2 t_2 + \cdots + x_r ^2 t_r= 0 \\ 
\cdots  \\ 
x_1 ^ r t_1 + x_2 ^r t_2 + \cdots + x_r ^r t_r = 0 
\end{cases}</script><p>其中 $x_i$ 互不相同，那么，假设 $r&gt;1$ 则由 Vandemode 行列式不为 0 知， $t_i = 0$ 矛盾，因此 $r=1$， 此时 $x_i=0$。</p>
</li>
<li><p>$C=AB-BA$ 且 $AC=CA$ 则，$C$ 幂零。</p>
<script type="math/tex; mode=display">
\forall k,tr (C^k) = tr(C^{k-1}AB - C^{k-1}BA) =tr(C^{k-1}AB) - tr(AC^{k-1}B) = 0</script><p>因此由上面结论知，$C$ 幂零</p>
</li>
<li><p>综合上述结论，充分性显然。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>最长递增子序列与连续子序列最大和</title>
    <url>/nondecraseSubsequence/</url>
    <content><![CDATA[<p>最长递增子序列最常规的做法是 $O(n^2)$ 的动态规划（dp） 做法（很容易想到不多说了）。这里可以维护一个单调的数列使其复杂度降至 $O(n \log n)$。相应的最长递减、不升、不降子序列完全类似，相应修改即可。另外，这个问题让我想起另一个降低复杂度的经典例子：连续子序列最大和。从 $O(n^3)$ 到 $O(n^2)$ 再到 $O(n)$.<br><a id="more"></a></p>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>我们用数组 $a$ 表示原始数列。用 $b[k]$ 表示长度为 $k$ 的不降子序列中尾数最小值。那么显然数组 $b$ 是单调递增的。初始状态 $b[1]=a[1],k=1$</p>
<h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>若 $a[i]&gt;b[k]$，则 $k=k+1,b[k]=a[i]$；否则,找到二分最小的 $j$ 使得 $b[j] \geq a[i]$ 然后 $b[j]=a[i]$。最终答案就是 $k$。</p>
<h3 id="例题：POJ-2533"><a href="#例题：POJ-2533" class="headerlink" title="例题：POJ 2533"></a>例题：POJ 2533</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// longest increasing subsquence for 0 ~ n-1</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    b[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[k]) b[++k]=a[i];</span><br><span class="line">        <span class="keyword">else</span>    b[lower_bound(b,b+k,a[i])-b]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lower_bound(first,end,val) 表示在单增 [frist,end) 中首次大于等于 val 的位置</span></span><br><span class="line"><span class="comment">// upper_bound(first,end,val) 表示在单增 [frist,end) 中首次大于 val 的位置</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N= <span class="number">1003</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,LIS(a,n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="记录子序列的做法"><a href="#记录子序列的做法" class="headerlink" title="记录子序列的做法"></a>记录子序列的做法</h3><p>由于同学的需要，这里给出加强版：记录子序列<br>首先我们定义一下变量，$a,b$ 已经说过，用 $c[i]$ 表示 $b[i]$ 元素所在的位置。$p[i]$ 表示 $i$ 前面一个元素所在位置。那么最后的子序列就是以 $b[k]$ 所在位置为结尾位置,再用 $p[i]$ 来回溯得到的序列（见代码）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N= <span class="number">1003</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],c[N],p[N],sa[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// longest increasing subsquence for 0 ~ n-1</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    b[<span class="number">0</span>]=a[<span class="number">0</span>];c[<span class="number">0</span>]=<span class="number">0</span>;p[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[k])&#123;</span><br><span class="line">            p[i]=c[k];</span><br><span class="line">            c[++k]=i;</span><br><span class="line">            b[k]=a[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="keyword">int</span>(lower_bound(b,b+k,a[i])-b);</span><br><span class="line">            b[tmp]=a[i];</span><br><span class="line">            c[tmp]=i;</span><br><span class="line">            p[i]=tmp&gt;<span class="number">0</span>?c[tmp<span class="number">-1</span>]:i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = c[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        sa[i]=a[x];</span><br><span class="line">        x=p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = LIS(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;sa[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连续子序列最大和"><a href="#连续子序列最大和" class="headerlink" title="连续子序列最大和"></a>连续子序列最大和</h2><p>$O(n^3)$ 实在不值一提。$O(n^2)$ 就是先预处理前 $m$ 项和。这里具体讲两种 $O(n)$ 的做法。</p>
<ol>
<li>遍历序列对 $s$ 进行累加，如果 $s&lt;0$，将 $s$ 重置为 $0$,每次更新 $s$ 的最大值。最后便能求出最大值(注意序列中全为负数的情况)</li>
<li>设 $dp[i]$ 表示尾为 $i$ 的最大和。那么 $dp[i]=\max (dp[i-1],a[i])$ 。</li>
</ol>
<p>上述两种做法本质上是一致的，做法 2 可能更好理解。并且其实实现的时候我们没必要去用数组标记。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MSCS</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// maximal sum of continue subsquence,mind overflow</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r=a[<span class="number">0</span>],s=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">        s = <span class="built_in">max</span>(s,<span class="number">0</span>);</span><br><span class="line">        s += a[i];</span><br><span class="line">        r = <span class="built_in">max</span>(r,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>第$n$个素数</title>
    <url>/nthPrimeNumber/</url>
    <content><![CDATA[<p>很早之前写过 <a href="/computationOfPiX/" title="$\pi(x)$ 的计算">$\pi(x)$ 的计算</a> ，在知乎上用它回答问题的时候，发现我怎么没有写 <strong>求第 $n$ 个素数。</strong></p>
<blockquote>
<p>做法依赖于 $\pi(x)$ 的计算，$\pi(x)$ 表示不超过$x$ 的素数个数</p>
</blockquote>
<a id="more"></a>
<h2 id="素数定理-这里就不证了"><a href="#素数定理-这里就不证了" class="headerlink" title="素数定理( 这里就不证了)"></a>素数定理( 这里就不证了)</h2><script type="math/tex; mode=display">
\lim _{x \to \infty} \frac{\pi(x)}{x/\ln x} = 1</script><p>从而我们知道：</p>
<script type="math/tex; mode=display">
\lim _{x \to \infty} \frac{p_n}{n \ln n} = 1</script><p>其中，$p_n$ 为第$n$ 个素数，显然$p_n$ 是$\pi(x) = n$ 最小的解。</p>
<h2 id="p-n-求解"><a href="#p-n-求解" class="headerlink" title="$p_n$ 求解"></a>$p_n$ 求解</h2><ul>
<li>预处理小于 $N$ 的素数</li>
<li>初始值 $n\ln n$</li>
<li>牛顿梯度法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e8</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;p[<span class="number">1</span>]=<span class="number">2</span>;isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)   isp[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])  p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>,t=(N<span class="number">-1</span>)/i + <span class="number">1</span>;j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j)&#123;</span><br><span class="line">            isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">8</span>; <span class="comment">// 不能再大了不然内存顶不住了</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span>*<span class="number">3</span>*<span class="number">5</span>*<span class="number">7</span>*<span class="number">11</span>*<span class="number">13</span>*<span class="number">17</span>*<span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM+<span class="number">1</span>][M+<span class="number">1</span>],sz[M+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    initprime();</span><br><span class="line">    pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;++i)&#123;</span><br><span class="line">        pi[i]=pi[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(isp[i])    ++pi[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sz[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=PM;++i)  phi[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        sz[i]=p[i]*sz[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=PM;++j)&#123;</span><br><span class="line">            phi[j][i]=phi[j][i<span class="number">-1</span>]-phi[j/p[i]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= M)  <span class="keyword">return</span> phi[x%sz[s]][s]+(x/sz[s])*phi[sz[s]][s];</span><br><span class="line">    <span class="keyword">if</span>(x/p[s] &lt;= p[s])  <span class="keyword">return</span> primepi(x)-s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x/p[s]/p[s] &lt;= p[s] &amp;&amp; x&lt;N)&#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">        LL ans = pi[x]-(s2x+s<span class="number">-2</span>)*(s2x-s+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=s2x;++i)&#123;</span><br><span class="line">            ans+=pi[x/p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primephi(x,s<span class="number">-1</span>)-primephi(x/p[s],s<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> pi[x];</span><br><span class="line">    <span class="keyword">int</span> ps2x = primepi(<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>)));</span><br><span class="line">    <span class="keyword">int</span> ps3x = primepi(<span class="keyword">int</span>(cbrt(x+<span class="number">0.2</span>)));</span><br><span class="line">    LL ans = primephi(x,ps3x) + LL(ps2x+ps3x<span class="number">-2</span>)*(ps2x-ps3x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =ps3x+<span class="number">1</span>,ed = ps2x;i&lt;=ed;++i)&#123;</span><br><span class="line">        ans -= primepi(x/p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(LL n)</span></span>&#123;  <span class="comment">// 可以用概率判别来替换</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;N) <span class="keyword">return</span> isp[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;p[i]&lt;=n/p[i]&amp;&amp;i&lt;N;++i)&#123; </span><br><span class="line">        <span class="keyword">if</span>(p[i]&amp;&amp;n%p[i]==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primep</span><span class="params">(LL n)</span></span>&#123;    <span class="comment">// Newton 梯度法</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= pi[N<span class="number">-1</span>])  <span class="keyword">return</span> p[n];</span><br><span class="line">    LL ans= n*<span class="built_in">log</span>(n), err = <span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">10</span>);</span><br><span class="line">    LL m = primepi(ans);</span><br><span class="line">    <span class="keyword">while</span>(m&lt;n||m&gt;n+err)&#123;</span><br><span class="line">        ans += (n-m)/(<span class="built_in">log</span>(m)<span class="number">-1</span>)*<span class="built_in">log</span>(m)*<span class="built_in">log</span>(m);</span><br><span class="line">        m = primepi(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span> = m-n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">step</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!isprime(ans))    --ans;</span><br><span class="line">        --ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ++ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    LL n;   <span class="comment">// n &lt; N*N </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n=987654321098 = 9.8*10^11 用时 128s 太慢了。</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;primep(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://primes.utm.edu/nthprime/index.php#nth" target="_blank" rel="noopener">第$n$ 个素数和 $\pi(x) $ 的网站</a></p>
<p><a href="https://github.com/kimwalisch/primecount" target="_blank" rel="noopener">世界纪录保持者的求法</a></p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>正约数个数 $d(n)$</title>
    <url>/numberOfdivisors/</url>
    <content><![CDATA[<p>codeforce 上有<a href="http://codeforces.com/contest/235/problem/E" target="_blank" rel="noopener">一道题</a> 。 rng_58 用一个奇妙的公式解决了这个问题。并且给出了公式的证明，这里给出另一个比较好的证明。</p>
<a id="more"></a>
<h2 id="d-n-的一个公式"><a href="#d-n-的一个公式" class="headerlink" title="$d(n)$ 的一个公式"></a>$d(n)$ 的一个公式</h2><p>按照公式，我们有 $d(n) = \sum_{i \mid n} 1$。其实这个公式可以推广为</p>
<script type="math/tex; mode=display">
d(n_1 \cdots n_m) = \sum_{i_1 \mid n_1} \cdots \sum_{i_m \mid n_m} 1, \; \gcd(i_s,i_t)=1,1 \leq  s < t \leq m</script><p><strong>Proof</strong>： 数学归纳法证明：$m=1$ 时结论显然。<br>设结论对 $m-1$ 成立。</p>
<script type="math/tex; mode=display">
\begin{aligned}
d(n_1 \cdots n_m) &= \sum_{i \mid n_1 \cdots n_m} 1 =  \sum_{d \mid n_m} \sum_{i \mid n_1 \cdots n_m , \gcd(i,n_m)=d} 1 \\
&= \sum_{d \mid n_m} \sum_{\frac{i}{d} \mid n_1 \cdots n_{m-1} , \gcd(\frac{i}{d},\frac{n_m}{d})=1} 1 \\
&= \sum_{d \mid n_m} \sum_{i \mid n_1 \cdots n_{m-1} , \gcd(i,d)=1} 1 
\end{aligned}</script><p>由数学归纳法知，原结论成立。</p>
<h2 id="上面公式的一个应用"><a href="#上面公式的一个应用" class="headerlink" title="上面公式的一个应用"></a>上面公式的一个应用</h2><script type="math/tex; mode=display">
\sum_{i_1 = 1} ^{n_1} \cdots \sum_{i_m = 1} ^{n_m} d(n_1 \cdots n_m) = \sum_{\gcd(i_s,i_t)=1,1 \leq  s < t \leq m } \lfloor \frac{n_1}{i_1} \rfloor \cdots  \lfloor \frac{n_m}{i_m} \rfloor</script><h4 id="m-2-的另一个公式"><a href="#m-2-的另一个公式" class="headerlink" title="$m=2$ 的另一个公式"></a>$m=2$ 的另一个公式</h4><p>令 $F(n) = \sum_{i=1} ^n \lfloor \frac{n}{i} \rfloor $，则显然</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1} ^n \sum_{j=1,\gcd(i,j)=1} ^m \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{j} \rfloor &= \sum_{i=1} ^n \lfloor \frac{n}{i} \rfloor \sum_{t \mid i} \mu(t) \sum_{1 \leq j \leq m, t \mid j} \lfloor \frac{m}{j} \rfloor \\
&= \sum_{i=1} ^n \lfloor \frac{n}{i} \rfloor \sum_{t \mid i} \mu(t) F(\lfloor \frac{m}{t} \rfloor) \\
&= \sum_{t} \mu(t) F(\lfloor \frac{m}{t} \rfloor) \sum_{1 \leq i \leq n, t \mid i} \lfloor \frac{n}{i} \rfloor \\
&= \sum_{t} \mu(t) F(\lfloor \frac{m}{t} \rfloor) F(\lfloor \frac{n}{t} \rfloor)
\end{aligned}</script><p>即</p>
<script type="math/tex; mode=display">
\sum_{i=1} ^n \sum_{j=1} ^m d(ij) =  \sum_{t} \mu(t) F(\lfloor \frac{m}{t} \rfloor) F(\lfloor \frac{n}{t} \rfloor)</script><h3 id="这说明我们可以在-O-n-log-n-复杂度内计算此问题"><a href="#这说明我们可以在-O-n-log-n-复杂度内计算此问题" class="headerlink" title="这说明我们可以在 $O(n \log n)$ 复杂度内计算此问题"></a>这说明我们可以在 $O(n \log n)$ 复杂度内计算此问题</h3><p>可是 $m&gt;2$ 就比较麻烦了。</p>
<h4 id="f-n-sum-i-1-n-d-i-sum-i-1-lfloor-frac-n-i-rfloor"><a href="#f-n-sum-i-1-n-d-i-sum-i-1-lfloor-frac-n-i-rfloor" class="headerlink" title="$f(n) = \sum_{i=1} ^n d(i) = \sum_{i=1} \lfloor \frac{n}{i} \rfloor$"></a>$f(n) = \sum_{i=1} ^n d(i) = \sum_{i=1} \lfloor \frac{n}{i} \rfloor$</h4><p>上面这个公式有趣的是,若要求单个的 $f(n)$ 用后面一个可以在 $O(\sqrt{n})$ 复杂度解决，而如果要求 $f(1),\cdots,f(n)$ 则可以用前面一个公式在 $O(n \log n)$ 复杂度解决。</p>
<h3 id="codeforce-235"><a href="#codeforce-235" class="headerlink" title="codeforce 235"></a><a href="http://codeforces.com/contest/235/problem/E" target="_blank" rel="noopener">codeforce 235</a></h3><p>求解:</p>
<script type="math/tex; mode=display">
 \sum_{i=1}^a \sum_{j=1}^b \sum_{k=1}^c d(ijk)</script><p>如果令 $f(n) = \sum_{i=1} ^n d(i),g(n)=\sum_{i \mid n} \mu(i) f(\lfloor \frac{c}{i} \rfloor) $<br>那么</p>
<script type="math/tex; mode=display">
\sum_{i=1}^a \sum_{j=1}^b \sum_{k=1}^c d(ijk) = \sum_{t} \mu(t) \lfloor \frac{a}{it} \rfloor \lfloor \frac{b}{it} \rfloor g(ijt^2)</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2002</span>;</span><br><span class="line"><span class="keyword">int</span> f[N],g[N*N];</span><br><span class="line"><span class="keyword">bool</span> ip[N];</span><br><span class="line"><span class="keyword">int</span> mu[N],p[N],nt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_mu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;ip[<span class="number">2</span>]=<span class="literal">true</span>;p[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i+=<span class="number">2</span>)   ip[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>,cnt = <span class="number">1</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ip[i])&#123;</span><br><span class="line">            p[cnt++] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>,t;j&lt;cnt&amp;&amp;(t= i * p[j])&lt;N;++j)&#123;</span><br><span class="line">            ip[t] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>)   <span class="keyword">break</span>;</span><br><span class="line">            mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;i+=<span class="number">4</span>)  mu[i]=-mu[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        sum += (j-i+<span class="number">1</span>)*(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)       f[i]=getsum(i);    init_mu();</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mu[i]==<span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">        nt[last]=i;</span><br><span class="line">        last = i;</span><br><span class="line">    &#125;</span><br><span class="line">    nt[last]=N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getg</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a*b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)   g[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;i&lt;=c;i=nt[i])&#123; <span class="comment">// n^2 \log n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i,t=mu[i]*f[c/i];j&lt;=n;j+=i)   g[j]+=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getf</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b;++j)&#123;</span><br><span class="line">            res+=(a/i)*(b/j)*g[i*j*d];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c))&#123;</span><br><span class="line">        getg(a,b,c);</span><br><span class="line">        <span class="keyword">int</span> ab = <span class="built_in">min</span>(a,b);</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ab;i=nt[i])&#123;</span><br><span class="line">            res+=mu[i]*getf(a/i,b/i,i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="keyword">int</span>(res%(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>$GL_n(\mathbb{Z}_m)$ 的阶数</title>
    <url>/orderOfGLnZm/</url>
    <content><![CDATA[<p>由线性无关性，我们不难知道 $|GL_n(\mathbb{Z}_p)| = \prod_{i=0} ^{n-1} (p^n-p^i)$，但是$|GL_n(\mathbb{Z}_m)|$  却是一个相对复杂的问题，它本质上是在考虑有限 Abel 群的自同构群的阶数问题。它又跟递推数列模 $m$ 的周期密切相关。</p>
<a id="more"></a> 
<p>2007 年 CHRISTOPHER J. HILLAR AND DARREN L. RHEA 发表一篇论文<a href="automorphismsOfFiniteAblianGroup.pdf">《AUTOMORPHISMS OF FINITE Abelian GROUPS》</a> 完美的解决了这个问题。</p>
<h2 id="有限生成-Abel-群结构定理"><a href="#有限生成-Abel-群结构定理" class="headerlink" title="有限生成 Abel 群结构定理"></a>有限生成 Abel 群结构定理</h2><p>设$G$是一个有限 Abel 群，那么$G$ 同构于一些</p>
<script type="math/tex; mode=display">
H_p = \mathbb{Z}_{p^{e_1}} \times \cdots  \mathbb{Z}_{p^{e_n}}</script><p>的乘积。其中$p$ 是素数（$p$ 一般默认为素数），$1 \leq e_1 \leq \cdots \leq e_n$ 是正整数。</p>
<blockquote>
<p>证明可见任意一般抽象代数（或近世代数）书。</p>
</blockquote>
<h2 id="乘积的自同构"><a href="#乘积的自同构" class="headerlink" title="乘积的自同构"></a>乘积的自同构</h2><p>若$H$  和 $K$ 是有限群，且它们的阶数互素。那么我们就有同构：</p>
<script type="math/tex; mode=display">
Aut(H) \times Aut(K) \simeq Aut(H \times K)</script><p><strong>Proof</strong> ：我们构造很自然的映射：</p>
<script type="math/tex; mode=display">
\phi: Aut(H) \times Aut(K) \to Aut(H \times K) \\
\phi(\alpha,\beta)(h,k) = (\alpha(h),\beta(k))</script><p>容易验证 $\phi$  是合理的映射，并且是单射，然后我们同构构造它的逆映射来说明它是满射。</p>
<p>我们记 $n = |H|,m = |K|$，$\pi_H,\pi_K$是标准投影映射： $\pi_H: H \times K \to H$，$\pi_K: H \times K \to K$ 。对于给定的 $\omega \in Aut(H \times K)$，我们定义同态 $\gamma: K \to H$， $\gamma(k) = \pi_H(\omega(1_H,k))$，注意到 $\lbrace k^n: k \in K \rbrace \subseteq \ker \gamma$。又 $m,n$是互素的，所以 $\gamma$ 是平凡的映射。同理，我们定义 $\delta: H \to K$，$\delta(h) = \pi_K(\omega(h,1_K))$ 也是平凡映射。最后我们定义$H$和$K$的自同态：</p>
<script type="math/tex; mode=display">
\omega_H(h) = \pi_H(w(h,1_K)) ,\quad \omega(k) = \pi_K(w(1_H,k)) \\
\omega(h,k) = \omega(h,1_K) \omega(1_H,k) = (\omega_H(h),  \omega_K(k)) = \phi(w_H,w_k)(h,k)</script><p>由于$\omega_H,\omega_K$都是单射，并且$H,K$ 是有限群，所以它们是自同构，证毕。</p>
<blockquote>
<p>所以我们考虑 $Aut(G)$，只需考虑 $Aut(H_p)$ 即可</p>
</blockquote>
<h2 id="H-p-的自同态"><a href="#H-p-的自同态" class="headerlink" title="$H_p$ 的自同态"></a>$H_p$ 的自同态</h2><p>我们定义，环$E_p = End(H_p)$（加法就是映射的加法，乘法就是映射的复合）</p>
<p>由于循环群  $C_{p^{e_i}}$对应的是 模$p^{e_i}$ 的加法群。所以 $H_p$ 中的元素可以表示成列向量 $(\overline{h_1},\cdots \overline{h_n})^T$，其中 $\overline{h_i} \in \mathbb{Z}_{p^{e_i}}, \; h_i \in \mathbb{Z}$</p>
<p>我们定义（<strong>精华所在</strong>)</p>
<script type="math/tex; mode=display">
R_p \doteq \lbrace (a_{ij} \in \mathbb{Z}^{n \times n}: p^{e_i - e_j}|a_{ij} \quad \forall 1 \leq j < i \leq n)</script><p>注意到 $\forall A \in R_p$，$A = P A’ P^{-1}$，其中 $P = diag(p^{e_1},\cdots,p^{e_n}), A’ \in \mathbb{Z}^{n \times n}$。从而 $R_p$ 根据加法和矩阵乘法，构成了一个环。</p>
<p>我们定义 $\pi_i: \mathbb{Z} \to \mathbb{Z}_{p^{e_i}}$为标准商映射。$\pi: \mathbb{Z}^n \to H_p$ 为：</p>
<script type="math/tex; mode=display">
\pi(h_1,\cdots h_n)^T = (\pi_1(h_1),\cdots,\pi_n(h_n))^T = (\overline{h_1},\cdots \overline{h_n})^T</script><p>我们不难验证 $\psi: R_p \to E_p$</p>
<script type="math/tex; mode=display">
\psi(A)(\overline{h_1},\cdots \overline{h_n})^T = \pi(A(h_1,\cdots,h_n)^T)</script><p>是环满同态（需要验证映射合理性，环同态，满射）且 $\ker \psi = \lbrace A = (a_{ij}) \in R_p: p^{e_i} | a_{ij}$ </p>
<h2 id="H-p-的自同构-Aut-H-p"><a href="#H-p-的自同构-Aut-H-p" class="headerlink" title="$H_p$ 的自同构 $Aut(H_p)$"></a>$H_p$ 的自同构 $Aut(H_p)$</h2><p>$M = \psi(A) \in Aut(H_p)$ 当且仅当 $A \mod p \in GL_n(\mathbb{F}_p)$，即 $\det(A) \in U(H_p)$ 是$H_p$ 中可逆元。</p>
<p><strong>Proof</strong>：利用$A$的逆矩阵推出$M$是自同构，利用$M$的逆映射给出$A$的逆矩阵。</p>
<h2 id="Aut-H-p"><a href="#Aut-H-p" class="headerlink" title="$| Aut(H_p)|$"></a>$| Aut(H_p)|$</h2><p>定义：$d_k = \max \lbrace l: e_l  = e_k \rbrace, c_k = \min \lbrace l: e_l  = e_k \rbrace$，显然 $c_k \leq k \leq d_k$。我们需要计算</p>
<ul>
<li>所有$GL_n(\mathbb{F}_p)$ 中可以拓展成 $A \in R_p$的元素</li>
<li>每个元素拓展方式</li>
</ul>
<p>我们找到所有 $M \in  GL_n(\mathbb{F}_p)$ 形如：</p>
<script type="math/tex; mode=display">
M = 
\begin{pmatrix} 
m_{11} & & & \star \\
\vdots \\
m_{d_1 1} \\
& m_{d_2 2} \\
& & \ddots \\
0 & & & m_{d_n n} 
\end{pmatrix}</script><blockquote>
<p>注意到 $\sum_{j=1} ^n \sum_{i=1} ^{d_j} m_{ij} = \sum_{e_i \leq e_j} m_{ij} = \sum_{i=1} ^n \sum_{j = c_i}^n m_{ij}$</p>
</blockquote>
<p>因为我们只考虑线性无关的，所以这种$M$的数量是</p>
<script type="math/tex; mode=display">
\prod_{k=1} ^n (p^{d_k} - p^{k-1})</script><p>将$m_{ij}$ 从$\overline{m_{ij}} \in \mathbb{Z}_p$ 到 $\overline{a_{ij}} \in p^{e_i-e_j} \mathbb{Z}/p^{e_i} \mathbb{Z}$ 使得 $a_{ij} \equiv m_{ij} \mod p$ 的方案数分两种情况</p>
<ul>
<li>$e_i &gt; e_j$ 时， $p^{e_j}$ 种</li>
<li>$e_i \leq e_j$ 时， $p^{e_i-1}$ 种</li>
</ul>
<p>从而</p>
<script type="math/tex; mode=display">
|Aut(H_p)| = \prod_{k=1} ^n (p^{d_k} - p^{k-1}) \prod _{j=1} ^n (p^{e_j})^{n-d_j} \prod_{i=1} ^n (p^{e_i -1})^{n-c_i+1}</script><h2 id="GL-n-mathbb-Z-m"><a href="#GL-n-mathbb-Z-m" class="headerlink" title="$|GL_n(\mathbb{Z}_m)|$"></a>$|GL_n(\mathbb{Z}_m)|$</h2><p>由$|Aut(H_p)| $的公式的特殊形式，我们知道 $|GL_n(Z_{p^s})| = p^{n^2 (s-1)} \prod_{k=1} ^n (p^n - p^{k-1})$。</p>
<p>将 $m$ 质因数分解 $m = p_1^{s_1} \cdots p_r ^{s_r}, \quad p_1 &lt; \cdots &lt; p_r$ </p>
<script type="math/tex; mode=display">
|GL_n(\mathbb{Z}_m)| =  \prod_{i=1} ^r |GL_n(Z_{p_i^{s_i}})|</script><h2 id="mathbb-Z-m-上-n-阶给定可逆矩阵-A-的周期"><a href="#mathbb-Z-m-上-n-阶给定可逆矩阵-A-的周期" class="headerlink" title="$\mathbb{Z}_m$ 上$n$阶给定可逆矩阵$A$的周期"></a>$\mathbb{Z}_m$ 上$n$阶给定可逆矩阵$A$的周期</h2><p>设$f(\lambda) = | \lambda I -A|$，$A$ 可逆等价于 $\gcd(f(\lambda),\lambda) = 1$，由于$A^k$都可以由$I,A,\cdots A^{n-1}$，线性表出，但是由于是在$\mod m$ 的意义下，所以根据容斥原理，对任意$k \geq m^n$ 时，必然存在 $l &lt; k$，使得 $A^k = A^l$。即$A$的周期上限是$m^n$，并且周期是$|GL_n(\mathbb{Z}_m)|$ 的一个真因子（n&gt;1)。</p>
<p>显然若$A$ 可对角化，那么$A$ 的周期必然是$\phi(m)$的一个因子！但是注意这里$A$对称并不能推出$A$ 可对角化。</p>
<h2 id="常系数递推数列模意义下的周期"><a href="#常系数递推数列模意义下的周期" class="headerlink" title="常系数递推数列模意义下的周期"></a>常系数递推数列模意义下的周期</h2><p>给定初值，$x_1,\cdots x_s$, 和递推关系：$x_{n+s} = a_1 x_{n+s-1} + \cdots + a_s x_n, a_s \neq 0$ 的数列 ${x_n}$可以表示成：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
x_n \\
x_{n-1} \\
\vdots  \\
x_{n-s+1}
\end{pmatrix} =
\begin{pmatrix}
a_1 & a_2 &\cdots & a_s \\
1 & 0 \\
\vdots  & & & 0\\
0 &\cdots & 1& 0
\end{pmatrix} 

\begin{pmatrix}
x_{n-1} \\
x_{n-2} \\
\vdots  \\
x_{n-s}
\end{pmatrix}</script><p>可以通过矩阵幂在 $O(s^3 \log n)$ 复杂度求出。</p>
<blockquote>
<p>当 $s$ 相对较大时，根据特征多项式将系数矩阵$A^n$ 写成 $I,A,\cdots A^{s-1}$的线性组合，然后只考虑仅乘以第一行，就可以在$O(s^2\log n)$ 复杂度求出</p>
</blockquote>
<p>我们考虑 数列$\lbrace x_n  \mod m \rbrace$ ，由容斥原理知，数列$\lbrace x_n  \mod m \rbrace$ 是周期数列，记它的最小正周期为 $f(m)$ ，则 </p>
<script type="math/tex; mode=display">
f(m) = lcm(f(p_1^{s_1}),\cdots f(p_r^{s_r}))</script><p>只要$p_i \not| \; a_s$，则 $f(p_i ^{s_i})$  是 $|GL_n(\mathbb{Z}_{p_i^{s_i}})|$的一个真因子（当$n&gt;1$ 时，$GL_n(\mathbb{Z}_{p_i^{s_i}})$ 不是循环群）。</p>
<blockquote>
<p>精确的周期要具体问题具体分析。</p>
</blockquote>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>不超过 $x$ 的素数之和</title>
    <url>/primePowSum/</url>
    <content><![CDATA[<p>我们可以在不求出 <strong>不超过 $x$ 的所有素数</strong> 的情况下，求出最终结果。</p>
<script type="math/tex; mode=display">
f_k(x) \doteq \sum_{p \leq x} p^k</script><ul>
<li>$f_0(x) = \pi(x)$ 这个在 <a href="/computationOfPiX/" title="$\pi(x)$ 的计算">$\pi(x)$ 的计算</a></li>
<li>$f_1(x) = \sum_{p \leq x} p$ 这是我们关心的结果</li>
<li>对于一般的 $k$ 借助 <a href="/fastPowSumOfNaturalNumber/" title="自然数方幂和快速算法">自然数方幂和快速算法</a> 也可以求</li>
</ul>
<a id="more"></a>
<h2 id="f-k-x-s-：-最小素因子大于-p-s-且不超过-x-的数的-k-次方和"><a href="#f-k-x-s-：-最小素因子大于-p-s-且不超过-x-的数的-k-次方和" class="headerlink" title="$f_k(x,s)$： 最小素因子大于 $p_s$ 且不超过 $x$ 的数的 $k$ 次方和"></a>$f_k(x,s)$： 最小素因子大于 $p_s$ 且不超过 $x$ 的数的 $k$ 次方和</h2><script type="math/tex; mode=display">
f_k(x,s) = \sum_{m \leq x, \delta(m)>p_s} m^k</script><p>其中，$\delta(m)$ 表示 $m$ 的最小素因子（约定 $\delta(1) = + \infty$）。</p>
<h3 id="f-k-x-s-的递推公式"><a href="#f-k-x-s-的递推公式" class="headerlink" title="$f_k(x,s)$ 的递推公式"></a>$f_k(x,s)$ 的递推公式</h3><script type="math/tex; mode=display">
\begin{aligned}
f_k(x,s) &= \sum_{m \leq x, \delta(m)>p_s} m^k \\
&= f(x,s-1) - \sum_{m \leq x, \delta(m) = p_s} m^k \\
&= f(x,s-1) - p_s ^k f(\frac{x}{p_s},s-1)
\end{aligned}</script><blockquote>
<p>$f_k(x,0) = \sum_{i=1} ^ {\lfloor x \rfloor} i^k$</p>
</blockquote>
<h3 id="f-k-x-s-和-f-k-x-的关系"><a href="#f-k-x-s-和-f-k-x-的关系" class="headerlink" title="$f_k(x,s)$  和 $f_k(x)$ 的关系"></a>$f_k(x,s)$  和 $f_k(x)$ 的关系</h3><p>若 $s &gt;= \pi(\sqrt{x})$，则</p>
<script type="math/tex; mode=display">
f_k(x) = f_k(x,s) - 1  + f_k(p_s)</script><h3 id="只对-k-1-写代码（一般的-k-同理）"><a href="#只对-k-1-写代码（一般的-k-同理）" class="headerlink" title="只对 $k=1$ 写代码（一般的 $k$ 同理）"></a>只对 $k=1$ 写代码（一般的 $k$ 同理）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;p[<span class="number">1</span>]=<span class="number">2</span>;isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)   isp[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])  p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>,t=(N<span class="number">-1</span>)/i + <span class="number">1</span>;j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j)&#123;</span><br><span class="line">            isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">LL spi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    initprime();</span><br><span class="line">    pi[<span class="number">2</span>] = <span class="number">1</span>;spi[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])&#123;</span><br><span class="line">            pi[i]=pi[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            spi[i] = spi[i<span class="number">-1</span>]+i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pi[i]=pi[i<span class="number">-1</span>];</span><br><span class="line">            spi[i] = spi[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sump</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">sumphi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)  <span class="keyword">return</span> (x+<span class="number">1</span>)*x/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x/p[s] &lt;= p[s])  <span class="keyword">return</span> sump(x)+<span class="number">1</span>-sump(p[s]);</span><br><span class="line">    <span class="keyword">return</span> sumphi(x,s<span class="number">-1</span>)-p[s]*sumphi(x/p[s],s<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sump</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> spi[x];</span><br><span class="line">    <span class="keyword">int</span> s = pi[<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">    <span class="keyword">return</span> sumphi(x,s) <span class="number">-1</span>+ sump(p[s]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n = 10^10 就超过int64了,此时用Int128 n &lt; N*N</span></span><br><span class="line">        <span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sump(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是其实我们还可以，类似于 $\pi(x)$ 的计算一样, 取 $\pi(\sqrt[3]{x}) \leq s \leq \pi(\sqrt{x})$</p>
<script type="math/tex; mode=display">
f_k(x) = f_k(x,s) - 1  + f_k(p_s) - \sum_{i=s+1} ^ {\pi(\sqrt{x})} (f(\frac{x}{p_i})-f(p_{i-1})) p_i ^k</script><h3 id="只对-k-1-写代码（一般的-k-同理）-1"><a href="#只对-k-1-写代码（一般的-k-同理）-1" class="headerlink" title="只对 $k=1$ 写代码（一般的 $k$ 同理）"></a>只对 $k=1$ 写代码（一般的 $k$ 同理）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;p[<span class="number">1</span>]=<span class="number">2</span>;isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)   isp[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])  p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>,t=(N<span class="number">-1</span>)/i + <span class="number">1</span>;j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j)&#123;</span><br><span class="line">            isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">LL spi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    initprime();</span><br><span class="line">    pi[<span class="number">2</span>] = <span class="number">1</span>;spi[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])&#123;</span><br><span class="line">            pi[i]=pi[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            spi[i] = spi[i<span class="number">-1</span>]+i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pi[i]=pi[i<span class="number">-1</span>];</span><br><span class="line">            spi[i] = spi[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sump</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">sumphi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)  <span class="keyword">return</span> (x+<span class="number">1</span>)*x/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x/p[s] &lt;= p[s])  <span class="keyword">return</span> sump(x)+<span class="number">1</span>-sump(p[s]);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N &amp;&amp; x/p[s]/p[s] &lt;= p[s])&#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">        LL ans = spi[x]+<span class="number">1</span>-spi[p[s]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=s2x;++i)&#123;</span><br><span class="line">            ans+=p[i]*(spi[x/p[i]]-spi[p[i<span class="number">-1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumphi(x,s<span class="number">-1</span>)-p[s]*sumphi(x/p[s],s<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sump</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> spi[x];</span><br><span class="line">    <span class="keyword">int</span> ps2x = pi[<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">    <span class="keyword">int</span> ps3x = pi[<span class="keyword">int</span>(cbrt(x+<span class="number">0.2</span>))];</span><br><span class="line">    LL ans = sumphi(x,ps3x) <span class="number">-1</span> + spi[p[ps3x]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =ps3x+<span class="number">1</span>;i&lt;=ps2x;++i)&#123;</span><br><span class="line">        ans -= p[i]*(sump(x/p[i])-sump(p[i<span class="number">-1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n = 10^10 就超过int64了,此时用Int128 n &lt; N*N</span></span><br><span class="line">        <span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sump(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>输出源代码的 C++ 代码</title>
    <url>/printSelfWithCpp/</url>
    <content><![CDATA[<p>我们可以把计算机看成一个函数，将一份代码映成一段输出，那么输出为代码本事就是数学中不动点。任意语言都有很多相应版本的这种程序，原理都是类似的，我自己写的 C++ 代码如下：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a[<span class="number">0</span>]=<span class="string">"#include&lt;iostream&gt;"</span>;</span><br><span class="line">a[<span class="number">1</span>]=<span class="string">"#include&lt;string&gt;"</span>;</span><br><span class="line">a[<span class="number">2</span>]=<span class="string">"using namespace std;"</span>;</span><br><span class="line">a[<span class="number">3</span>]=<span class="string">"string a[10];"</span>;</span><br><span class="line">a[<span class="number">4</span>]=<span class="string">"int main()&#123;"</span>;</span><br><span class="line">a[<span class="number">5</span>]=<span class="string">"for(int i=0;i&lt;5;++i) cout&lt;&lt;a[i]&lt;&lt;endl;"</span>;</span><br><span class="line">a[<span class="number">6</span>]=<span class="string">"for(int i=0;i&lt;10;++i) cout&lt;&lt;char(97)&lt;&lt;char(91)&lt;&lt;i&lt;&lt;char(93)&lt;&lt;char(61)&lt;&lt;char(34)&lt;&lt;a[i]&lt;&lt;char(34)&lt;&lt;char(59)&lt;&lt;endl;"</span>;</span><br><span class="line">a[<span class="number">7</span>]=<span class="string">"for(int i=5;i&lt;10;++i) cout&lt;&lt;a[i]&lt;&lt;endl;"</span>;</span><br><span class="line">a[<span class="number">8</span>]=<span class="string">"return 0;"</span>;</span><br><span class="line">a[<span class="number">9</span>]=<span class="string">"&#125;"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i) <span class="built_in">cout</span>&lt;&lt;<span class="keyword">char</span>(<span class="number">97</span>)&lt;&lt;<span class="keyword">char</span>(<span class="number">91</span>)&lt;&lt;i&lt;&lt;<span class="keyword">char</span>(<span class="number">93</span>)&lt;&lt;<span class="keyword">char</span>(<span class="number">61</span>)&lt;&lt;<span class="keyword">char</span>(<span class="number">34</span>)&lt;&lt;a[i]&lt;&lt;<span class="keyword">char</span>(<span class="number">34</span>)&lt;&lt;<span class="keyword">char</span>(<span class="number">59</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&lt;<span class="number">10</span>;++i) <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码原理和步骤：</p>
<ol>
<li>先把头写好，定义好数组，记作头部</li>
<li>开始对数组赋值一直赋值到头部，然后空几行</li>
<li>把头用数组打印出来，再讲数组全部打印出来，再将后面的部分打印出来</li>
<li>再去空的几行，做数组赋值，赋值的时候后面的每一行</li>
</ol>
<blockquote>
<p>注意代码中特殊字符需要转义，不然就很尬了，而且代码不能用 tab 缩进</p>
<p>后来我又写了一篇<a href="/printSelfWithPy/" title="用 Python 打印自身的代码">用 Python 打印自身的代码</a></p>
<p>文件打印就太没水平了，这里就不给出了</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>输出源代码的 Python 代码</title>
    <url>/printSelfWithPy/</url>
    <content><![CDATA[<p>之前，现在用 Python 写一遍</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">with</span> open(sys.argv[<span class="number">0</span>]) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read(), end =<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>但是利用传入参数读文件属实耍赖，所以在写一个不用读文件的版本：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = list(range(<span class="number">6</span>))</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">'a = list(range(6))'</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">'print(a[0])'</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="string">'for i in range(6):'</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="string">'    print("a["+str(i)+"] = "+chr(39)+a[i]+chr(39))'</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="string">'for i in range(1,5): print(a[i])'</span></span><br><span class="line">a[<span class="number">5</span>] = <span class="string">'print(a[5], end = "")'</span></span><br><span class="line">print(a[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    print(<span class="string">"a["</span>+str(i)+<span class="string">"] = "</span>+chr(<span class="number">39</span>)+a[i]+chr(<span class="number">39</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>): print(a[i])</span><br><span class="line">print(a[<span class="number">5</span>], end = <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后一行是因为 Python 默认以 print 回车结尾<br>我无法用 tab 缩进，只能用空格缩进，这是唯一不完美的地方</p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>二次剩余和 Gauss 互反律</title>
    <url>/quadraticResidueAndGaussReciprocity/</url>
    <content><![CDATA[<p>从二次剩余问题，引入 Legendre 符号，由此一步步导出 Gauss 互反律，最后延伸到 Jacobi 符号，整个步骤确实连贯优美，脍炙人口。<br><a id="more"></a></p>
<p>寒假回家好好调整了一下状态，回学校后感觉还不错，效率也蛮高。发现理图虽然比较破，但是还是很不错的，哈哈哈。每次读潘承洞先生的《数论基础》都觉得受益匪浅，我把自己很喜欢的部分写入到该文中。</p>
<h2 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h2><p>考虑如下形式二次同余式</p>
<script type="math/tex; mode=display">
x^2 \equiv  a \; \mod \; p</script><p>其中 $p$ 是奇素数，$a$ 是非负整数。若上述方程有解，则称 $a$ 是 $p$ 的二次剩余，记作 $a\; R \; p$，否则称 $a$ 是 $p$ 的二次非剩余，记作 $a \; \overline{R}\; p$ 。$p=2$ 时就没啥意思了，所以 <strong>仅考虑奇素数。</strong></p>
<p>经过简单推理很容易发现，在模 $p$ 的简化系中，二次剩余与二次非剩余各占一半。且容易知道，$1^2,2^2,\cdots,(\frac{p-1}{2})^2$ 都是 $p$ 二次剩余。</p>
<h2 id="Legendre-符号"><a href="#Legendre-符号" class="headerlink" title="Legendre 符号"></a>Legendre 符号</h2><script type="math/tex; mode=display">
\left( \frac{a}{p} \right) = \left\{ \begin{array}{cc} 1, & a\; R\; p \\
0, & p \mid a \\
-1, & a\; \overline{R}\; p. \end{array} \right.</script><h3 id="定理-1-quad-frac-a-p-p-1-equiv-a-frac-p-1-2-mod-p"><a href="#定理-1-quad-frac-a-p-p-1-equiv-a-frac-p-1-2-mod-p" class="headerlink" title="定理 1: $ \quad -(\frac{a}{p}) (p-1)! \equiv a^{\frac{p-1}{2}} \mod p $"></a>定理 1: $ \quad -(\frac{a}{p}) (p-1)! \equiv a^{\frac{p-1}{2}} \mod p $</h3><p><strong>Proof</strong>: 对于 $p \mid a$ 的情形，结论显然。下面考虑 $(p,a)=1$ 的情形，令</p>
<script type="math/tex; mode=display">
 S = \lbrace 1,2,\cdots,p-1 \rbrace</script><p>对任意的 $ x \in S $ 必存在唯一的 $ y \in S $ 为下面同余式的解</p>
<script type="math/tex; mode=display">
yx \equiv a \; \mod p</script><p>当 $ (\frac{a}{p}) = -1 $ 时，同余式 $ x^2 = a \; \mod p$ 无解，所以 $y \neq x $ .因此集合 $S$ 中的元素可以分成 $\frac{p-1}{2} $ 对，我们就有</p>
<script type="math/tex; mode=display">
(p-1)! \equiv a^{\frac{p-1}{2}} \;\mod p</script><p>当 $ (\frac{a}{p}) = 1 $ 时，同余式 $ x^2 = a \; \mod p $有两个解 $x_0$ 和 $p - x_0$.在$S$中去掉这两个数外剩下$p-3$个数分出 $\frac{p-3}{2}$对，则有</p>
<script type="math/tex; mode=display">
(p-1)! \equiv a^{\frac{p-3}{2}}x_0(p-x_0) \equiv - a^{\frac{p-1}{2}} \; \mod p</script><p> 证毕。</p>
<h2 id="推论-2-Wilson-定理"><a href="#推论-2-Wilson-定理" class="headerlink" title="推论 2 (Wilson 定理)"></a>推论 2 (Wilson 定理)</h2><script type="math/tex; mode=display">
(p-1)! \equiv -1 \;\mod p</script><p><strong>Proof</strong>: <strong>定理 1</strong> 中取 $a=1$ 即可。</p>
<h2 id="推论-3-Euler-判别法"><a href="#推论-3-Euler-判别法" class="headerlink" title="推论 3(Euler 判别法)"></a>推论 3(Euler 判别法)</h2><script type="math/tex; mode=display">
\left( \frac{a}{p} \right ) \equiv a^{\frac{p-1}{2}} \; \mod \;p</script><p><strong>Proof</strong>: 由 <strong>定理 1</strong> 和 <strong>推论 2</strong> 显然。Euler 判别法不仅有理论价值(下面都是推论 3 的直接推论)，由于快速幂的存在，使得 Euler 判别法在计算时有相当好的效果。</p>
<h2 id="推论-4-Format-小定理-设-a-p-1-则"><a href="#推论-4-Format-小定理-设-a-p-1-则" class="headerlink" title="推论 4(Format 小定理) 设 $(a,p)=1$ ,则"></a>推论 4(Format 小定理) 设 $(a,p)=1$ ,则</h2><script type="math/tex; mode=display">
a^{p-1} \equiv 1 \;\mod p</script><h2 id="推论-5-frac-1-p-1-frac-p-1-2"><a href="#推论-5-frac-1-p-1-frac-p-1-2" class="headerlink" title="推论 5 $\; (\frac{-1}{p}) = (-1)^{\frac{p-1}{2}}$"></a>推论 5 $\; (\frac{-1}{p}) = (-1)^{\frac{p-1}{2}}$</h2><h2 id="推论-6-frac-ab-p-frac-a-p-frac-b-p"><a href="#推论-6-frac-ab-p-frac-a-p-frac-b-p" class="headerlink" title="推论 6 $\; (\frac{ab}{p}) =(\frac{a}{p})(\frac{b}{p}) $"></a>推论 6 $\; (\frac{ab}{p}) =(\frac{a}{p})(\frac{b}{p}) $</h2><h4 id="推论-6-说明，我们求-Legendre-符号，只需求-frac-2-p-frac-q-p-即可"><a href="#推论-6-说明，我们求-Legendre-符号，只需求-frac-2-p-frac-q-p-即可" class="headerlink" title="推论 6 说明，我们求 Legendre 符号，只需求 $ (\frac{2}{p}),(\frac{q}{p}) $ 即可"></a>推论 6 说明，我们求 Legendre 符号，只需求 $ (\frac{2}{p}),(\frac{q}{p}) $ 即可</h4><h2 id="定理-7-frac-2-p-1-frac-p-2-1-8"><a href="#定理-7-frac-2-p-1-frac-p-2-1-8" class="headerlink" title="定理 7 $\; (\frac{2}{p}) = (-1)^{\frac{p^2-1}{8}}$"></a>定理 7 $\; (\frac{2}{p}) = (-1)^{\frac{p^2-1}{8}}$</h2><p><strong>Proof</strong>: </p>
<script type="math/tex; mode=display">
2^{\frac{p-1}{2}}(\frac{p-1}{2})! = 2 \cdot 4 \cdots (p-1) \equiv (\frac{p-1}{2})!(-1)^{1+2+\cdots+\frac{p-1}{2}}\;\mod p</script><blockquote>
<p>其中最后一个等价是因为：</p>
<script type="math/tex; mode=display">
\begin{array}{c} p-1 \equiv (-1)^1 \mod p \\
2 \equiv (-1)^2 \mod p \\
p-3 \equiv (-1)^3 \mod p \\
\cdots
\end{array}</script></blockquote>
<script type="math/tex; mode=display">
(\frac{2}{p}) \equiv 2^{\frac{p-1}{2}} \equiv (-1)^{\frac{p^2-1}{8}} \;\mod p</script><p>  证毕。</p>
<h2 id="定理-8-Gauss-二次互反律-设-p-q-为不同的奇素数，则有"><a href="#定理-8-Gauss-二次互反律-设-p-q-为不同的奇素数，则有" class="headerlink" title="定理 8 (Gauss 二次互反律) 设 $p,q$ 为不同的奇素数，则有"></a>定理 8 (Gauss 二次互反律) 设 $p,q$ 为不同的奇素数，则有</h2><script type="math/tex; mode=display">
(\frac{p}{q}) (\frac{q}{p}) = (-1)^{\frac{(p-1)(q-1)}{4}}</script><blockquote>
<p>太长了，下次一定吧 0.0</p>
</blockquote>
<h2 id="Jacobi-符号"><a href="#Jacobi-符号" class="headerlink" title="Jacobi 符号"></a>Jacobi 符号</h2><blockquote>
<p>Jacobi 符号的引入只是为了让计算更加简洁！</p>
</blockquote>
<p> 我们在计算用 Gauss 二次互反律求 $(\frac{a}{q})$ 时，由于 $a$ 要因式分解成很多项，所以直接用不是很方便。因此我们引入 Jacobi 符号:</p>
<p>设 $Q =  q_1 \cdots q_s$ 是正奇数，其中 $q_1 \leq \cdots \leq q_s$  是奇素数（手算时候可以保证严格小于），我们定义：</p>
<script type="math/tex; mode=display">
(\frac{a}{Q}) = (\frac{a}{q_1}) \cdots (\frac{1}{q_s})</script><ul>
<li>$Q$ 为奇素数时，Jacobi 符号就是 Legendre 符号</li>
<li>$(\frac{a}{Q}) = 1$ 并不等价于 $x^2 \equiv a \mod Q$ 有解！</li>
<li>$(\frac{a}{Q})$ 是 $a$ 的可乘函数，周期为 $Q$ 的周期函数</li>
<li>当 $(a,Q)&gt;1$ 时，$(\frac{a}{Q})=0$</li>
<li>当 $(a,Q)= 1$ 时，$(\frac{a^2}{Q})=1$；特别地，$(\frac{1}{Q}) = 1$</li>
<li>$(\frac{-1}{Q}) = (-1)^{\frac{Q-1}{2}}$</li>
<li>$(\frac{2}{Q}) = (-1)^{\frac{Q^2-1}{8}}$</li>
<li>$(\frac{P}{Q}) = (-1)^{\frac{(P-1)(Q-1)}{4}} (\frac{Q}{P})$，其中 $P,Q$ 都是正奇数。</li>
<li>写程序计算时可以避免做质因数分解！！！</li>
</ul>
<blockquote>
<p>注意到 Jacobi 符号只是为了简化 Legendre 符号的计算的！</p>
</blockquote>
<h2 id="计算例子"><a href="#计算例子" class="headerlink" title="计算例子"></a>计算例子</h2><p>判断二次同余式 $x^2 \equiv 888 \mod 1999$ 是否有解。</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\frac{888}{1999}) &= (\frac{4}{1999}) (\frac{2}{1999}) (\frac{111}{1999}) \\
&= (-1) ^{\frac{1999^2 -1}{8}}  (\frac{111}{1999}) \\
&= (-1)^{\frac{(1999-1)(111-1)}{4}} (\frac{1999}{111}) \\
&= -(\frac{1}{111}) = -1
\end{aligned}</script><blockquote>
<p>如果取模的数不是素数，那么就把它分解素因数，然后每个单独判断即可。</p>
</blockquote>
<h2 id="Jacobi-符号-Python-程序"><a href="#Jacobi-符号-Python-程序" class="headerlink" title="Jacobi 符号 Python 程序"></a>Jacobi 符号 Python 程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># a是整数，Q是正奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Jacobi</span><span class="params">(a,Q)</span>:</span></span><br><span class="line">    <span class="comment"># print(a,Q)  # 需要看过程就取消本行最前面的注释</span></span><br><span class="line">    a%=Q</span><br><span class="line">    <span class="keyword">if</span> math.gcd(a,Q) &gt; <span class="number">1</span>:  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> a%<span class="number">4</span>==<span class="number">0</span>: a//=<span class="number">4</span></span><br><span class="line">    f = <span class="keyword">lambda</span> n:<span class="number">1</span><span class="number">-2</span>*(n&amp;<span class="number">1</span>)</span><br><span class="line">    ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a%<span class="number">2</span>==<span class="number">0</span>: a//=<span class="number">2</span>;ans = f((Q**<span class="number">2</span><span class="number">-1</span>)//<span class="number">8</span>)</span><br><span class="line">    <span class="comment"># 此时a也是正奇数了</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">1</span>:  <span class="keyword">return</span> ans</span><br><span class="line">    <span class="keyword">return</span> ans*f((a<span class="number">-1</span>)*(Q<span class="number">-1</span>)//<span class="number">4</span>)*Jacobi(Q,a)</span><br><span class="line"></span><br><span class="line">print(Jacobi(<span class="number">888</span>,<span class="number">1999</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>上流开源免费数学软件之 SageMath</title>
    <url>/sageMath/</url>
    <content><![CDATA[<p>Sage 的是“ 圣”的意思，所以 <a href="http://www.sagemath.org/" target="_blank" rel="noopener">SageMath</a>懂啥意思了吧，上流！哈哈。SageMath 整合了当前开源的所有高效包，用来取代 MATLAB（20G)，Mathematics(5G）等商业软件。 而 SageMath 安装包仅 1G 不到，而且语言基于 Python，就很快乐。而且你还能免费注册账号用基于 Jupyter Notebook 的<a href="https://cocalc.com/" target="_blank" rel="noopener">SageMath 在线版: Cocalc</a> </p>
<blockquote>
<p>感谢知乎好友<a href="https://www.zhihu.com/people/li-yong-xiang-38" target="_blank" rel="noopener">Vivr0</a> 的推荐</p>
</blockquote>
<a id="more"></a>
<p>SageMath 的安装，入门教程在<a href="http://www.sagemath.org/" target="_blank" rel="noopener">官网</a>很容易就找到了，而且下载提供国内镜像下载地址，特别友好。除了入门教程，还有专题教程。语言和 Python 几乎一致。不用一致 import，内建的特别好。文件格式：<code>.sage</code></p>
<blockquote>
<p>Macos or Linux 上用 sage 会更加快乐！WSL 就没法用 Jupyter 了，不过也还行！</p>
</blockquote>
<h2 id="SageMath-特征"><a href="#SageMath-特征" class="headerlink" title="SageMath 特征"></a>SageMath 特征</h2><ul>
<li>交互界面下，有赋值就不输出，表达式会输出(调用<code>__repr__</code>方法)</li>
<li><code>ZZ,QQ,RR,CC</code>分别表示整数，有理数，实数，复数</li>
<li>Tab 补全，vim 姿势退出，git 姿势复制粘贴，很上流</li>
<li><code>^</code> 等同 <code>**</code>，<code>^^</code>表示<code>xor</code>, <code>/</code> 表示分数的除。其它和 Python 一致</li>
<li>（Python）函数和 SageMath 符号表达式是有本质区别的。</li>
<li>自带抽象代数：群，多项式环，$\mathbb{Z}_n$ ，$p$-adic 数等等。上流</li>
<li><code>latex(expr)</code> ：表达式的 latex 形式</li>
<li>可以直接使用 <code>oeis</code></li>
<li>sage.arith.misc 各种杂类函数，sage.games 有几个有意思的。</li>
<li><code>%time</code>： 测时间，<code>?</code> 帮助文章并且可以定位到源码位置查看源码！</li>
<li><a href="https://github.com/sagemath/sage/blob/develop/src/sage" target="_blank" rel="noopener">github 上查看 SageMath 模块源码</a></li>
<li>线性规划有包 MixIntegerLinearProgram</li>
<li>To be Continue</li>
</ul>
<h2 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h2><p><a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="noopener">jupyter 主题</a></p>
<p><code>Esc</code> 进入命令模式，<code>Enter</code> 进入编辑模式。<a href="https://www.cnblogs.com/locke-hu/p/9236540.html" target="_blank" rel="noopener">快捷键</a>友好(工具栏最右边有快捷键查询)</p>
<h4 id="命令模式常用快捷键（按-Esc-键开启）"><a href="#命令模式常用快捷键（按-Esc-键开启）" class="headerlink" title="命令模式常用快捷键（按 Esc 键开启）"></a>命令模式常用快捷键（按 Esc 键开启）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>S</code></td>
<td>保存当前 NoteBook</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><code>Shift-Enter</code></td>
<td>运行本单元，选中下个单元</td>
<td>新单元默认为命令模式</td>
</tr>
<tr>
<td style="text-align:left"><code>Ctrl-Enter</code></td>
<td>运行本单元</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><code>Alt-Enter</code></td>
<td>运行本单元，在其下插入新单元</td>
<td>新单元默认为编辑模式</td>
</tr>
<tr>
<td style="text-align:left"><code>D,D</code></td>
<td>删除选中的单元</td>
<td>连续按两个 D 键</td>
</tr>
<tr>
<td style="text-align:left"><code>Y</code></td>
<td>单元转入代码状态</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><code>M</code></td>
<td>单元转入 markdown 状态</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><code>R</code></td>
<td>单元转入 raw 状态</td>
<td>保持原始格式</td>
</tr>
<tr>
<td style="text-align:left"><code>B</code></td>
<td>当前行下方插入一行，并进入该行</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><code>Shift-H</code></td>
<td>清空所有输出</td>
<td>个人定制哈哈</td>
</tr>
</tbody>
</table>
</div>
<h4 id="编辑模式常用快捷键（-按-Enter-键启动）"><a href="#编辑模式常用快捷键（-按-Enter-键启动）" class="headerlink" title="编辑模式常用快捷键（ 按 Enter 键启动）"></a>编辑模式常用快捷键（ 按 Enter 键启动）</h4><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Tab</code></td>
<td>代码补全或缩进</td>
<td></td>
</tr>
<tr>
<td><code>Shift-Tab</code></td>
<td>提示</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-]</code></td>
<td>缩进</td>
<td>向右缩进</td>
</tr>
<tr>
<td><code>Ctrl-[</code></td>
<td>解除缩进</td>
<td>向左缩进</td>
</tr>
<tr>
<td><code>Ctrl-/</code></td>
<td>注释整行/撤销注释</td>
<td>仅代码状态有效</td>
</tr>
<tr>
<td><code>Ctrl-Z</code></td>
<td>撤销</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-ShiftZ</code></td>
<td>重做</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-Y</code></td>
<td>重做</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-Home</code></td>
<td>跳到单元开头</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-Up</code></td>
<td>跳到单元开头</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-End</code></td>
<td>跳到单元末尾</td>
<td></td>
</tr>
<tr>
<td><code>Ctrl-Down</code></td>
<td>跳到单元末尾</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Jupyter Notebook 在绘图方面特别方便，而且可以将代码和 Markdown 很清楚的写在一起</p>
<p>Jupyter 卡顿时候一定要强制中断！有数字的说明运行好了的！</p>
</blockquote>
<h2 id="SageMath-文档"><a href="#SageMath-文档" class="headerlink" title="SageMath 文档"></a>SageMath 文档</h2><p><a href="https://doc.sagemath.org/html/en/tutorial/index.html" target="_blank" rel="noopener">入门教程</a>，<a href="https://doc.sagemath.org/html/en/reference/index.html" target="_blank" rel="noopener">用户手册</a>，<a href="https://doc.sagemath.org/html/en/reference/py-modindex.html" target="_blank" rel="noopener">所有模块</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模块索引(首字母)</th>
<th>模块全名（<code>sage.</code>）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a</code></td>
<td>algebra, arith</td>
</tr>
<tr>
<td><code>c</code></td>
<td>calculus, categories, coding, combinat, cPython , crypto</td>
</tr>
<tr>
<td><code>d</code></td>
<td>date_structures, databases, docs, doctest, dynaimics</td>
</tr>
<tr>
<td><code>e, f</code></td>
<td>ext, features, finance, functions</td>
</tr>
<tr>
<td><code>g</code></td>
<td>game_theory, games, geometry, graphs, groups</td>
</tr>
<tr>
<td><code>h, i</code></td>
<td>knots, lfuntions libs, logic</td>
</tr>
<tr>
<td><code>m</code></td>
<td>manifolds, matrix, matroids media, misc, modular, modules, monoids</td>
</tr>
<tr>
<td><code>n, p, q, r</code></td>
<td>numerical, parallel, plot probability, quadratic_forms, quivers, repl, rings</td>
</tr>
<tr>
<td><code>s, t</code></td>
<td>sandpiles, sat, schemes, sets, stats, structure, symbolic, tensor, typeset</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>记不清名字的时候多用代码补全！</p>
</blockquote>
<p>先找对应名字，再找对应模块中的函数，最后看手册用的例子。</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Math</tag>
        <tag>SageMath</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言中函数 scanf 和 printf</title>
    <url>/scanfAndPrintInC/</url>
    <content><![CDATA[<p>在 C 语言中最常用的函数应该就是 scanf，printf 吧。对于大量输入输出时 C++ 也常用 scanf 和 print 代替 cin 和 cout。然而我们学习 C 语言最先接触的 scanf 和 printf 其实我们并不完全了解。 <del>弃用</del></p>
<a id="more"></a>
<h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>按照 <a href="http://www.cplusplus.com/reference/cstdio/scanf/?kw=scanf" target="_blank" rel="noopener">C++ reference</a> 的介绍，scanf 的原型为<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * format, ... )</span></span>;</span><br><span class="line">format = %[*][<span class="built_in">width</span>][length]specifier</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-lazy-src="scanf.png" alt="scanf 对应length"></p>
<p>其中上面的 <code>[*]</code> 表示输入的东西被忽略，<code>[width]</code> 表示最大输入长度，而<code>[length</code>表示是类型的一种延伸，可以是 <code>hh, h, l, ll, j, z, t, L</code> 中的一种。例如<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%3ld"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// input : 12345</span></span><br><span class="line"><span class="comment">// output: 123</span></span><br></pre></td></tr></table></figure><br>specifier 是必选项 它可以是 <code>i,d,u,o,x,f,e,g,a,c,s,p,n,%​</code>。还有两个特殊的<code>[characters]</code>和<code>[^characters]</code>。上面的参数就不过多说了。特别要强调的是这两个特殊的。<br><code>[characters]</code> 表示只接受 <code>[characters]</code> 中的字符；<code>[^characters]</code> 表示只不接受<code>[characters]</code> 中的字符。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>],a[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[1-9A-Z]"</span>,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^b]"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// input : 123AaBbCc</span></span><br><span class="line"><span class="comment">// output: 123A</span></span><br><span class="line"><span class="comment">// output: aB</span></span><br></pre></td></tr></table></figure>
<h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a><strong>特别注意</strong></h3><p>在使用下面语句进行输入时遇到空白符(whitespace)会结束输入的。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);</span><br></pre></td></tr></table></figure><br>whitespace 可以使用 <code>int isspace(int c);</code> 判断。有这些字符有：<br><img src= "/img/loading.gif" data-lazy-src="whitespace.png" alt="whitespace"></p>
<h3 id="scanf-典型例子"><a href="#scanf-典型例子" class="headerlink" title="scanf 典型例子"></a>scanf 典型例子</h3><ol>
<li>有时我们明确知道输入为 <code>(a,b)​</code> 这种类型，我们可以这样做<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"(%d,%d)"</span>,&amp;a,&amp;b);</span><br></pre></td></tr></table></figure></li>
<li>输入字符包含除回车之外的字符<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>,str);</span><br></pre></td></tr></table></figure></li>
<li>只输入小写字母和数字<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%[0-9a-z]"</span>,str);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="scanf-返回值"><a href="#scanf-返回值" class="headerlink" title="scanf 返回值"></a>scanf 返回值</h3><ol>
<li>正整数：表示正确输入参数的个数</li>
<li>0：输入不匹配，无法正确输入任何值</li>
<li>EOF（一般为-1）为读到文件结尾或在 terminal 中输入了 <code>ctrl + z</code></li>
</ol>
<h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>print 的原型为<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * format, ... )</span></span>;</span><br><span class="line">%[flags][<span class="built_in">width</span>][.precision][length]specifier</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-lazy-src="printf.png" alt="printf"></p>
<p>specifier 和 scanf 的类似就不多说了。<code>[length] [width]</code>同理。<code>[.precision]</code> 一看就懂<br><code>[flags]</code>可选有<code>\-,\+,\#,0</code>。其中</p>
<ol>
<li><code>-</code>表示在给定宽度内向左靠齐。默认向右见下例子</li>
<li><code>+</code> 表示即使是非负数，前面也要加正号。</li>
<li><code>#</code> 目前不清楚用法。</li>
<li><code>0</code> 就是在不足宽度的时候补 0</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">123.45678</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%+10.4f "</span>,a);</span><br><span class="line"><span class="keyword">int</span> t =<span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%04d "</span>,t);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">printf</span>(x&amp;<span class="number">1</span>?<span class="string">"%d is odd"</span>:<span class="string">"%d is even"</span>,x);</span><br><span class="line"><span class="comment">// output: +0123.4568 0100 123 is odd</span></span><br></pre></td></tr></table></figure>
<h3 id="神器：sscanf-和-sprintf"><a href="#神器：sscanf-和-sprintf" class="headerlink" title="神器：sscanf 和 sprintf"></a>神器：sscanf 和 sprintf</h3><p>不多说了，举个例子说明问题吧<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* sscanf example */</span></span><br><span class="line">    <span class="keyword">char</span> sentence []=<span class="string">"Rudolph is 12 years old"</span>;</span><br><span class="line">    <span class="keyword">char</span> str [<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">sscanf</span> (sentence,<span class="string">"%s %*s %d"</span>,str,&amp;i);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%s -&gt; %d\n"</span>,str,i);</span><br><span class="line">    <span class="comment">/* sprintf example */</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span> [<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> n, a=<span class="number">5</span>, b=<span class="number">3</span>;</span><br><span class="line">    n=<span class="built_in">sprintf</span> (<span class="built_in">buffer</span>, <span class="string">"%d plus %d is %d"</span>, a, b, a+b);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"[%s] is a string %d chars long\n"</span>,<span class="built_in">buffer</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// Rudolph -&gt; 12</span></span><br><span class="line"><span class="comment">// [5 plus 3 is 8] is a string 13 chars long</span></span><br></pre></td></tr></table></figure></p>
<h3 id="最后说一个比较诡异但是可以理解的事情"><a href="#最后说一个比较诡异但是可以理解的事情" class="headerlink" title="最后说一个比较诡异但是可以理解的事情"></a>最后说一个比较诡异但是可以理解的事情</h3><blockquote>
<p>sacnf 输入 float 和 double 时分别用 <code>%f,%lf</code>。<br>printf 输出 float 和 double 时用的都是 <code>%f</code>。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Schur 定理</title>
    <url>/schurTheorem/</url>
    <content><![CDATA[<p>在研究一个数学对象时，我们经常会对它进行分类。比如我们通常把数分为：实数，虚数；实数又分成有理数，无理数；当然也有按照正负来分的。还有整数分成素数（也叫质数）和合数，等等。现在我们谈谈矩阵的分类，以下默认矩阵是方的。<br><a id="more"></a></p>
<h2 id="数学中分类一般是按照等价关系划分等价类的"><a href="#数学中分类一般是按照等价关系划分等价类的" class="headerlink" title="数学中分类一般是按照等价关系划分等价类的"></a>数学中分类一般是按照等价关系划分等价类的</h2><p>所谓等价关系其实就是满足反身性，对称性，传递性的二元关系（总结一下我们等于号的全部性质就知道了）<br>矩阵中最常见的三种等价关系分别是</p>
<ol>
<li>相抵等价—-初等变换</li>
<li>合同等价—-合同变换</li>
<li>相似等价—-相似变换</li>
</ol>
<p>相抵等价完全由秩确定，合同变换我们一般只针对实对称矩阵处理。相似变化是我们讨论最多的也是最复杂的，我们总想把复杂的东西变简单，对于一个矩阵我们总想做变换把它变成最简单形式（称为标准型），相抵等价的标准型和对称矩阵合同等价的标准型都十分简单，但是很不幸的也是最幸运的是，并非所有的矩阵都可以相似于对角阵，相似变换标准型称为若尔当标准型，以纪念若尔当对矩阵相似变换所做的贡献。</p>
<p>然而今天主题并不是上面的任何一种，而是由伟大的数学家 Issai Schur 提出的酉相似，酉变换的概念和相应定理。</p>
<h2 id="任意复方阵酉相似于上三角矩阵"><a href="#任意复方阵酉相似于上三角矩阵" class="headerlink" title="任意复方阵酉相似于上三角矩阵"></a>任意复方阵酉相似于上三角矩阵</h2><h3 id="酉矩阵和酉相似"><a href="#酉矩阵和酉相似" class="headerlink" title="酉矩阵和酉相似"></a>酉矩阵和酉相似</h3><p>一个矩阵称为酉矩阵，如果它的共轭转置是它的逆。复矩阵 $A$ 与 $B$ 称为酉相似的，如果存在酉矩阵 $U$ 使得 $B=U^ \star AU$ ，这里$U^ \star$ 表示 $U$ 的共轭转置。</p>
<h3 id="定理-1-对任意复方阵-A-，存在酉矩阵-U-使得"><a href="#定理-1-对任意复方阵-A-，存在酉矩阵-U-使得" class="headerlink" title="定理 1.  对任意复方阵 $A$，存在酉矩阵 $U$ 使得"></a>定理 1.  <strong>对任意复方阵 $A$，存在酉矩阵 $U$ 使得</strong></h3><script type="math/tex; mode=display">
A = U \left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)U^\star</script><p>其中$\lambda_1,\lambda_2,\cdots,\lambda_n$ 为$A$的全部特征值。</p>
<p><strong>Proof</strong>：设 $\alpha_1$ 是$A$的特征值 $\lambda_1$ 对应的特征向量，将 $\alpha_1$ 扩充为$\mathbf{C}^n$的一组标准正交基 $P=(\alpha_1,\alpha_2,\cdots,\alpha_n)$ ，则 $A = P \left( \begin{matrix} \lambda_1 &amp; \star \\ \mathbf{0} &amp; B \end{matrix} \right)P^\star$ 。对复矩阵的阶数应用数学归纳法，存在$n-1$ 阶酉矩阵 $Q$ 使得</p>
<script type="math/tex; mode=display">
B = Q \left( \begin{matrix} \lambda_2 & \star & \star  \\
 & \ddots & \star \\
 & & \lambda_n \end{matrix} \right) Q^ \star</script><p>因此 </p>
<script type="math/tex; mode=display">
A = U \left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)U^\star</script><p>其中 $U = P \left( \begin{matrix} 1 &amp;  \\ &amp; Q \end{matrix} \right)$ 是 $n$ 阶酉矩阵，证毕。</p>
<h3 id="矩阵酉相似于对角阵当且仅当它是正规矩阵"><a href="#矩阵酉相似于对角阵当且仅当它是正规矩阵" class="headerlink" title="矩阵酉相似于对角阵当且仅当它是正规矩阵"></a>矩阵酉相似于对角阵当且仅当它是正规矩阵</h3><p>矩阵 $A$ 称为正规矩阵(<strong>normal matrix</strong>)，如果$ A^ \star A=AA^ \star $。显然酉矩阵，Hermite 阵，反 Hermite 阵都是正规矩阵。</p>
<h3 id="定理-2（Issai-Schur）矩阵-A-酉相似于对角阵的充分必要条件是-A-是正规矩阵"><a href="#定理-2（Issai-Schur）矩阵-A-酉相似于对角阵的充分必要条件是-A-是正规矩阵" class="headerlink" title="定理 2（Issai Schur）矩阵 $A$ 酉相似于对角阵的充分必要条件是 $A$ 是正规矩阵"></a>定理 2（Issai Schur）矩阵 $A$ 酉相似于对角阵的充分必要条件是 $A$ 是正规矩阵</h3><p><strong>Proof</strong>：必要性显然，下证明充分性：</p>
<p>由定理 1 知，存在酉矩阵 $U$ 使得：</p>
<script type="math/tex; mode=display">
A = U \left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)U^\star</script><p>若 $A$ 是正规矩阵，则有</p>
<script type="math/tex; mode=display">
\left( \begin{matrix} 
\overline{\lambda_1} &  &  &  \\
* & \overline{\lambda_2} &  &  \\
* & * & \ddots & \\
* & * & * &  \overline{\lambda_n}
\end{matrix} \right)

\left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)
=
\left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)
\left( \begin{matrix} 
\overline{\lambda_1} &  &  &  \\
\star & \overline{\lambda_2} &  &  \\
\star & \star & \ddots & \\
\star & \star & \star &  \overline{\lambda_n}
\end{matrix} \right)</script><p>考虑矩阵两端$(1,1)$位置得到:</p>
<script type="math/tex; mode=display">
\overline{\lambda_1}\lambda_1 ＝ \lambda_1 \overline{\lambda_1}+\sigma^2</script><p>其中$ \sigma^2 $是上三角矩阵</p>
<script type="math/tex; mode=display">
\left( \begin{matrix} 
\lambda_1 & \star & \star & \star \\
 & \lambda_2 & \star & \star \\
 & & \ddots & \star \\
 & & &  \lambda_n
\end{matrix} \right)</script><p>的第一行的非对角元绝对值之平方和，因此由 $\sigma^2$ 可知上三角矩阵的第一行非对角元全为 0，类似的考察矩阵两端 $(2,2)$ 的位置，一直到 $(n,n)$ 的位置即可知道上面矩阵是对角阵，证毕。</p>
<p>上述定理给出了酉相似于对角型的充分必要条件，而且条件十分易于判断。整个过程简洁优美。另外由于酉矩阵条件数恒定为 1，有其数值稳定性，因此经常用于实际计算中，例如 QR 方法涉及的两个矩阵变换 Househoulder 变换和 Givens 变换都是酉变换。</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 语法糖之防蛀牙</title>
    <url>/syntacticSugar/</url>
    <content><![CDATA[<p>因为 Python 的语法糖，代码简洁优美，越来越喜欢 Python 了。</p>
<blockquote>
<p>人生苦短，请用 Python</p>
</blockquote>
<a id="more"></a>
<ul>
<li>四则运算不会溢出</li>
<li>乘方，排列组合数内置且不会溢出</li>
<li>支持 <code>x,y = y,x</code> 等简单操作</li>
<li>分号可用来分割，实现一行多句</li>
<li>函数返回值可以是元组，列表，甚至是函数</li>
<li>lambda 表达式</li>
<li>列表生成式 ， 三元操作符： <code>[x//2 if x%2 == 0 else x for x in range(10)]</code></li>
<li><code>in,  enumerate</code> 在<code>for</code>循环中使用</li>
<li>列表，元组反向标号从<code>-1</code> 开始数，不用担心越界<ul>
<li>字符串的 <code>split</code> 和 <code>join</code> 方法，<code>eval</code> 计算器。</li>
</ul>
</li>
<li><code>map</code> 将一批数据同时用一个函数处理</li>
<li><code>zip</code> 把列表或元组打包</li>
<li><code>argv</code> 直接可用，不用再管 <code>argc</code></li>
<li>函数可变参数 <code>*args</code>（保存元组）, <code>**kwargs</code>（保存字典）</li>
<li><code>yield</code>  和 <code>yield from</code> 做生成器</li>
<li><code>reduce</code> 函数计算列表内全部乘积等（需要 <code>from functools import reduce</code>）。</li>
<li><a href="https://raycoder.me/p/Python-exec/" target="_blank" rel="noopener">exec 函数</a> 执行 Python 文件中的代码。</li>
<li>用 list 当函数参数实现传引用（指针）的功能</li>
<li>装饰器</li>
<li>带<code>*</code> 赋值： <code>a,*b,c = [1,3,4,5,6,3,6]</code></li>
<li><code>raise ValueError(&#39;error type...&#39;)</code> 处理异常，哈哈</li>
<li>Python 交互界面中：<code>_</code> 返回的是最近一次的值</li>
<li>任意类有 <code>__init__</code> 和 <code>__repr__</code> 方法（不解释了，顾名思义）</li>
<li><a href="https://blog.csdn.net/goodlixueyong/article/details/52589979" target="_blank" rel="noopener">运算符重载</a>，<a href="https://www.yiibai.com/Python/operator-overloading.html#" target="_blank" rel="noopener">运算符重载 2</a> </li>
</ul>
<blockquote>
<p>非语法糖： 生成器表达式中, in 子句在声明时执行, 而条件子句则是在运行时执行</p>
</blockquote>
<h2 id="装饰器示例"><a href="#装饰器示例" class="headerlink" title="装饰器示例"></a>装饰器示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*arg, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'start %s'</span> %func)</span><br><span class="line">        <span class="keyword">return</span> func(*arg, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcA</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funB</span><span class="params">(arg)</span>:</span>   <span class="comment">#注意这里没有@</span></span><br><span class="line">    print(<span class="string">'不带@的装饰器: '</span>,end=<span class="string">''</span>)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">x = funcA <span class="comment"># 函数也是对象0.0 骚操作</span></span><br><span class="line">x(<span class="string">'xxxxx'</span>)</span><br><span class="line">log(funB(<span class="number">12</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看 <code>log(funB(12))</code> 就知道了！因为 log 是 return 的是函数 wrapper ，然后 12 就作为 arg 传入了。 </p>
</blockquote>
<h3 id="类中装饰器：-自带-properity-staticmethod-classmethod"><a href="#类中装饰器：-自带-properity-staticmethod-classmethod" class="headerlink" title="类中装饰器： 自带 @properity @staticmethod @classmethod"></a>类中装饰器： 自带 <code>@properity @staticmethod @classmethod</code></h3><h2 id="To-be-Continue"><a href="#To-be-Continue" class="headerlink" title="To be Continue"></a>To be Continue</h2><blockquote>
<p>我始终相信极简的代码，优美的代码才是正确的编程姿势。</p>
</blockquote>
<h3 id="Python-的坑-动态语言火葬场岂是浪得虚名"><a href="#Python-的坑-动态语言火葬场岂是浪得虚名" class="headerlink" title="Python 的坑 :  动态语言火葬场岂是浪得虚名"></a><a href="https://Python-small-examples.readthedocs.io/en/latest/chapters/p08_keng.html" target="_blank" rel="noopener">Python 的坑</a> :  <strong>动态语言火葬场岂是浪得虚名</strong></h3><ul>
<li>列表快速复制是浅复制</li>
<li>注意传列表等同转指针</li>
<li><a href="https://www.cnblogs.com/xueli/p/4952063.html" target="_blank" rel="noopener">深复制和浅复制</a> 一定要细心</li>
<li>list 自带的 copy 是浅 copy</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Python 写 Windows 关机程序</title>
    <url>/shutdownWithPy/</url>
    <content><![CDATA[<p>用 Python 的 Tkinter GUI 做一让用户输入指定文字（比如叫我爸爸 0.0 哈哈哈），否则关机的程序(只合适 Windows 用户)</p>
<a id="more"></a>
<h2 id="Windows-关机命令-shutdown"><a href="#Windows-关机命令-shutdown" class="headerlink" title="Windows 关机命令 shutdown"></a>Windows 关机命令 shutdown</h2><p>在命令行窗口输入 help shutdown 可以看到详细的参数列表</p>
<h2 id="用-Tkinter-创建出输入框"><a href="#用-Tkinter-创建出输入框" class="headerlink" title="用 Tkinter 创建出输入框"></a>用 Tkinter 创建出输入框</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># baibai.py</span></span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> tkinter.simpledialog <span class="keyword">import</span> askstring</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.withdraw() <span class="comment"># 隐藏tkinter的主界面</span></span><br><span class="line">os.system(<span class="string">'shutdown -s -t 30'</span>) <span class="comment"># 30s内关机</span></span><br><span class="line">x, answer = <span class="string">''</span>,<span class="string">'白白是我爸爸'</span></span><br><span class="line">hint = <span class="string">'输入：'</span>+ answer + <span class="string">'，否则在30s内关机！'</span></span><br><span class="line"><span class="keyword">while</span> x != answer:</span><br><span class="line">    x = askstring(<span class="string">'askstring'</span>,hint)</span><br><span class="line"><span class="keyword">if</span>(x == answer):	os.system(<span class="string">'shutdown -a'</span>) <span class="comment"># 用户正确输入了就不关机了</span></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>
<h2 id="用-pyinstaller-打包"><a href="#用-pyinstaller-打包" class="headerlink" title="用 pyinstaller 打包"></a>用 pyinstaller 打包</h2><p><code>pyinstaller -F baibai.py -w</code></p>
<p>就可以在 <code>dist</code> 文件夹中找到对应的 exe 文件了。然后发给小伙伴让 Ta 们叫你爸爸 0.0</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>玩具：HC6800-ES 开发版</title>
    <url>/singleChip/</url>
    <content><![CDATA[<p>这里记录一些我的新玩具:<code>51单片机</code>的基础常识，作为初学者，下文必然是错误百出。</p>
<blockquote>
<p>很久没更新博客了,毕竟很久没写程序了。数学类的嵌套的定义又太多，很不好写。</p>
</blockquote>
<a id="more"></a>
<h2 id="新玩具"><a href="#新玩具" class="headerlink" title="新玩具"></a>新玩具</h2><p>这次淘宝买的新玩具是：HC6800-ES V2.0 开发版，内部单片机是 STC89C52。见下图</p>
<p><img src= "/img/loading.gif" data-lazy-src="HC6800.png" alt="HC6800"></p>
<p>作为小白看了一下视频，但是呢，感觉视频什么的太慢，还是看书看手册来的爽。安装好单片机版 C 语言的 IDE Keil4 以及烧录软件之后，装一下开发版驱动，就可以在不知道单片机原理的情况下轻松的控制单片机了。例如什么 LED 灯闪烁，跑马灯，等等很基础的程序。</p>
<p>下面是单片机的管脚图和说明：</p>
<p><img src= "/img/loading.gif" data-lazy-src="89C52.png" alt="89C52"></p>
<p><img src= "/img/loading.gif" data-lazy-src="STC89C52_1.png" alt="STC89C52_1"></p>
<p><img src= "/img/loading.gif" data-lazy-src="STC89C52_2.png" alt="STC89C52_2"></p>
<p>从图上看知道 P0,P1,P2,P3 是重要的 I/O 口，例如我们把 P2 接到 LED 灯，那么给低电平 0，就可以使灯亮。还有 P0，P1 不仅可以作为 I/O 口，还可以作为地址，计时器、计数器来用。还有 P3，等等。由于我用的是开发版，每个口接什么基本上已经固定了，用的时候查相应的官方资料就行了。它也提供了很多程序例子，因此还是很好掌握的，只是要记点东西才能灵活操作它。</p>
<h2 id="HC6800-ES-VS2-0-常见管脚接法"><a href="#HC6800-ES-VS2-0-常见管脚接法" class="headerlink" title="HC6800-ES-VS2.0 常见管脚接法"></a>HC6800-ES-VS2.0 常见管脚接法</h2><ol>
<li><p>P2 口 8 个位接了 8 个 LED 灯，至 0 灯亮。</p>
</li>
<li><p>P1.5 接了蜂鸣器。循环至 0 至 1 发声。</p>
</li>
<li><p>P3.0 ~ P3.3 接了独立键盘（不过开发版上竟然接反了 K1 和 K2），使用按键的时候要软件消除抖动，一般延迟 10ms 来完成。</p>
</li>
<li><p>通过 P1 的数据，来判断矩阵键盘按的键。（见下图)  <img src= "/img/loading.gif" data-lazy-src="keyboard.png" alt="keyboard"></p>
</li>
</ol>
<ol>
<li><p>数码管使用 P0, 通过 LSA=P2.2, LSB=P2.3, LSB=P2.4 的 0-1 指来控制显示的地方。</p>
</li>
<li><p>常用定时器和中断标程。</p>
</li>
</ol>
<h2 id="1602-液晶显示"><a href="#1602-液晶显示" class="headerlink" title="1602 液晶显示"></a>1602 液晶显示</h2><p>这个虽然很复杂，但是生产该显示屏的会提供<code>lcd.h</code>和<code>lcd.c</code>然后我们只要先初始化 LCD：<code>LcdInit()</code>再执行字节输出函数：<code>LcdWriteData(char c)</code>即可。</p>
<h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>程序功能: 按下 k1 键 LED 跑马灯，K2 蜂鸣器发生，K3 数码管显示 1-8。由于不会中断，所以跑马灯写的很挫。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> u8;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> led P2</span></span><br><span class="line">sbit k1=P3^<span class="number">1</span>;</span><br><span class="line">sbit k2=P3^<span class="number">0</span>;</span><br><span class="line">sbit k3=P3^<span class="number">2</span>;</span><br><span class="line">sbit LSA=P2^<span class="number">2</span>;</span><br><span class="line">sbit LSB=P2^<span class="number">3</span>;</span><br><span class="line">sbit LSC=P2^<span class="number">4</span>;</span><br><span class="line">sbit <span class="built_in">beep</span>=P1^<span class="number">5</span>;</span><br><span class="line">u8 beepS,i,ledState = <span class="number">0</span>,DigState = <span class="number">0</span>;</span><br><span class="line">u8 code smgduan[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">                    <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;; <span class="comment">//显示0~F的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 t)</span></span>&#123; 	<span class="comment">//  每次约10us</span></span><br><span class="line">    <span class="keyword">while</span>(t--);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ledStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ledState = <span class="number">1</span>;</span><br><span class="line">    led=<span class="number">0xfe</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i!=<span class="number">7</span>;++i)&#123;</span><br><span class="line">        led = _crol_(led,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">50000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ledStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ledState = <span class="number">0</span>;</span><br><span class="line">    led = <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigDisplay</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DigState = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(i)&#123;	 <span class="comment">//位选，选择点亮的数码管</span></span><br><span class="line">            <span class="keyword">case</span>(<span class="number">0</span>):</span><br><span class="line">                LSA=<span class="number">0</span>;LSB=<span class="number">0</span>;LSC=<span class="number">0</span>; <span class="keyword">break</span>;<span class="comment">//显示第0位</span></span><br><span class="line">            <span class="keyword">case</span>(<span class="number">1</span>):</span><br><span class="line">                LSA=<span class="number">1</span>;LSB=<span class="number">0</span>;LSC=<span class="number">0</span>; <span class="keyword">break</span>;<span class="comment">//显示第1位</span></span><br><span class="line">            <span class="keyword">case</span>(<span class="number">2</span>):</span><br><span class="line">                LSA=<span class="number">0</span>;LSB=<span class="number">1</span>;LSC=<span class="number">0</span>; <span class="keyword">break</span>;<span class="comment">//显示第2位</span></span><br><span class="line">            <span class="keyword">case</span>(<span class="number">3</span>):</span><br><span class="line">                LSA=<span class="number">1</span>;LSB=<span class="number">1</span>;LSC=<span class="number">0</span>; <span class="keyword">break</span>;<span class="comment">//显示第3位</span></span><br><span class="line">            <span class="keyword">case</span>(<span class="number">4</span>):</span><br><span class="line">                LSA=<span class="number">0</span>;LSB=<span class="number">0</span>;LSC=<span class="number">1</span>; <span class="keyword">break</span>;<span class="comment">//显示第4位</span></span><br><span class="line">            <span class="keyword">case</span>(<span class="number">5</span>):</span><br><span class="line">                LSA=<span class="number">1</span>;LSB=<span class="number">0</span>;LSC=<span class="number">1</span>; <span class="keyword">break</span>;<span class="comment">//显示第5位</span></span><br><span class="line">            <span class="keyword">case</span>(<span class="number">6</span>):</span><br><span class="line">                LSA=<span class="number">0</span>;LSB=<span class="number">1</span>;LSC=<span class="number">1</span>; <span class="keyword">break</span>;<span class="comment">//显示第6位</span></span><br><span class="line">            <span class="keyword">case</span>(<span class="number">7</span>):</span><br><span class="line">                LSA=<span class="number">1</span>;LSB=<span class="number">1</span>;LSC=<span class="number">1</span>; <span class="keyword">break</span>;<span class="comment">//显示第7位	</span></span><br><span class="line">        &#125;</span><br><span class="line">        P0=smgduan[i];	<span class="comment">//发送段码</span></span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">50000</span>); 	<span class="comment">//间隔一段时间扫描	</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DigStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DigState = <span class="number">0</span>;</span><br><span class="line">    P0 = <span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyPress</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k1==<span class="number">0</span>)&#123;		<span class="comment">// 检测k1是否按下</span></span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">1000</span>);<span class="comment">//消除抖动 一般大约10ms</span></span><br><span class="line">        <span class="keyword">if</span>(k1==<span class="number">0</span>)&#123;	<span class="comment">//再次判断按键是否按下</span></span><br><span class="line">            <span class="keyword">if</span>(ledState==<span class="number">0</span>)	ledStart();</span><br><span class="line">            <span class="keyword">else</span>	ledStop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!k1);	 <span class="comment">//检测按键是否松开</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k2==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(k2==<span class="number">0</span>)&#123;</span><br><span class="line">            beepS=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">while</span>(beepS&lt;<span class="number">200</span>)&#123;</span><br><span class="line">                <span class="built_in">beep</span>=~<span class="built_in">beep</span>;</span><br><span class="line">                <span class="built_in">delay</span>(beepS);</span><br><span class="line">                ++beepS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!k2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k3==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(k3==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(DigState == <span class="number">0</span>)	DigDisplay();</span><br><span class="line">            <span class="keyword">else</span>	DigStop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!k3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)	keyPress();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>整数集上的一种特殊拓扑</title>
    <url>/specialTopologyOnNaturalNumber/</url>
    <content><![CDATA[<p>在《Proofs from THE BOOK》里素数无限的六种证明的第五种讲到了一种用点集拓扑学知识证明的方法，其中引入了整数集上的一种奇特拓扑。</p>
<a id="more"></a>
<h2 id="特殊拓扑的定义"><a href="#特殊拓扑的定义" class="headerlink" title="特殊拓扑的定义"></a>特殊拓扑的定义</h2><p>对 $a,b \in \mathbb{Z},b&gt;0$，令</p>
<script type="math/tex; mode=display">
N_{a,b} = \lbrace a + nb \colon n \in \mathbb{Z} \rbrace</script><p>我们称集合 $O \subset \mathbb{Z}$ 是开集，若 $O = \emptyset$，或者 $\forall a \in O,\exists b&gt;0,st. N_{a,b} \subset O$,容易验证这样定义的开集族全体构成了 $\mathbb{Z}$ 上的拓扑。</p>
<h3 id="上述拓扑的性质"><a href="#上述拓扑的性质" class="headerlink" title="上述拓扑的性质"></a>上述拓扑的性质</h3><p>每个 $N_{a,b}$ 都是既开又闭的。这是由于</p>
<script type="math/tex; mode=display">
N_{a,b} = \mathbb{Z} \setminus \cup_{i=1}^{b-1} N_{a+i,b}</script><p>又由</p>
<script type="math/tex; mode=display">
\mathbb{Z} \setminus \lbrace -1,1 \rbrace = \cup_{p \in P} N_{0,p}</script><p>其中 $P$ 是素数集。</p>
<h3 id="上述拓扑的应用"><a href="#上述拓扑的应用" class="headerlink" title="上述拓扑的应用"></a>上述拓扑的应用</h3><p>若素数只有有限个，即 $P$ 是有限集，则 $\lbrace -1,1 \rbrace$ 是开集，矛盾。</p>
<p>上述方法脑洞大，形式简洁，不愧是 <a href="0.pdf">《Proofs from THE BOOK》</a></p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>树上线段树</title>
    <url>/treeSegmentTree/</url>
    <content><![CDATA[<p>学了这么久的线段树，竟然从没写过树上线段树。其实本质还是线段树。只是把一开始的树结构用 dfs 序变成线段的形式，然后再用线段树加速。</p>
<a id="more"></a>
<p>问题是给你一颗树，每个节点都有权重，问从起点 0 开始必须经过节点$x$的权重和的最大值。经过 dfs，$L[x], R[x]$ 是以 $x$ 为根的节点。那么每次更新 $x$ 的值相当于给区间 $L[x], R[x]$ 加一个值。而最终我们的问题，其实就是求区间 $L[x], R[x]$ 的最大值。最后写线段树时要延迟更新。</p>
<h2 id="例题-hdu"><a href="#例题-hdu" class="headerlink" title="例题 hdu"></a>例题 hdu</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; <span class="keyword">if</span>(a&lt;b) a=b;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m+1,r,rrt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line">LL mx[N*<span class="number">3</span>],flag[N*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], sc, ncnt, L[N], R[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ed;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    sc = ncnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)    head[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    e[sc].ed = v;</span><br><span class="line">    e[sc].next = head[u];</span><br><span class="line">    head[u] = sc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123; <span class="comment">// dfs order</span></span><br><span class="line">    L[x] = ++ncnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x]; i!=<span class="number">-1</span>; i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].ed != fa)   dfs(e[i].ed, x);</span><br><span class="line">    &#125;</span><br><span class="line">    R[x] = ncnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    mx[rt]=<span class="built_in">max</span>(mx[lrt],mx[rrt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag[rt])&#123;</span><br><span class="line">        flag[lrt]+=flag[rt];</span><br><span class="line">        flag[rrt]+=flag[rt];</span><br><span class="line">        mx[lrt]+=flag[rt];</span><br><span class="line">        mx[rrt]+=flag[rt];</span><br><span class="line">        flag[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    flag[rt] = mx[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r&lt;= R)&#123;</span><br><span class="line">        mx[rt] += p;</span><br><span class="line">        flag[rt] += p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushDown(rt);</span><br><span class="line">    <span class="keyword">int</span> m = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= m)  add(p, L, R, lson);</span><br><span class="line">    <span class="keyword">if</span>(R &gt; m)   add(p, L, R, rson);</span><br><span class="line">    pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;=l &amp;&amp; r &lt;= R) <span class="keyword">return</span> mx[rt];</span><br><span class="line">    pushDown(rt);</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    LL ans= <span class="number">-1L</span>L&lt;&lt;<span class="number">62</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= m)    upmax(ans, query(L, R, lson));</span><br><span class="line">    <span class="keyword">if</span>(R &gt; m)     upmax(ans, query(L, R, rson));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, Case = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++Case);</span><br><span class="line">        <span class="keyword">int</span> n, m, u, v, op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        init(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            addedge(u, v);</span><br><span class="line">            addedge(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">            add(a[i], L[i], R[i], <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;op, &amp;u);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line">                v -= a[u];</span><br><span class="line">                add(v, L[u], R[u], <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">                a[u] += v;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;query(L[u], R[u], <span class="number">1</span>, n, <span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaplansky 定理</title>
    <url>/kaplanskyTheorem/</url>
    <content><![CDATA[<p>(非交换)环中有一个有趣的（Kaplansky）定理说：</p>
<blockquote>
<p>如果环 $R$ 中元素 $a$ 有不止一个右逆，那么 $a$ 有无数多个右逆。</p>
</blockquote>
<p><strong>像极了出轨只有零次，或者无数次。</strong></p>
<a id="more"></a>
<blockquote>
<p>(Kaplansky) Suppose an element $a$ in a ring $R$ has more than one right inverse. Show that $a$ has infinitely many right inverses.</p>
</blockquote>
<h2 id="Kaplansky-若环-R-中元素-a-有不止一个右逆，那么它有无数个右逆"><a href="#Kaplansky-若环-R-中元素-a-有不止一个右逆，那么它有无数个右逆" class="headerlink" title="(Kaplansky) 若环 $R$ 中元素 $a$ 有不止一个右逆，那么它有无数个右逆"></a>(Kaplansky) 若环 $R$ 中元素 $a$ 有不止一个右逆，那么它有无数个右逆</h2><p>证明：（反证法）设 $a$ 的所有右逆构成的集合为 $A = \lbrace x \in R \mid ax=1 \rbrace$.</p>
<p>若 $A$ 有限，不妨设 $A = \lbrace x_1,x_2,\cdots,x_n \rbrace, (n&gt;1)$ , 则</p>
<script type="math/tex; mode=display">
a(1- x_i a + x_1) = a-(a x_i) a + a x_1 = 1</script><p>并且, 若 $1-x_ia+x_1=1-x_ja+x_1$, 即 $x_i a=x_ja,$ 那么 $x_i=x_i(ax_i)=(x_j a)x_j$, 也就是说   </p>
<script type="math/tex; mode=display">
A = \lbrace x_1,x_2,\cdots,x_n \rbrace =  \lbrace 1- x_1 a + x_1,1- x_2 a + x_1,\cdots,1- x_n a + x_1 \rbrace</script><p>所以存在 $k$ 使得 $1- x_k a + x_1 = x_1$，即 $x_ka=1$ 所以对任意 $1 \leq i \leq n$,</p>
<script type="math/tex; mode=display">
x_i = (x_k a)x_i = x_k(a x_i) = x_k</script><p>即所有 $x_i$ 都相同，矛盾与 $A$ 中元素个数大于 1，证毕。</p>
<h2 id="等价叙述：-如果环-R-中元素-a-有右逆而没有左逆，那么-a-有无穷多个右逆"><a href="#等价叙述：-如果环-R-中元素-a-有右逆而没有左逆，那么-a-有无穷多个右逆" class="headerlink" title="等价叙述： 如果环$R$中元素$a$有右逆而没有左逆，那么$a$有无穷多个右逆"></a>等价叙述： 如果环$R$中元素$a$有右逆而没有左逆，那么$a$有无穷多个右逆</h2><blockquote>
<p>通俗的讲就是，如果你喜欢一个不喜欢你的人，那你不仅仅只喜欢这个人。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>异或运算及其在 Nim 游戏中的应用</title>
    <url>/xorAndItsApplicationInNimGame/</url>
    <content><![CDATA[<p>异或运算是一种很神奇用途很广的运算. 从性质上, 异或运算作为二元运算, 关于所有非负整数构成一个 Abel 群, 0 作为幺元, 每个元的逆元都是自身(等价于说 $char(N ^ \star,xor)=2$)。</p>
<a id="more"></a>
<h2 id="异或的定义和简单性质"><a href="#异或的定义和简单性质" class="headerlink" title="异或的定义和简单性质"></a>异或的定义和简单性质</h2><p>异或, 英文: exclusive OR, 缩写 xor, 习惯记作 $\wedge$。这个运算 $1\wedge 1=0\wedge 0=0,1\wedge 0=0\wedge 1=1$。 对任意是两个非负整数 $a,b$ 将其写成二进制, 然后各位分别进行异或操作即可. 容易根据上面定义说明之前提到的性质. 下面再介绍一个重要但不是很明显的性质:</p>
<p><strong>引理</strong>: 若 $k=a_1\wedge ⋯\wedge a_n≠0$ 则必然存在 $i$, 使得 $a_i \wedge k&lt;a_i$。<br>证明: 因为 $k \neq 0$, 所以必然记 $k$ 得最高位是第 $t$ 位, 则必然存在 $i$, 使得 $a_i$ 的第 $t$ 为不为 0(否则 $k$ 的第 $t$ 位的 1 咋来的). 那么此时 $a_i \wedge k$ 的第 $t$ 为 0, 前面的位不变, 从而小于 $a_i$。</p>
<h2 id="异或的简单应用"><a href="#异或的简单应用" class="headerlink" title="异或的简单应用"></a>异或的简单应用</h2><p>简单的直接贴代码吧, 不废话.</p>
<h3 id="用异或来改变两个数"><a href="#用异或来改变两个数" class="headerlink" title="用异或来改变两个数"></a>用异或来改变两个数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">swap(UI &amp; a, UI &amp; b)&#123;</span><br><span class="line">    a = a^b;</span><br><span class="line">    b = a^b;</span><br><span class="line">    a = a^b</span><br><span class="line">&#125; <span class="comment">// UI 表示 unsigned int, 写的很骚气.</span></span><br></pre></td></tr></table></figure>
<h3 id="异或找出唯一出现奇数次的数"><a href="#异或找出唯一出现奇数次的数" class="headerlink" title="异或找出唯一出现奇数次的数"></a>异或找出唯一出现奇数次的数</h3><p>把这一堆数全体直接异或即可.</p>
<blockquote>
<p>这个方法可以推广到找出两个只出现奇数次的, 其它出现偶数次的两个数, 方法就是先异或之后的值按照最高位进行标记然后分成两组, 再来一遍.</p>
</blockquote>
<h2 id="Nim-取石子问题"><a href="#Nim-取石子问题" class="headerlink" title="Nim 取石子问题"></a>Nim 取石子问题</h2><p>在 2002 年国家 IO 集训队中张一飞写了<a href="nimGame.pdf">&lt;&lt;由感性认识到理性认识——透析一类搏弈游戏的解答过程&gt;&gt;</a>中明确的表面了这个取 Nim 石子游戏用异或可以完美的解决.</p>
<blockquote>
<p>我把他结果简单表达如下, 并在做一点小小的改变之后得到类似的结果</p>
</blockquote>
<p>游戏规则 1 : 甲乙两人面对若干堆石子，其中每一堆石子的数目任意给定, 两人轮流取走一些石子, 每次至少取一枚石子, 每次只能从某一堆中取, 可以取完, 谁无法取子, 谁就是输家(规则 2 正好相反).</p>
<blockquote>
<p>在规则 1 中张一飞一步一步由浅入深, 从具体例子过度到理性的判断, 最终给出若所有石子数异或结果为 0, 则后手胜, 反之先手胜.</p>
</blockquote>
<p>首先对于此类取石子博弈问题: <strong>必败准则</strong></p>
<blockquote>
<p>必胜局面必然存在一步转化成为一个必负局面;<br>必负局面必然任意一步转化都会成为必胜局面.</p>
</blockquote>
<p>而对于异或也有类似的结果: $k=a_1\wedge  \cdots \wedge a_n$</p>
<blockquote>
<p>若 $k \neq 0$ 由引理知道, 可以减小某个 $a_i$ 使得之后的异或和为 0.<br>若 $k=0$, 则任意改变都会导致异或和不为 0.</p>
</blockquote>
<p>这样操作下去堆数一定在一直减小.<br>对于规则 1: 由于空局面是负局面容易看出, 若异或和为 0 则先手负, 反之先手胜.<br>而对于规则 2, 由于空局面是胜局面,而 1 局面是负局面, 这就有些尴尬了. 并且局面并不能像规则 1 一样进行局面分解, 因此十分麻烦.</p>
<h3 id="规则-2-的感性判断"><a href="#规则-2-的感性判断" class="headerlink" title="规则 2 的感性判断"></a>规则 2 的感性判断</h3><ol>
<li>去掉任意多的 0 和偶数个 1 并不会影响结果(是对的, 但是要分情况推敲一下)</li>
<li>无法根据子局面的胜负来判断总局面的胜负.</li>
<li>负局面的价值远远高于胜局面, $(1),(n,n&gt;1),(1,2n,2n+1)$, 奇数个 1, 偶数个 2 是负局面(用数学归纳法容易证明)</li>
<li>从小的开始枚举, 为被负局面包含的极小局面是胜局面, 被所有胜局面包围的是负局面, 这样可以一直进行下去直到得到我们的结果.</li>
<li>前戏终于结束了, 要来真的了 0.0(好害怕)</li>
</ol>
<h3 id="规则-2-的理性判断"><a href="#规则-2-的理性判断" class="headerlink" title="规则 2 的理性判断"></a>规则 2 的理性判断</h3><p>经过总时长 8 个小时左右的零碎时间思考, 最终给出下面结果:</p>
<ol>
<li>首先我们先剔除所有 0 和偶数个 1 得到新的局面至多有一个 1. 如果为空, 则为胜局面.</li>
<li>对于堆数 $n=1$ 的情形,  $a1=1$ 为负局面, 其它为胜局面.<br>对于堆数 $n&gt;1$ 是若 $a_1\wedge ⋯\wedge a_n=0$ 为负局面, 其它为胜局面.<br><strong>证明</strong>: 首先证明结论对 $n=2$ 是成立, 即 $a_1=a_2$(不可能同时为 1)时是负局面, 因为 $a_1=a_2=2$是负局面, 若 $a_1=a_2&lt;k$ 是负局面, $a_1=a_2 = k$, 则下一步必然是 $(a1,a2)=(m&lt;k,k)$ 为胜局面(若 $m=0,1$ 时显然, 否则下一步 $(a_1=a2)=(m,m)$ 为负局面). 因此结论对 $n=2$ 成立. 现在若结论对于 $n&lt;k$ 成立, 那么由引理若 $a_1\wedge ⋯\wedge a_n=0$ 则下一步必然导致 $a′_1 \wedge ⋯ \wedge a′_n \neq 0$. 若其中某个 $a′_i=0$, 那么由归纳法必然导致结论成立. 那么后手就可以取走一些石子导致 $a′′_1 \wedge ⋯\wedge a′′_n=0$. 另外一出现多于 2 个 1 直接剔除(不会改变异或和的值). 这样下去堆数必然减少, 由归纳法可知结论成立.</li>
</ol>
<p>例如<code>1∧3∧5∧7=01∧3∧5∧7=0</code> 从而可以判断这是一个负局面.(可以简单试试这个策略玩一玩这个游戏)</p>
<blockquote>
<p>感谢张一飞的论文, 感谢 FDU 高数杭老师提供题目, 感谢蔡学弟把问题分享给我。感谢网友批评指正。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 年厦门马拉松</title>
    <url>/xiamenMarathon2016/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">日常表白 zly</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="ed129bf858d5e1657069cf592a7eababd7136305adabde97956142894a3144f9">a4417ccd9839412bfc6235b630b90e51e61d31baac8e539a84c553ae86cbb1014c7f7cd9443aff65abe0deebb457ef7a72353ba3afe7d0f0371e485008f5ca52125e77246bd9d0db08d5f9d4689483841e1d4df1ffd65fbb638504aa0806490c3e47cd36b9bfedd2da3874366f46b452bdc06d0319d3ae5497d5d74e4f9cbdae197e07b54bb48f181bfc6996143f136069c8552b645873a4329e3d65a9d0ef26a3f2500728a9156b9f3cb1ae382cfc2cc2a3598ef54c9fc070f5332ab28d5d1cdff8c6776e9265be2cbdc04923f61ae028242952adadb685d003a63533ebdb9e251e46686e1a640c278f6d5f168f6869ed6e793c189d8678c4717a0d1c958d64ab772982496d72d3125877cdb9e3a6d68c2a9292fb6bb2f9fa1428c0951eb4332994d9d8c08f32189fc501734f4d862ffd8ddeb77a516279d2298b31237ca93c93014884baa729018515760cdcfe262d82753d18558ada126f56849d0cc6565a8b8f97f8e33b3153d411e35a2d977752abf2f04c5a1a4085c9ecc00928a8b4582123fdb35ba1c3d325041ad6fbaa30bf33d37cc99754bcd0d8b80a8d8d58b9552e404d50944ff3ab8fe6c8079cc34d9d9af3dfa61b04c935d496080add1971dc8abe652588b7fc8b8c8343f8af7103df2865be28cb5ce40ffd2fcd613e101b0fc64e43b09d79434340d97aedfd56a547052a60312581d5af4c8b1f215f37c5bf0a63edc974353638234e230180ea9d27f5c8c033100c8eee83adba05f24dc9f8349e725656725834685767afcbc5a5c279c24c2e41f07d58ed550ba9666b4f96044cddf2ee59bc5196b91a9e0bfbd3e4ec12ad10e3572a4f2fda35670961ac3a5f777fd8cd3059fa94d2eb8cfd78a3e7263862bf2190eaa927e64e526afe0c1c5c12884c95d5fcf4b91e1d81e2f6a0dc6129db7bd6fc60fa9d5b883c0a58d9280a30367f8d8018d77be616c2542c67b7389a64973d3f713b2fa87d3cfb2e285f9145796c5f14b6449e9464913461b680da525a1247aa40a6ecfb0e222f2d30834ce5c7a63b40bdca83efb6dd9d8c561a4cd05dab443aafc2299d6718162ac637ac8354631da2ced5f2202153f21e96f7f75e15de40ee4d99a07195d1071db0bb6c887fcb152aec16546ce9dd6d1a3fc0a0473be86a114c9231b725532c418b73d9820c62b1e8882c6d49cc3662a39dabbcca1df61c12ac87269546d6c5cb8f38791c55454377bc37e1012eb749a2799271c4de44e001694516156b27bbca685b041ac6544bde34f3ae74ba9d50c7e907662769d7cf5c799a83e48b5d1536234bb5332e8c29387c449af81e88eb450a3049434ba3df50f9f4f7216525968732452ace0e923c8aa074b5702a123426d858cc8154103bbdd92b4883ca2e12663d56002be5be50f529edb5e2f74eaa45b46dd5df30ba35ebc01012bf3093543d80284e98a80a51cc8520167ce485d478dd3c8e09c723b13ff54383f6a5421ea97b55dfa5e176677694669316f107cbef2cb4f6ebb6d4f44c286f006ce13207e85729ea543fa7ecf85802e35c4307dcaed3cfb8fea24f5e4eeb6ba841f2707ca46210ad032e79f7dc882e2c7fc6ee9fb70e6c7f5328d4b54808651e96ab23aeaa26b7bd08b0f9f42752ea3a4324bb4904c803edf3023efed9f69895c0e67900c6666733210d0ff22f2edbd8ec885f128e26deb59b02d39e48effbe2128189aea77f4c44d06948a7f5775c0a652f1f1a4e5c4b5df78d2e5074dc9f0298cab06854e30ddfbda842487952ae737dbc9db7bec72d04596e91abfaa6af16403cbdcac3b5a6e3739f4ea9769489691ec55ed08f6637c80ea57655cc2cac0d229e6624a2d5846948188e514c8e6291c952de279de4aaa561fd3b66623742a66fd842ebb01bb319e9ea8a8a090b899a835f33df11cff36e1d325131cea14af056f677da89e22ed3732d7fdf9b324f79fc5610a0c3fad3a635a37d1ec4277da2f3ff9a05ee4562836aaaa7faee52d132eb919fbc9f8ce68cbfb2b8fcf78a65f2900668ddbacde127f16afe4869252a1a617ecfb9795b6b2331eae18a97152f0fab235dcf10d6a2687a7c31847b49eda081b368290329bafb9a219fa788b65c8b825ca40647a2e4f5351e083127f578bc4e815d1684adecae6b97b8ed74bd37ff80903f5423a49d4a67f43d8ab98bfa4a9e7f3d408ea858b2fc453cf11dd0d52ffc9d65a64c264547245cbf26e988573b30599571cd0d6a09c09baf91fa64cea4cbbf72c6502680935fd164f15c72ed27653335afdd45f470fec3e9ecda63ef54077d83cfa76b2e4b32bc8e642ced2edb77dfe2dfbc55440376b37ad6f99af21dc79641ce0029e5fc179700a24828ab87ab0ef0a075da9a24a6c94f6e32d18d8efbf7687f5076b1aa97ff65e838ca8fa464cb4b6a0edb0c76a7a0dfc154358749485091bae542fd2589f81e384f7e04097f741b3f5e1950002531a8849f5508fe403db1b99c6d218bfed5a0cbea661d15ef1cc970c6ead786e374758311b2955d4fed7a7b057953494f9b1f1cbb0d0cfc1151d15a5d2a3e8079634d8a517aedd88ee5d761bf18e6bf65b24bfc36fe8559c2346b102431cc38f44e8f86c00ed3c8dc1f7a39b61864b87e94da89ee4ab7c08c46bbd7bd12b7b51ff13fa0ae1df8cab3dceb823107a2673a95b238793d548e0fa3f9134ed8032e2202981ea541a67dcc1baa9d386f98b2500e83f35feb74a5897ab04a8fb1210fe269bc7b7e2b44d50af37bb78715903d5e4600763f18d8070c0c2254705d6b91af955012139b7fd5f3f61d1b9839509070143c1866afc082457e9d45979347abd854eee105d4543d775b5bf913280ccc77604913f6c7e384d00cca804cbf7b5b31114d129fbe13431bc549f981c605cbfe638e6a129975fcbcff5ede60c3f53e6cefa5afd8878bb5360120e015cd99df039bd9903e90d90cf773dfd85a7b8f66fc96ab14dcef40a740fc80a47eb715eef331869aaec80e3e377266bd49ca10e25f641f683b877b53ab159f634432a24aebdcfe1316ce207929aaff83a589b453925fc8f1d48d3900d3f6ae8abdc492c9f7fb058a245f0636971b7bb7124759d2afcad48dc0596f79cc1a3bb9eb7a7344b9eab29a5b59cb9d7db14504396db1e65863b895949865e03a362c738d24c72cc76c46adf889907fef0a169d0fb8e1fa046f109b97e24810cffc8e7a65e87795ca137135777ba8131abd089a6b66358576fe6862d3b5a866f516ad36695cc2fb7fca129131db6d7406f1d76a2ba90bea14ad4f1425a55b756460df1e0b328bd9814f7c65380edfce53128e70562693ac060e37d59e4d0fb106e3245fefa076c4f822acbf4b1e60939b4727de5af6cb243c55942628780a425616a2c84aea948996e2de8fdf0fdbd1c7c4453a1a5f997ba92d33b4429e35e03fa562da1bf935f68cb1ee542935b2446202bcbb3efcd2d0c125ccfc5dcca5d26f958c3ef0d075698e8a531c29f812d009fe9094a2ee8c91a6f38fdd2e3012579a2429e97b22f13d3be4947462133065eaef31ab3b4e2fa60795121bf9a4fcf1388fbafd47ead0c655cdddb3ffebcd7dd4ad03cd0fea25bf455c2561bdea83ae23fa48e51cbe08999b8738411ddeb192cfb125d517605f864a56caa99d46612cbe69a9c5f9872d96eae1586b7fc7d41a56212dc063a93c60a6f264bff99c714562505625508591675cebc9713d1c22e8498ec3dde55968ff8937ebfadf72eeccdb84afe282c1301ce3d8b1923ad52b8886c38d9580571efc99d03506a120311f9177bfc9f0c5837dee1bbb44b184d0ff534984dfb907b1d798aebb6dcba97b64e4a69a2c0544fe44899afec198ae8ad58df739952f76f40102ad468394112863914b8304ee2c967f98d60b1b7392e3e4fb767b2317a0809028ca8d31665d09aefe66de1ec32a58f7afadc301c20c8e31715162313a3b4e3569e14bfa076c996735a20171fb045a835c0e7f6c5733bc05169ce74b5d67b6e9d4acf2a7978d17b91136e2720724e5fbd047006d68297a59919b9dbd291ff089e34dbde924542d4efa5e8c0f88d9956d9622084adbfbd88e54940fe1c44ead8a127b2952d1f01e465dd256ede6d15a22c63225b8007f156284aead33869ea39ee87b9ace594116c7bb3351df0c9a18d0f563317357f958e46b2005fd8bcf84c43af10f85970131c4bf28decae809fbd394bd961eb149aa5d6ea5d97bccf789ddf50ed2014ed507834f13ce44a0af032b516b3185950c4d83bafee18f2fdcca5bf43e4917cbfbcf0cb77256bc1606494977f6333ce36ea70f89dfb2020038326e3cd15a435655822082afdfc2ea67888c0214342cefce01290fc2b552940a93c99e5ea2e3ca209277f93328b4cb08767a0943b9effa77e4054d2fb5790917cfe460ae5bd1201508dda15b45ae7b53786c7f4308d872654552406b23273af72951120dc6a760671c5df8e060bd8167616c0111bb977618e65863a2bb29e03ea8848b3f800daca9ad29403c71934f295c63c18ba14d540d638bf380739822017b16b8f3e9f10d4d49b4ed9a9aeb4135770792ee1642e6d1011597904ecaad879957c3f14bfc156dc9bcb2f16c7d77de28e5629b94eb75835998968ea5decb32fa5be5ba08d3545351c7fb1d1772975c5ca858403461e905f8494d2d4c069b500c482a3c5b23c1b079e75d499252f831ccc0e88f2a1c6e78e7ac5ed9605babd8f928cfd01023e3eb4ddb0fbe4d6893188f784a5a44091114361d9112546200c69958acdc5066bfb5b9c8b9f8f3d12632d8185b9edf51820f04d5e35cbdb94e671c2de1830a31b85f9c82e259fdbba682033cd2b32ca07e7edbec372b3ac9e0e0b5d4f51c04eec720d5d016d386f0f14ecda67430fcbcfea6381462d2bca9406562de2602ae49c6f8f26bed5f68f231f6ef1abdbe42547e3028b9dfa8a82205c8e3b693eb1d14e9bf94b63419c0b50e0019392965e71feb8805aeb779af6a58115d7d1f1d6e16ca80b979131e5423658d242cbf0c138f33b039d428959a39a6a26a178252cb72e3e7fd57561969d82b5976e8fbf0e373b8fe1f60cde1cb1d7e281de32d312f2cbbc0474a61efda0f3ccb1f64f0fb4692f72da2a4d6b43d3b88b5063e168b6050df007ab1ed3b8fa5cefd50f4963978ba2ac585fb209b06b81734cdb71d7628fa17a5a1e966fb101b5f05019034506fdb5d99210bd4f5148bdc46611618169f880d65d5df628afed53a71b3b13fd86d4891dd54987ef8a99c48f5df79043a70b8734f2014fa1ba21af375e569d0a7b9be98fe91572ffb0c264cf7a66c80ad10f810bfbbd8e0efc49ec9889e8bf1193b5b94ac4dc92108ad30123743a35b03ca38992d0a812c8eaee0d967c8dd9e918405b022d6a554f39664cf68bd</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>最强装逼题目 0.0</title>
    <url>/zhuangbility/</url>
    <content><![CDATA[<p>数学老师想好了两个自然数 $m,n$ 满足 $2 \leq m \leq n \leq 100$ ,他把 $m,n$ 的和 $s$ 告诉了 $S$ 同学，把 $m,n$ 的积 $p$ 告诉了 $P$ 同学，他们都是聪明诚实的学生。进行了下面对话<br>$S$: 我不知道 $m,n$ 的值，但我知道你也不知道。<br>$P$: 现在我知道了。<br>$S$: 现在我也知道了。<br>请问 $m,n$ 的值。</p>
<a id="more"></a>
<ol>
<li><p>由第一句话，我们知道 $s \geq 6$,且 $p$ 中无大于或者等于 53 的质因数。但是 $S$ 是如何知道的呢，可见 $s \leq 54$。对 数 $6 \to 54$ 逐一检查发现，除了$A = \lbrace 11,17,23,27,29,35,37,41,47,51,53 \rbrace$的其他元素外，其余每个数都可以表示成两个素数的和，因此从第一句话知道，$ s \in A$。</p>
</li>
<li><p>刚刚推理 $P$ 同学当然也能完成。由于 $A$ 中的元素全是奇数，因此，若 $p = 2^k \cdot (2v+1), k \geq 0, v \geq 0$ 或者 $p = 2^k \cdot (2v+1)(2j+1), k \geq 0, v \geq 0, j \geq 0$ 则 $P$ 同学就能确定的知道答案。</p>
</li>
<li><p>$S$ 同学最后也知道了 $m,n$ 的值，说明在 $s$ 所有分解 $s = m+ n, 2 \leq m \leq n \leq 100$ 中，且有一种满足 $xy = 2^k v$。<br> 检查 $11 = 4+7 = 3+8$, $23 = 4 + 19 = 7+16$, $27 = 4+23 = 8+19$, $35=4+31=16+19$, $37 = 8+29 = 5+32$, $47= 4 + 43 = 16+31$, $51 = 4+47 = 8+43$。<br> 又因为 </p>
<script type="math/tex; mode=display">
29 = 4 + 25 = 13 +16,\; 41 = 4+37 = 16 + 25,\; 53 = 16 +37 = 21 + 32</script><p>其中 $4 \times 25 = 100 = 20 \times 5$, $20+5 =25 \notin A$, $16 \times 25 = 400 = 80 \times 5$, $80+5 =85 \notin A$, $21 \times 32 = 672 = 7 \times 96$ ,$ 7+96 =103 \notin A$。<br>因此，只可能 $s=17$</p>
<script type="math/tex; mode=display">
17 = 2+15 = 3+14 = 4+13 = 5+12 = 6+11 = 7 +10 = 8+9</script><p>其中只有 $17 =4 + 13$ 满足 $P$ 的断言，因此 $m = 4,n=13$。</p>
</li>
</ol>
<blockquote>
<p>此题是我高三（2011 年）在《奥赛金牌之路》中所见，实在很吊，一直铭记于心,特此记录。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex 编辑的一些文档</title>
    <url>/workWithLatex/</url>
    <content><![CDATA[<blockquote>
<p>很久之前写的，舍不得删，保持原貌吧</p>
</blockquote>
<p>This blog makes a record of my math work and will be update frequently.Click to view or download it.</p>
<a id="more"></a>
<h4 id="Here-are-PDF-version-of-my-math-work"><a href="#Here-are-PDF-version-of-my-math-work" class="headerlink" title="Here are PDF version of my math work"></a>Here are PDF version of my math work</h4><p><a href="1.pdf">Config of ACM-ICPC</a></p>
<p><a href="2.pdf">Some results about matrix</a></p>
<p><a href="3.pdf">Decomposition of 1 by 1/n</a></p>
<p><a href="4.pdf">Nowhere dense set and frist category set</a></p>
<p><a href="5.pdf">Relationship between Spectral Radius ,Numerical Radius and Spectral norm</a></p>
<p><a href="6.pdf">Some results about group</a></p>
<p><a href="7.pdf">The inverse of I-ba and I-ab</a></p>
<p><a href="8.pdf">example of function that only derivable on one point</a></p>
<p><a href="0.pdf">undergraduate graduation paper</a></p>
<h4 id="Here-are-Tex-version-of-my-math-work"><a href="#Here-are-Tex-version-of-my-math-work" class="headerlink" title="Here are Tex version of my math work"></a>Here are Tex version of my math work</h4><p><a href="1.tex">Config of ACM-ICPC.tex</a></p>
<p><a href="2.tex">Some results about matrix.tex</a></p>
<p><a href="3.tex">Decomposition of 1 by 1/n.tex</a></p>
<p><a href="4.tex">Nowhere dense set and frist category set.tex</a></p>
<p><a href="5.tex">Relationship between Spectral Radius ,Numerical Radius and Spectral norm.tex</a></p>
<p><a href="6.tex">Some results about group.tex</a></p>
<p><a href="7.tex">The inverse of I-ba and I-ab.tex</a></p>
<p><a href="8.tex">example of function that only derivable on one point.tex</a></p>
<h3 id="LaTex-is-a-wonderful-tool-for-Mathematics"><a href="#LaTex-is-a-wonderful-tool-for-Mathematics" class="headerlink" title="LaTex is a wonderful tool for Mathematics"></a>LaTex is a wonderful tool for Mathematics</h3>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>环的 Zariski 拓扑(素谱)</title>
    <url>/zariskiTopologyOfRing/</url>
    <content><![CDATA[<p>设 $A$ 是(交换)环。令 $X$ 为 $A$ 的素理想全体，定义 $V(E)$ 为 $A$ 中包含 $E$ 的素理想全体，则将所有 $V(E)$ 看做闭集，它满足拓扑空间三条公理，即构成了拓扑，该拓扑称作 Zariski 拓扑，这个拓扑空间叫做环$A$的素谱，记作 $Spec(A)$。<br>有了拓扑，我们自然要考虑 1.集合的内部、闭包。2.拓扑的基，拓扑的分离性，紧性，3.空间的连通性，不可约性，4.拓扑空间的连续函数等等概念在这个具体拓扑下的样子。</p>
<a id="more"></a>
<h2 id="Zariski-拓扑"><a href="#Zariski-拓扑" class="headerlink" title="Zariski 拓扑"></a>Zariski 拓扑</h2><p>要证明 $T = \lbrace V(E),E \subset A \rbrace$ 作为闭集确实构成了一个拓扑，即证明 $\emptyset \in T,X \in T$，且 $T$ 中任意并，有限交运算是封闭的。而显然我们有</p>
<ol>
<li>$V(0)=X,V(A)=\emptyset$</li>
<li>$\cap_{i \in I} V(E_i) = V(\cup_{i \in I}E_i)$</li>
<li>为说明 $V(E_1) \cap V(E_2) \in T$ 我们需要一些准备工作。</li>
</ol>
<p>设 $I(E)$ 为由 $E$ 生成的理想，定义</p>
<script type="math/tex; mode=display">
\sqrt{\alpha} = \lbrace x\in A : x^n \in \alpha \rbrace</script><p>则显然我们有</p>
<ol>
<li>$\alpha \subset \sqrt{\alpha} = \sqrt{\sqrt{\alpha}}$</li>
<li>$\sqrt{\alpha \beta} = \sqrt{\alpha \cap \beta} = \sqrt{\alpha} \cap \sqrt{\beta}$</li>
<li>$\sqrt{\alpha}=(1) \Leftrightarrow \sqrt{\alpha}$</li>
<li>$\sqrt{\alpha+\beta} = \sqrt{ \sqrt{\alpha}+\sqrt{\beta} }$</li>
<li>若 $p$ 是素理想，$\sqrt{p} = p$。</li>
<li>$V(E)=V(I(E))=V(\sqrt{I(E)})$</li>
<li>$V(\alpha \cap \beta)=V(\alpha \beta)=V(\alpha) \cup V(\beta)$</li>
<li>$\cap_{p \in V(\alpha)} p = \sqrt{\alpha}$ </li>
<li>$V(E_1) = V(E_2) \Leftrightarrow \sqrt{I(E_1)} = \sqrt{I(E_2)}$</li>
</ol>
<p>因此，$V(E_1) \cap V(E_2) = V(I(E_1)) \cap V(I(E_2)) = V(I(E_1) \cap I(E_2)) \in T$。这说明它确实满足拓扑空间的三条公理。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>有了拓扑之后，我们自然用具体的例子来看一下，这个拓扑大致长什么样子。<br>考虑 $Spec(\mathbb{Z})$ ，此时 $X = \lbrace (p) : p\text{ is prime } \rbrace \cup (0)$。可以看出，包含 $(0)$ 闭集仅有 $X$，除 $(0)$ 外，$X$ 中的单点集全是闭集。因此 $Spec(\mathbb{Z})$ 不是 $T_1$ 空间，由此可见，一般地，$Spec(A)$ 不是 $T_1$ 空间，即此拓扑的分离性很差。</p>
<h2 id="内部和闭包"><a href="#内部和闭包" class="headerlink" title="内部和闭包"></a>内部和闭包</h2><p>因为在一般的拓扑理论中我们有 $A^{o} = \overline{A^c} ^c$，因此，我们只需搞清楚 $A^{o}$ 和 $\overline{A}$中任意一个即可，我们考虑闭包($\overline{A}$)。对于 $Y \subset X$。若 $Y \subset V(E)$ 则 $\forall \; p \in Y, E \in p$,即 $ E \in \cap_{p \in Y} p$。因此 $Y \subset V(\cap_{p \in Y}) \subset V(E)$。因此 $\overline{Y} = V(\cap_{p \in Y})$。<br>特别地，</p>
<ol>
<li>$\overline{\lbrace p_x \rbrace} = V(p_x)$</li>
<li>$\overline{\lbrace p_x \rbrace} = \lbrace p_x \rbrace \Leftrightarrow p_x$ 是极大理想。</li>
<li>$p_y \in \overline{\lbrace p_x \rbrace} \Leftrightarrow p_x \subset p_y$</li>
<li>$X$ 是 $T_0$ 空间（$p_y \notin \overline{\lbrace p_x \rbrace}$ 或者 $p_x \notin \overline{\lbrace p_y \rbrace}$）。</li>
</ol>
<p>因此，这样就很清楚为何在之前的例子$Spec(\mathbb{Z})$中除$(0)$外单点集都是闭集了。有了之前的结论我们再看一下其他的例子。<br>$Spec(\mathbb{R})$：此时 $X = \lbrace 0 \rbrace$ 只有一个元素拓扑是平凡的。<br>因为 若 $A$ 为域,则 $A[x]$ 为 ED 为 PID，其素理想为 $(f)$ 不可约多项式。且 PID 中非零素理想就是极大理想。<br>$Spec(\mathbb{C}[x])$: 此时 $X = \lbrace (x+t): t \in \mathbb{C} \rbrace \cup \lbrace (0) \rbrace$<br>$Spec(\mathbb{R}[x])$: 此时 $X = \lbrace (x+t): t \in \mathbb{R} \rbrace \cup \lbrace (x^2+ax+b): a,b \in \mathbb{R},a^2 &lt; 4b \rbrace \cup \lbrace (0) \rbrace$</p>
<h2 id="基，紧性"><a href="#基，紧性" class="headerlink" title="基，紧性"></a>基，紧性</h2><p>由于 $V(\cup_{i \in I}E_i) = \cap_{i \in I} V(E_i)$ 我们定义 $X_E = X \setminus V(E)$。则 $X_E = \cup_{f \in E} X_f$ 这说明 $X_f,f \in A$ 确实构成了 $X$ 的一组基。$X_f$ 表示不包含 $f$ 的素理想全体。</p>
<ol>
<li>$X_f \cap X_g = X_{fg}$</li>
<li>$X_f = \emptyset \Leftrightarrow f$ 是幂零的。</li>
<li>$X_f = X \Leftrightarrow f$ 是单位。</li>
<li>$X_f = X_g \Leftrightarrow \sqrt{(f)} = \sqrt{(g)}$</li>
</ol>
<h3 id="X-是拟紧的"><a href="#X-是拟紧的" class="headerlink" title="$X$ 是拟紧的"></a>$X$ 是拟紧的</h3><blockquote>
<p>这里的拟紧,实际上就是一般点集拓扑学中的紧，在代数中紧这个概念是拟紧＋Hausdorff。</p>
</blockquote>
<p>我们只需证明：若 $\cup_{f \in S} X_f = X$ 则存在有限并使上式成立。实际上，</p>
<script type="math/tex; mode=display">
\cup_{f \in S} X_f = X \Leftrightarrow V(I(S))=V(S) = \emptyset</script><p>因此 $I(S)=A$，即 $1 = \sum_{i=1}^n a_i s_i$。所以$I(s_1,\cdots,s_n) = A$，即 $\cup_{i=1}^n X_{s_i} = X$。证毕。</p>
<h3 id="X-f-是拟紧的"><a href="#X-f-是拟紧的" class="headerlink" title="$X_f$ 是拟紧的"></a>$X_f$ 是拟紧的</h3><p>我们只需证明：若 $X_f \subset \cup_{g \in S} X_g$，则存在有限并使上式成立。实际上，</p>
<script type="math/tex; mode=display">
X_f \subset \cup_{g \in S} X_g  \Leftrightarrow V(\sqrt{I(S)}) = V(S) \subset V(f)</script><p>因此 $f \in \sqrt{I(S)}$，即 $f^m = \sum_{i=1}^n a_i s_i$。所以 $f^m \in I(s_1,\cdots,s_n)$即。$X_f \subset \cup_{i=1}^n X_{s_i}$。证毕。</p>
<h4 id="任意开集-Y-subset-X-是拟紧的当且仅当-Y-可以写成有限多个-X-f-的并"><a href="#任意开集-Y-subset-X-是拟紧的当且仅当-Y-可以写成有限多个-X-f-的并" class="headerlink" title="任意开集 $Y \subset X$ 是拟紧的当且仅当 $Y$ 可以写成有限多个 $X_f$ 的并"></a>任意开集 $Y \subset X$ 是拟紧的当且仅当 $Y$ 可以写成有限多个 $X_f$ 的并</h4><p>Proof: 由 $X_f$ 是拟紧的知道，“$\Leftarrow$” 是显然的。<br>“$\Rightarrow$” 是因为存在$E \subset A$ 使得</p>
<script type="math/tex; mode=display">
Y = X_E = \cup_{f \in E} X_f</script><p>是 $Y$ 的一个开覆盖，由于是拟紧的，因此可以写成有限个 $X_f$ 的并，证毕。</p>
<blockquote>
<p>以上结论来自 Atiyah <strong>An Introduction to Coummutative Algebra</strong> 习题。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>SG 函数之取石子博弈</title>
    <url>/nimSgFunction/</url>
    <content><![CDATA[<p>在 2002 年张一飞写过一篇论文 <a href="NimGame.pdf">《由感性认识到理性认识－透析一类博弈游戏的解答过程》</a> 从此开启了这类博弈问题的大门，留下学习笔记。</p>
<a id="more"></a>
<h2 id="取石子游戏"><a href="#取石子游戏" class="headerlink" title="取石子游戏"></a>取石子游戏</h2><p>$A,B$ 两人面对若干堆石子，按照如下规则取石子</p>
<ol>
<li>每步至少取一枚石子</li>
<li>每步只能在某一堆取走部分或者全部石子</li>
<li>谁无法按照规则取石子，谁就是输家</li>
</ol>
<p>首先抛开问题，我们先从一般的入手。</p>
<p>我们可以用一个 $n$ 元组 $(a_1,a_2,\cdots,a_n)$ 表示一个局面 $S$。显然 <strong>改变 $n$ 元组的顺序仍然是一个局面。</strong></p>
<p>一个局面 $n$ 元局面$(a_1,a_2,\cdots,a_n)$和一个 $m$ 元局面 $(b_1,b_2,\cdots,b_m)$ 之和显然就是一个 $m + n$ 元局面 $(a_1,a_2,\cdots,a_n,b_1,b_2,\cdots,b_m)$。类似的一个局面也可以有多种分解。</p>
<p>对于局面 $S$，若先行者有必胜策略，则称 “$S$ 胜”；<br>对于局面 $S$，若后行者有必胜策略，则称 “$S$ 负”。</p>
<p>如果局面 $S$ 胜，则必然存在取子方式 $S \to T$，且 $T$ 负；<br>如果局面 $S$ 负，则对任意取子方式 $S \to T$，有 $T$ 胜。</p>
<p>局面分解理论，若 $S = A + B$ 则下面结论显然</p>
<ol>
<li>若 $A,B$ 一胜一负，则 $S$ 胜</li>
<li>若 $A,B$ 全为负，则 $S$ 负</li>
<li>若 $A,B$ 全为胜，则 $S$ 无法判断</li>
<li>若 $A=B$，则 $S$ 负</li>
<li>空局面是负局面</li>
</ol>
<p>因此根据上面的分解理论，可以将一个局面进行化简。例如 $(2,2,2,7,9,9)$ 可以化简成 $(2,7)$</p>
<p>而局面分解的关系，很容易让人联想到整数的位运算－异或。</p>
<p>对于上面取石子问题，每一个局面都可以分解成只有一堆石子的局面。<br>对一个局面，定义一个函数 $f$，然后把它们异或是不是，然后判断是非为 0，作为是否胜的充要条件.这样做是否可行呢？先对原始例子进行实验。</p>
<p>函数 $f$：若局面 $S$ 只有一个石子，设 $S={a}$，则定义 $f(a) = a$。<br>设局面 $S = (a_1,a_2,\cdots,a_n)=(a_1)+(a_2)+\cdots (a_n)$，则 $f(S) = f(a_1) \oplus f(a_2) \oplus \cdots \oplus f(a_n)$<br>对于一个局面 $S$，若 $f(S) = 0$，则 $S$ 负，否则，$S$ 胜。</p>
<p>下面证明上面的结论。<br>引理：$a_1 \oplus a_2 \oplus a_n = p \neq 0$，则必存在 $1 \leq k \leq n$，使得 $a_k \oplus p &lt; a_k$。这是因为我们看 $p$ 的最高位即知存在 $a_k$ 其最高位也为 $1$, 那么与 $p$ 异或后，这一位就从 $1$ 变为 $0$，证毕。</p>
<p>若 $f(S) = 0$，则无论先行者如何取子 $S \to T$，都有 $f(T) \neq 0$。<br>若 $f(S) \neq 0$，则先行者存在一种取法 $S \to T$, 使得 $f(T) = 0$。这是因为由引理 $a_1 \oplus a_2 \oplus a_n = p \neq 0$，存在 $1 \leq k \leq n$，使得 $x = a_k \oplus p &lt; a_k$。那么我们在第 $k$ 堆取走 $a_k - x$ 个石子，那么 $a_1 \oplus a_2 \oplus a_n \oplus p = 0$，证毕。</p>
<p>这说明了上述想法的可行性。下面把这种思想推广成一般的 SG 函数的情形</p>
<h2 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h2><p>当对石子的取法进行限制时，例如每次最多能去 $m$ 个，或每次最少取 $l$ 个等，此时再令 $f(x) = x$ 就不合适了。那么应该选择怎样的 $f$ 呢。显然 $f$ 必须满足：</p>
<ol>
<li>若 $f(S) = 0$, 则无论先行者如何取子 $S \to T$，都有 $f(T) \neq 0$</li>
<li>若 $f(S) \neq 0$, 则先行者存在一种取子 $S \to T$，使得 $f(T) = 0$。</li>
</ol>
<p>我们用 $(S) = \lbrace S_1,S_2, \cdots S_k \rbrace$ 表示 $S$ 的下一个可能的局面，定义 $g(S) = \lbrace f(S_1),f(S_2), \cdots f(S_k) \rbrace $</p>
<p>由 $f$ 满足条件 1 知</p>
<script type="math/tex; mode=display">
\lbrace f(S) \rbrace \cap g(S) = \emptyset</script><p>由条件 2 知</p>
<script type="math/tex; mode=display">
\max g(S) < f(S)</script><p>因此我们定义函数 $f(S)$ 为 $f(S) \doteq \min g(S)$</p>
<blockquote>
<p>写的这么乱，估计只有自己看的懂 0.0</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>运筹学</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器和 Tab 的选择</title>
    <url>/ide/</url>
    <content><![CDATA[<p>由于 Sublime 本身以及插件的下载巨慢无比，并且 Python 插件中对 <code>\r \b</code> 不支持，让我很想转 VSCode</p>
<blockquote>
<p>VSCode + Jupyter Notebook + Sagemath 太快乐了！</p>
</blockquote>
<a id="more"></a>
<h2 id="IDE：（文本编辑器，代码编辑器，集成开发环境）"><a href="#IDE：（文本编辑器，代码编辑器，集成开发环境）" class="headerlink" title="IDE：（文本编辑器，代码编辑器，集成开发环境）"></a>IDE：（文本编辑器，代码编辑器，集成开发环境）</h2><ul>
<li>2011-2012 学校机房 VC++6.0 写 C ，属实 SB…</li>
<li>2012-now ACM 集训队 Codeblocks 写 C/C++，<del>依旧是写 C/C++ 的首选环境</del> (VScode 无敌)</li>
<li>2013-now MATLAB </li>
<li>2013-now Sublime (打开任何文本文件，编译运行 <code>C++，Python，Latex</code>)，别说了，爱过 0.0</li>
<li>2015-2015 VS 游戏公司实习</li>
<li>2015-2015 vim 配置 ACM/ICPC 区域赛服务器（只记得<code>i :wq</code> 和 <code>vim.rc</code>了）</li>
<li>2015-2017 macDown 写 markdown</li>
<li>2020.1-now  Typora 写 markdown (2020/8/6 被 VScode 取代)</li>
<li>2020.3-now VSCode 试图替代 Sublime （done！）</li>
<li>2020.5-now Jupyter Notebook 写 SegaMath 上流！</li>
</ul>
<blockquote>
<p>从 古董 VC++6.0 到重量级 VS，一直对微软的编辑器有这莫名的反感，但是这次 VSCode 全开源确实做的很不错。（新 Edge 浏览器也很不错，莫非微软变了？）</p>
</blockquote>
<h2 id="Vi-m-VS-Emacs"><a href="#Vi-m-VS-Emacs" class="headerlink" title="Vi(m) VS Emacs"></a>Vi(m) VS Emacs</h2><p>因为没用过 Emacs，<a href="/vimWithLinuxShell/" title="Vim">Vim</a> 只用在无图形界面的系统，例如服务器，所以对此问题无感。搜狐上的一篇<a href="https://www.sohu.com/a/149343369_487482" target="_blank" rel="noopener">图文</a>挺有意思的。</p>
<h2 id="Tab-VS-Space"><a href="#Tab-VS-Space" class="headerlink" title="Tab VS Space"></a>Tab VS Space</h2><p>之前学 C 的时候默认都是用 tab 缩进，也用 tab 缩进了很多年（C/C++ 本身对缩进就不要求），后来学 Python 的时候，缩进是必要的，并且不允许用 tab 和 space 混合缩进，然后 Python 一群人就说 4 个空格代替 tab 可以使代码变得整体和美观，听起来很不错，但是 tab 党真的受不了！</p>
<blockquote>
<p>tab 设计出来不就是为了美观的缩进吗？ 而且 tab 的姿势很潇洒不觉得吗？</p>
<p>用 tab 缩进，用空格对齐 （前无空格，后无 tab）</p>
</blockquote>
<h2 id="VSCode-配置"><a href="#VSCode-配置" class="headerlink" title="VSCode 配置"></a>VSCode 配置</h2><p>添加： 中文，Font 20（左下角设置），主题（One Monokai Theme）</p>
<p>C/C++，C/C++ Compile Run，Python，Markdown All in One，Latex WorkShop，draw.io</p>
<blockquote>
<p>可以在下面多搞一个 terminal 然后 进入 py 测试</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="vi.jpg" alt="vscode"></p>
<blockquote>
<p>VSCode + WSL 也太快乐了吧</p>
</blockquote>
<h2 id="VSCode-快捷键"><a href="#VSCode-快捷键" class="headerlink" title="VSCode 快捷键"></a>VSCode 快捷键</h2><p>（sublime 完全退役了，爱过）</p>
<ul>
<li><code>shift + alt + f</code> 文件夹查找</li>
<li><code>F12</code> 定义跳转（很多都有）</li>
<li><code>alt + left</code> 回到跳转前的位置</li>
<li><code>F1</code> 无敌的搜索</li>
<li><code>F1</code> 搜索 <code>Clang</code> 配置 <code>C++</code> 代码风格</li>
</ul>
<h2 id="硬件环境（完美搭配）"><a href="#硬件环境（完美搭配）" class="headerlink" title="硬件环境（完美搭配）"></a>硬件环境（完美搭配）</h2><ul>
<li>杂牌组装台式机装 Windows7 + VMware 里装 Ubuntu(Linux 一个流行的发行版) </li>
<li>或者 杂牌组装台式机装 Win10 + WSL（无图形界面，也挺好）</li>
<li>MacBook</li>
<li>ipad pro + pencil</li>
<li>非 iphone</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Zariski Topology on  $k^n$</title>
    <url>/zariskiTopologyOnKn/</url>
    <content><![CDATA[<p>$k^n$ 最常见的拓扑自然是欧式拓扑，但是下面介绍的 Zariski 拓扑也是十分重要和“常见”的拓扑，并且它也保持了很多自然的性质，又有其独特的地方，值得了解一番。</p>
<blockquote>
<p>详见 Jacobson《Basic Algebra 2》</p>
</blockquote>
<a id="more"></a>
<h2 id="Zariski-Topology"><a href="#Zariski-Topology" class="headerlink" title="Zariski Topology"></a>Zariski Topology</h2><p>给定一个交换环 $A$ ,$Spec(A)$  表示 $A$ 理想全体构成的集合，带上一个 Zariski topology，拓扑中闭集为所有形式</p>
<script type="math/tex; mode=display">
V(I)=\lbrace P \in Spec(A) | I \subset P \rbrace , I \subset A</script><p>的集合，那么它必然会满足拓扑关于闭集的公理。</p>
<h3 id="k-n-上的-Zariski-拓扑"><a href="#k-n-上的-Zariski-拓扑" class="headerlink" title="$k^n$ 上的 Zariski 拓扑"></a>$k^n$ 上的 Zariski 拓扑</h3><p>由于 $k^n=\lbrace(a_1,a_2,\cdots,a_n)| a_i \in k \rbrace$  到 $k$ 的多项式函数与 $k[x_1,x_2,\cdots,x_n]$ 同构。所有 $k^n$ 上的拓扑</p>
<p>本质上是由交换环 $k[x_1,x_2,\cdots,x_n]$ 的 Zariski 拓扑所确定。</p>
<script type="math/tex; mode=display">
V(S)=\lbrace (a_1,a_2,\cdots,a_n) \in k^n | f(a_1,a_2,\cdots,a_n) = 0 , \forall f \in S \rbrace</script><ol>
<li><p>$V(k[x_1,x_2,\cdots,x_n]) = \emptyset$;$V(\emptyset)=k[x_1,x_2,\cdots,x_n]$</p>
</li>
<li><p>$\cap_{i \in I} V(S_i) = V(\cup_{i \in I} S_i)$</p>
</li>
<li><p>$V(S) = V(I(S))$ for ideals $I_1,I_2$,$V(I_1) \cup V(I_2) = V(I_1 I_2)$</p>
</li>
</ol>
<p>所以，上述 $V(S)$ 全体作为闭集构成了 $k^n$ 的一个拓扑，称为 $k^n$ 上的 Zariski 拓扑。</p>
<h3 id="性质（设-k-是代数闭域）"><a href="#性质（设-k-是代数闭域）" class="headerlink" title="性质（设$k$是代数闭域）"></a>性质（设$k$是代数闭域）</h3><ol>
<li><p>拓扑基： $k^n$中开集有形式$k^n \setminus V(S) = \cup_{f \in S} O_f$其中 $O_f = k^n \setminus V(f)$为开集。因此 ${O_f|f \in k[x_1,x_2,⋯,x_n]}$构成了$ k^n$上的拓扑集</p>
</li>
<li><p>$k^a$是 $T_1$空间。</p>
</li>
<li><p>$k^n$是不可约空间，即有限个非空开集交集非空。</p>
</li>
<li><p>$k^n$多项式映射在 Zariski 拓扑下连续。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>$\pi(x)$ 的计算</title>
    <url>/computationOfPiX/</url>
    <content><![CDATA[<p>$\pi(x)$ 表示不超过 $x$ 的素数个数。容易看出可以在 $O(N)$ 时间复杂度，$O(N)$ 空间复杂度离线预处理求出小于 $N$ 的素数全体。但是如果 $N=10^{14}$ 或者更大，这种做法必然是不现实的。因此下面给出高效的求解方法…</p>
<blockquote>
<p>再读一次还是觉得很巧妙，一步一步走向更优。</p>
</blockquote>
<a id="more"></a>
<p>理论基础: 参考潘承洞《数论基础》和 <a href="COMPUTING pix THE MEISSEL, LEHMER, LAGARIAS,MILLER, ODLYZKO METHOD.pdf">ams 上的一篇论文</a>，<a href="Computing pix the combinatorial method.pdf">另一篇论文</a></p>
<h2 id="psi-x-s"><a href="#psi-x-s" class="headerlink" title="$\psi(x,s)$"></a>$\psi(x,s)$</h2><p>$\psi(x,s)$ 表示不超过 $x$ 且能不能被前 $s$ 个素数整除的正整数个数。即</p>
<script type="math/tex; mode=display">
\psi(x,s) = \sum_{n \leq x} \sum_{d|(n,m_s)} \mu(d) = \sum_{d|m_s} u(d)\lfloor \frac{x}{d} \rfloor</script><p>其中 $m_s = p_1 \cdots p_s$ 为前 $s$ 个素数的积。</p>
<p>另一方面，显然我们有</p>
<script type="math/tex; mode=display">
\psi(x,s) = \psi(x,s-1) - \psi(\frac{x}{p_s},s-1)</script><h2 id="pi-x"><a href="#pi-x" class="headerlink" title="$\pi(x)$"></a>$\pi(x)$</h2><p>我们知道一个数 $n&gt;1$ 是素数当且仅当不存在素数 $p \leq \sqrt{n}$ 使得 $p \mid n$。因此当 $s \geq \pi(\sqrt{x})$ 时，</p>
<script type="math/tex; mode=display">
\psi(x,s) = \pi(x) - s + 1</script><h2 id="P-k-x-s"><a href="#P-k-x-s" class="headerlink" title="$P_k(x,s)$"></a>$P_k(x,s)$</h2><p>设 $P_k(x,s)$ 为 <strong>不超过 $x$ 且每个素因子都大于 $p_s$ 且素因子(按重根计)个数为 $k$</strong> 的整数个数（方法属于 Lehmer）。进一步设 $P_0(x,s)=1$。则</p>
<script type="math/tex; mode=display">
\psi(x,s) = \sum_{k=0} ^{\infty} P_k(x,s)</script><p>显然 $P_1(x,s) = \pi(x)-s$。</p>
<p>若 $\pi(\sqrt[3]{x}) \leq s \leq \pi(\sqrt{x})$ 则 $P_k(x,s)=0,k \geq 3$ 此时</p>
<script type="math/tex; mode=display">
\psi(x,s) = 1 + \pi(x)-s + P_2(x,s)</script><p>其中</p>
<script type="math/tex; mode=display">
P_2(x,s) = \sum_{k=s+1}^{\pi(\sqrt{x})} \left( \pi(\frac{x}{p_k}) - k + 1 \right)</script><blockquote>
<p>注意到上式中 $\frac{x}{p_k} &lt;  x^{\frac{2}{3}}$ </p>
</blockquote>
<h2 id="pi-x-的计算公式"><a href="#pi-x-的计算公式" class="headerlink" title="$\pi(x)$ 的计算公式"></a>$\pi(x)$ 的计算公式</h2><script type="math/tex; mode=display">
\pi(x) = \psi(x,s) + \frac{(\pi(\sqrt{x})+s-2)(\pi(\sqrt{x})- s+1)}{2} - \sum_{k=s+1}^{\pi(\sqrt{x})} \pi(\frac{x}{p_k})</script><blockquote>
<p>取上面 $s = \pi(\sqrt[3]{x}) $<br>因此问题最终转化成求 $\psi(x,\pi(\sqrt[3]{x}))$。它可以利用</p>
</blockquote>
<ol>
<li>$\psi(x,0) = \lfloor x \rfloor$</li>
<li>$\psi(x,s) = \psi(x,s-1) - \psi(\frac{x}{p_s},s-1)$</li>
</ol>
<p>至此问题貌似就这么解决了。但是由于这个递归会使得程序效率大大降低，因此需要一些预处理操作。</p>
<ol>
<li>若 $x&lt;p_s$ 则 $\psi(x,s) ＝ 1$ </li>
<li>给定一个小整数 M，预处理出 $\psi(x,s)$,其中 $x &lt; q=p_1 \cdots p_s,\quad s&lt;=M$<br>则 $\psi(x,s) = \psi(x \mod q,s) + \lfloor \frac{x}{q} \rfloor \psi(q,s)$</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e8</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;p[<span class="number">1</span>]=<span class="number">2</span>;isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)   isp[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])  p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>,t=(N<span class="number">-1</span>)/i + <span class="number">1</span>;j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j)&#123;</span><br><span class="line">            isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span>*<span class="number">3</span>*<span class="number">5</span>*<span class="number">7</span>*<span class="number">11</span>*<span class="number">13</span>*<span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM+<span class="number">1</span>][M+<span class="number">1</span>],sz[M+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    initprime();</span><br><span class="line">    pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])  pi[i]=pi[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>  pi[i]=pi[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sz[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=PM;++i)  phi[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        sz[i]=p[i]*sz[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=PM;++j)&#123;</span><br><span class="line">            phi[j][i]=phi[j][i<span class="number">-1</span>]-phi[j/p[i]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= M)  <span class="keyword">return</span> phi[x%sz[s]][s]+(x/sz[s])*phi[sz[s]][s];</span><br><span class="line">    <span class="keyword">if</span>(x/p[s] &lt;= p[s])  <span class="keyword">return</span> primepi(x)-s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N &amp;&amp; x/p[s]/p[s] &lt;= p[s])&#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">        LL ans = pi[x]-LL(s2x+s<span class="number">-2</span>)*(s2x-s+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=s2x;++i)&#123;</span><br><span class="line">            ans+=pi[x/p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primephi(x,s<span class="number">-1</span>)-primephi(x/p[s],s<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> pi[x];</span><br><span class="line">    <span class="keyword">int</span> ps2x = pi[<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">    <span class="keyword">int</span> ps3x = pi[<span class="keyword">int</span>(cbrt(x+<span class="number">0.2</span>))];</span><br><span class="line">    LL ans = primephi(x,ps3x) + LL(ps2x+ps3x<span class="number">-2</span>)*(ps2x-ps3x+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =ps3x+<span class="number">1</span>,ed = ps2x;i&lt;=ed;++i)&#123;</span><br><span class="line">        ans -= primepi(x/p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n=98765432109876 = 9.8*10^13 用时 38s, N 大点，耗时会小点</span></span><br><span class="line">        <span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;primepi(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lehmer-计算公式"><a href="#lehmer-计算公式" class="headerlink" title="lehmer 计算公式"></a>lehmer 计算公式</h2><blockquote>
<p>我自己写的代码没有上面的快，两种计算各有优势</p>
</blockquote>
<p>令 $s = \pi(\sqrt[4]{x}), t= \pi(\sqrt[3]{x})$。则，对任意 $i&gt;3, P_i(x,s) = 0$,</p>
<script type="math/tex; mode=display">
\begin{array}{rl}
\psi(x,s) &= 1 + \pi(x) - s + P_2(x,s) + P_3(x,s) \\
&= 1+ \pi(x) - s  + P_2(x,s) + \sum_{k=s+1}^{t} P_2(\frac{x}{p_k},k-1) \\
\end{array}</script><p>即：</p>
<script type="math/tex; mode=display">
\pi(x) = \psi(x,s)-1+s-P_2(x,s) - \sum_{k=s+1}^{t} P_2(\frac{x}{p_k},k-1)</script><blockquote>
<p>注意到 $\frac{x}{p_k} &lt; \sqrt{x}$ ，所以最后一个式子可以用下式求，最后计算复杂度在于 $P_2(x,s)$ </p>
</blockquote>
<script type="math/tex; mode=display">
\sum_{k=s+1}^{t} P_2(\frac{x}{p_k},k-1) = \sum_{k=s+1}^{t}  \sum_{j=k}^{\pi(\sqrt{\frac{x}{p_k}})} \pi(\frac{x}{p_k p_j}) - j+1</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e8</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],pi[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;p[<span class="number">1</span>]=<span class="number">2</span>;isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)   isp[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])  p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>,t=(N<span class="number">-1</span>)/i + <span class="number">1</span>;j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j)&#123;</span><br><span class="line">            isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span>*<span class="number">3</span>*<span class="number">5</span>*<span class="number">7</span>*<span class="number">11</span>*<span class="number">13</span>*<span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM+<span class="number">1</span>][M+<span class="number">1</span>],sz[M+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    initprime();</span><br><span class="line">    pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isp[i])    pi[i] = pi[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span> pi[i]=pi[i<span class="number">-1</span>];    </span><br><span class="line">    &#125;</span><br><span class="line">    sz[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=PM;++i)  phi[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        sz[i]=p[i]*sz[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=PM;++j)&#123;</span><br><span class="line">            phi[j][i]=phi[j][i<span class="number">-1</span>]-phi[j/p[i]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lehmerpi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">P_2</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= M)  <span class="keyword">return</span> phi[x%sz[s]][s]+(x/sz[s])*phi[sz[s]][s];</span><br><span class="line">    <span class="keyword">if</span>(x/p[s] &lt;= p[s])  <span class="keyword">return</span> lehmerpi(x)-s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x/p[s]/p[s] &lt;= p[s] &amp;&amp; x&lt;N)&#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>))];</span><br><span class="line">        LL ans = pi[x]-(s2x+s<span class="number">-2</span>)*(s2x-s+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=s2x;++i)&#123;</span><br><span class="line">            ans+=pi[x/p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primephi(x,s<span class="number">-1</span>)-primephi(x/p[s],s<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">P_2</span><span class="params">(LL x,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ps2x = lehmerpi(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>));</span><br><span class="line">    LL ans = LL(s-ps2x)*(ps2x+s<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=ps2x;++i)&#123;</span><br><span class="line">        ans += lehmerpi(x/p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lehmerpi</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> pi[x];</span><br><span class="line">    <span class="keyword">int</span> ps3x = lehmerpi(<span class="keyword">int</span>( cbrt(x+<span class="number">0.2</span>) ));</span><br><span class="line">    <span class="keyword">int</span> ps4x = lehmerpi(<span class="keyword">int</span>( <span class="built_in">sqrt</span>(<span class="built_in">sqrt</span>(x+<span class="number">0.2</span>)) ));</span><br><span class="line">    LL ans = primephi(x,ps4x) + ps4x<span class="number">-1</span> - P_2(x,ps4x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =ps4x+<span class="number">1</span>;i&lt;=ps3x;++i)&#123;</span><br><span class="line">        ans -= P_2(x/p[i],i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123; <span class="comment">// n=98765432109876 = 9.8*10^13 用时 42s, N 大点，耗时会小点</span></span><br><span class="line">        <span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;lehmerpi(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Time used: "</span>&lt;&lt;difftime(time(<span class="number">0</span>),now)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="稳定简洁的-DP-做法"><a href="#稳定简洁的-DP-做法" class="headerlink" title="稳定简洁的 DP 做法"></a>稳定简洁的 DP 做法</h2><p>我们令 $dp(x,s) = \psi(x,s)+s-1$ 它的意义是，$2～x$ 中被前 $s$ 个素数筛完后的伪素数个数。因此我们有 $dp(0,0)=0,dp(x,0)=x-1,x&gt;1,dp(x,\pi(\sqrt{x})) = \pi(x)$ 且有状态转移</p>
<script type="math/tex; mode=display">
dp(x,s) = dp(x,s-1)-dp(\frac{x}{p_s},s-1)+s-1</script><p>因为 $dp(p_{s-1},s-1) = s-1$，最后一项可以写成 $dp(p_{s-1},s-1)$。虽然上面需要二维数组，但是实际上我们可以优化成一维数组的情况。因为</p>
<script type="math/tex; mode=display">
dp(x,s) = dp(x,s-1)-dp(\frac{x}{p_s},s-1)+ dp(p_{s-1},s-1)</script><p>另外我们也不可能开 $O(n)$ 的数组，但是可以利用一种黑科技开 $O(\sqrt{n})$ 的数组即可达到我们的目的。<br>即我们用 $L[x]$ 表示 $dp(x,s)$ 用 $R[x]$ 表示 $dp(\frac{n}{x},s)$。</p>
<blockquote>
<p>若$L[m]!=L[m-1]$ ，则说明 $m$ 不能被前 $s$  个素数整除是第 $s+1$ 个素数。</p>
<p>我们需要的是 $R[1]$</p>
</blockquote>
<p>上述做法的时间复杂度为 $O(\frac{n}{\log n})$ 且常数特别小，代码十分简洁。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line">LL L[N],R[N];</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL n)</span></span>&#123;</span><br><span class="line">    LL rn = (LL)<span class="built_in">sqrt</span>(n+<span class="number">0.2</span>);</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=rn;++i)   R[i]=n/i<span class="number">-1</span>;</span><br><span class="line">    LL ln = n/(rn+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=ln;++i)   L[i]=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL p=<span class="number">2</span>;p&lt;=rn;++p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L[p]==L[p<span class="number">-1</span>])    <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(LL i=<span class="number">1</span>,tn=<span class="built_in">min</span>(n/(p*p),rn);i&lt;=tn;++i)&#123;</span><br><span class="line">            R[i] -= (i*p&lt;=rn?R[i*p]:L[n/(i*p)])-L[p<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(LL i=ln;i&gt;=p*p;--i)&#123;</span><br><span class="line">            L[i] -= L[i/p]-L[p<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;  <span class="comment">// n=98765432109876 = 9.8*10^13 用时 193s</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;primepi(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个骚方法还目前还没有找到其它的应用 0.0</p>
<p>主要还没法对它用树状数组</p>
</blockquote>
<h2 id="求第-n-个素数的方法"><a href="#求第-n-个素数的方法" class="headerlink" title="求第 n 个素数的方法"></a>求第 n 个素数的方法</h2><ul>
<li>根据概率分布找到大致界限</li>
<li>再牛顿梯度法（或者二分查找）使得 $\pi(m)= n$ </li>
<li>素数判断递减 $m$ 直到 $m$ 为素数</li>
<li><a href="/nthPrimeNumber/" title="参考这里">参考这里</a>
</li>
</ul>
<h2 id="psi-x-s-计算太慢了，需要优化"><a href="#psi-x-s-计算太慢了，需要优化" class="headerlink" title="$\psi(x,s)$ 计算太慢了，需要优化"></a>$\psi(x,s)$ 计算太慢了，需要优化</h2><blockquote>
<p>理论依据见此 <a href="countPrime.zip">压缩包</a></p>
</blockquote>
<p>我们知道，若 $\pi(\sqrt[3]{x}) \leq s \leq \pi(\sqrt{x})$ 则</p>
<script type="math/tex; mode=display">
\psi(x,s) = 1 + \pi(x)-s + P_2(x,s)</script><p>其中</p>
<script type="math/tex; mode=display">
P_2(x,s) = \sum_{k=s+1}^{\pi(\sqrt{x})} \left( \pi(\frac{x}{p_k}) - k + 1 \right) =  \sum_{k=s+1}^{\pi(\sqrt{x})} \left( \psi(\frac{x}{p_k},s)+ s - k \right)</script><blockquote>
<p>注意到上式中 $\frac{x}{p_k} &lt;  x^{\frac{2}{3}} $ </p>
</blockquote>
<p>我们之前的操作本质是递归让 $x,s$ 变小，通过打表预处理来加速递归使得满足一定的效率需要。</p>
<p>现在我们来直接计算得到我们的答案。</p>
<h3 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h3><p>取定整数 $\sqrt[3]{x} \leq y = x^{\frac{1}{3}+\epsilon }&lt; \sqrt{x}, z = \frac{x}{y}, s = \pi(y)$ ，约定 $p,q$ 是素数。 预处理 $y$ 以内的数组：<code>isp[], p[], mu[], pi[]</code> ，对 $[1,z]$ 内的 $\psi(x,s)$ 用树状数组（可以在我的博客网站搜索：<code>树状数组</code>）维护（注意到这需要 $O(z)$ 的内存，单次维护不现实，所以我们可以一段段的维护，保证每一段的长度为 $2^{\lfloor \log_2(y) \rfloor +1}$ 来提高效率）</p>
<blockquote>
<p>做完上面的预处理后，我们发现 $P_2(x,s)$ 可以直接计算了。</p>
</blockquote>
<h3 id="psi-x-s-直接计算"><a href="#psi-x-s-直接计算" class="headerlink" title="$\psi(x,s)$  直接计算"></a>$\psi(x,s)$  直接计算</h3><p>在本博文的最开始有：</p>
<script type="math/tex; mode=display">
\psi(x,s) = \sum_{n \leq x} \sum_{d|(n,p)} \mu(d) = \sum_{d|p} u(d)\lfloor \frac{x}{d} \rfloor</script><p>其中 $p$ 为前 $s$ 个素数的积。</p>
<blockquote>
<p>但是最右边本质上有很多项，所以直接算，其实复杂度特别高。</p>
</blockquote>
<p>我们还有递归公式：</p>
<script type="math/tex; mode=display">
\begin{array}{cl}
\psi(x,s) &= \psi(x,s-1) - \psi(\frac{x}{p_s},s-1) \\
&= \psi(x,s-2) - \psi(\frac{x}{p_{s-1}},s-2) - \psi(\frac{x}{p_s},s-2)  + \psi(\frac{x}{p_sp_{s-1}},s-2) 
\end{array}</script><p>可以一直分解下去，如果一直分解下去就可以得到最上面的公式了。</p>
<p>所以我们约定：对于节点 $\mu(n) \psi(\frac{x}{n},b)$ ，如果满足</p>
<ul>
<li>原始节点： $b = c, n \leq y$  </li>
<li>特殊节点：$n&gt;y$  </li>
</ul>
<p>就不再分解。这也等价于说 如果  $n &lt; y$ 且 $b&gt;c$  就分解。因为一开始 $n=1,b=a&gt;c$。而且 $n$ 会增大，$b$ 会减小，所以节点一定会有限步内，落入上述两种框架中的一种。并且 <strong>特殊节点的父节点 $-\mu(n) \psi(\frac{x}{\frac{n}{p_{d+1}}},b+1)$</strong> 必然满足 $\frac{n}{ p_{d+1} } \leq y <n$  且 $b+1>c$。综上：</p>
<blockquote>
<p>以前设置 $c = 7$，但是后来发现没必要，$c=0$ 就挺好。</p>
</blockquote>
<script type="math/tex; mode=display">
\psi(x,s) = \sum_{n=1} ^y \mu(n) \lfloor \frac{x}{n} \rfloor +  \sum_{\frac{n}{\delta(n)} \leq y < n} \mu(n) \psi(\frac{x}{n}, \pi(\delta(n))-1) = S_0 + S</script><p>$S_0$ 很好处理，计算 $S$： 对 $p = \delta(n)$ 一起求：</p>
<script type="math/tex; mode=display">
S = - \sum_{p \leq y} \sum_{\begin{array}{c} \delta(m) >p \\ m \leq y < mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)</script><p>注意到：$\frac{x}{mp} &lt; z$ ，所以我们已经可以把 $\psi(x,s)$ 直接计算出来了。</p>
<blockquote>
<p>但是我们可以避免很多计算来提高效率。于是我们有下列一系列的操作</p>
</blockquote>
<ul>
<li>$p \geq \sqrt{y}$，则 $m$ 为素数 ，且此时 $mp &gt; p^2 \geq y$ (若 $m$ 为合数，则 $m \geq \delta(m) ^2 &gt;p^2 \geq y$ 矛盾)</li>
<li>$\frac{x}{mp} &lt; p$ 时，$\psi(\frac{x}{mp},\pi(p)-1) = 1$</li>
<li>$\sqrt{\frac{x}{mp}} &lt; p$ 时，$\psi(\frac{x}{mp},\pi(p)-1) = \pi(\frac{x}{mp}) - \pi(p) +2$</li>
<li>$\sqrt{y} &lt; \sqrt{z} &lt;  x^{\frac{1}{4}}  &lt; x^{\frac{1}{3}} &lt; y$</li>
</ul>
<h4 id="由此对-S-分段计算"><a href="#由此对-S-分段计算" class="headerlink" title="由此对$S$分段计算"></a>由此对$S$分段计算</h4><script type="math/tex; mode=display">
S_1 = - \sum_{\sqrt[3]{x} < p \leq y} \sum_{\begin{array}{c} \delta(m) >p \\ m \leq y < mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)</script><script type="math/tex; mode=display">
S_2 = - \sum_{\sqrt{z} < p \leq \sqrt[3]{x}} \sum_{\begin{array}{c} \delta(m) >p \\ m \leq y < mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)</script><script type="math/tex; mode=display">
S_3 = - \sum_{\sqrt{y} < p \leq \sqrt{z}} \sum_{\begin{array}{c} \delta(m) >p \\ m \leq y < mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)</script><script type="math/tex; mode=display">
S_4 = - \sum_{p \leq \sqrt{y}} \sum_{\begin{array}{c} \delta(m) >p \\ m \leq y < mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)</script><p>由限制关系式，我们化简 $S_1, S_2, S_3 $</p>
<script type="math/tex; mode=display">
\begin{array}{cl}
S_1 &= - \sum_{\sqrt[3]{x} < p \leq y} \sum_{p<q \leq y} \mu(q) \psi(\frac{x}{pq},\pi(p)-1) \\
&=  \sum_{\sqrt[3]{x} < p < q \leq y} 1 \\
&= {\pi(y)-\pi(\sqrt[3]{x}) \choose 2} 
\end{array}</script><script type="math/tex; mode=display">
\begin{array}{cl}
S_2 &= - \sum_{\sqrt{z} < p \leq \sqrt[3]{x}} \sum_{p<q \leq y} \mu(q) \psi(\frac{x}{pq},\pi(p)-1) \\
&=  \sum_{\sqrt{z} < p \leq \sqrt[3]{x}} \sum_{p<q \leq y} \pi(\frac{x}{pq}) - \pi(p) +2 \\
&= \sum_{\sqrt{z} < p \leq \sqrt[3]{x}} \sum_{p<q \leq y} \pi(\frac{x}{pq}) + \sum_{\sqrt{z} < p \leq \sqrt[3]{x}} (\pi(p)-\pi(y))(\pi(p)-2)
\end{array}</script><script type="math/tex; mode=display">
\begin{array}{cl}
S_3 &= - \sum_{\sqrt{y} < p \leq \sqrt{z}} \sum_{p < q \leq y} \mu(q) \psi(\frac{x}{pq},\pi(p)-1) \\
&=  \sum_{\sqrt{y} < p \leq \sqrt{z}}  \sum_{p < q \leq y} \psi(\frac{x}{pq},\pi(p)-1)
\end{array}</script><blockquote>
<p>$S_2$ 也可以用 $S_3$ 的式子求，只是效率不高。</p>
<p>$S_2$ 中 $\frac{x}{pq}, p&lt;y$，即可以直接求。</p>
</blockquote>
<p><strong>当然了还可以继续细化，但是我嫌麻烦就不想再细化了！</strong></p>
<blockquote>
<p>也就是现在的核心就是树状数组分段维护数据，然后每一段的总值要用数组存起来就好了。然后用这个数据结果计算 $S_2,S_3,S_4,P_2(x,s)$，然后就大功告成了 0.0</p>
<p>用 $\psi(x,s)$ 计算 $\pi(x)$，还是用 $\pi(x)$ 计算 $\psi(x,s)$ ，这是一个问题。</p>
<p>用树状数组维护的时候会有一个很大的问题就是：求和式中 每此动 $p$ 整个维护就要从 $1 \to p$ 重新维护一次很麻烦。这个问题没解决所以我不想写代码。 </p>
<p>想把 $\frac{x}{pq}$ 的所有可能的值单调递增排列但是又不现实。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊数列</title>
    <url>/SpecialNumberSequences/</url>
    <content><![CDATA[<p>在知乎上看到一个有趣的问题: <a href="https://www.zhihu.com/question/383254359" target="_blank" rel="noopener">如何证明这个数列无界？</a> 在此记录一下简单的做法，然后把这篇博客记录以后遇到的一些特殊数列。</p>
<p>证明：当$x$是无理数时，$f_n(x) = \sum_{i=1}^n (-1)^{\lfloor ix \rfloor} $  无界</p>
<blockquote>
<p>$\lfloor x \rfloor$ 表示 $x$ 的整数部分， $0 \leq \lbrace x \rbrace \doteq x- \lfloor x \rfloor&lt;1 $ 表示 $x$ 的小数部分</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>为了更顺畅的介绍这个数列，我们先来点前戏，不然插入的时候就不那么顺滑了 0.0 不要笑，我没有开车 0.0</p>
</blockquote>
<h2 id="连分数"><a href="#连分数" class="headerlink" title="连分数"></a><a href="ContinuedFractions.pdf">连分数</a></h2><blockquote>
<p>它和 Farey 序列，无理数的有理逼近，密切相关</p>
</blockquote>
<p>我们将一个整数序列 $a_0,a_1, \cdots, a_n$ 构成的分数叫做连分数，记作</p>
<script type="math/tex; mode=display">
[a_0,a_1,\cdots, a_n] = a_0 + \frac{1}{a_1 + \frac{1}{a_2 + \cdots}}</script><p>其中$a_0$ 是整数， $a_i (i&gt;0)$是正整数。</p>
<p>我们定义:</p>
<p>$p_0 = a_0,p_1 = a_1a_0 +1,p_n = a_np_{n-1} + p_{n-2} (n&gt;1)$</p>
<p>$q_0 = 1,q_1 = a_1,q_n=a_nq_{n-1}+q_{n-2} (n&gt;1)$</p>
<p>那么数学归纳法易证：</p>
<script type="math/tex; mode=display">
[a_0,a_1,\cdots, a_n] = \frac{p_n}{q_n} = x_0</script><p>并且还有</p>
<ul>
<li>$[a_0,a_1,\cdots, a_n] = [a_0,a_1,\cdots, a_{n-1} + \frac{1}{a_n}]$</li>
<li>$p_{n+1}q_n - q_{n+1}p_n = (-1)^n$</li>
<li>从而 $(p_n,p_{n+1}) = (q_n,q_{n+1}) = (p_n,q_n) = 1$</li>
<li>$x_{n+2} - x_n = \frac{(-1)^n a_{n+2}}{q_n q_{n+2}}$</li>
<li>从而 $x_0 &lt; x_2&lt; x_4 &lt; \cdots &lt; x_5 &lt; x_3 &lt; x_1$</li>
</ul>
<h3 id="对任意一个数-x-构造连分数"><a href="#对任意一个数-x-构造连分数" class="headerlink" title="对任意一个数 $x$ 构造连分数"></a>对任意一个数 $x$ 构造连分数</h3><ol>
<li>初始 $i = 0$</li>
<li>$a_i = \lfloor x \rfloor$ 取 $x$  的整数部分。</li>
<li>$x - a_i == 0$ 结束</li>
<li>取 $x = \frac{1}{x-a_i}$ </li>
<li>++$i$ 回到步骤 1</li>
</ol>
<p>从构造中，我们看出：<strong>连分数长度有限当且仅当$x$是有理数</strong>，此时，最后一项得到的连分数就是$x$。</p>
<p>当$x$ 是无理数时， $x_{2n} &lt; x &lt; x_{2n+1}$ ，又因为</p>
<script type="math/tex; mode=display">
x_{2n+1} - x_{2n} = \frac{1}{q_{2n}q_{2n+1}} \leq  \frac{1}{2n(2n+1)}</script><p>且  $x_{2n}$  单调递增，$x_{2n+1}$ 单调递减。所以 $\lim _{n \to \infty} x_n = x$。并且</p>
<script type="math/tex; mode=display">
|x - \frac{p_n}{q_n} | < \frac{1}{q_n ^2}</script><h3 id="补充定义"><a href="#补充定义" class="headerlink" title="补充定义"></a>补充定义</h3><script type="math/tex; mode=display">
a_n' \doteq a_n'(x) \doteq [a_n, a_{n+1}, a_{n+2},\cdots]</script><script type="math/tex; mode=display">
p_{n+1}' \doteq a_{n+1}' p_n + p_{n-1} = \frac{p_{n+2}'}{a_{n+2}'} \\ 
q_{n+1}' \doteq a_{n+1}' q_n + q_{n-1} = \frac{q_{n+2}'}{a_{n+2}'}</script><p>显然，$x = \frac{p_n’}{q_n’} =  \frac{p_n}{q_n} + \frac{(-1)^n}{q_n q_{n+1}’}$</p>
<h3 id="唯一分解"><a href="#唯一分解" class="headerlink" title="唯一分解"></a>唯一分解</h3><p>对于任意给定 $x = [a_0,a_1,\cdots,a_n,\cdots]$，对任意$N$，有如下唯一分解：</p>
<script type="math/tex; mode=display">
N = \sum c_i q_i  = \sum_{i=0} ^{m(N,x)} c_i(N,x)q_i(x)</script><p>其中 $0  \leq  c_i \leq a_{i+1}, c_m(N,x) &gt;0$ 且对任意 $0 \leq j \leq m(N,x)$，$\sum_{i=0} ^ j c_i q_i &lt; q_{j+1}$ 。</p>
<h2 id="f-n-x-sum-i-1-n-1-lfloor-ix-rfloor-何时有界"><a href="#f-n-x-sum-i-1-n-1-lfloor-ix-rfloor-何时有界" class="headerlink" title="$ f_n(x) = \sum_{i=1}^n (-1)^{\lfloor ix \rfloor} $ 何时有界"></a>$ f_n(x) = \sum_{i=1}^n (-1)^{\lfloor ix \rfloor} $ 何时有界</h2><p>由于 $f_n(x+2) = f_n(x) $， 所以我们仅考虑 $x \in [0,2) $ ， 在不引起混淆时，简记成 $f_n $</p>
<h3 id="当-x-是有理数时，记-x-frac-p-q-quad-p-q-1"><a href="#当-x-是有理数时，记-x-frac-p-q-quad-p-q-1" class="headerlink" title="当 $x$ 是有理数时，记$ x = \frac{p}{q},\quad (p,q)=1$"></a>当 $x$ 是有理数时，记$ x = \frac{p}{q},\quad (p,q)=1$</h3><p>则 $f_{2q+n} = f_{2q} + f_n$， 从而  $a_n$  有界当且仅当 $f_{2q} \neq 0 $</p>
<script type="math/tex; mode=display">
f_{2q} = \sum_{i=1}^{2q} (-1)^{\lfloor \frac{ip}{q} \rfloor } =\sum_{i=1}^{q} (-1)^{\lfloor \frac{ip}{q} \rfloor } + \sum_{i=1}^{q} (-1)^{\lfloor  \frac{(i+q)p}{q} \rfloor  } = (1+(-1)^p) f_q</script><ul>
<li><p>当 $q$ 为奇数， $f_{2q} = 0$，即 $f_n$  有界</p>
</li>
<li><p>当$p$为偶数时，此时$q$ 为奇数，且$(\frac{p}{2},q)=1$，所以当 $i$ 跑遍 $[1, q]$ 时，$i\frac{p}{2} \mod q$ 跑遍 $[0,q-1]$，即</p>
<script type="math/tex; mode=display">
f_q = \sum_{i=1}^q (-1)^{ \lfloor \frac{2( i\frac{p}{2} \mod q)}{q} \rfloor} =\sum_{i=0} ^{q-1} (-1)^{\lfloor \frac{2i}{q} \rfloor} = \frac{q+1}{2} - \frac{q-1}{2} = 1</script><p>从而$f_{2q} = 2f_q = 2$ 推出$f_n$ 无界。</p>
</li>
</ul>
<h2 id="对任意无理数-x-，我们证明-g-n-x-f-n-2x-无界，从而-f-n-x-无界"><a href="#对任意无理数-x-，我们证明-g-n-x-f-n-2x-无界，从而-f-n-x-无界" class="headerlink" title="对任意无理数$x$，我们证明 $g_n(x) = f_n(2x)$ 无界，从而 $f_n(x)$ 无界"></a>对任意无理数$x$，我们证明 $g_n(x) = f_n(2x)$ 无界，从而 $f_n(x)$ 无界</h2><blockquote>
<p>目前没理解论文中的做法，太繁琐了</p>
</blockquote>
<p>显然，我们只需考虑 $0&lt; x &lt;1$</p>
<p>我们考虑 $x$ 的连分数 $[0,a_1,a_2,\cdots,a_n,\cdots]$，由于 $(p_n,q_n)=(q_n,q_{n+1})=1$ (目前不知道有什么简单的操作)</p>
<p>这个问题可以推广到更一般的情形 ： <a href="1.pdf">单栏阅读</a> <a href="2.pdf">双栏阅读</a></p>
<blockquote>
<p>里面定理一挺有意思的，虽然长但是很清晰。</p>
</blockquote>
<h2 id="另一个相关问题-：https-www-zhihu-com-question-392014769"><a href="#另一个相关问题-：https-www-zhihu-com-question-392014769" class="headerlink" title="另一个相关问题 ：https://www.zhihu.com/question/392014769"></a>另一个相关问题 ：<a href="https://www.zhihu.com/question/392014769" target="_blank" rel="noopener">https://www.zhihu.com/question/392014769</a></h2><p>是否存在$N$使得， $|\sin n|&gt;\frac{1}{n}$ 对所有 $n&gt;N$ 成立。(<a href="https://www.zhihu.com/people/dna049" target="_blank" rel="noopener">dna049</a> 和 <a href="https://www.zhihu.com/people/zhai-sen-8" target="_blank" rel="noopener">寨森 Lambda-CDM</a> 建议修改)</p>
<h3 id="存在无穷多个正整数-x-n-使得-sin-x-n-lt-frac-2-pi-x-n"><a href="#存在无穷多个正整数-x-n-使得-sin-x-n-lt-frac-2-pi-x-n" class="headerlink" title="存在无穷多个正整数 $x_n$ 使得 $|\sin x_n| &lt; \frac{2 \pi}{x_n}$"></a>存在无穷多个正整数 $x_n$ 使得 $|\sin x_n| &lt; \frac{2 \pi}{x_n}$</h3><p>引理： 对任意无理数 $a$ , 存在无穷多个 $x_n$，使得 $\min(\{a x_n\},\{-a x_n\}) &lt; \frac{2}{x_n}$</p>
<p>我们考虑 $a $  的连分数 $[a_0,a_1,\cdots,a_n,\cdots]$, 我们知道 $|a - \frac{p_n}{q_n} | &lt; \frac{1}{q_n ^2}$，由于$(p_n,q_n) = 1$,  所以存在$u_n,v_n$ 使得 $p_n u_n + q_n v_n = 1$, 此时 $p_n(u_n+tq_n) + q_n(v_n - tp_n) = 1$，所以我们不妨假设 $q_n &lt; u_n &lt; 2q_n$。所以 </p>
<script type="math/tex; mode=display">
\{ a u_n \} = \{ (a-\frac{p_n}{q_n})u_n + \frac{p_n}{q_n}u_n \}  = \{ (a-\frac{p_n}{q_n})u_n + \frac{1}{q_n} \}</script><p>我们仅考虑 $n$ 为奇数数的情况，此时 $ -\frac{1}{q_n^2}<a-\frac{p_n}{q_n}<0 $，所以 $-\frac{1}{q_n} <(a-\frac{p_n}{q_n})u_n + \frac{1}{q_n} <\frac{1}{q_n}$。而 $x_n = u_{2n+1} > q_{2n+1}$  即为所求。</p>
<blockquote>
<p>实际上 $n$ 为偶数时，也可以取做，只是此时 $u_n$ 要换成 $3q_n - u_n$</p>
</blockquote>
<p>取引理中$a = \frac{1}{\pi}$，由于$|\sin(x)|$是周期为 $\pi$ 的偶函数。所以 $|\sin(x_n)| = |\sin(\{ax_n\}\pi)| = |\sin(\{-ax_n\}\pi)| &lt; \frac{2\pi}{x_n}$</p>
<p>受 <a href="https://www.zhihu.com/people/zhai-sen-8" target="_blank" rel="noopener">寨森 Lambda-CDM</a>  启发，可以不用引理直接证明：</p>
<h3 id="存在无穷多个正整数-m-，使得-sin-m-lt-frac-pi-m"><a href="#存在无穷多个正整数-m-，使得-sin-m-lt-frac-pi-m" class="headerlink" title="存在无穷多个正整数$m$，使得 $|\sin m| &lt; \frac{\pi}{m}$"></a>存在无穷多个正整数$m$，使得 $|\sin m| &lt; \frac{\pi}{m}$</h3><p>Proof：考虑$\frac{1}{\pi}$ 的连分数 $[a_0,a_1,\cdots,a_n,\cdots]$，我们有 $|\frac{1}{\pi} - \frac{p_n}{q_n} | &lt; \frac{1}{q_n ^2}$，所以</p>
<script type="math/tex; mode=display">
|\sin q_n| = |\sin[(\frac{q_n}{\pi} -p_n) \pi + p_n\pi ]|  =  |\sin[(|\frac{q_n}{\pi} -p_n|) \pi]| < \frac{\pi}{q_n}</script><p>这个问题还关联这 <a href="https://mathworld.wolfram.com/IrrationalityMeasure.html" target="_blank" rel="noopener">Irrationality Measure</a>，菲尔兹奖级别的工作！</p>
<h3 id="Irrationality-Measure"><a href="#Irrationality-Measure" class="headerlink" title="Irrationality Measure"></a><a href="https://mathworld.wolfram.com/IrrationalityMeasure.html" target="_blank" rel="noopener">Irrationality Measure</a></h3><p>对于给定是实数$x$, 定义</p>
<script type="math/tex; mode=display">
\mu(x) \doteq \inf_{u \in R} u \\
R = \{ u\mid \exists \text{ infty } (p,q)\; s.t.\quad 0< |x -\frac{p}{q}| < \frac{1}{q^u} \}</script><p>显然考虑连分数，我们知道 当$x$是有理数时，$u(x) = 1$，无理数时，$\mu(x) \geq 2$。</p>
<p>Roth 证明，当$x$ 是代数数时$\mu(x) = 2$，因此获得 Field 奖。</p>
<p>$\mu(L) = \infty$，其中 $L = \sum_{n=1} ^{\infty} 10^{-n!}$ 为刘维尔（Joseph Liouville）数</p>
<p>我们下面证明：当$u&gt;2$时，$A = \{ x \mid 0&lt; |x -\frac{p}{q}| &lt; \frac{1}{q^u}\}$，则 $A$的外（lebesgue）测度$m^{\star}(A) = 0$，从而（lebesgue）测度$m(A)=0$</p>
<p>由于 当$1\leq p \leq q$时， $(\frac{p}{q}-\frac{1}{q^u},\frac{p}{q} + \frac{1}{q^u})$ 只有可数个，记作$I_1, I_2,\cdots I_n,\cdots$ ，按照定义，$A \cap (0,1) \subseteq \overline\lim I_n$, 另一方面 $\sum_{i=1}^{\infty} I_n = \sum_{q=1}^{\infty} \frac{q+1}{q^u} &lt; +\infty$，从而 $m^{\star}(A \cup (0,1)) = 0$，同理可证了$m^{\star}(A \cup (n,n+1))=0, n \in \mathbb{Z}$，从而 </p>
<script type="math/tex; mode=display">
0 \leq m^{\star}(A) \leq \sum_{n \in \mathbb{Z}} m^{\star}(A \cup (n,n+1)) =0</script><p>从而$m^{\star}(A) = m(A) = 0$。其中 $m^{\star}(I) = \inf \{u|u=\sum_{k=1}^{\infty} |I_k|,\; \cup_{k=1}^ {\infty} I_k \supset m ,I_k \text{ 是开矩形 } \}$</p>
<h2 id="sagemath-数值测试-Jupyter-Notebook-上运行"><a href="#sagemath-数值测试-Jupyter-Notebook-上运行" class="headerlink" title="sagemath 数值测试(Jupyter Notebook 上运行)"></a>sagemath 数值测试(Jupyter Notebook 上运行)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = continued_fraction(<span class="number">1</span>/pi).convergents()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">32</span>):</span><br><span class="line">    n = x[i].denominator()</span><br><span class="line">    print(N(abs(sin(n))-pi/n),<span class="string">"\t= "</span>,abs(sin(n))-pi/n ) <span class="comment"># 后来精度就崩了</span></span><br><span class="line">    </span><br><span class="line">x = continued_fraction(<span class="number">1</span>/pi).convergents()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">32</span>):</span><br><span class="line">    n = x[i].denominator()</span><br><span class="line">    print(i,N(abs(sin(n))*n),<span class="string">"\t= "</span>,abs(sin(n))*n) <span class="comment"># 后来精度就崩了</span></span><br></pre></td></tr></table></figure>
<h3 id="1-sum-s-in-S-frac-1-s-2-1-其中-S-a-m-a-gt-1-m-gt-1-a-m-in-mathbb-N"><a href="#1-sum-s-in-S-frac-1-s-2-1-其中-S-a-m-a-gt-1-m-gt-1-a-m-in-mathbb-N" class="headerlink" title="$1 = \sum_{s \in S} \frac{1}{s^2-1}$, 其中 $S = \{a^m | a &gt; 1, m&gt;1, a,m \in \mathbb{N} \}$"></a>$1 = \sum_{s \in S} \frac{1}{s^2-1}$, 其中 $S = \{a^m | a &gt; 1, m&gt;1, a,m \in \mathbb{N} \}$</h3><blockquote>
<p>方法：<a href="https://link.zhihu.com/?target=https%3A//www.maa.org/sites/default/files/pdf/upload_library/22/Ford/bibiloni206.pdf">On a Series of Goldbach and Euler</a></p>
</blockquote>
<script type="math/tex; mode=display">
\begin{aligned} \lim S(n)  &= \sum_{a \in A} \sum_{m\geq 2} \frac{1}{a^m -1} \\ &=  \sum_{a \in A} \sum_{m\geq 2} \frac{1}{a^m} + \sum_{a \in A} \sum_{m\geq 2} \frac{1}{a^m(a^m -1)} \\ & =  \sum_{a \in A} \frac{1}{a(a-1)} +   \sum_{b \in B} \frac{1}{b(b -1)} \\ & = \sum_{i=2}^n \frac{1}{n(n-1)} = 1 \end{aligned}</script><p>其中 $B = \{n \in \mathbb{N} \mid n = k^m , k&gt;1 \} $，$A= \{n \in \mathbb{N} \mid n &gt;1 \} - B$</p>
<h2 id="f-n-m-sum-i-0-i-leq-n-im-C-n-im-i"><a href="#f-n-m-sum-i-0-i-leq-n-im-C-n-im-i" class="headerlink" title="$f(n,m) = \sum_{i=0}^{i \leq n-im} C_{n-im}^i $"></a>$f(n,m) = \sum_{i=0}^{i \leq n-im} C_{n-im}^i $</h2><blockquote>
<p>洛谷题目，具体题号就不便说了。</p>
</blockquote>
<p>数据范围 $ 1 \leq n \leq 10^{18} , m \leq 100 $ 。我们注意考察 $f(n,m)$ 的意义！假设我们要上楼梯，每次只能上 1 步或者$m+1$步，那么 $f(n,m)$ 就是方案数，因此，我们显然有</p>
<script type="math/tex; mode=display">
f(n,m) = f(n-1,m)+f(n-m-1,m)</script><p>当然了我们不考虑意义直接用$f(n,m)-f(n-1,m)$ 也可以得到这个公式。</p>
<h3 id="无法过题的-O-m-log-m-log-n-代码，原因是没法找一个合适的基底"><a href="#无法过题的-O-m-log-m-log-n-代码，原因是没法找一个合适的基底" class="headerlink" title="无法过题的 $O(m \log m \log n ) $代码，原因是没法找一个合适的基底"></a>无法过题的 $O(m \log m \log n ) $代码，原因是没法找一个合适的基底</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> BI=__int128;</span><br><span class="line"><span class="keyword">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M =<span class="number">10004</span>;</span><br><span class="line">BI a[<span class="number">4</span>*M],r[<span class="number">4</span>*M],ans[<span class="number">2</span>*M];</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">powmod</span><span class="params">(T x,U n,T p)</span></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=x*x%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(BI *x,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;j) swap(x[i],x[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=len&gt;&gt;<span class="number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> BI FM = BI(<span class="number">29</span>)&lt;&lt;<span class="number">57</span>|<span class="number">1</span>,gg=<span class="number">3</span>;</span><br><span class="line"><span class="comment">// the mod must NFT-friendly or (len+1)*mod^2 &lt; FM</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(BI *x,<span class="keyword">int</span> len,<span class="keyword">bool</span> isInverse=<span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">    g = powmod(gg,(FM<span class="number">-1</span>)/len,FM);</span><br><span class="line">    <span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">        g=powmod(g,len<span class="number">-1</span>,FM);</span><br><span class="line">        BI invlen = powmod(BI(len),FM<span class="number">-2</span>,FM);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">            x[i]=x[i]*invlen%FM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bitreverse(x,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> half=<span class="number">1</span>,<span class="built_in">step</span>=<span class="number">2</span>;half!=len;half&lt;&lt;=<span class="number">1</span>,<span class="built_in">step</span>&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        BI wn = powmod(g,len/<span class="built_in">step</span>,FM);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="built_in">step</span>)&#123;</span><br><span class="line">            <span class="function">BI <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;i+half;++j)&#123;</span><br><span class="line">                BI t=(w*x[j+half])%FM;</span><br><span class="line">                x[j+half]=(FM-t+x[j])%FM;</span><br><span class="line">                x[j]=(x[j]+t)%FM;</span><br><span class="line">                w = w*wn%FM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stand</span><span class="params">(BI *a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*n;i&gt;n;--i)&#123;</span><br><span class="line">        a[i<span class="number">-1</span>]=(a[i<span class="number">-1</span>]+a[i])%mod;</span><br><span class="line">        a[i-n<span class="number">-1</span>]=(a[i-n<span class="number">-1</span>]+a[i])%mod;</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">square</span><span class="params">(BI *a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(<span class="number">2</span>*n+<span class="number">1</span>));</span><br><span class="line">    nft(a,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        a[i]=a[i]*a[i]%FM;</span><br><span class="line">    &#125;</span><br><span class="line">    nft(a,len,<span class="number">1</span>);</span><br><span class="line">    stand(a,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(BI *a,BI *b,<span class="keyword">int</span> na,<span class="keyword">int</span> nb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz((na+nb)+<span class="number">1</span>));</span><br><span class="line">    nft(a,len);nft(b,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        a[i] = a[i]*b[i]%FM;</span><br><span class="line">    &#125;</span><br><span class="line">    nft(b,len,<span class="number">1</span>);nft(a,len,<span class="number">1</span>);</span><br><span class="line">    stand(a,na);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initC</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        ans[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=<span class="number">2</span>*m;++i)&#123;</span><br><span class="line">        ans[i] = (ans[i<span class="number">-1</span>]+ans[i-m<span class="number">-1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(r,<span class="number">0</span>,<span class="keyword">sizeof</span>(r));</span><br><span class="line">    r[<span class="number">0</span>]=a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(LL n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    initC(m);</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) mul(r,a,m,m);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>; square(a,m);</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        ret+=(r[i]*ans[i+m])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("m","w",stdout);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;powmod(<span class="number">2L</span>L,n,mod)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;=m)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;getans(n-m,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求-m-阶线性递推关系式第-n-项"><a href="#求-m-阶线性递推关系式第-n-项" class="headerlink" title="求$m$阶线性递推关系式第$n$项"></a>求$m$阶线性递推关系式第$n$项</h2><blockquote>
<p>参考：<a href="https://wenku.baidu.com/view/bac23be1c8d376eeafaa3111.html" target="_blank" rel="noopener">2013/03/02 线性递推关系和矩阵乘法</a></p>
<p><strong>上面文献的意义</strong>：矩阵加速已经成为过去式了，多项式加速时代的到来，NFT 加速多项式的时代到来。</p>
</blockquote>
<p>设$a_n = c_{m-1} a_{n-1} + c_{m-2} a_{n-2} + c_0 a_{n-m}$，给定了初值$a_1,a_2,\cdots,a_m$的情况下，求$a_n$</p>
<p>我们记 </p>
<script type="math/tex; mode=display">
A = \begin{pmatrix}
c_1 & c_2 &\cdots& c_m \\
1 & 0&  & 0 \\
& &\vdots&  \\
0 & \cdots &1 & 0
\end{pmatrix}</script><p>并且显然</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
a_n \\
a_{n-1} \\
\vdots \\
a_{n-m+1}
\end{pmatrix} = 
A
\begin{pmatrix}
a_{n-1} \\
a_{n-2} \\
\vdots \\
a_{n-m}
\end{pmatrix}  = 
A^{n-m}
\begin{pmatrix}
a_{m} \\
a_{m-1} \\
\vdots \\
a_{1}
\end{pmatrix}</script><p>我们就可以用矩阵乘法在$O(m^3 \log n) $ 解决这个问题了。</p>
<p><strong>但线性递推关系式可以不用矩阵优化到</strong> $O(m^2 \log n)$ ：</p>
<p>显然 $A$ 的特征多项式$f(x) = x^m - c_1 x^{m-1}- \cdots -c_m$，所以 $A^n = c_{m-1} A^{n-1} + \cdots c_0 I$，也就是说$A^n$ 可以由 $A^{m-1},A^{m-2},\cdots,I $ 线性表出，而 $A^{n_1+n_2} = A^{n1}A^{n_2}$然后运算就是卷积运算，相当于多项式乘法！也就是说我们可以在$O(m^2 \log n)$ 时间复杂度，求出 $A^n = b_0 I + b_1 A + \cdots b_{m-1} A^{m-1}$, 注意到</p>
<script type="math/tex; mode=display">
A^i \begin{pmatrix}
a_{m} \\
a_{m-1} \\
\vdots \\
a_{1}
\end{pmatrix} =
\begin{pmatrix}
a_{i+m} \\
a_{i+m-1} \\
\vdots \\
a_{i+1}
\end{pmatrix}</script><p>所以我们只需预处理出$a_1,\cdots,a_{2m-1}$ 这 $2m-1$个数即可。</p>
<blockquote>
<p>这也提供了一般$m$ 阶矩阵的$n$ 次方的一个 $O(m^3+m^2\log n)$ 的算法！！！卧槽！我也太帅了吧。</p>
</blockquote>
<p><del>最后如果递推关系中仅有常数个$c_i$不为 0，此时还能用 NFT（数论快速变换）</del> 利用<a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">多项式带模除法: Division with remainder</a> 的 $O(m \log m) $ 算法，上述算法可以优化到$O(m\log m \log n + m^2)$，（暂时不知道如何去掉$m^2$）但是写法太复杂。搞定！参考<a href="https://oi-wiki.org/math/linear-recurrence/" target="_blank" rel="noopener">这里</a>，不要涉及矩阵</p>
<p>注意到一次乘法之后，会变成$I,A,\cdots A^{2m-1}$ 的线性组合，$A^{m},\cdots A^{2m-1}$这$m$个要再用前$m$线性表出，由于$c_i$ 仅有常数个不为 0，可以 $O(m)$复杂度把他们写成前 $m$ 个的线性组合。</p>
<blockquote>
<p>当$m&gt;10^4$时，我们就有必要写带 NFT 的版本了（NFT 模板可以在我博客中找到）有需求的时候再写吧。</p>
</blockquote>
<h2 id="sum-i-equiv-r-pmod-m-binom-n-i-mod-M"><a href="#sum-i-equiv-r-pmod-m-binom-n-i-mod-M" class="headerlink" title="$\sum_{i \equiv r \pmod{m}} \binom{n}{i} \mod M $"></a>$\sum_{i \equiv r \pmod{m}} \binom{n}{i} \mod M $</h2><p>数据范围：$1 \leq n \leq 10^{18},\; 2 \leq m \leq 2000,\; 0 \leq r &lt; m,\; 10^8 &lt; M &lt; 10^9$</p>
<p>记$w$满足 $w^m = 1,w^n \neq 1, 0 &lt; n &lt; m $，则答案为 $\frac{1}{m}\sum_{i=0}^{m-1}F(w^i)$，其中 $F(x) = x^{m-r}(1+x)^n \mod x^{m}-1$</p>
<p>假设$ F(x) = \sum_{i=0}^{m-1} a_i x^i $，则答案就是$a_0 $，即答案是$F(0)$</p>
<p>这个跟上面一样本质是一样的，做带模的多项式运算。</p>
<blockquote>
<p>参考：<a href="https://codeforces.ml/blog/zscoder" target="_blank" rel="noopener">zscoder 的博客</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poly</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">2003</span>;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    LL a[N];</span><br><span class="line">    Poly(<span class="keyword">int</span> _d):d(_d)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Poly <span class="keyword">operator</span>*(Poly &amp;A)&#123;</span><br><span class="line">        <span class="function">Poly <span class="title">R</span><span class="params">(d+A.d)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=d;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=A.d;++j)&#123;</span><br><span class="line">                R[i+j] += a[i]*A[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Poly <span class="title">mulmod</span><span class="params">(Poly &amp;A,Poly &amp;B,<span class="keyword">int</span> m,LL mod)</span></span>&#123;</span><br><span class="line">    Poly R = A*B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=R.d;i&gt;=m;--i)&#123;</span><br><span class="line">        R[i-m] += R[i];</span><br><span class="line">        R[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R.d = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        R[i]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">powmod</span><span class="params">(T x,U n,<span class="keyword">int</span> m,LL mod)</span></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">r</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=mulmod(r,x,m,mod);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=mulmod(x,x,m,mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    LL n,r,mod;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;mod)&#123;</span><br><span class="line">        <span class="function">Poly <span class="title">A</span><span class="params">(m<span class="number">-1</span>)</span></span>;</span><br><span class="line">        A[<span class="number">0</span>]=A[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        Poly R = powmod(A,n,m,mod);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(R[r%m]*m%mod)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合数倒数交错和"><a href="#组合数倒数交错和" class="headerlink" title="组合数倒数交错和"></a>组合数倒数交错和</h2><p>$ \sum_{i=0}^n \frac{(-1)^i}{{n \choose i}}$</p>
<p>考虑积分$F(n,m) = \int _0^1 x^m (1-x)^{n-m} dx $，显然 $F(n,m)=F(n,n-m),F(n,0) = \frac{1}{n+1} $<br>且分部积分即可知道 $F(n,m) = \frac{m}{n-m+1} F(n,m-1) = \frac{1}{(n+1){n \choose m}} $，再等比数列求和就有</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n \frac{(-1)^i}{{n \choose i}} = (n+1) \int _0 ^1 \sum _{i=0} ^n (-x)^ i (1-x)^ {n-i} dx = (n+1) \int _0 ^1 (1-x)^{n+1}-(-x)^{n+1}dx = \frac{n+1}{n+2} (1+(-1)^n)</script><h2 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h2>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>数论函数的 Dirichlet 积</title>
    <url>/dirichletProduct/</url>
    <content><![CDATA[<p>最近重温潘承洞老先生的《数论基础》(现代数学基础丛书 34)，确实是经典中的经典。以现代的眼光看数论函数，使得分析问题更加简洁本质，而这些都要归功于 Dirichlet 积的引入。</p>
<a id="more"></a>
<h2 id="常见数论函数"><a href="#常见数论函数" class="headerlink" title="常见数论函数"></a>常见数论函数</h2><p>为了更好的介绍 Dirichlet 积，先引入一些记号，数论函数是指定义于全体正整数集上的函数。</p>
<ol>
<li><p>$u(n) \equiv 1$</p>
</li>
<li><p>$e(n) = n$</p>
</li>
<li><p>$I(n) = \left\{\begin{array}{ll} 1, &amp; n=1, \\ 0, &amp; n&gt;1. \end{array} \right.$</p>
</li>
<li><p>$n$ 的所有正除数的个数 $d(n)$.</p>
<script type="math/tex; mode=display">
d(n)= \sum_{d|n} 1 = (a_1+1)(a_2+1) \cdots (a_n+1), \; n=p_1^{a_1} \cdots p_s^{a_s}</script></li>
<li><p>$n$ 的全部素因子的个数（按重数计）$\Omega(n)$</p>
<script type="math/tex; mode=display">
\begin{array}{ll} \Omega(1)=0 & \\
\Omega(n) = a_1 + a_2+ \cdots a_n, & n=p_1^{a_1} \cdots p_s^{a_s} \end{array}</script></li>
<li><p>$n$ 的不同素因子的个数 $\omega(n)$</p>
<script type="math/tex; mode=display">
\begin{array}{ll} \omega(1)=0 & \\
\omega(n) = s, & n=p_1^{a_1} \cdots p_s^{a_s} \end{array}</script></li>
<li><p>$n$ 的正除数的幂和函数 $\sigma_{\lambda}(n) = \sum_{d|n} d^{\lambda}$</p>
</li>
<li><p>所有不超过 $n$ 且和 $n$ 互素的正整数的个数 $\psi(n)$</p>
<script type="math/tex; mode=display">
\psi(n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } 1</script><p>$\psi(n)$ 称之为 Euler 函数。</p>
</li>
<li><p>Mobius 函数 $\mu(n)$</p>
<script type="math/tex; mode=display">
\mu(n) = \left\{\begin{array}{ll} 1, & n=1, \\ (-1)^s, & n=p_1p_2 \cdots p_s, \; p_1 < p_2< \cdots < p_s. \\
0, & else. \end{array} \right.</script></li>
<li><p>Mangoldt 函数 $\Lambda(n)$</p>
<script type="math/tex; mode=display">
\Lambda(n) = \left\{\begin{array}{ll} \log p, & n= p^k, k \geq 1\\
0, & else. \end{array} \right.</script></li>
<li><p>Liouville 函数 $\lambda(n) = (-1)^{\Omega(n)}$</p>
</li>
<li><p>Euler 函数的推广(自创 dna0.49) $\psi _{\lambda}(n)$</p>
<script type="math/tex; mode=display">
\psi _{\lambda} (n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } d^{\lambda}</script><p>当 $\lambda = 0$ 时即为 Euler 函数。</p>
</li>
<li><p>$M(n)=\sum_{i=1}^n \mu(i)$，则我们有 $\sum_{i=1} ^n M(\lfloor \frac{n}{i} \rfloor) = 1$</p>
</li>
<li><p>$N(n)=\sum_{i=1}^n \psi(i)$，我们有</p>
<script type="math/tex; mode=display">
\sum_{i=1} ^n N(\lfloor \frac{n}{i} \rfloor) = \frac{n(n+1)}{2}</script></li>
</ol>
<blockquote>
<p>上面 $M(n), N(n)$ 的计算公式见下面 <strong>广义 Dirichlet 积</strong> 以及 <a href="/algorithmsOfRootComplex/" title="这篇博文">这篇博文</a>。</p>
</blockquote>
<p>用下面的 Dirichlet 积的概念，大家就会对上面常见的数论函数有更深刻的认识。</p>
<h2 id="Dirichlet-积"><a href="#Dirichlet-积" class="headerlink" title="Dirichlet 积"></a>Dirichlet 积</h2><p>设$f(n)$,$g(n)$是两个数论函数，则</p>
<script type="math/tex; mode=display">
h(n) = \sum_{d|n} f(d)g(\frac{n}{d})</script><p>称为$f(n)$和$g(n)$的 Dirichlet 积,记作$h=f \star g$.</p>
<h3 id="定理-1-Dirichlet-积满足交换律和结合律即"><a href="#定理-1-Dirichlet-积满足交换律和结合律即" class="headerlink" title="定理 1 Dirichlet 积满足交换律和结合律即"></a>定理 1 Dirichlet 积满足交换律和结合律即</h3><ol>
<li>交换律： $f \star g = g \star f$</li>
<li>结合律： $(f\star g) \star h = f \star (g \star h)$</li>
</ol>
<h3 id="定理-2-Dirichlet-积的幺元存在为-I-n"><a href="#定理-2-Dirichlet-积的幺元存在为-I-n" class="headerlink" title="定理 2 Dirichlet 积的幺元存在为 $I(n)$"></a>定理 2 Dirichlet 积的幺元存在为 $I(n)$</h3><ul>
<li>由 <strong>定理 1</strong> 和 <strong>定理 2</strong> 知。数论函数全体关于 Dirichlet 积构成了一个含幺交换半群(Commutative Monoid)</li>
<li>由抽象代数的基本知识知道 Monoid 中的元如果存在逆元必然唯一，证明也是显然的</li>
<li>现在的问题就是这个 Monoid 那些元有逆元( Dirichlet 逆，以下简称逆)。或者说一个数论函数可逆的充要条件是什么。</li>
</ul>
<p>实际上，我们有如下结论</p>
<h3 id="定理-3-数论函数-f-可逆的充要条件是-f-1-neq-0-此时它的逆元为"><a href="#定理-3-数论函数-f-可逆的充要条件是-f-1-neq-0-此时它的逆元为" class="headerlink" title="定理 3 数论函数 $f$ 可逆的充要条件是 $f(1) \neq 0$.此时它的逆元为"></a>定理 3 数论函数 $f$ 可逆的充要条件是 $f(1) \neq 0$.此时它的逆元为</h3><script type="math/tex; mode=display">
f^{-1} (1) = \frac{1}{f(1)},\quad
f^{-1} (n) = \frac{-1}{f(1)} \sum _{d|n,\, d<n} f(\frac{n}{d})f^{-1}(d),\; n>1</script><p>证明是显然的，验算即知。</p>
<blockquote>
<p>至此从抽象的层次已经对数论函数的 Dirichlet 积有了一个清晰的认识，下面用这套语言考虑我们的常见函数</p>
</blockquote>
<h3 id="定理-4-Mobius-函数-mu-n-是-u-n-的逆，即"><a href="#定理-4-Mobius-函数-mu-n-是-u-n-的逆，即" class="headerlink" title="定理 4 Mobius 函数 $\mu(n)$ 是 $u(n)$ 的逆，即"></a>定理 4 Mobius 函数 $\mu(n)$ 是 $u(n)$ 的逆，即</h3><script type="math/tex; mode=display">
\sum_{ d|n } \mu(n) = \left\{ \begin{array}{ll}  1, & n=1, \\
0, & n>1. \end{array} \right.</script><p><strong>Proof</strong> : $n=1$ 时显然，不妨设 $n = p_1^{a_1} p_2^{a_2} \cdots p_s^{a_s} &gt; 0$ 则由 $\mu(n)$ 的定义</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\sum_{ d|n } \mu(n) & = \mu(1) + \mu(p_1) + \mu(p_2) + \cdots +\mu(p_s) + \cdots + \mu(p_1 p_2) + \cdots \\
& \quad + \mu(p_{s-1}p_s) + \cdots \mu(p_1 p_2 \cdots p_s) \\
& =  1 + {s \choose 1} (-1) + {s \choose 2} (-1)^2 + \cdots + {s \choose s} (-1)^s \\
&= (1-1)^s = 0 \end{array}</script><blockquote>
<p>由此可见，原来看上去复杂的不知所以然的 Mobius 函数本质上是恒为 1 的函数的 Dirichlet 逆元。</p>
</blockquote>
<h3 id="定义-5-若-F-f-star-u-则称-F-是-f-的-Mobius-变换，即"><a href="#定义-5-若-F-f-star-u-则称-F-是-f-的-Mobius-变换，即" class="headerlink" title="定义 5 若 $F=f \star u$ 则称 $F$ 是 $f$ 的 Mobius 变换，即"></a>定义 5 若 $F=f \star u$ 则称 $F$ 是 $f$ 的 Mobius 变换，即</h3><script type="math/tex; mode=display">
F(n) = \sum_{d|n} f(d)</script><p>显然此时我们有 $f=F * \mu$, 称 $f$ 是 $F$ 的 Mobius 反变换。<br>实际上，这就是我们常说的 Mobius 反演公式。</p>
<script type="math/tex; mode=display">
F(n) = \sum_{d|n} f(d) \Longleftrightarrow f(n) = \sum_{d|n} F(d) \mu(\frac{n}{d})</script><p>Mobius 变换的例子</p>
<ol>
<li>$I(n)$ 是 $\mu(n)$ 的 Mobius 变换</li>
<li>$d(n)$ 是 $u(n)$ 的 Mobius 变换</li>
<li>$e(n)$ 是 $\psi(n)$ 的 Mobius 变换</li>
<li>$\log n$ 是 $\Lambda(n)$ 的 Mobius 变换</li>
</ol>
<p>前两个由定义显然，后面两个证明如下。</p>
<script type="math/tex; mode=display">
n = \sum _{i=1} ^n 1 =
\sum _{d|n} \sum_{(n,i) = d} 1 =
\sum _{d|n} \sum_{(\frac{n}{d},k)=1} 1 =
\sum _{d|n} \psi(\frac{n}{d}) = \sum _{d|n} \psi(d)</script><p>因此</p>
<script type="math/tex; mode=display">
\psi(n) = \sum _{d|n} \mu(d) \frac{n}{d} = n \sum _{d|n} \frac{\mu(d)}{d}</script><p>另外我们还有一个证明方式</p>
<script type="math/tex; mode=display">
\psi(n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } 1 ＝ \sum_{1 \leq d \leq n} \sum_{l|(d,n)} \mu(l) = \sum _{l|n} \mu(l) \sum _{1 \leq d \leq n , l|d} 1 = \sum _{l|n} \mu(l) \frac{n}{l}</script><blockquote>
<p>上述两种证明都是两种常用处理数论函数的技术手段。</p>
</blockquote>
<p>至于 $\log n$ 是 $\Lambda(n)$ 的 Mobius 变换的证明只需验算即知。</p>
<p>用上面所说的技术，我们来考虑一下推广的 Euler 函数 $\psi _{\lambda}$</p>
<script type="math/tex; mode=display">
\sum _{i=1} ^n i^{\lambda} =
\sum _{d|n} \sum_{(n,i) = d} i^{\lambda}  =
\sum _{d|n} d^{\lambda} \sum_{(\frac{n}{d},k)=1} k^{\lambda}  =
\sum _{d|n} d^{\lambda} \psi _{\lambda} (\frac{n}{d}) =
n^{\lambda} * \psi _{\lambda}</script><h3 id="可乘函数"><a href="#可乘函数" class="headerlink" title="可乘函数"></a>可乘函数</h3><p>寻找不变量一直是数学关心的问题，变化中的不变量，可以大大简化运算，并且反过来刻画了变化。具体说，寻找 Dirichlet 积不变量一方面对于那些不变量，可以简化它们操作，另一方面，由于 Dirichlet 积保持这些性质也就刻画了 Dirichlet 本身。其中这样的一个不变量就是可乘函数。</p>
<p>设 $f(n)$ 是定义在全体自然数上不恒为 0 的数论函数，若它满足条件</p>
<script type="math/tex; mode=display">
f(mn) = f(m) f(n), \quad (m,n)=1</script><p>则称之为可乘函数。若对任意正整数 $m,n$ 恒有</p>
<script type="math/tex; mode=display">
f(mn) = f(m) f(n)</script><p>则称之为完全可乘函数。</p>
<p>可乘函数例子： $\mu(n)$, $d(n)$.<br>完全可乘函数例子： $n^{\lambda}$, $I(n)$.</p>
<blockquote>
<p>显然(完全)可乘函数的的积，倒数(如果有意义的话)都是(完全)可乘函数。</p>
</blockquote>
<h3 id="定理-6-可乘函数-f-n-有如下性质"><a href="#定理-6-可乘函数-f-n-有如下性质" class="headerlink" title="定理 6 可乘函数 $f(n)$ 有如下性质"></a>定理 6 可乘函数 $f(n)$ 有如下性质</h3><ol>
<li>$f(1)=1$</li>
<li>$f(n)=f(p_1^{a_1}) f(p_2)^{a_2} \cdots f(p_s)^{a_s}, \quad n = p_1^{a_1} p_2^{a_2} \cdots p_s^{a_s}$</li>
<li>$f(n)$ 为完全可乘的充要条件是对任意的 $p$ 和 $k \geq 1$ 恒有<script type="math/tex; mode=display">f(p^k) = f ^k (p)</script></li>
<li>$f((m,n)[m,n])=f(m)f(n)$</li>
<li>$f$的逆元必然存在</li>
<li>$f$的 Mobius 变换也可逆</li>
</ol>
<blockquote>
<p>上述定理的证明是显然的，结论是重要的。</p>
</blockquote>
<h3 id="定理七-Dirchlet-积-保持可乘性"><a href="#定理七-Dirchlet-积-保持可乘性" class="headerlink" title="定理七 Dirchlet 积 保持可乘性"></a>定理七 Dirchlet 积 保持可乘性</h3><ol>
<li>若 $f$ 可乘, $g$ 可乘, 则 $h=f \star g$ 可乘;</li>
<li>若 $g$ 可乘, $h=f \star g$ 可乘，则 $f$ 可乘.</li>
</ol>
<p><strong>Proof</strong>:</p>
<ol>
<li>若 $f$ 可乘, $g$ 可乘, 则对任意满足 $(m,n)=1$ 的正整数 $m,n$,对于 $mn$ 的每一个正因子 $d$ 可以分解为 $d=d_1 d_2$ 的形式, 其中 $(d_1,d_2)=1, d_1|m, d_2|n$</li>
</ol>
<script type="math/tex; mode=display">
  h(mn) = \sum _{d|mn} f(d)g(\frac{mn}{d}) = \sum _{d_1|m} f(d_1)g(\frac{m}{d_1}) \sum _{d_2|n} f(d_2)g(\frac{n}{d_2}) = h(m)h(n)</script><ol>
<li>反证，若 $f$ 不可乘，则可以推出$h$不可乘即可。若 $f$ 不可乘,则必存在 $m,n$,$(m,n)=1$ 但是</li>
</ol>
<script type="math/tex; mode=display">
  f(mn) \neq f(m)f(n)</script><p>若 $mn=1$ , 则 $f(1) \neq f(1) f(1)$ 知 $f(1) \neq 1$. 因此 $h(1)=f(1)g(1)=f(1) \neq 1$ 矛盾于 $h$ 可乘。<br>我们选取满足上述性质的最小正整数 $mn$,即当 $d_1d_2&lt;mn$ 是恒有</p>
<script type="math/tex; mode=display">
f(d_1d_2) = f(d_1)f(d_2),\quad (d_1,d_2)=1</script><p>由 $h$ 的定义</p>
<script type="math/tex; mode=display">
\begin{array}{cl}
h(mn) = \sum_{d \mid mn} f(d) g(\frac{mn}{d}) &=
\sum_{d_1 \mid m} f(d_1) g(\frac{m}{d_1}) \sum_{d_2|m} f(d_2)g(\frac{n}{d_2}) - f(m)f(n) + f(mn) \\
&= h(m)h(n) - f(m)f(n) + f(mn) \neq h(m)h(n)
\end{array}</script><p>证毕。</p>
<blockquote>
<p>Dirichlet 积一般不保持完全可乘性。</p>
</blockquote>
<p>由 <strong>定理 6</strong> 和 <strong>定理 7</strong>，我们有如下推论: 若 $F$ 是 $f$ 的 Mobius 变换，则</p>
<ol>
<li><p>$f$ 可乘 $\Longleftrightarrow$ $F$ 可乘</p>
</li>
<li><p>$f$ 可乘，则</p>
</li>
</ol>
<script type="math/tex; mode=display">
F(n) = \sum_{d|n} f(d) =
    \prod _{p^a || n} (1+ f(p)+\cdots f(p^a))</script><ol>
<li>$f$ 可乘，则</li>
</ol>
<script type="math/tex; mode=display">
\sum _{d|n} \mu(d) f(d) = \prod _{p | n} (1 - f(p))</script><blockquote>
<p>上面 1 是定理 7.1 的直接推论，2 可由定理 6.2 的直接推论，3 是 2 的直接推论。由 3 我们可以得到著名的欧拉公式：</p>
</blockquote>
<script type="math/tex; mode=display">
\psi(n) = n \sum _{d|n} \frac{\mu(d)}{d} ＝ n \prod _{p|n} (1-\frac{1}{p})</script><h3 id="完全可乘的逆"><a href="#完全可乘的逆" class="headerlink" title="完全可乘的逆"></a>完全可乘的逆</h3><p>由于可乘函数满足 $f(1)=1$ 因此可乘函数的逆相对而言更加简单，并且它的逆也是可乘函数。但是计算逆的过程仍然很复杂，但是完全可乘函数的逆却特别简单。</p>
<h3 id="定理-8-设-f-可乘，则-f-完全可乘的充要条件是"><a href="#定理-8-设-f-可乘，则-f-完全可乘的充要条件是" class="headerlink" title="定理 8 设 $f$ 可乘，则 $f$ 完全可乘的充要条件是"></a>定理 8 设 $f$ 可乘，则 $f$ 完全可乘的充要条件是</h3><script type="math/tex; mode=display">
f^{-1}(n) = \mu(n)f(n)</script><h3 id="推广的-Mobius-反演公式"><a href="#推广的-Mobius-反演公式" class="headerlink" title="推广的 Mobius 反演公式"></a>推广的 Mobius 反演公式</h3><p>设 $g$ 完全可乘, $h= f \star g$ ,则 $f= h \star \mu g$，即</p>
<script type="math/tex; mode=display">
h(n) = \sum _{d|n} f(d)g(\frac{n}{d})
\quad \Longleftrightarrow \quad f(n) = \sum _{d|n} h(d)
\mu(\frac{n}{d})g(\frac{n}{d})</script><p>另上式中 $g=u$，上式就变成了 Mobius 反演公式。<br>由推广的 Mobius 反演公式，我们由</p>
<script type="math/tex; mode=display">
\sum _{i=1} ^n i^{\lambda} = n^{\lambda} \star \psi _{\lambda}</script><p>可知</p>
<script type="math/tex; mode=display">
\psi_{\lambda}(n) = (\sum _{i=1} ^n i^{\lambda}) \star \mu(n) n^{\lambda}</script><h2 id="广义-Dirichlet-积"><a href="#广义-Dirichlet-积" class="headerlink" title="广义 Dirichlet 积"></a>广义 Dirichlet 积</h2><p>考虑和式</p>
<script type="math/tex; mode=display">
G(x) = \sum_{n \leq x} f(n)H(\frac{x}{n})</script><p>其中 $f(n)$ 是数论函数，$H(x)$ 是 $(0,\infty)$上的函数。<br>我们记 $G = f o H$。特别的若$H(x)$在所有非整数点取值为$0$，则此时就是通常的 Dirichlet 积。<br>我们有以下性质：</p>
<script type="math/tex; mode=display">
f o (g o H) = (f*g) o H</script><p>若 $G = f o H$ 则 $H = f^{-1} o G$。<br>特别的，若 $G(x) = \sum_{n \leq x} H(\frac{x}{n})$, 则我们有</p>
<script type="math/tex; mode=display">
H(x) = \sum_{n \leq x} \mu(n) G(\frac{x}{n})</script><h4 id="一个技巧相当强大的公式-Q-x-sum-n-leq-x-mu-n-，显然表示不超过-x-的无平方因子的正整数个数，则"><a href="#一个技巧相当强大的公式-Q-x-sum-n-leq-x-mu-n-，显然表示不超过-x-的无平方因子的正整数个数，则" class="headerlink" title="一个技巧相当强大的公式 $Q(x)=\sum_{n \leq x} |\mu(n)|$，显然表示不超过 $x$ 的无平方因子的正整数个数，则"></a>一个技巧相当强大的公式 $Q(x)=\sum_{n \leq x} |\mu(n)|$，显然表示不超过 $x$ 的无平方因子的正整数个数，则</h4><script type="math/tex; mode=display">
Q(x) = \frac{6}{\pi^2} x + O(\sqrt{x})</script><p><strong>Proof</strong> ：显然我们有</p>
<script type="math/tex; mode=display">
\lfloor x \rfloor = \sum_{k \leq \sqrt{x}} Q(\frac{x}{k^2})</script><p>另一方面</p>
<script type="math/tex; mode=display">
Q(x) = \sum_{n \leq \sqrt{x}} Q(\frac{x}{n^2}) \sum_{d \mid n} \mu(d) =  \sum_{d \leq \sqrt{x}} \mu(d) \sum_{ k \leq \sqrt{\frac{x}{d^2}} } Q(\frac{x}{d^2k^2})</script><p>所以</p>
<script type="math/tex; mode=display">
\sum_{n \leq x} |\mu(n)| =  Q(x) =  \sum_{d \leq \sqrt{x}} \mu(d) \lfloor \frac{x}{d^2} \rfloor</script><p>根据上式</p>
<script type="math/tex; mode=display">
Q(x) = x \sum_{d=1}^{\infty} \frac{\mu(d)}{d^2} +O(\sqrt{x}) = \frac{6}{\pi^2} x + O(\sqrt{x})</script><h2 id="三个优美公式"><a href="#三个优美公式" class="headerlink" title="三个优美公式"></a>三个优美公式</h2><p>最后我用三个我很喜欢的公式结束这篇博文。</p>
<ol>
<li>$\sum_{n \leq x} d(n) = \sum_{n \leq x} \lfloor \frac{x}{n} \rfloor$</li>
</ol>
<script type="math/tex; mode=display">
\sum_{n \leq x} \lfloor \frac{x}{n} \rfloor =
\sum_{n \leq x} \sum_{l \leq x,\; n|l} 1 =
\sum_{l \leq x} \sum_{n|l} 1 =
\sum_{l \leq x} d(l) =
\sum_{n \leq x} d(n)</script><ol>
<li>$\sum _{n \leq x} \mu(n) \lfloor \frac{x}{n} \rfloor = 1$</li>
</ol>
<script type="math/tex; mode=display">
\sum _{n \leq x} \mu(n) \lfloor \frac{x}{n} \rfloor =
\sum _{n \leq x} \mu(n) \sum _{l \leq x,\; n|l} 1 =
\sum _{l \leq x} \sum _{n|l} \mu(n) = \sum _{l \leq x} I(n) = 1</script><ol>
<li>$\sum _{n=1} ^{\infty} \frac{\mu(n)}{n^2} = \frac{6}{\pi^2} $</li>
</ol>
<p><strong>Proof</strong>:</p>
<script type="math/tex; mode=display">
\sum _{n=1} ^{\infty} \frac{1}{n^2} \sum_{n=1} ^{\infty} \frac{\mu(n)}{n^2} = \sum_{n=1} ^{\infty} \frac{a_n}{n^2}</script><p>其中 $a_n = \sum _{d|n} \mu(d) = I(n)$，又由 $\sum _{n=1} ^{\infty} \frac{1}{n^2} = \frac{\pi^2}{6}$ 结论显然。</p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/dynamicProgramming/</url>
    <content><![CDATA[<p>动态规划是研究一大类问题（特别是最值问题）的一种思路。从大二刚开始 ICPC 竞赛的时候第一次遇到，到大三学运筹学系统的了解，再到后来一直成为解决问题的一种思考方式。可以说动态规划真的是万金油的方法。</p>
<p>计算机领域（或者说博弈论）中的动态规划，就如同数学中的数学归纳法，一样重要。</p>
<blockquote>
<p>运用动态规划的能力，就好比武侠小说中的内功，是随着时间慢慢累积的。</p>
</blockquote>
<a id="more"></a>
<h2 id="动态规划应用举例"><a href="#动态规划应用举例" class="headerlink" title="动态规划应用举例"></a>动态规划应用举例</h2><ul>
<li>数列的递推关系</li>
<li>背包问题</li>
<li>图论中 ，Dijkstra 算法</li>
<li>流水线问题，旅行商问题</li>
<li>其它杂类问题</li>
</ul>
<h2 id="动态规划原理"><a href="#动态规划原理" class="headerlink" title="动态规划原理"></a>动态规划原理</h2><p>动态规划（dynamic programming）于 1950s 被 Richard Bellman 发现。<a href="https://www.zhihu.com/question/23995189/answer/35324479" target="_blank" rel="noopener">引用这里的话</a>，动态规划本质就是：</p>
<ul>
<li>定义问题的状态（必须满足”无后效性”：这个就很玄学了）</li>
<li>写出状态间的转移方程</li>
</ul>
<p>从而递推（分治）的解决问题。</p>
<blockquote>
<p>难点就在于定义问题的状态</p>
<p>很多时候一个变量的问题，我们需要强行加一个（甚至两个）变量来定义状态</p>
<p>然后给出状态转移方程，再做时间空间的优化。</p>
</blockquote>
<h2 id="常规动态规划的状态定义"><a href="#常规动态规划的状态定义" class="headerlink" title="常规动态规划的状态定义"></a>常规动态规划的状态定义</h2><ul>
<li>以该位置结尾的最优策略</li>
<li>多设一个变量的最优策略</li>
</ul>
<h2 id="动态规划举例（长期更新）"><a href="#动态规划举例（长期更新）" class="headerlink" title="动态规划举例（长期更新）"></a>动态规划举例（长期更新）</h2><h3 id="codeforces1354F"><a href="#codeforces1354F" class="headerlink" title="codeforces1354F"></a><a href="https://codeforces.ml/problemset/problem/1354/F" target="_blank" rel="noopener">codeforces1354F</a></h3><p>有 $n$ 张牌，$i$ 号牌的数值是 $a_i$，当 $i$ 号牌放入桌上，之前在桌上的牌，每张数值增加 $b_i$，桌上的牌可以销毁（每张牌最多销毁一次），但是桌上牌的数量不能超过 $k$。 问使桌上牌数值总和最大的放法。其中数据满足</p>
<script type="math/tex; mode=display">
1 \leq k \leq n,\; 1 \leq a_i \leq N,\; 0 \leq b_i \leq N = 10^5, \; a_i,b_i,n,k \in \mathbb{N}</script><blockquote>
<p>由于牌的编号于问题无关，所以不妨设 $b_i$ 单调递增。</p>
</blockquote>
<p>状态定义：$dp[i][j]$ 表示：场上前 $j$ 张牌数（编号都不超过 $i$ ）的桌面牌总和最大值（其实还要减去后 $k-j$ 张牌的原始面值）。如果不减去就有后效性了！！！</p>
<p>状态转移：我们考虑第 $i$ 张牌，</p>
<ul>
<li>如果将它最终留在桌面上，那么它一定是最后一张放在桌面上的，因为 $b_i$ 单调递增。此时 $dp[i][j] = dp[i-1][j-1]+(j-1)b[i] + a[i]$</li>
<li>如果它没留在桌面，那么它一定会在后来第 $k$ 张牌加过 buff，$dp[i][j] = dp[i-1][j] + (k-1)b[i]$</li>
</ul>
<p>所以</p>
<script type="math/tex; mode=display">
dp[i][j] = \max(dp[i-1][j-1]+(j-1)b[i]+a[i],\; dp[i-1][j]+(k-1)b[i])</script><p>我们可以用 $isin[i][j]$ 来标记桌上第 $j$ 张牌是否是 $i$ 号牌。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">bool</span> isin[N][N],chose[N];</span><br><span class="line"><span class="keyword">using</span> node = tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line">node q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+(k<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;i &amp;&amp; j&lt;=k;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = dp[i<span class="number">-1</span>][j]+(k<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i]);</span><br><span class="line">            <span class="keyword">int</span> y = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(j<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i])+<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(q[i]);</span><br><span class="line">            <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">                dp[i][j] = x;</span><br><span class="line">                isin[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = y;</span><br><span class="line">                isin[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=k)&#123;</span><br><span class="line">            dp[i][i] = dp[i<span class="number">-1</span>][i<span class="number">-1</span>]+(i<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i])+<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(q[i]);</span><br><span class="line">            isin[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n,j=k;i;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isin[i][j])&#123;</span><br><span class="line">            chose[i]=<span class="literal">true</span>;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            chose[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas,n,k,a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            q[i] = &#123;i,a,b&#125;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        sort(q+<span class="number">1</span>,q+n+<span class="number">1</span>,[](<span class="keyword">const</span> node &amp; x, <span class="keyword">const</span> node &amp; y)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(x)&lt;<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(y);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(<span class="number">2</span>*n-k)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        getans(n,k);</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chose[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(++last == k)&#123;</span><br><span class="line">                    last = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!chose[i])  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>&lt;&lt;-<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[last])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hdu-5691"><a href="#hdu-5691" class="headerlink" title="hdu 5691"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5691" target="_blank" rel="noopener">hdu 5691</a></h3><p>这题大意：给你一些数，数值固定，部分数的位置随意调节，问你如何调解使得下式取值最大</p>
<script type="math/tex; mode=display">
a_0 a_1 + a_1 a_2 + \cdots + a_{n-1} a_n</script><p>这确实是经典的状态转移问题：</p>
<p>设 $i$ 的 2 进制表示是 $0 \cdots 0 i_1 0 \cdots 0 i_x 0\cdots 0$ 有 $x$ 位。<br>$dp[i][j]$ 表示前 $x$ 个空 分别填了 $a[i_1],a[i_2],\cdots,a[i_x]$ 的一个排列 且 $i_x = j$ 使目标最大的最大值。<br>那么，自然地有 </p>
<script type="math/tex; mode=display">
dp[i|(1<<k)][k] = max(dp[i][j]+a[j]*a[k])</script><p>详细转移见代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; <span class="keyword">if</span> (a&lt;b) a=b;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF =  <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],p[N];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, Case = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++Case);</span><br><span class="line">        <span class="keyword">int</span> n, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)    p[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,a+i, &amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x != <span class="number">-1</span>) p[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                dp[i][j] = -INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">0</span>]!=<span class="number">-1</span>)    dp[<span class="number">1</span>&lt;&lt;p[<span class="number">0</span>]][p[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)   dp[<span class="number">1</span>&lt;&lt;i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(i&amp;(<span class="number">1</span>&lt;&lt;j)))   <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;k))    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> x = __builtin_popcount(i);</span><br><span class="line">                    <span class="keyword">if</span>(p[x] == <span class="number">-1</span> || p[x] == k)&#123;</span><br><span class="line">                        upmax(dp[i|(<span class="number">1</span>&lt;&lt;k)][k], dp[i][j]+a[j]*a[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) upmax(res, dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Codeforces-1312E"><a href="#Codeforces-1312E" class="headerlink" title="Codeforces 1312E"></a><a href="https://codeforces.com/contest/1312/problem/E" target="_blank" rel="noopener">Codeforces 1312E</a></h3><p>我们用 <code>ans[i][j]</code> 表示前 <code>i</code> 个数中以 <code>j</code> 结尾的最短数列长度，并用 <code>b[i][j]</code> 保存导致它以 <code>j</code> 结尾的前缀首项的位置。那么状态转移就显然，可从代码中读取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1022</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">502</span>][N],b[<span class="number">502</span>][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans,inf,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        ans[<span class="number">0</span>][x] = <span class="number">1</span>;</span><br><span class="line">        b[<span class="number">0</span>][x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;N;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i<span class="number">-1</span>][j]!=inf)&#123;</span><br><span class="line">                    ans[i][x] = <span class="built_in">min</span>(ans[i][x],ans[i<span class="number">-1</span>][j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                b[i][x]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> s = i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(s&gt;=<span class="number">0</span>&amp;&amp;ans[s][x]!=inf)&#123;</span><br><span class="line">                ans[i][x+<span class="number">1</span>] = ans[s][x];</span><br><span class="line">                b[i][x+<span class="number">1</span>] = b[s][x];</span><br><span class="line">                s = b[s][x]<span class="number">-1</span>;</span><br><span class="line">                ++x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">            r = <span class="built_in">min</span>(r,ans[n<span class="number">-1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷-P1005-矩阵取数游戏"><a href="#洛谷-P1005-矩阵取数游戏" class="headerlink" title="洛谷 P1005 矩阵取数游戏"></a><a href="https://www.luogu.com.cn/problem/P1005" target="_blank" rel="noopener">洛谷 P1005 矩阵取数游戏</a></h3><blockquote>
<p>每一行单独考虑，然后因为数据范围，所以用 Python 交题</p>
<p>按照规模做 <code>dp</code>，最近做的很少，记录一哈 2020/7/4</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a)</span>:</span></span><br><span class="line">    b = a.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(a)):</span><br><span class="line">        c = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,len(b)<span class="number">-1</span>):</span><br><span class="line">            c.append(max(<span class="number">2</span>*b[j]+a[i+j],<span class="number">2</span>*b[j+<span class="number">1</span>]+a[j]))</span><br><span class="line">        b=c</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*b[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">n = int(input().split()[<span class="number">0</span>])</span><br><span class="line">r=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    r += f([int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> input().split()])</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure>
<h3 id="洛谷-T135246-「SWTR-05」Grid"><a href="#洛谷-T135246-「SWTR-05」Grid" class="headerlink" title="洛谷 T135246 「SWTR-05」Grid"></a><a href="https://www.luogu.com.cn/problem/T135246?contestId=28195" target="_blank" rel="noopener">洛谷 T135246 「SWTR-05」Grid</a></h3><p><code>dp[i][j]</code> ：第 <code>i</code> 行，以第 <code>j</code> 个数结尾的最小和， <code>s[i][j]</code> ：第 <code>i</code> 行，前 <code>j</code> 个数之和</p>
<p><code>rr[i][j]</code> ：到达 <code>i,j</code> 位置经过的数字和。 </p>
<p><code>r[i][j]</code> ：首次到达 <code>i,j</code> 位置经过格子的数字和(不包括 <code>i,j</code> 的值）初值为 <code>rr[i+1][j]</code></p>
<p><code>dp[i][j]</code> 和 <code>s[i][j]</code> 的状态转移是显然的，<code>rr[i][j]</code> 和 <code>r[i][j]</code> 状态转移：</p>
<script type="math/tex; mode=display">
r[i][j] = \min_{j \leq k<m} r[i][k] + s[i][k] - s[i][j] \\
rr[i][j] = r[i][j] + dp[i][j]</script><p>由于 <code>r[i][j]</code> 转移式的对称性，我们考虑记录 <code>s[i][j] + r[i][j]</code> 的最小值，（直接优化了一个 $O(m)$），这也是此题的经典之处。最后 <code>rr</code> 数组可被优化掉。当然也可以对 <code>r</code> 进行空间优化，<del>但是没必要</del>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    LL a[n][m],dp[n][m],s[n][m],r[n+<span class="number">1</span>][m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>) s[i][j] = a[i][j];</span><br><span class="line">            <span class="keyword">else</span> s[i][j] = s[i][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">            cur += a[i][j];</span><br><span class="line">            dp[i][j] = cur;</span><br><span class="line">            cur = <span class="built_in">min</span>(cur,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        LL mi = <span class="number">1e9</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">            r[i][j] = (i==n<span class="number">-1</span>?<span class="number">0</span>:r[i+<span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span>(r[i][j]&lt;mi-s[i][j])&#123;</span><br><span class="line">                mi = r[i][j]+s[i][j]; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r[i][j] = mi-s[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">            r[i][j] += dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = r[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;++j)&#123;</span><br><span class="line">        ret = <span class="built_in">min</span>(ret,r[<span class="number">0</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面上题的 <strong>空间优化版本（优雅的不行，需要考虑从上向下走）</strong>：</p>
<p><code>rr[j]</code> 表示上一行的答案， <code>r[j]</code> 表示当前行的答案。那么 <code>r[j]</code> 的初始值应该为 <code>rr[j]+dp[j]</code>，状态转移</p>
<script type="math/tex; mode=display">
r[j] = \min_{0 \leq k \leq j} r[k] - s[k] + s[j]</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    LL a[m],s[m],dp[m],r[m],rr[m]=&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        LL cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[j];</span><br><span class="line">            cur += a[j];</span><br><span class="line">            dp[j] = cur;</span><br><span class="line">            cur = <span class="built_in">min</span>(cur,<span class="number">0L</span>L);</span><br><span class="line">            s[j] = a[j]+(j==<span class="number">0</span>?<span class="number">0</span>:s[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = rr[<span class="number">0</span>]+dp[<span class="number">0</span>]-s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">            r[j] = <span class="built_in">min</span>(rr[j]+dp[j],cur+s[j]);</span><br><span class="line">            cur = <span class="built_in">min</span>(cur,r[j]-s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j) rr[j] = r[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*min_element(rr,rr+m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T134867-YsOI2020-归零"><a href="#T134867-YsOI2020-归零" class="headerlink" title="T134867 [YsOI2020]归零"></a><a href="https://www.luogu.com.cn/problem/T134867?contestId=31074" target="_blank" rel="noopener">T134867 [YsOI2020]归零</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">132</span>;</span><br><span class="line">LL f[N],invf[N];</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,LL n)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%M;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>; x=x*x%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) f[i]=f[i<span class="number">-1</span>]*i%M;</span><br><span class="line">    invf[N<span class="number">-1</span>] = pow_mod(f[N<span class="number">-1</span>],M<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i) invf[i] = invf[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> f[n]*invf[n-k]%M*invf[k]%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">string</span> ss;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ss;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:ss) s.emplace_back(c-<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">auto</span> plusOne = [&amp;](<span class="keyword">int</span> l,<span class="keyword">int</span> r)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = r<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[id]==<span class="number">9</span>) --id;</span><br><span class="line">        ++s[id];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=id+<span class="number">1</span>;i&lt;r;++i) s[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> minusOne = [&amp;](<span class="keyword">int</span> l,<span class="keyword">int</span> r)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = r<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[id]==<span class="number">0</span>) --id;</span><br><span class="line">        --s[id];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=id+<span class="number">1</span>;i&lt;r;++i) s[i] = <span class="number">9</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    function&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>,LL&gt;(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; f = [&amp;](<span class="keyword">int</span> l,<span class="keyword">int</span> r) -&gt; <span class="built_in">map</span>&lt;<span class="keyword">int</span>,LL&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(all_of(s.<span class="built_in">begin</span>()+l,s.<span class="built_in">begin</span>()+r,[](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x == <span class="number">0</span>;&#125;))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>,LL&gt;&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,LL&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;r;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> x = s[i];</span><br><span class="line">                s[i]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;<span class="number">4</span>) plusOne(l,i);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ia:f(l,i))&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ib:f(i,r))&#123;</span><br><span class="line">                        <span class="keyword">int</span> t1 = <span class="number">1</span>+ia.first+ib.first;</span><br><span class="line">                        LL t2 = ia.second*ib.second%M*C(ia.first+ib.first,ia.first)%M;</span><br><span class="line">                        <span class="keyword">if</span>(ret.<span class="built_in">find</span>(t1)==ret.<span class="built_in">end</span>())&#123;</span><br><span class="line">                            ret[t1] = t2;</span><br><span class="line">                        &#125;<span class="keyword">else</span> ret[t1] = (ret[t1]+t2)%M;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;<span class="number">4</span>) minusOne(l,i);</span><br><span class="line">                s[i]=x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:f(<span class="number">0</span>,s.<span class="built_in">size</span>()))&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;x.first&lt;&lt;" "&lt;&lt;x.second&lt;&lt;endl;</span></span><br><span class="line">        res+=x.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res%M&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树形-DP"><a href="#树形-DP" class="headerlink" title="树形 DP"></a>树形 DP</h2><blockquote>
<p>树形 DP 本质上就是，树结构可以给出各种不同的偏序关系，针对不同的问题，给出偏序关系，再来 DP</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
        <tag>运筹学</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Grossman 常数</title>
    <url>/grossmanConstant/</url>
    <content><![CDATA[<p>考虑由如下递推关系确定的实数数列 $\lbrace A_n \rbrace$：</p>
<script type="math/tex; mode=display">
A_{n+2} = \frac{A_n}{1+A_{n+1}} \\
A_0=1,\; A_1=x</script><p>可以证明，有且仅有一个 $x=x_0$ 使得 $\lbrace A_n \rbrace$ 收敛。这个 $x_0 = 0.7373383…$  被称为 Grossman 常数。</p>
<p><a href="https://mathworld.wolfram.com/GrossmansConstant.html" target="_blank" rel="noopener">Grossman 常数</a> 在 Wolfram 百科里面有讲，也在 Finch, S. R.《 Mathematical Constants》又讲，但是都依赖于核心论文 <a href="1987_Article_MathematicalEntertainments.pdf">Janssen, A. J. E. M. and Tjaden, D. L. A. Solution to Problem 86-2. <em>Math. Intel.</em> <strong>9</strong>, 40-43, 1987.</a> 折腾终于下下来了。</p>
<blockquote>
<p>吐槽一下 Wolfram 百科提供的所有 Reference 链接没法访问。。。</p>
</blockquote>
<a id="more"></a>
<p>为了方便起见，我们记：</p>
<script type="math/tex; mode=display">
A_0(x) = \alpha >0 ,\; A_1(x) = x \\
A_{n+2}(x) = \frac{A_{n}(x)}{1+A_{n+1}(x)}</script><p>首先罗列一些显而易见的结果：</p>
<ul>
<li><p>如果 $x&gt;0$，则 $A_n(x)&gt;0$，且 $A_{2n}(0)=\alpha,A_{2n+1}(0)=0$</p>
</li>
<li><p>$a(x) = \lim A_{2n}(x),\; b(x)= \lim A_{2n+1}(x)$ 均存在，且 $a(x)b(x)=0$</p>
</li>
<li><p>如果 $\lim A_n(x)$ 存在，则为 $0$</p>
</li>
<li><p>如果 $x \leq 0$，则 $\lim A_n(x)$ 不存在 （反证，奇偶项写出两个递推关系分析）</p>
<p><strong>以下仅考虑 $x\geq 0$ 的情形</strong></p>
</li>
<li><p>$A_{2n}(x)$ 是连续单调递减的函数 （数学归纳）</p>
</li>
<li><p>$A_{2n+1}(x)$ 是连续单调递增的函数 （数学归纳）</p>
</li>
<li><p>$a(x) \geq 0$ 单调递减，$b(x) \geq 0$ 单调递增</p>
</li>
<li><p>$A_{2n}(x),\;A_{2n+1}(x)$ 都关于 $n$ 单调递减</p>
</li>
<li><p>重要公式（累和相加）： </p>
<script type="math/tex; mode=display">
\alpha - A_{2N+2}(x) =  \sum_{n=0} ^N A_{2n+1}(x) A_{2n+2}(x) \\
x - A_{2N+3}(x) = \sum_{n=0} ^N A_{2n+3}(x) A_{2n+2}(x)</script></li>
</ul>
<blockquote>
<p>以上罗列的结果按顺序证明是容易的！</p>
</blockquote>
<h2 id="lim-A-n-x-0-当且仅当-A-n-x-关于-n-单调递减"><a href="#lim-A-n-x-0-当且仅当-A-n-x-关于-n-单调递减" class="headerlink" title="$\lim A_n(x) =0$  当且仅当 $A_n(x)$ 关于$n$ 单调递减"></a>$\lim A_n(x) =0$  当且仅当 $A_n(x)$ 关于$n$ 单调递减</h2><p><strong>Proof</strong>： 若 $\lim A_n(x) =0$ ，再由上面的 “重要公式” 易知：</p>
<script type="math/tex; mode=display">
A_{2N+2}(x) =  \sum_{n=N+1} ^ \infty A_{2n+1}(x) A_{2n+2}(x) \\
A_{2N+3}(x) = \sum_{n=N+1} ^ \infty A_{2n+3}(x) A_{2n+2}(x)</script><p>所以 $A_{2N+2}&gt;A_{2N+3}$ ，紧接着 $A_{2N+1} = \sum_{n=N+1} ^ \infty A_{2n+1}A_{2n} &gt; A_{2N+2}$，所以 $A_n(x)$ 关于 $n$ 单调递减</p>
<blockquote>
<p>这也提供了一个求解 Grossman 常数的数值依据。</p>
</blockquote>
<h2 id="最多只有一个-x-使得-lim-A-n-x-0"><a href="#最多只有一个-x-使得-lim-A-n-x-0" class="headerlink" title="最多只有一个 $x$ 使得 $\lim A_n(x) =0$"></a>最多只有一个 $x$ 使得 $\lim A_n(x) =0$</h2><p><strong>Proof</strong>：若 $\lim A_n(y) = \lim A_n(x) = 0,\; y&gt;x$，则：</p>
<script type="math/tex; mode=display">
\frac{A_{n+2}(y)}{A_{n+2}(x)} = \frac{A_{n}(y)}{A_{n}(x)} \frac{1+A_{n+1}(x)}{1+A_{n+1}(y)}</script><p>从而</p>
<script type="math/tex; mode=display">
\frac{A_{2n+2}(y)}{A_{2n+2}(x)} = \prod _{k=1} ^n \frac{1+A_{2k+1}(y)}{1+A_{2k+1}(x)} \\
\frac{A_{2n+1}(y)}{A_{2n+1}(x)} = \frac{y}{x} \prod _{k=1} ^n \frac{1+A_{2k}(y)}{1+A_{2k}(x)}</script><p>从而  $\frac{A_{2n+2}(y)}{A_{2n+2}(x)}$ 单调递减收敛于 $L_1 \leq 1$，$\frac{A_{2n+1}(y)}{A_{2n+1}(x)}$  单调递增收敛于 $L_2&gt;1$。所以</p>
<script type="math/tex; mode=display">
\lim \frac{A_{2n+2}(y)}{A_{2n+2}(x)} \frac{A_{2n+1}(x)}{A_{2n+1}(y)} = \frac{L_1}{L_2} <1</script><p>但是另一方面</p>
<script type="math/tex; mode=display">
1 \geq \frac{A_{2n+2}(y)}{A_{2n+1}(y)} \geq \frac{A_{2n+3}(y)}{A_{2n+1}(y)} = \frac{1}{1+A_{2n+2}(y)} \to 1 \\
1 \leq \frac{A_{2n+1}(x)}{A_{2n+2}(x)} \geq \frac{A_{2n+1}(x)}{A_{2n+3}(x)} = 1+A_{2n+2}(x) \to 1</script><p>矛盾！</p>
<h2 id="Dini-定理"><a href="#Dini-定理" class="headerlink" title="Dini 定理"></a>Dini 定理</h2><p>为了证明的连贯性，先给出下面需要引用 <strong>Dini 定理</strong>（证明见陈纪修《数学分析》下册定理 10.2.7）</p>
<p>设函数序列 $\{S_n(x)\}$ 在闭区间 $[a,b]$ 上（点态）收敛于 $S(x)$，且满足：</p>
<ul>
<li>$S_n(x)$ 在 $[a,b]$ 上连续</li>
<li>$\{S_n(x)\}$ 关于 $n$ 单调</li>
</ul>
<p>则 $\{S_n(x)\}$ 在 $[a,b]$ 一致收敛于 $S(x)$ 当且仅当 $S(x)$ 在 $[a,b]$ 上连续 （”$\Rightarrow$”易证，”$\Leftarrow$” 称作 Dini <strong>定理</strong>）</p>
<h2 id="存在唯一的-x-使得-lim-A-n-x-0"><a href="#存在唯一的-x-使得-lim-A-n-x-0" class="headerlink" title="存在唯一的 $x$ 使得 $\lim A_{n}(x) = 0$"></a>存在唯一的 $x$ 使得 $\lim A_{n}(x) = 0$</h2><p>由“重要公式”知：</p>
<script type="math/tex; mode=display">
\alpha - a(x) = \sum_{n=0} ^{\infty} A_{2n+1}(x) A_{2n+2}(x) \\
x - b(x) = \sum_{n=0} ^{\infty} A_{2n+3}(x) A_{2n+2}(x) \\</script><p>从而 $\alpha -  a(x) &gt; x - b(x)$，所以 $b(\alpha) &gt; 0$，从而 $a(\alpha) = 0$，并且 $a(0) = \alpha,\; b(0) = 0$。令</p>
<script type="math/tex; mode=display">
x_0 = \sup \{ x \in [0, \alpha] \mid a(x) >0 \} \\
x_1 = \inf \{ x \in [0,\alpha] \mid b(x)>0 \}</script><p>显然 $x_0 \leq x_1$， 若 $x_0 &lt; x_1$，则 对任意 $x_0 &lt; x &lt; x_1$ 有，$a(x) = b(x) = 0$，矛盾于收敛于 0 的 $x$ 最多只有一个，从而 $x_0 = x_1$。</p>
<p>注意到 $\frac{1}{1+\alpha} A_{2n+1}(x) A_{2n+2}(x) \leq  A_{2n+3}(x) A_{2n+2}(x) \leq  A_{2n+1}(x) A_{2n+2}(x)$，所以 $a(x),b(x)$ 在闭区间 $D$ 上有共同的一致收敛性，从而由 <strong>Dini 定理</strong> 知，$a(x)$ 在闭区间 $D$ 上连续当且仅当 $b(x)$ 在闭区间 $D$ 上连续。</p>
<blockquote>
<p>我们想要证明 $a(x),b(x) $ 在区间 $[0,\alpha]$ 上连续，从而 $a(x_0) = b(x_0) = 0$。</p>
</blockquote>
<p>当 $x &lt; x_0$ 时，$b(x)=0$，当 $x &gt; x_0$ 时，$a(x)=0$，所以 $a(x),b(x)$ 在 $[0,x_0) \cup (x_0, \alpha]$ 上连续。</p>
<p>若 $a(x_0) &gt;0$，则 $b(x_0) = 0$，记 $b_0 = \lim_{x \to x_0 ^{+}} b(x)$，若 $b_0&gt;0$， 则</p>
<script type="math/tex; mode=display">
A_{2k+2}(x) = \prod_{j=1} ^k \frac{1}{1+A_{2j-1}(x)} < \frac{1}{(1+b_0)^k} \quad x \in (x_0, \alpha ] \\
A_{2k+1}(x) = \prod_{j=1}^k \frac{1}{1+A_{2j}(x)} < \frac{1}{(1+a(x_0))^k} \quad x \in [0,x_0]</script><p>从而 $a(x),b(x)$ 在 $[0,\alpha]$ 上一致收敛，矛盾，从而 $b_0 = 0$，从而 $b(x)$ 连续，从而 $a(x)$ 连续，矛盾，从而 $a(x_0) = 0$。同理 $b(x_0) = 0$。所以 $\lim A_n(x) = 0$。</p>
<h2 id="Grossman-常数的推广"><a href="#Grossman-常数的推广" class="headerlink" title="Grossman 常数的推广"></a>Grossman 常数的推广</h2><p>由上述过程可知，本质上，对每个给定的 $A_0 \geq 0$, 都存在唯一的 $0 \leq A_1 \leq A_0$ ，使得 $\lim A_n$ 存在（且等于 0）。我们不妨 $A_1 = F(A_0)$，其中 $F: [0, +\infty] \to [0, \infty]$，满足 $F(0)= 0$，若$x&gt;0$ 则，$0&lt;F(x)&lt;x$ ，假设 $A_0 = \alpha$，则 $A_1 = F(\alpha),\;A_2 = \frac{\alpha}{1+F(\alpha)}$，而 $(A_0, A_1) = (F(\alpha),\frac{\alpha}{1+F(\alpha)})$ 必然能使得 $\lim A_n = 0$， 所以 $F(F(\alpha)) = \frac{\alpha}{1+F(\alpha)}$，写成</p>
<script type="math/tex; mode=display">
x = (1+F(x))F(F(x))</script><p>由于 $a(x)$ 关于 $\alpha$ 连续，所以 $x_0(\alpha) = \sup \{ x \in [0, \alpha] \mid a(x) &gt;0 \}$ 关于 $\alpha$ 连续，即上述 $F(x)$ 连续，若可导​，则 $F(x)$ 单调递增。</p>
<blockquote>
<p>上述形式最早由 Gabor Nyerges 给出（由于找不到文献，所以就自己推导了一下）</p>
</blockquote>
<p>按照上述观点，从而 Grossman 常数就是 $F(1)$。</p>
<h2 id="Grossman-常数的数值计算"><a href="#Grossman-常数的数值计算" class="headerlink" title="Grossman 常数的数值计算"></a>Grossman 常数的数值计算</h2><p>由于 $\lim A_n(x) =0$  当且仅当 $A_n(x)$ 关于 $n$ 单调递减 。令 $n_0$ 是最小的 $n$ 使得 $A_{n+1}(x) &gt; A_n(x)$，则</p>
<script type="math/tex; mode=display">
A_{n+3}(x) - A_{n+2}(x) = \frac{(A_{n+1} - A_n) + (A_{n+1}^2 - A_n A_{n+2}) }{(1+A_{n+2})(1+A_{n-1})} > 0</script><p>从而对任意 $k \geq 0$，$A_{n+2k+1} &gt; A_{n+2k}$。</p>
<p>若 $n$ 为偶数，则 $b(x)&gt;a(x)$，从而 $b(x) &gt; 0 = a(x)$，即 $x&gt;x_0$。反之，若 $n$ 为奇数，则 $x &lt; x_0$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bigercheck</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> m,<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">10000</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ans=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(--<span class="built_in">step</span>&amp;&amp;x&gt;m)&#123;</span><br><span class="line">        ans = !ans;</span><br><span class="line">        <span class="keyword">double</span> t=x/(<span class="number">1</span>+m);</span><br><span class="line">        x = m;</span><br><span class="line">        m = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x&gt;m||ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> eps = <span class="number">1e-12</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l =x/(<span class="number">1</span>+x),r = x;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;eps)&#123;</span><br><span class="line">        <span class="keyword">double</span> m = (l+r)*<span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">if</span>(bigercheck(x,m))  r=m;</span><br><span class="line">        <span class="keyword">else</span> l=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;x)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;F(x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;F(F(x))*(F(x)+<span class="number">1</span>)-x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>高精度太耗时了！参考 <a href="https://oeis.org/A085835" target="_blank" rel="noopener">A085835</a> </p>
</blockquote>
<h2 id="后来的故事"><a href="#后来的故事" class="headerlink" title="后来的故事"></a>后来的故事</h2><p>Gabor Nyerges 在 2014 年的论文 《On the convergence of $x_n = f(x_{n–2}, x_{n–1})$ when $f (x, y) &lt; x$. Advances in Difference Equations2014, 2014:8》中证明，只需 $f: (0,\infty)^2 \to (0,\infty)$，$f (x, y) &lt; x$，且$f(x,y)$ 关于 $y$ 递减，则对任意 $x_0 &gt; 0$，存在 $f(x_0,x_0)&lt;x_1&lt;x_0$ 使得 $x_n$ 单调递减趋于 0 。但是没法保证唯一性，毕竟条件这么弱。证明过程巧妙的应用了闭区间套定理。</p>
<h3 id="明显的推论：若-x-n-frac-x-n-2-1-f-x-n-1-，其中-f-0-infty-to-0-infty-为单调递增的连续函数，-则，对任意-x-geq-0-，存在唯一的-frac-x-0-1-f-x-0-leq-x-1-leq-x-0"><a href="#明显的推论：若-x-n-frac-x-n-2-1-f-x-n-1-，其中-f-0-infty-to-0-infty-为单调递增的连续函数，-则，对任意-x-geq-0-，存在唯一的-frac-x-0-1-f-x-0-leq-x-1-leq-x-0" class="headerlink" title="明显的推论：若 $x_n = \frac{x_{n-2}}{1+f(x_{n-1})}$，其中 $f: (0,\infty) \to (0, \infty)$为单调递增的连续函数， 则，对任意 $x \geq 0$，存在唯一的 $\frac{x_0}{1+f(x_0)} \leq x_1 \leq x_0$"></a>明显的推论：若 $x_n = \frac{x_{n-2}}{1+f(x_{n-1})}$，其中 $f: (0,\infty) \to (0, \infty)$为单调递增的连续函数， 则，对任意 $x \geq 0$，存在唯一的 $\frac{x_0}{1+f(x_0)} \leq x_1 \leq x_0$</h3><p><strong>Proof</strong> ：存在性由 Gabor Nyerges 的证明显然，唯一性模仿之前的过程显然。</p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到 Hexo</title>
    <url>/helloHexo/</url>
    <content><![CDATA[<p>首先要感谢给我们免费提供二级域名和云服务器的 <a href="https://github.com/" target="_blank" rel="noopener">github</a> 还有提供框架 <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>和主题 next（再见 next，你好 Butterfly：<a href="https://demo.jerryc.me/" target="_blank" rel="noopener">官方demo</a>或者 <a href="https://www.antmoe.com/posts/75a6347a/index.html" target="_blank" rel="noopener">官方配置方法</a>, <a href="https://blog.lete114.top/article/Butterfly-config.html" target="_blank" rel="noopener">魔性修改</a>）。在最后还有一些小技巧的汇总方便查阅，其中包括 mathjax，git 的配置，pip 和 npm的国内镜像加速设置。（将 win10 下 WSL Ubuntu20.04 作为唯一开发环境，将 VScode 作为唯一开发工具。） <strong>换主题了不再更新</strong>, 请移步到: <a href="/butterfly/" title="butterfly 主题配置">butterfly 主题配置</a></p>
<a id="more"></a>
<blockquote>
<p>本站 .com 域名不用备案，只需实名制即可</p>
<p>每次迁移都要处理 Github SSL，deploy Save，mathjax渲染, Nunjucks报错处理(对应修改local Search, feed)</p>
</blockquote>
<h2 id="Hexo环境搭建"><a href="#Hexo环境搭建" class="headerlink" title="Hexo环境搭建"></a>Hexo环境搭建</h2><ol>
<li><a href="https://tding.top/archives/7f189df5.html" target="_blank" rel="noopener">小丁教程：</a>安装 Hexo 并上传到 git 上(<a href="https://blog.csdn.net/grave2015/article/details/79961843" target="_blank" rel="noopener">这里超详细</a>）</li>
<li>注意 <strong>一定要把github上Pages功能打开</strong> 才行（最后enable HTTPs）</li>
<li>主题 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a>安装</li>
<li>安装 nmp 和 pip 的 post_link note 国内加速</li>
<li><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">mathjax渲染</a></li>
<li>Windows 下安装 markdown IDE: sublime3 + <a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> </li>
<li>Typora 写公式快捷键 <code>ctrl + shift + m</code></li>
<li>hexo文章加密 <a href="https://blog.csdn.net/qq_24495287/article/details/89025371" target="_blank" rel="noopener">方式1</a> 和 <a href="https://blog.csdn.net/cungudafa/article/details/104346521" target="_blank" rel="noopener">方式2</a></li>
<li><a href="https://www.jianshu.com/p/728a9594bb6c" target="_blank" rel="noopener">添加 Valine 评论系统</a>，<a href="https://tab.leancloud.cn/data.html?appid=TkSRiW6UjDGmsxqmjPiPRjHV-9Nh9j0Va#/" target="_blank" rel="noopener">LeanCloud 管理数据</a> (以后再换到 <a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>，<a href="https://blog.dlzhang.com/posts/32/" target="_blank" rel="noopener">注意Gitalk的公开仓库读写权限问题</a></li>
<li><a href="https://www.itrhx.com/2019/09/16/A47-hexo-deployed-to-github-and-coding/" target="_blank" rel="noopener">部署代码到 Coding</a> 并把源代码提交到Coding（账号是手机号）</li>
</ol>
<h3 id="这次大更新的说明-（2020-3-12）"><a href="#这次大更新的说明-（2020-3-12）" class="headerlink" title="这次大更新的说明 （2020/3/12）"></a>这次大更新的说明 （2020/3/12）</h3><p>因为我之前的失误，导致 markdown 源文件丢失，又因为备份更新的时间比较久，导致了我两年没有更新博客，所以这次我配置 hexo 的时候，有讲源码提交到 github 上去。可是最后我还是选择了 next5.1.4 主题，而没有更新到 next7.7.2</p>
<blockquote>
<p>老博客地址：<a href="https://dna049.github.io/" target="_blank" rel="noopener">https://dna049.github.io/</a> （绑定账号：<a href="https://github.com/dna049" target="_blank" rel="noopener">FDU校邮</a>）</p>
</blockquote>
<h4 id="这次迁移的工作量是巨大，但是很有意义的："><a href="#这次迁移的工作量是巨大，但是很有意义的：" class="headerlink" title="这次迁移的工作量是巨大，但是很有意义的："></a>这次迁移的工作量是巨大，但是很有意义的：</h4><ol>
<li>我把博文中个人生活部分加密了</li>
<li>http 升级到 https（超级简单）</li>
<li>域名 dna049.com 到 2022 年过期，记得到时候续费</li>
<li>加评论系统：<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 真香 0.0</li>
<li>加了百度统计，<del>leanCould 文章数量统计</del>，打赏，不蒜子统计博客访问量</li>
<li>加了<a href="https://tding.top/archives/761b6f4d.html" target="_blank" rel="noopener">背景</a>， <a href="https://tding.top/archives/2bd6d82.html" target="_blank" rel="noopener">圆角设置</a>(<del>sidebar不是圆角很难受</del>，被 <a href="https://blog.maplesugar.space/" target="_blank" rel="noopener">枫糖</a>帮助解决)，<a href="https://github.com/MikeCoder/hexo-tag-cloud" target="_blank" rel="noopener">标签云</a>，<a href="https://www.liaofuzhan.com/posts/2114475547.html" target="_blank" rel="noopener">彩色 Tags 和 logo</a></li>
<li>加了<a href="https://tding.top/archives/73ce4e7.html" target="_blank" rel="noopener">友链</a> 方式一（方式二容易出问题）</li>
<li>复习一下之前写的博文，熟练一下语法(markdown, C++, Python, Latex)，顺带查错</li>
<li>删除了一点现在看来没什么意思的博文</li>
<li>知道保存好自己修改过的 next 主题。</li>
<li>增加<a href="https://tding.top/archives/567debe0.html" target="_blank" rel="noopener">RSS 功能</a>，<a href="https://zhuanlan.zhihu.com/p/64457116" target="_blank" rel="noopener">RSS 使用说明</a></li>
</ol>
<h3 id="Hexo功能介绍"><a href="#Hexo功能介绍" class="headerlink" title="Hexo功能介绍"></a>Hexo功能介绍</h3><ol>
<li>内部引用：<code></code></li>
<li>创建新文件夹： hexo new page newdir</li>
<li>hexo 中渲染 mathjax： <a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">看这里</a></li>
<li>设置 <a href="https://blog.csdn.net/qwerty200696/article/details/79010629" target="_blank" rel="noopener">文章置顶</a></li>
<li>安装主题next更新到稳定的<a href="https://github.com/iissnan/hexo-theme-next/releases/tag/v5.1.4" target="_blank" rel="noopener">版本 5.1.4</a>并 <a href="https://blog.csdn.net/loze/article/details/94210320" target="_blank" rel="noopener">配置</a> （不用看教程就能配置），不建议更新到最新版本很不稳定</li>
<li>显示更新时间： 找到 next 主题的 <code>_config.yml</code>在里面查找 <code>update</code> 会找到一个 <code>updated_at</code> 的属性改为 <code>true</code> 即可看到更新时间</li>
<li><a href="https://www.jianshu.com/p/d4a7daebfff7" target="_blank" rel="noopener">next中添加爱心</a></li>
<li>next主题记得设置tags文件夹下的index.md</li>
<li><a href="https://www.jianshu.com/p/79fe9fb9dfa0" target="_blank" rel="noopener"><del>next隐藏部分博文</del></a> </li>
<li><a href="https://blog.csdn.net/shuiyunxc/article/details/104150894" target="_blank" rel="noopener">next5.1.4 的问题</a></li>
<li><a href="https://www.dazhuanlan.com/2020/01/30/5e322259a87e5/" target="_blank" rel="noopener">Nunjucks 报错处理</a></li>
</ol>
<h3 id="mathjax-示例"><a href="#mathjax-示例" class="headerlink" title="mathjax 示例"></a>mathjax 示例</h3><h4 id="The-Quadratic-Formula"><a href="#The-Quadratic-Formula" class="headerlink" title="The Quadratic Formula"></a>The Quadratic Formula</h4><script type="math/tex; mode=display">
x = {-b \pm \sqrt{b^2-4ac} \over 2a}</script><h4 id="The-Lorenz-Equations"><a href="#The-Lorenz-Equations" class="headerlink" title="The Lorenz Equations"></a>The Lorenz Equations</h4><script type="math/tex; mode=display">
\begin{aligned}
\dot{x} & = \sigma(y-x) \\
\dot{y} & = \rho x - y - xz \\
\dot{z} & = -\beta z + xy
\end{aligned}</script><h4 id="The-Cauchy-Schwarz-Inequality"><a href="#The-Cauchy-Schwarz-Inequality" class="headerlink" title="The Cauchy-Schwarz Inequality"></a>The Cauchy-Schwarz Inequality</h4><script type="math/tex; mode=display">
\left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)</script><h4 id="A-Cross-Product-Formula"><a href="#A-Cross-Product-Formula" class="headerlink" title="A Cross Product Formula"></a>A Cross Product Formula</h4><script type="math/tex; mode=display">
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}
\mathbf{i} & \mathbf{j} & \mathbf{k} \\
\frac{\partial X}{\partial u} &  \frac{\partial Y}{\partial u} & 0 \\
\frac{\partial X}{\partial v} &  \frac{\partial Y}{\partial v} & 0
\end{vmatrix}</script><blockquote>
<p><code>\displaystyle</code> 可以让行内公式有行间公式的视觉效果</p>
</blockquote>
<h3 id="git-上传源代码到私有仓库"><a href="#git-上传源代码到私有仓库" class="headerlink" title="git 上传源代码到私有仓库"></a>git 上传源代码到私有仓库</h3><p>在博客所用的 github 账号下再建立一个私有仓库，然后，在 blog 目录下相应修改 <code>.gitignore</code> 的内容，并在 blog 目录下执行下面git命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line"><span class="comment"># git remote rm origin</span></span><br><span class="line">git remote add origin https://github.com/dna049/dna049Source.git  <span class="comment"># 只需添加一次</span></span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git push -u origin master <span class="comment"># -u 一次之后就可以直接用 git push提交了</span></span><br></pre></td></tr></table></figure>
<h3 id="一键提交源代码"><a href="#一键提交源代码" class="headerlink" title="一键提交源代码"></a>一键提交源代码</h3><p>可以正常更新后，在 blog 目录下新建一个 <code>updateSourceCode.py</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># update source code</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#os.system('git init')</span></span><br><span class="line">os.system(<span class="string">'git add .'</span>)</span><br><span class="line"><span class="comment">#os.system('git remote add origin https://github.com/dna049/dna049Source.git')</span></span><br><span class="line"><span class="comment"># 上面是github 下面是 Coding</span></span><br><span class="line"><span class="comment">#os.system('git remote add origin https://e.coding.net/dna049/dna049Source.git') </span></span><br><span class="line">os.system(<span class="string">'git commit -m "update"'</span>)</span><br><span class="line">os.system(<span class="string">'git push origin master'</span>)</span><br></pre></td></tr></table></figure>
<p>以后每次在 blog 目录下执行 <code>py update.py</code> 就可以了。 </p>
<p><a href="https://shuiyunxc.gitee.io/2020/03/03/download/index/" target="_blank" rel="noopener">如何快速从GitHub下载文件</a></p>
<h3 id="nmp-安装国内镜像"><a href="#nmp-安装国内镜像" class="headerlink" title="nmp 安装国内镜像:"></a>nmp 安装国内镜像:</h3><p><code>npm config set registry https://registry.npm.taobao.org</code></p>
<h4 id="pip-安装的国内镜像在后面加-也可以一劳永逸，就是麻烦了点-："><a href="#pip-安装的国内镜像在后面加-也可以一劳永逸，就是麻烦了点-：" class="headerlink" title="pip 安装的国内镜像在后面加(也可以一劳永逸，就是麻烦了点)："></a>pip 安装的国内镜像在后面加(也可以<a href="https://www.cnblogs.com/cqliu/p/11131092.html" target="_blank" rel="noopener">一劳永逸</a>，就是麻烦了点)：</h4><p><code>-i https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<p>pip 本地安装</p>
<ul>
<li>tar.gz 文件： <code>pip install *.tar.gz</code></li>
<li>解压好的source 文件：<code>pip install -e filePath -i ...</code>，加 <code>-i</code> 是防止要安装依赖包</li>
</ul>
<h3 id="Windows-文件比较：-FC-A-py-B-py"><a href="#Windows-文件比较：-FC-A-py-B-py" class="headerlink" title="Windows 文件比较： FC A.py B.py"></a>Windows 文件比较： <code>FC A.py B.py</code></h3><h2 id="Hexo-git-教程："><a href="#Hexo-git-教程：" class="headerlink" title="Hexo + git 教程："></a>Hexo + git 教程：</h2><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><ul>
<li><p>安装<a href="https://git-scm.com/download" target="_blank" rel="noopener">git</a></p>
</li>
<li><p>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> （选择自动安装依赖包）</p>
</li>
<li><p>nmp添加国内镜像源： <code>npm config set registry https://registry.npm.taobao.org</code></p>
</li>
<li><p>安装<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a> ： <code>npm install -g hexo-cli</code></p>
</li>
</ul>
<blockquote>
<p>以下所有跟 github 相关的内容都建议<strong>早上</strong>操作</p>
</blockquote>
<h3 id="搭建hexo："><a href="#搭建hexo：" class="headerlink" title="搭建hexo："></a>搭建hexo：</h3><p>新建一个blog文件夹，进入blog目录，依次输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">nmp install</span><br><span class="line">hexo clean <span class="comment">#可选</span></span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>在浏览器输入网址： <code>localhost:4000</code> 看到 HelloWorld 说明成功了。</p>
<h3 id="部署到-github"><a href="#部署到-github" class="headerlink" title="部署到 github"></a>部署到 github</h3><p>登录 <a href="https://github.com" target="_blank" rel="noopener">github</a> ，创建 yourname/yourname.github.io 仓库， 进入该仓库 setting，下拉到 Github Page</p>
<p>设置 master branch，Custom domain（可选），Enforce HTTPS</p>
<p>git 命令行进入 blog 目录，执行下面操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C yourmail@example.com <span class="comment">#建议不设置密码，按回车</span></span><br><span class="line">clip &lt; ~/.ssh/id_rsa.pub <span class="comment"># 复制公钥到系统粘贴板</span></span><br></pre></td></tr></table></figure>
<p>去 github 账号的 setting 中添加 ssh key（复制到 key 就可以了）</p>
<p>检测是否成功： <code>ssh -T git@github.com</code></p>
<p>设置全局用户信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name yourname</span><br><span class="line">git config --<span class="keyword">global</span> user.email  yourmail@example.com</span><br></pre></td></tr></table></figure>
<p>在 <code>_config.yml</code> （最后一行）设置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yourname/yourname.github.io.git</span><br></pre></td></tr></table></figure>
<p>执行：<code>npm install hexo-deployer-git --save</code></p>
<p>然后执行： <code>hexo g -d</code> 就可以去 <code>http(s)://yourname.github.io</code> 看到自己的博客了。</p>
<h4 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置 _config.yml"></a>配置 <code>_config.yml</code></h4><p>填写 site 信息， 设置 url ， 建议 permalink 改为 ：<code>title/</code>，设置 <code># Pagination</code> 下的 <code>per_page: 0</code>。</p>
<h4 id="配置主题，配好了修改-config-yml-的-theme-为当前主题"><a href="#配置主题，配好了修改-config-yml-的-theme-为当前主题" class="headerlink" title="配置主题，配好了修改 _config.yml 的 theme 为当前主题"></a>配置主题，配好了修改 <code>_config.yml</code> 的 theme 为当前主题</h4><blockquote>
<p>2022 年 2 月把主题更新到最新版本</p>
</blockquote>
]]></content>
      <tags>
        <tag>Theme</tag>
        <tag>Hexo</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title>快速数论变换</title>
    <url>/nft/</url>
    <content><![CDATA[<p>快速 Fourier 变换，被称为 20 世纪最伟大的十大算法之一。所以很多软件都有对应的 FFT，例如 Python 的 <code>scipy.fftpack</code> 中就有关于 FFT 的包。所以个人写 FFT 就没有那么必要了。但是 NFT 的包一般都没多少，而且会写 NFT 必然就会写 FFT 了。大约在 5 年前就写过 NFT 的 C++ 代码，现在一看依然不记得蝶式映射到底是咋想的，<del>所以想独立思考出整个过程</del>(失败）。</p>
<blockquote>
<p>此博文特别划水，建议直接阅读 <a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform" target="_blank" rel="noopener">miskcoo 博文：从多项式乘法到快速傅里叶变换</a></p>
</blockquote>
<p>发现 NFT 一个很大的限制就是你只能在 <code>NFT-friendly</code> 的域（例如 $\mod 998244353 = 119 \cdot2^{23}$，原根为$3$ ）或者模很小的数的环中处理。即环中所有运算放在整数环中都不会超过选择的大基底。</p>
<p>选择 $n$ 个 <code>NFT-friendly</code> 的大基底$p_1,\cdots, p_n$ 使得$p_1\cdots p_n$大于 ans 的上界，然后再用 <a href="/chineseRemainTheorem/" title="中国剩余定理">中国剩余定理</a> 就可以把 ans 搞出来了。</p>
<a id="more"></a>
<h2 id="基底的选择"><a href="#基底的选择" class="headerlink" title="基底的选择"></a>基底的选择</h2><p>我们考虑$\mod p$  构成的域。即运算默认是 $\mod p$ 的（除了指数上的幂次数），因为原根定理，此形式必有原根$g$，即存在$\mod p$ 中所有元素都可以写成 $g^n$ 的形式（所以$g^{p-1}=1,g^{n}\neq 1, 0&lt;n&lt;p-1$）。而我们做 NFT 是需要找一个元素 $w$，使得 $w^{2^k} = 1$，因此我们需要找素数$p$，使得$p-1=c \cdot 2^k$，其中$c$ 是个小奇数。</p>
<h3 id="查找基底的-SageMath-代码"><a href="#查找基底的-SageMath-代码" class="headerlink" title="查找基底的 SageMath 代码"></a>查找基底的 SageMath 代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>,<span class="number">32</span>): <span class="comment"># 调节这个数值范围来找自己想要的 p</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">25</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span>(is_prime(j*<span class="number">2</span>^i+<span class="number">1</span>)):</span><br><span class="line">            ans.append(j*<span class="number">2</span>^i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ans: </span><br><span class="line">    print(<span class="string">"1 + "</span>,factor(i<span class="number">-1</span>),<span class="string">"\t=\t"</span>,i)</span><br></pre></td></tr></table></figure>
<p>我们会发现有很多可供选择的例子，其中的娇楚（$c$ 较小，$k$ 较大，$p^2 &lt; 2^{63}$）</p>
<ul>
<li><code>x_1 = 1 + 2^27 * 15</code> 十分推荐！$x_2$ 刚好不超过 <code>INT_MAX</code>，所以在乘积取模之前还多一次加法运算，就很方便！</li>
<li><code>x_2 = 1 + 2^27 * 17</code> 是平方不超过 <code>LL(long long)</code> 中最大的一个，但是不推荐，因为 $2*x_1^2$ 超了 <code>LL</code>。</li>
<li><code>x_3 = 1 + 2^21 * 479</code> 是网上常见的一个，但并不推荐。$c$ 太大了！</li>
<li><code>x_4 = 1 + 2^12 * 3</code> 是最小不超过<code>INT16</code>，并且 $c$ 特别小的一个！如果不用<code>LL</code>就很推荐</li>
<li><code>x_5 = 1 +  2^57 * 29</code> 是不超过 <code>INT64</code> 中最推荐的一个！然后基础运算需要用 GCC 内建的 <code>__int128</code></li>
</ul>
<p>总之，$x_1$ 是最为推荐的，$x_2,x_3$ 很常见主要是因为国内第一篇比较完整的介绍 NFT 的是 <a href="http://blog.miskcoo.com/" target="_blank" rel="noopener">大佬 miskcoo</a>，他当时给的常数是$x_2,x_3$，然后就人云亦云了！$x_5$ 很有意思，它敲好比$2^{62}$小一点，然后它又大于$1e9+9$，而$1e9+7,1e9+9$这两个孪生素数又经常的出现在<code>ICPC/IO</code>中！<strong>但是，貌似也没啥用，见 NFT 模板代码的注释</strong></p>
<p>用 SageMath 自带的<code>primtive_root</code>函数分别求对应的原根 $g_1=31,g_2=g_3=g_5=3,g_4=11$。</p>
<p>所以，在 <code>LL</code> 的数据范围内，我们可以使用 $x_1$，可以处理最长长度为 $2^{27}$ 的 NFT，最长为 $2^{26} \sim 6 \times 10^7$ 项的 NFT 多项式乘法。 </p>
<blockquote>
<p>我们现在存在 $w$，有 $w^N = 1,\; w^n \neq 1, 0&lt; n &lt; N$，其中 $N = 2^k, k&lt;27$，有时我们用 $w_N$ 表明 $w$ 和 $N$ 的关系。</p>
</blockquote>
<h2 id="离散-Fourier-变换-DFT"><a href="#离散-Fourier-变换-DFT" class="headerlink" title="离散 Fourier 变换 DFT"></a>离散 Fourier 变换 DFT</h2><p>对长度为 $N$ 的数列 $a_0,\cdots a_{N-1}$ 做离散 Fourier 变换得到数列 $\hat{a}_0 \cdots \hat{a}_{N-1}$：</p>
<script type="math/tex; mode=display">
\hat{a}_k = \sum_{n=0} ^{N-1} w^{kn}a_n</script><p>写成矩阵形式：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
\hat{a}_0 \\
\hat{a}_1 \\
\vdots \\
\hat{a}_{N-1} 
\end{pmatrix} 
= 
\begin{pmatrix}
1 & 1   & \cdots &1 \\
1 & w & \cdots &w^{N-1} \\
\vdots& & \ddots & \\
1 & w^{N-1}& \cdots & w^{(N-1)(N-1)}
\end{pmatrix} 
\begin{pmatrix}
a_0 \\
a_1 \\
\vdots \\
a_{N-1} 
\end{pmatrix}</script><p>即上述矩阵为 $A$，则 $a_{ij} = w^{ij}$, 即 $b_{ij}= w^{-ij}$，则 $AB = NI$，即 $A^{-1} = \frac{1}{N}(w^{-ij})_{N \times N}$。即我们得到了 Fourier 逆变换公式：</p>
<script type="math/tex; mode=display">
a_k = \frac{1}{N} \sum_{n=0} ^{N-1} w^{-kn} \hat{a}_n</script><h2 id="快速-Fourier-数论变换-NFT"><a href="#快速-Fourier-数论变换-NFT" class="headerlink" title="快速 Fourier 数论变换 NFT"></a>快速 Fourier 数论变换 NFT</h2><p>记 $H = \frac{N}{2}$，</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat{a}_{k} &= \sum_{n=0} ^{N-1} w^{kn}a_n \\
&= (a_0+w^{2k}a_2+\cdots+ w^{2k(H-1)}a_{N-2})+w^k(a_1+w_{2k}a_3+\cdots+w^{2k(H-1)}a_{N-1}) \\
&= \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n} + w^k  \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n+1} \\
\hat{a}_{k+H} &= \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n} - w^k  \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n+1} \\
\end{aligned}</script><p>即长度为 $N$ 的 Fourier 变换可以其奇数项和偶数项的长度为 $\frac{N}{2}$ 的 Fourier 变换表出。于是递归的我们可以在 $O(n\log n)$ 时间复杂度求出。</p>
<blockquote>
<p>递归太消耗计算时间了。因此我们需要给出非递归的版本</p>
</blockquote>
<h3 id="快速-NFT-图"><a href="#快速-NFT-图" class="headerlink" title="快速 NFT 图"></a>快速 NFT 图</h3><p>下图出自 <a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform" target="_blank" rel="noopener">miskcoo 从多项式乘法到快速傅里叶变换</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="bit-reverse-miskcoo.png" alt="bit-reverse-miskcoo"></p>
<p>从这个图发现，最终的计算顺序，是每个数的位倒序。处理的细节 miskcoo 博客写的特别清楚了！</p>
<blockquote>
<p>当我想要修改 Miskcoo 的代码形式时，发现怎么修改都没他的好！</p>
</blockquote>
<p>还有 NFT 可以用于求多项式的逆！也可见<a href="http://blog.miskcoo.com/2015/05/polynomial-inverse" target="_blank" rel="noopener">Miskcoo 的博文</a></p>
<h2 id="NFT-和卷积的关系"><a href="#NFT-和卷积的关系" class="headerlink" title="NFT 和卷积的关系"></a>NFT 和卷积的关系</h2><p>设 $a,b$ 是长度为 $N$（不必 2 的幂次，之前这个限制只是为了快速计算）的数列，则</p>
<script type="math/tex; mode=display">
\hat{ab} = \hat{a} \star \hat{b}</script><p><strong>Proof</strong>：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat{a} \star \hat{b}(k) &=  \sum_{n=0} ^k  \hat{a}(n) \hat{b}(k-n) \\ 
&=  \sum_{n=0} ^k (\sum_{i=0} ^{N-1}  w^{ni} a_i ) (\sum_{j=0} ^{N-1}w^{(k-n)j}b_j) \\ 
&= \hat{ab}(k)
\end{aligned}</script><blockquote>
<p>最后一个式子成立是因为若$i \neq j$，则 $\sum_{n=0} ^k w^{ni} a_i w^{(k-n)j}b_j=0$</p>
</blockquote>
<p>所以我们有 $a \star b= \hat{\hat{a}\hat{b}}$，而多项式乘法只是卷积的一个例子。有些时候 <strong>计算式</strong> 一开始不是卷积形式，但是可以转换成卷积形式，再利用 FFT 或者 NFT 加速。</p>
<h2 id="NFT-模板"><a href="#NFT-模板" class="headerlink" title="NFT 模板"></a>NFT 模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> BI = __int128;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(BI *x,<span class="keyword">int</span> len)</span></span>&#123; <span class="comment">// note that bitreverse(i)=j</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;j) swap(x[i],x[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=len&gt;&gt;<span class="number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the mod must NFT-friendly or (len+1)*mod^2 &lt; FM</span></span><br><span class="line"><span class="keyword">const</span> BI FM = BI(<span class="number">29</span>)&lt;&lt;<span class="number">57</span>|<span class="number">1</span>, gg=<span class="number">3</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(BI *x,<span class="keyword">int</span> len,<span class="keyword">bool</span> isInverse=<span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">    g = powmod(gg,(FM<span class="number">-1</span>)/len,FM);</span><br><span class="line">    <span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">        g = powmod(g,FM<span class="number">-2</span>,FM);</span><br><span class="line">        BI invlen = powmod(BI(len),FM<span class="number">-2</span>,FM);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">            x[i]=x[i]*invlen%FM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bitreverse(x,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> half=<span class="number">1</span>,<span class="built_in">step</span>=<span class="number">2</span>;half!=len;half&lt;&lt;=<span class="number">1</span>,<span class="built_in">step</span>&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        BI wn = powmod(g,len/<span class="built_in">step</span>,FM),w=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="built_in">step</span>,w=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;i+half;++j)&#123;</span><br><span class="line">                BI t=(w*x[j+half])%FM;</span><br><span class="line">                x[j+half]=(FM-t+x[j])%FM;</span><br><span class="line">                x[j]=(x[j]+t)%FM;</span><br><span class="line">                w = w*wn%FM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">square</span><span class="params">(BI *a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(<span class="number">2</span>*n+<span class="number">1</span>));</span><br><span class="line">    nft(a,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">        a[i]=a[i]*a[i]%FM;</span><br><span class="line">    &#125;</span><br><span class="line">    nft(a,len,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(BI *a,BI *b,<span class="keyword">int</span> na,<span class="keyword">int</span> nb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>&lt;&lt;(<span class="number">32</span>-__builtin_clz(na+nb+<span class="number">1</span>));</span><br><span class="line">    nft(a,len);nft(b,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">        a[i] = a[i]*b[i]%FM;</span><br><span class="line">    &#125;</span><br><span class="line">    nft(b,len,<span class="number">1</span>);nft(a,len,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NFT-模板更新（2020-7-9"><a href="#NFT-模板更新（2020-7-9" class="headerlink" title="NFT 模板更新（2020/7/9)"></a>NFT 模板更新（2020/7/9)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> LL M = <span class="number">998244353</span>,ROOT=<span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powmod</span><span class="params">(LL x,LL n)</span></span>&#123;</span><br><span class="line">    <span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%M;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>; x=x*x%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i!=a.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;j) swap(a[i],a[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=a.<span class="built_in">size</span>()&gt;&gt;<span class="number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; &amp;a,<span class="keyword">bool</span> isInverse=<span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">    LL g = powmod(ROOT,(M<span class="number">-1</span>)/a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">        g = powmod(g,M<span class="number">-2</span>);</span><br><span class="line">        LL invLen = powmod(LL(a.<span class="built_in">size</span>()),M<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) x=x*invLen%M;</span><br><span class="line">    &#125;</span><br><span class="line">    bitreverse(a);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(),<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=w.<span class="built_in">size</span>();++i) w[i] = w[i<span class="number">-1</span>]*g%M;</span><br><span class="line">    <span class="keyword">auto</span> addMod = [](LL x,LL y)&#123;<span class="keyword">return</span> (x+=y)&gt;=M?x-=M:x;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">2</span>,half = <span class="number">1</span>;half!=a.<span class="built_in">size</span>();<span class="built_in">step</span>&lt;&lt;=<span class="number">1</span>,half&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,wstep=a.<span class="built_in">size</span>()/<span class="built_in">step</span>;i!=a.<span class="built_in">size</span>();i+=<span class="built_in">step</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j!=i+half;++j)&#123;</span><br><span class="line">                LL t = (a[j+half]*w[wstep*(j-i)])%M;</span><br><span class="line">                a[j+half]=addMod(a[j],M-t);</span><br><span class="line">                a[j]=addMod(a[j],t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;LL&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; a,<span class="built_in">vector</span>&lt;LL&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz=<span class="number">1</span>,tot = a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(sz&lt;tot) sz*=<span class="number">2</span>;</span><br><span class="line">    a.resize(sz);b.resize(sz);</span><br><span class="line">    nft(a);nft(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=sz;++i) a[i] = a[i]*b[i]%M;</span><br><span class="line">    nft(a,<span class="number">1</span>);</span><br><span class="line">    a.resize(tot);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于多项式乘法，求逆，带余除法的理论基础见下图，取自<a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">cp-algorithm</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="mulInv.png" alt="mulInv"></p>
<p><img src= "/img/loading.gif" data-lazy-src="divRem.png" alt="divRem"></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
        <tag>SageMath</tag>
      </tags>
  </entry>
  <entry>
    <title>Perron-Frobenius 理论</title>
    <url>/perronFrobeniusTheory/</url>
    <content><![CDATA[<p>1907 年 O.Perron 发现正矩阵的谱有特别有趣的性质。G.Frobenius 在 1908-1912 年间将 Perron 的工作推广到不可约非负矩阵的情形，并得到了新的进一步结果。Ferron-Frobenius 理论有很多证明方式，下面介绍 H.Wielandt 的优美证明。（一步步的读下去会发现很清晰明了简单）</p>
<blockquote>
<p>非负矩阵的谱半径（下面有定义）是它的一个特征值，并且这个特征值对应着非负特征向量。</p>
</blockquote>
<a id="more"></a>
<p>两个矩阵 $X$ 和 $Y$ 称为置换相似的，若存在一个置换矩阵 $P$ 满足 $P^TXP=Y$。设$A\in M_n$.称$A$为可约的，若 $A$ 置换相似于一个形如$\left( \begin{matrix}<br>B &amp; 0\\<br>C &amp; D<br>\end{matrix} \right)$ 其中 $B,D$ 是方阵，否则称 $A$ 不可约。</p>
<blockquote>
<p>$X \geq 0$ 表示矩阵的每个元素 $\geq 0$, （对向量，或者 $&gt;0$ 等情形类似定义即可）。</p>
<p>以下矩阵除非特别说明都是 $n \times n$ 矩阵 $n&gt;1$</p>
</blockquote>
<h2 id="引理-1-设-A-是不可约非负矩阵，-y-in-mathbf-R-n-backslash-lbrace-0-rbrace-且至少有一个分量为-0-则-I-A-y-的正分量的个数大于-y-的正分量个数"><a href="#引理-1-设-A-是不可约非负矩阵，-y-in-mathbf-R-n-backslash-lbrace-0-rbrace-且至少有一个分量为-0-则-I-A-y-的正分量的个数大于-y-的正分量个数" class="headerlink" title="引理 1 设 $A$ 是不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 且至少有一个分量为 0, 则 $(I+A)y$ 的正分量的个数大于 $y$ 的正分量个数"></a>引理 1 设 $A$ 是不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 且至少有一个分量为 0, 则 $(I+A)y$ 的正分量的个数大于 $y$ 的正分量个数</h2><p><strong>Proof</strong>： 设 $y$ 恰好有 $k$ 个正分量，$1 \leq k \leq n-1$。设 $P$ 是置换矩阵，使得$x=Py$的前$k$个分量为正，其它为 0，因为 $A$ 是非负矩阵，所以 $(I+A)y$的零分量个数不会超过 $n-k$。假设这个个数等于 $n-k$，则有 $y_i = 0 \Rightarrow (Ay)_i = 0$。即 $(PAP^Tx)_i = (PAy)_i = 0,\quad i=k+1,\cdots,n$，设 $B=PAP^T$. 则当 $k+1 \leq i \leq n$ 时，</p>
<script type="math/tex; mode=display">
(Bx)_i = \sum _{j=1} ^{n} b _{ij} x _j = 
\sum _{j=1} ^{k} b _{ij} x _j = 0</script><p>但当 $1 \leq j \leq k$ 时，$x_j &gt;0$。所以 $b_{ij}=0$, 其中 $k+1 \leq i \leq n,1 \leq j \leq k$ 矛盾于 $A$ 不可约，证毕。</p>
<h2 id="引理-2-设-A-是-n-阶不可约非负矩阵，-y-in-mathbf-R-n-backslash-lbrace-0-rbrace-则-I-A-n-1-y-gt-0"><a href="#引理-2-设-A-是-n-阶不可约非负矩阵，-y-in-mathbf-R-n-backslash-lbrace-0-rbrace-则-I-A-n-1-y-gt-0" class="headerlink" title="引理 2 设 $A$ 是 $n$ 阶不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 则 $(I+A)^{n-1}y&gt;0$"></a>引理 2 设 $A$ 是 $n$ 阶不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 则 $(I+A)^{n-1}y&gt;0$</h2><h2 id="引理-3-设-n-gt-1-，则-n-阶非负矩阵-A-不可约当且仅当-I-A-n-1-gt-0"><a href="#引理-3-设-n-gt-1-，则-n-阶非负矩阵-A-不可约当且仅当-I-A-n-1-gt-0" class="headerlink" title="引理 3 设 $n&gt;1$，则 $n$ 阶非负矩阵 $A$ 不可约当且仅当 $(I+A)^{n-1}&gt;0$"></a>引理 3 设 $n&gt;1$，则 $n$ 阶非负矩阵 $A$ 不可约当且仅当 $(I+A)^{n-1}&gt;0$</h2><p><strong>Proof</strong>: 应用<strong>引理 2</strong>，考虑 $(I+A)^{n-1}e_j$ 即可。</p>
<h2 id="引理-4-一个不可约非负矩阵的非负特征向量是正特征向量"><a href="#引理-4-一个不可约非负矩阵的非负特征向量是正特征向量" class="headerlink" title="引理 4 一个不可约非负矩阵的非负特征向量是正特征向量"></a>引理 4 一个不可约非负矩阵的非负特征向量是正特征向量</h2><p><strong>Proof</strong>：设 $A$ 是不可约非负矩阵，$Ax=\lambda x, x \geq 0,x \neq 0$。显然 $\lambda \geq 0$ 我们有 $(I+A)x = (1 + \lambda)x$ ，因此$(1+A)x$与$x$有相同个数的正分量，有 <strong>引理 1</strong> 知 $x&gt;0$。</p>
<h3 id="Collatz-Wielandt-函数"><a href="#Collatz-Wielandt-函数" class="headerlink" title="Collatz-Wielandt 函数"></a>Collatz-Wielandt 函数</h3><p>设 $A$ 是一个非负矩阵。$A$ 的 Collatz－Wielandt 函数 $f_A \colon \mathbf{R}_+ ^n \backslash \lbrace 0 \rbrace  \to \mathbf{R}_+$ 定义为：</p>
<script type="math/tex; mode=display">
f_A(x) = \min _{ x _i \neq 0 } \frac{(Ax) _i }{x _i}</script><h2 id="引理-5-设-A-为非负不可约矩阵，则"><a href="#引理-5-设-A-为非负不可约矩阵，则" class="headerlink" title="引理 5 设 $A$ 为非负不可约矩阵，则"></a>引理 5 设 $A$ 为非负不可约矩阵，则</h2><ol>
<li>$f_A(tx) = f_A(x), \forall t &gt; 0$</li>
<li>$f_A(x) = \max \lbrace \rho | Ax-\rho x \geq 0 \rbrace$</li>
<li>设 $x \in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace$，记 $y = (I+A)^{n-1} x$ ,则 $f_A(y) \geq f_A(x)$。</li>
</ol>
<p><strong>Proof</strong>：(1),(2)显然。下证明(3)： 我们有$Ax- f_A(x)x \geq 0$，在等式两边左乘以$(I+A)^{n-1}$并利用$A$和$(I+A)^{n-1}$乘法可交换的性质，得到$A(I+A)^{n-1}x - f_A(x)(I+A)^{n-1}x \geq 0$ 即 $Ay - f_A(x)y\geq 0$ 再由（2）证毕。</p>
<blockquote>
<p>容易证明：$f_A$ 是有界函数，实际上，$f_A$ 非负且不超过 $A$ 的最大行和。</p>
<p>记$\Omega _n = \lbrace x \in \mathbf{R} _+ ^n | \sum _{i=1} ^n = 1 \rbrace$ 引理 5.1 说明，我们只需要在 $\Omega_n$ 上研究 $f_A$ 即可。显然$\Omega_n$是一个紧集，但是 $f_A$ 可能在 $\Omega _n$ 的边界不连续。</p>
<p>但是我们仍然有下面 <strong>引理 6</strong>。</p>
</blockquote>
<h2 id="引理-6-设-A-是非负不可约矩阵，则-f-A-在-mathbf-R-n-backslash-lbrace-0-rbrace-上可以取到最大值"><a href="#引理-6-设-A-是非负不可约矩阵，则-f-A-在-mathbf-R-n-backslash-lbrace-0-rbrace-上可以取到最大值" class="headerlink" title="引理 6 设 $A$ 是非负不可约矩阵，则 $f_A$ 在 $\mathbf{R}_{+} ^n \backslash \lbrace 0 \rbrace $上可以取到最大值"></a>引理 6 设 $A$ 是非负不可约矩阵，则 $f_A$ 在 $\mathbf{R}_{+} ^n \backslash \lbrace 0 \rbrace $上可以取到最大值</h2><p><strong>Proof</strong>: 记$\Delta = (I+A)^{n-1} \Omega _n = \lbrace y \mid y=(I+A)^{n-1} x ,x \in \Omega _n \rbrace$ 则 $\Delta$ 是一个紧集， 且有 <strong>引理 2</strong> 知 $\Delta$ 中向量都是正向量，因此 $f_A$ 在 $\Delta$ 上连续，由 Weierstrass 定理，$f_A$ 在某一点 $y^0 \in \Delta$ 取得 $f_A$ 在 $\Delta$ 上的最大值。记 $z^0 = y^0/ \sum_{i=1} ^n y_i ^0 \in \Omega_ n$。$\forall x \in \Omega_n$，记 $y=(I+A)^{n-1}x$ 利用 <strong>引理 5</strong> 可知</p>
<script type="math/tex; mode=display">
f_A(x) \leq f_A(y) \leq f_A(y^0) = f_A(z^0)</script><p>这就证明了 $f_A$ 在 $z^0$ 上取到它在 $\Omega_n$ 上的最大值。利用对$ \forall z \in R _+ ^n \backslash \lbrace 0 \rbrace $ 和 <strong>引理 6.1</strong> 有</p>
<script type="math/tex; mode=display">
f_A(z) = f_A(\frac{z}{\sum_{i=1}^n z_i}) \leq f_A(z^0)</script><p>可见 $f_A$ 在 $z^0$ 处取到它在 $R _+ ^n \backslash \lbrace 0 \rbrace$ 上的最大值。</p>
<h2 id="Perron-Frobenius-定理"><a href="#Perron-Frobenius-定理" class="headerlink" title="Perron-Frobenius 定理"></a>Perron-Frobenius 定理</h2><p><strong>矩阵 $A$ 的谱半径 $\rho(A)$ 定义成矩阵 $A$ 的所有特征值的绝对值的最大值。</strong></p>
<p>现在万事俱备了，下面开始介绍著名的 Perron-Frobenius 定理</p>
<h3 id="定理-7-Perron-Frobenius-设-A-是非负不可约矩阵，则下面结论成立"><a href="#定理-7-Perron-Frobenius-设-A-是非负不可约矩阵，则下面结论成立" class="headerlink" title="定理 7(Perron-Frobenius) 设$A$是非负不可约矩阵，则下面结论成立"></a>定理 7(Perron-Frobenius) 设$A$是非负不可约矩阵，则下面结论成立</h3><ol>
<li>$\rho(A)&gt;0$ 且 $\rho(A)$ 是矩阵 $A$ 的一个单特征值</li>
<li>$A$ 有一个对应于 $\rho(A)$ 的正特征向量</li>
<li>$A$ 的每个非负特征向量都对应于特征值 $\rho(A)$</li>
</ol>
<p><strong>Proof</strong>：由 <strong>引理 6</strong> 存在 $x^0 \in R _+ ^n \backslash \lbrace 0 \rbrace$ 满足 $f_A(x^0) \geq f_A(x), \forall x \in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace$ 记 $r=f_A(x^0)$，取 $u=(1,\cdots,1)^T$。因为 $A$ 不可约，没有零行，所以 $r \geq f_A(u) = \min \sum_ {i=1} ^n a _{ij} &gt; 0$</p>
<p>下面证明 $r$ 是 $A$ 的一个特征值，我们有: $Ax^0 - rx^0 \geq 0$，假设 $Ax^0 - rx^0 \neq 0$。由 <strong>引理 5.2</strong> 知 $(I+A)^{n-1}(Ax^0 - rx^0) &gt; 0$ 即 $Ay^0 - ry^0&gt; 0$ 其中，$y_0 = (I+A)^{n-1}x^0 &gt;0$。因此存在 $\epsilon &gt; 0$ 使得 $Ay^0 - (r+\epsilon)y^0&gt; 0$. 由<strong>引理 5.2</strong>，$f_A(y^0) \geq r+\epsilon &gt; r$ 这就与 $r=f_A(x^0)$ 的最大性矛盾。所以 $Ax^0=rx^0$。从而$r$是$A$的一个特征值，$x^0$ 是 $A$ 的一个特征向量。有 <strong>引理 4</strong> 知，$x^0$ 是正向量。<br>设 $\lambda$ 是 $A$ 的任何一个特征向量：$Ax=\lambda x$ 则 $|\lambda||x| \leq A|x|$，于是 $|\lambda| \leq f _ A(|x|) \leq r$ 这表明 $r = \rho(A)$。</p>
<blockquote>
<p>以下关于证明 $\rho(A)$ 是单特征值的部分可以不看</p>
</blockquote>
<hr>
<p>现证明 $\rho(A)$ 是单特征值，我们先证明 $\rho(A)$ 的几何重数是 1，设 $Ay = \rho(A) y,0 \neq y \in \mathbf{C}^n$ 则 $A|y|  \geq \rho(A)|y|$ 上面证明过程表明上式是等式（细品，走一遍没毛病）且 $|y|&gt;0$。可见 $A$ 的对应于 $\rho(A)$ 的特征向量不含零分量。设 $y$ 和 $z$ 是对应 $\rho(A)$ 的特征向量。则 $|y|&gt;0,|z|&gt;0.z_ 1 y-y_ 1 z$ 属于 $\rho(A)$ 的特征子空间，但 $z_ 1 y-y_ 1 z$ 的第一个分量为 0，所以它不可能是 $\rho(A)$ 的特征值，因此，$z_ 1 y-y_ 1 z＝0$，$y$ 和 $z$ 线性相关，所以 $\rho(A)$ 的几何重数为 1.</p>
<p>为了证明 $r=\rho(A)$ 是特征多项式 $\phi(\lambda) = det(\lambda I - A)$ 的单根，只需证明，导数 $\phi’(r) \neq 0$</p>
<p>用 $adj(X)$ 表示矩阵 $X$ 的 <a href="https://baike.baidu.com/item/%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5/10034983?fr=aladdin" target="_blank" rel="noopener">伴随矩阵</a>。我们有</p>
<script type="math/tex; mode=display">
\phi'(\lambda) = \sum_{i=1}^n det[(\lambda I - A)(i|i)]
=tr[adj(\lambda I - A)]</script><blockquote>
<p>$X(i|j)$ 表示矩阵去掉第 $i$ 行和第 $j$ 列所剩下的矩阵</p>
</blockquote>
<p>记 $B(r)=adj(rI-A)$ 则 $\phi’(r) = tr B(r)$</p>
<script type="math/tex; mode=display">
(rI-A)B(r) = det(rI-A)I</script><p>因为 $r$ 的几何重数为 1，所以 $rank(rI-A)=n-1$，于是 $B(r) \neq 0$。设 $b$ 是$B(r)$的任意一个非零列，则$(rI-A)b=0$,因此 $b$ 是 $A$ 的对应于 $r$ 的特征向量，但是 $A$ 有一个对应于 $r$ 的特征向量 $x^0$，且因为 $r$ 的几何重数为 1，因此 $b$ 是 $x^0$ 的一个常数倍，从而 $b&gt;0$ 或者 $b<0$。这就证明了 $B(r)$ 的每一列要么是零列，要么是正向量，要么是负向量。考虑 $[B(r)]^T = adj(rI-A^T),r=\rho(A)=\rho(A^T)$。上面结论应用于 $[B(r)]^T$ 的列，所以 $B(r)>0$ 或者 $B(r)&lt;0$，从而 $\phi’(r)=tr[B(r)] \neq 0$，这就证明了 $\rho(A)$ 是单特征值。</p>
<hr>
<p>我们已经证明了(1),(2)。现在来证明(3)。设 $y&gt;0$ 是 $A^T$ 对应于 $\rho(A)$ 的特征向量，设 $x$ 是 $A$ 的任意一个非负特征向量：$Ax = \mu x$。则 $\mu y^T x = y^T Ax = \rho(A)y^Tx$, 因为 $y^Tx&gt;0$, 我们有 $\mu = \rho(A)$，证毕。</p>
<blockquote>
<p>由<strong>引理 4</strong>，$A$ 的非负特征向量实际上都是正向量，因此结论 3 可叙述成：在$A$ 的所有特征向量中，只有 $\rho(A)$ 有非负特征向量。上述证明还确定了以下结果：</p>
</blockquote>
<h2 id="定理-8-设-A-是不可约非负矩阵，则-rho-A-max-lbrace-f-A-x-x-in-mathbf-R-n-backslash-lbrace-0-rbrace-rbrace-gt-0-若-x-in-mathbf-R-n-backslash-lbrace-0-rbrace-f-A-x-rho-A-则-x-gt-0-是对应于-rho-A-的一个特征向量"><a href="#定理-8-设-A-是不可约非负矩阵，则-rho-A-max-lbrace-f-A-x-x-in-mathbf-R-n-backslash-lbrace-0-rbrace-rbrace-gt-0-若-x-in-mathbf-R-n-backslash-lbrace-0-rbrace-f-A-x-rho-A-则-x-gt-0-是对应于-rho-A-的一个特征向量" class="headerlink" title="定理 8. 设 $A$ 是不可约非负矩阵，则 $\rho(A) = \max \lbrace f_A(x)|x\in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace \rbrace &gt; 0$ , 若$ x \in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace ,f_A(x) = \rho(A)$ 则$x&gt;0$ 是对应于$\rho(A)$的一个特征向量"></a>定理 8. 设 $A$ 是不可约非负矩阵，则 $\rho(A) = \max \lbrace f_A(x)|x\in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace \rbrace &gt; 0$ , 若$ x \in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace ,f_A(x) = \rho(A)$ 则$x&gt;0$ 是对应于$\rho(A)$的一个特征向量</h2><h2 id="定理-9-设-A-是一个非负矩阵，则-rho-A-是-A-的特征值，且-A-有一个对应于-rho-A-的非负特征向量"><a href="#定理-9-设-A-是一个非负矩阵，则-rho-A-是-A-的特征值，且-A-有一个对应于-rho-A-的非负特征向量" class="headerlink" title="定理 9. 设 $A$ 是一个非负矩阵，则 $\rho(A)$ 是 $A$ 的特征值，且 $A$ 有一个对应于$\rho(A)$的非负特征向量"></a>定理 9. 设 $A$ 是一个非负矩阵，则 $\rho(A)$ 是 $A$ 的特征值，且 $A$ 有一个对应于$\rho(A)$的非负特征向量</h2><p><strong>Proof</strong>：设$A$的阶数为$n$，定理对$n=1$是平凡地成立。下面设$n=2$，用$J$表示元素全为 1 的矩阵。<br>对于正整数 $k$，记 $A_k = A + \frac{1}{k} J$ 是一个正矩阵，由 Perron-Frobenius 定理，$A_k$ 在 $\Omega _n = \lbrace x \in \mathbf{R} _+ ^n | \sum _{i=1} ^n = 1 \rbrace$ 中有唯一一个对应于 $\rho(A_k)$ 的特征向量 $x^k$。</p>
<p>因为向量序列 $\lbrace x^k \rbrace$ 有界因此，由 Bolzano-Weierstrass 定理,$\lbrace x^k \rbrace $ 有收敛子列 $\lbrace x^{k_i} \rbrace: \lim _{i \to \infty } x^{k_i} = x$。显然 $x \in \Omega _n$ 因此</p>
<script type="math/tex; mode=display">
A _{k_i}x^{k _i} = \rho(A _{k _i}) x^{k _i}</script><p>注意到当 $i \to \infty$ 时， $A _{k_i} \to A , \rho(A _{k _i}) \to \rho(A)$ 从而得到 $Ax = \rho(A)x$，证毕。</p>
<blockquote>
<p>至此，Prron-Frobenius 定理介绍完毕。下面介绍一个非负矩阵特征值的界。</p>
</blockquote>
<h2 id="定理-10-设-A-是非负矩阵，则"><a href="#定理-10-设-A-是非负矩阵，则" class="headerlink" title="定理 10 设 $A$ 是非负矩阵，则"></a>定理 10 设 $A$ 是非负矩阵，则</h2><script type="math/tex; mode=display">
\min_{1 \leq i \leq n} r_i \leq \rho(A) \leq \max_{1 \leq i \leq n} r_i</script><script type="math/tex; mode=display">
\min_{1 \leq i \leq n} c_i \leq \rho(A) \leq \max_{1 \leq i \leq n} c_i</script><p>其中 $r_i, c_i$ 分别为 $A$ 的第 $i$ 行之和以及第 $i$ 列之和。</p>
<p><strong>Proof</strong>：设 $x$ 是 $A^T$ 的一个 Perron 向量(对应于谱半径的非负特征向量)。因为 $\rho(A^T)=\rho(A)$， 从而 $A^Tx=\rho(A)x$ 得到</p>
<script type="math/tex; mode=display">
\rho(A)x_i = \sum_{k=1}^n a_{ki}x_k \qquad i = 1,\cdots,n.</script><p>将这些等式相加得到 $\rho(A) \sum_{i=1}^n x_i =\sum_{k=1}^n r_k x_k$ 即</p>
<script type="math/tex; mode=display">
\rho(A)= \frac{\sum_{k=1}^n r_k x_k }{\sum_{i=1}^n x_i}</script><p>证毕。</p>
<h2 id="定理-11-Wielandt-设-A-是不可约非负矩阵，且-B-leq-A-则对于-B-的任何特征值-lambda-有"><a href="#定理-11-Wielandt-设-A-是不可约非负矩阵，且-B-leq-A-则对于-B-的任何特征值-lambda-有" class="headerlink" title="定理 11(Wielandt) 设$A$是不可约非负矩阵，且$|B| \leq A$ 则对于 $B$ 的任何特征值 $\lambda$有"></a>定理 11(Wielandt) 设$A$是不可约非负矩阵，且$|B| \leq A$ 则对于 $B$ 的任何特征值 $\lambda$有</h2><script type="math/tex; mode=display">
|\lambda| \leq \rho(A)</script><p><strong>Proof</strong>：设$Bx=\lambda x$ 则 $|B||x| \geq |\lambda||x|$，但是 $|B| \leq A$，所以 $|\lambda| |x| \leq |B||x| \leq A |x|$，由 <strong>引理 5.2</strong> 和 <strong>引理 8</strong> 知</p>
<script type="math/tex; mode=display">
|\lambda| \leq f_A(|x|) \leq \rho(A)</script><p>证毕。</p>
<p>根据谱半径的连续性，我们马上有如下推论</p>
<ol>
<li>若矩阵 $A$ 非负，且$|B| \leq A$，则 $\rho(B) \leq \rho(A)$</li>
<li>对任意矩阵$A$，$\rho(A) \leq \rho(|A|)$.(这个直接证明也可以)</li>
</ol>
<blockquote>
<p>本文源自詹兴致所著的《矩阵论》第六章。</p>
</blockquote>
<p>定理虽然很长但是整个过程十分优美，思路十分清晰，仔细分析每一步还是很容易看懂的，并且在证明的过程中就能体会为什么一开始要提出“非负不可约矩阵”的概念了，然后应用连续性把一些结果推广到非负矩阵。</p>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>$x^2 \equiv a \mod n$ 何时有解</title>
    <url>/quadraticModEquation/</url>
    <content><![CDATA[<p>显然，我们只需考虑$0 \leq a &lt; n$ 的情形。这个问题应该很早就被人考虑好了，不过无所谓吧（反正只是个博文而已）。以下内容都是独立完成的。并可看作<a href="/quadraticResidueAndGaussReciprocity/" title="二次剩余和 Gauss 互反律">二次剩余和 Gauss 互反律</a> 这篇博文的延续。最后再给出方程的一个解（如果存在的话）。</p>
<a id="more"></a>
<p>记 $A_n =  \{0&lt;x&lt;n \mid \gcd(x,n) = 1\}$，则 $A_n$ 关于 $\mod n$ 的乘法构成一个群（根据 Euler 定理$|A_n| = \psi(n)$）</p>
<p>所以若$\gcd(a,n)= 1$，则任意$x \in A_n$，存在唯一$y \in A_n$ 使得$xy \equiv a \mod n$ </p>
<p>若 $x^2 \equiv a \mod n$ 无解，则 $\prod_{x \in A_n} x = a^{\frac{\psi(n)}{2}} \mod n$</p>
<p>若 $x^2 \equiv a \mod n$ 有解，设$0&lt;a_1&lt;a_2&lt;\cdots&lt;a_r&lt;n$ 是全部解。则 $\prod_{x \in A_n} x = a^{\frac{\psi(n)-r}{2}} a_1 \cdots a_r  \mod n$，注意到$r$只与$n$有关，与$a$ 无关。</p>
<blockquote>
<p>用$[\frac{a}{n}] = 1$表示有解，用$[\frac{a}{n}] = 0$ 表示无解。</p>
</blockquote>
<p>为了考虑这个问题，我们分情况讨论</p>
<h2 id="x-2-equiv-a-mod-2-m-gcd-a-p-m-1-何时有解"><a href="#x-2-equiv-a-mod-2-m-gcd-a-p-m-1-何时有解" class="headerlink" title="$x^2 \equiv a \mod 2^m,  \gcd(a,p^m) = 1$ 何时有解"></a>$x^2 \equiv a \mod 2^m,  \gcd(a,p^m) = 1$ 何时有解</h2><p>当 $m=1,2$ 时，有解当且仅当 $a=1$</p>
<p>当 $m \geq 3$ 时，$2^m | (a_2 -a_1)(a_2+a_1)$, 若 $(a_2-a_1)$ 和 $a_2+a_1$ 都是 <code>4· 的倍数，则 $a_1,a_2$ 也是</code>2` 的倍数矛盾于 $\gcd(a,2^m) = 1$。所以 $2^{m-1}|(a_2+a_1)$ 或者 $2^{m-1}|(a_2-a_1)$。所以 $0 &lt; a_1 &lt; 2^{m-2}$，$a_2 = 2^{m-1}-a_1,a_3 = 2^{m-1}+a_1,a_4 = 2^m-a_1$。</p>
<p>但是，若 $x$ 是奇数，则 $x^2 \equiv 1\mod 8$ ，令一方面 $\gcd(a,2^m) = 1$ 当且仅当 $a \equiv \mod 2$，而且每一个解对应 4 个 $x$。</p>
<p>即 $1^2,2^2,\cdots,(2^m-1)^2 \mod 2^m$，只有 $2^{m-3}$ 个数，但是小于 $2^m$ 且模 8 为 1 的数也只有，$2^{m-3}$个。因此，</p>
<p>有解 <strong>当且仅当</strong> $a \equiv 1 \mod 8$</p>
<h2 id="x-2-equiv-a-mod-p-m-p-gt-2-gcd-a-p-m-1-何时有解"><a href="#x-2-equiv-a-mod-p-m-p-gt-2-gcd-a-p-m-1-何时有解" class="headerlink" title="$x^2 \equiv a \mod p^m,\;p&gt;2,  \gcd(a,p^m) = 1$ 何时有解"></a>$x^2 \equiv a \mod p^m,\;p&gt;2,  \gcd(a,p^m) = 1$ 何时有解</h2><p>因为  $p^m|(a_2-a_1)(a_2+a_1)$，若$(a_2-a_1)$ 和 $a_2+a_1$ 都是 $p$ 的倍数，则 $a_1,a_2$ 也是 $p$ 的倍数矛盾于 $\gcd(a,p^m) = 1$，所以  $a_2 = p^m - a_1$。从而 $r=2,\; a_1a_2 \equiv -a \mod p^m$，所以</p>
<ul>
<li><p>若 $x^2 \equiv a \mod p^m$ 无解，则 $\prod_{x \in A_n} x = a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m$</p>
</li>
<li><p>若 $x^2 \equiv a \mod p^m$ 有解，则 $\prod_{x \in A_n} x = -a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m$</p>
</li>
</ul>
<p>取 $a=1$，则 $\prod_{x \in A_n} x = -1 \mod p^m$，即 </p>
<script type="math/tex; mode=display">
[\frac{a}{p^m}] =  (1 \equiv a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m)?</script><h2 id="x-2-equiv-a-p-i-mod-p-m-i-lt-m-gcd-a-p-m-1-何时有解"><a href="#x-2-equiv-a-p-i-mod-p-m-i-lt-m-gcd-a-p-m-1-何时有解" class="headerlink" title="$x^2 \equiv a p^i \mod p^m, \; i&lt;m, \; \gcd(a,p^m) = 1$ 何时有解"></a>$x^2 \equiv a p^i \mod p^m, \; i&lt;m, \; \gcd(a,p^m) = 1$ 何时有解</h2><p>若 $i=2k-1$ 为奇数，则 $p^k|x$，从而 $p^{i+1} | ap^i$，矛盾于 $\gcd(a,p^m) = 1$</p>
<p>所以$i$ 为偶数，显然此时上式有解当且仅当 $x^2 \equiv a \mod p^{m-i},\gcd(a,p^{m-i}) = 1$ 有解</p>
<p>综上 </p>
<script type="math/tex; mode=display">
[ \frac{a}{p^m} ] = \left\{ \begin{array}{cc} 
1 & a=0 \\
1 & p=2,\; a \equiv 1 \mod 8 \\
-1 & p=2,\; a \not \equiv 1 \mod 8 \\
(1 \equiv a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m)? & p>2,\; \gcd(a,p^m) = 1\\
-1 & \gcd(a,p^m) = p^i, i \equiv 1 \mod 2 \\
[\frac{ap^{-i}}{p^{m-i}}] & \gcd(a,p^m) = p^i, i \equiv 0 \mod 2 \\
\end{array} \right.</script><h2 id="x-2-equiv-a-mod-m-1m-2-gcd-m-1-m-2-1-何时有解"><a href="#x-2-equiv-a-mod-m-1m-2-gcd-m-1-m-2-1-何时有解" class="headerlink" title="$x^2 \equiv a \mod m_1m_2,\gcd(m_1,m_2)=1$何时有解"></a>$x^2 \equiv a \mod m_1m_2,\gcd(m_1,m_2)=1$何时有解</h2><p>考虑</p>
<script type="math/tex; mode=display">
x \equiv a_1^2 \mod m_1 \\
x \equiv a_2^2 \mod m_2</script><p>则，存在 $t_1,t_2$ 使得，$t_1m_1 + t_2m_2 = 1$，所以 $t_1^2m_1^2 + t_2^2 m_2^2 + 2t_1m_1t_2m_2=1$, 所以 $x \equiv (t_2m_2 a_1)^2$ 且$x \equiv (t_1m_1a_2)^2$，所以 </p>
<script type="math/tex; mode=display">
x \equiv (t_2m_2a_1)^2 + (t_1m_1a_2)^2 \equiv (t_2m_2a_1 + t_1m_1a_2)^2 \mod m_1m_2</script><p>令一方面若 $x \equiv a^2 \mod m_1m_2$，则 $x \equiv (a \mod m_i)^2 \mod m_i$</p>
<p>即 $x^2 = a \mod m_1m_2$ <strong>有解当且仅当</strong> $[\frac{a}{m_1}] = [\frac{a}{m_2}]=1$</p>
<blockquote>
<p>最终方案：$n = p_1^{m_1} \cdots p_r^{m_r},\;p_1&lt; \cdots &lt;p_r$, $[\frac{a}{m}] = \prod [\frac{a}{p_i^{m_i}}]$ </p>
</blockquote>
<h2 id="判断是否有解的-sagemath-代码"><a href="#判断是否有解的-sagemath-代码" class="headerlink" title="判断是否有解的 sagemath 代码"></a>判断是否有解的 sagemath 代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modSqrtSymbol.ipynb</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modSqrtSymbol</span><span class="params">(an,n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> p,m <span class="keyword">in</span> factor(n):</span><br><span class="line">        a = an%p^m</span><br><span class="line">        <span class="keyword">if</span> a == <span class="number">0</span>:  <span class="keyword">continue</span></span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> a%p == <span class="number">0</span>:</span><br><span class="line">            a//=p</span><br><span class="line">            m-=<span class="number">1</span></span><br><span class="line">            flag = <span class="keyword">not</span> flag</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:  <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> a%<span class="number">8</span> != <span class="number">1</span>:  <span class="keyword">return</span>  <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> power_mod(a,p^(m<span class="number">-1</span>)*(p<span class="number">-1</span>)//<span class="number">2</span>,p^m) != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为<code>factor</code>复杂度是 $O(\sqrt{n})$， 所以整体复杂度 $O(\sqrt{n})$</p>
</blockquote>
<h2 id="求出-x-2-equiv-a-mod-n-的一个解"><a href="#求出-x-2-equiv-a-mod-n-的一个解" class="headerlink" title="求出 $x^2 \equiv a \mod n$ 的一个解"></a>求出 $x^2 \equiv a \mod n$ 的一个解</h2><blockquote>
<p>本来是想求全部解的，但是考虑到如果 $\gcd(a,n) \neq 1$ 则解的个数实在太多，就不想求全部解了，当然如果真的有这个需要，求全部解也不难。</p>
<p>另外，无论是是否有解还是求全部解都可以直接暴力做，只是复杂度为$O(n)$ ，效率太低。</p>
</blockquote>
<h3 id="求-x-2-equiv-a-mod-2-m-的全部解，不妨设-a-equiv-1-mod-8"><a href="#求-x-2-equiv-a-mod-2-m-的全部解，不妨设-a-equiv-1-mod-8" class="headerlink" title="求$x^2 \equiv a \mod 2^m$ 的全部解，不妨设 $a \equiv 1 \mod 8 $"></a>求$x^2 \equiv a \mod 2^m$ 的全部解，不妨设 $a \equiv 1 \mod 8 $</h3><p>若 $m=1$，则 $x=1$，若 $m=2$，则 $x=1,3$，若 $m=3$，则 $x=1,3,5,7$，若 $m \geq 4$，不妨设 $x_{m-1}$ 是满足方程 $x^2 \equiv a \mod 2^{m-1}$的最小正整数解，即 $x_{m-1}^2 = a + 2^{m-1}k$</p>
<ul>
<li><p>若 $k$ 是偶数，则必然是 $x_{m-1}^2 \equiv a \mod 2^m$ 的解，最小的解就是 $\min(x_{m-1},2^{m-2}-x_{m-1})$，但由于 $x_{m-1} \leq 2^{m-3}$，所以 $x_m=x_{m-1}$</p>
</li>
<li><p>若 $k$ 为奇数，则 $(2^{m-2}-x_{m-1})^2 = 2^{2m-4}-2^{m-1}+x_{m-1}^2 \equiv a \mod 2^m$，且 $0&lt;2^{m-2}-x_{m-1}&lt;2^{m-2}$，所以 $x_m =2^{m-2}-x_{m-1}$</p>
</li>
</ul>
<p>所以经过 $m$ 步就可找到所有解就是 $x_m,2^{m-1}-x_m,2^{m-1}+x_m,2^m-x_m$</p>
<h3 id="求-x-2-equiv-a-mod-p-m-p-gt-2-的全部解，其中-gcd-a-p-m-1"><a href="#求-x-2-equiv-a-mod-p-m-p-gt-2-的全部解，其中-gcd-a-p-m-1" class="headerlink" title="求 $x^2 \equiv a \mod p^m, \; p&gt;2$ 的全部解，其中 $\gcd(a,p^m) = 1$"></a>求 $x^2 \equiv a \mod p^m, \; p&gt;2$ 的全部解，其中 $\gcd(a,p^m) = 1$</h3><p>令 $q = \frac{\psi(p^m)}{2} = p^{m-1}\frac{p-1}{2}$，若 $q$ 是奇数，则 $(a^{\frac{q+1}{2}})^2 = a^q a \equiv a\mod p^m$，从而解就是 $a^{\frac{q+1}{2}},p^m-a^{\frac{q+1}{2}}$</p>
<p>否则，记 $q = 2^{i}q’$（想模仿上面 $q$ 是奇数的情况），我们找一个非二次剩余 $b$，即 $b^q \equiv -1 \mod p^m$。我们记 $x = a^{\frac{q’+1}{2}},\;y = b^{q’}, \; t= a^{q’}$。则</p>
<p>$x^2 = ta, t^{2^i} = 1, y^{2^i}=-1$。我们想保持 $x^2 = ta$，让 $t$ 变成 1。就打到了我们的目的。</p>
<p>若 $t^{2^{s}} = -1, t^{2^{s+1}} = 1$, 则 $s&lt;i$，那么 $(y^{2^{i-s}}t)^{2^{s}} = y^{2^i}t^{2^{s}} = 1$，并且 $(y^{2^{i-s-1}}x)^2 = (y^{2^{i-s}}t)a$，我们更新 $t = y^{2^{i-s}}t$，更新 $x=y^{2^{i-s-1}}x$。重复上述过程直到 $t=1$。</p>
<p>我们也可以类似 $p=2$ 的情况，经过 $m$ 步得到全部解，只是 $m=1$ 的时候是困难的，并且和上述分析一致，所以就没用 $p=2$ 时的方法。若 $x_{m-1}$ 满足 $x_{m-1}^2 = a + p^{m-1}k$</p>
<ul>
<li><p>若 $k$ 是偶数，$(x_{m-1} - \frac{k}{2}p^{m-1})^2 \equiv a \mod p^m$</p>
</li>
<li><p>若 $k$ 是奇数，$(x_{m-1} + \frac{p-k}{2}p^{m-1})^2 \equiv a \mod p^m$</p>
</li>
</ul>
<p>对一般的 $n = p_1^{m_1} \cdots p_r ^{m_r}$，我们对每个 $(a, p_i ^m)$ 给出一个解，再用 <a href="/chineseRemainTheorem/" title="中国剩余定理">中国剩余定理</a> 拼出最终解。</p>
<h3 id="x-2-equiv-a-mod-n-的一个解的-Sagemath-代码"><a href="#x-2-equiv-a-mod-n-的一个解的-Sagemath-代码" class="headerlink" title="$x^2 \equiv a \mod n$ 的一个解的 Sagemath 代码"></a>$x^2 \equiv a \mod n$ 的一个解的 Sagemath 代码</h3><blockquote>
<p>需要用到上面的 <code>modSqrtSymbol</code> 函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modSqrt.ipynb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find one x s.t. x^2 = a mod 2^m, gcd(a,2) = 1 and 0 &lt; a &lt; 2^m and must have an answer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modSqrt2Core</span><span class="params">(a,m)</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>,m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (x*x-a)%(<span class="number">1</span>&lt;&lt;i) != <span class="number">0</span>:</span><br><span class="line">            x = (<span class="number">1</span>&lt;&lt;i<span class="number">-2</span>)-x</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># find one x s.t. x^2 = a mod p^m, gcd(a,p)=1, p&gt;2 and  0 &lt; a &lt; p^m and must have an answer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modSqrtPCore</span><span class="params">(a,p,m)</span>:</span></span><br><span class="line">    n = p^m</span><br><span class="line">    q = p^(m<span class="number">-1</span>)*(p<span class="number">-1</span>)&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> q%<span class="number">2</span> == <span class="number">1</span>:  <span class="keyword">return</span> power_mod(a,(q+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,n)</span><br><span class="line">    b=randint(<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">while</span>(power_mod(b,q,n)==<span class="number">1</span>):  b=randint(<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    ni = q&amp;(-q)</span><br><span class="line">    q //= ni</span><br><span class="line">    x = power_mod(a,(q+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,n)</span><br><span class="line">    y = power_mod(b,q,n)</span><br><span class="line">    t = power_mod(a,q,n)</span><br><span class="line">    <span class="comment"># x^2 = ta mod n, y^ni = -1 mod n</span></span><br><span class="line">    <span class="keyword">while</span> t != <span class="number">1</span>:</span><br><span class="line">        ns = <span class="number">1</span>;tt=t*t;</span><br><span class="line">        <span class="keyword">while</span> tt!=<span class="number">1</span>:</span><br><span class="line">            tt=(tt*tt)%n</span><br><span class="line">            ns&lt;&lt;=<span class="number">1</span></span><br><span class="line">        <span class="comment"># t^ns = -1 mod n</span></span><br><span class="line">        t = power_mod(y,ni//ns,n)*t%n</span><br><span class="line">        x = power_mod(y,ni//(ns*<span class="number">2</span>),n)*x%n</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># find one x s.t. x^2 = a mod p^m and must have an answer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modPowerSqrt</span><span class="params">(a,p,m)</span>:</span></span><br><span class="line">    n = p^m</span><br><span class="line">    a %= n</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> a%p==<span class="number">0</span>:</span><br><span class="line">        a//=p</span><br><span class="line">        m-=<span class="number">1</span></span><br><span class="line">        time+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>**(time//<span class="number">2</span>)*(modSqrt2Core(a,m) <span class="keyword">if</span> p==<span class="number">2</span> <span class="keyword">else</span> modSqrtPCore(a,p,m))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modSqrt</span><span class="params">(a,n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> modSqrtSymbol(a,n):  <span class="keyword">return</span> []</span><br><span class="line">    fact = list(factor(n))</span><br><span class="line">    x = [modPowerSqrt(a,p,m) <span class="keyword">for</span> p,m <span class="keyword">in</span> fact]</span><br><span class="line">    m = [p^m <span class="keyword">for</span> p,m <span class="keyword">in</span> fact]</span><br><span class="line">    <span class="keyword">return</span> crt(x,m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试几个样例</span></span><br><span class="line">a,m = <span class="number">17</span>,<span class="number">2</span>**<span class="number">8</span></span><br><span class="line">x =  modSqrt(a,m)</span><br><span class="line">print(x,x*x%m,a,m)</span><br><span class="line"></span><br><span class="line">a,m = <span class="number">15</span>,<span class="number">7</span>**<span class="number">8</span></span><br><span class="line">x =  modSqrt(a,m)</span><br><span class="line">print(x,x*x%m,a,m)</span><br><span class="line"></span><br><span class="line">a,m = <span class="number">16</span>,<span class="number">3</span>*<span class="number">5</span>*<span class="number">5</span>*<span class="number">7</span>*<span class="number">7</span>*<span class="number">7</span></span><br><span class="line">x =  modSqrt(a,m)</span><br><span class="line">print(x,x*x%m,a,m)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Math</tag>
        <tag>SageMath</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 入门</title>
    <url>/pythonLearning/</url>
    <content><![CDATA[<p>在苏铭和蓝莓带领下，最近开始学习 Python，下面是走过的坑，吐槽正式开始</p>
<blockquote>
<p>Python 在代码书写上要求极高，所有很多时候代码复制过来报错。。还有代码区分空格和 Tab</p>
<p>Python 中，对象赋值本质上是对象的引用</p>
<p>不要把 Python 代码写成 C/C++的风格！同样 SageMath 的代码也不要迁就 Python</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Python 官网慢的我想吐，几次都没有下下来，最后是在一次中午时分用手机流量定位了下载的地方，然后直接在电脑上手动输入长达 30 字符的网址（带文件名）直接下载，然后网速“飞快”，终于下下来了 26M 的 windows 64 位 Python3.8.2。然后就是用 pip 安装各种包，然后安装的时候真的是一头包，各种报错，各种而且奇慢无比，我吐了。后来终于找到解决方案：引用豆瓣源（其他源也行）。例子如下：</p>
<a id="more"></a>
<p><code>pip install numpy -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com</code></p>
<p><code>pip install wxPython -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com</code></p>
<p>安装好一些必要的包之后就可以跑程序了。</p>
<blockquote>
<p>pip freeze/list 查看所有安装了的包</p>
</blockquote>
<p><a href="https://pypi.org/" target="_blank" rel="noopener">PyPi</a> ：Python Package Index 查看所有发布的包的索引。</p>
<h2 id="简单的终端-Python-程序示例"><a href="#简单的终端-Python-程序示例" class="headerlink" title="简单的终端 Python 程序示例"></a>简单的终端 Python 程序示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># score.py</span></span><br><span class="line">tmp = input(<span class="string">'苏铭的Python分数：'</span>)</span><br><span class="line"><span class="keyword">if</span> tmp.isdigit():</span><br><span class="line">    score = int(tmp)</span><br><span class="line">    <span class="keyword">if</span> score &gt; <span class="number">100</span>:</span><br><span class="line">        print(<span class="string">'我信了你的鬼话'</span>)</span><br><span class="line">    <span class="keyword">elif</span> score &gt;=<span class="number">60</span>:</span><br><span class="line">        print(<span class="string">'可以呀苏铭'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'菜的呀苏铭'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'你输入的是什么鬼哦'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="简单的-GUI-Python-程序示例"><a href="#简单的-GUI-Python-程序示例" class="headerlink" title="简单的 GUI Python 程序示例"></a>简单的 GUI Python 程序示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.py</span></span><br><span class="line"><span class="keyword">import</span>	wx  <span class="comment">#需要安装wxPython包，见上面pip安装</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frame1</span><span class="params">(wx.Frame)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, superior)</span>:</span></span><br><span class="line">        wx.Frame.__init__(self, parent= superior, title = <span class="string">'Example'</span>,pos = (<span class="number">400</span>,<span class="number">200</span>),size=(<span class="number">350</span>,<span class="number">500</span>))</span><br><span class="line">        panel = wx.Panel(self)</span><br><span class="line">        text1 = wx.TextCtrl(panel,value = <span class="string">'Hello'</span>,pos = (<span class="number">250</span>,<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = wx.App()</span><br><span class="line">    frame = Frame1(<span class="literal">None</span>)</span><br><span class="line">    frame.Show(<span class="literal">True</span>)</span><br><span class="line">    app.MainLoop()</span><br></pre></td></tr></table></figure>
<h2 id="IDE-选择-sublime-大法好-VSCode-无敌"><a href="#IDE-选择-sublime-大法好-VSCode-无敌" class="headerlink" title="IDE 选择(sublime 大法好, VSCode 无敌)"></a>IDE 选择(<del>sublime 大法好</del>, VSCode 无敌)</h2><p>当时我是大 sublime 啊， 百度 sublime+ Python 就可以获得<a href="https://www.cnblogs.com/honkly/p/6599642.html" target="_blank" rel="noopener">完整教程</a> 配置 和 <a href="https://blog.csdn.net/gui951753/article/details/82667860#安装Python3和sublime3" target="_blank" rel="noopener">代码补全</a> 配置，安装 packageControl <strong>网速慢的话可以早上 7 点起来尝试</strong>。(缺点是每次要先 Ctrl+S 保存再 F5 编译，然后下次编译上次的编译窗口不能自己关，我也不知道怎么搞解决这两个问题，可惜！)</p>
<p><code>再也不用担心tab不是tab了！ view ---&gt;  Indentation ---&gt; Convert Indentation to tabs</code></p>
<p><code>多行注释：ctrl + shift + /</code></p>
<blockquote>
<p><strong>一定要配置代码补全!!!, 特别是在用各种包的时候</strong></p>
</blockquote>
<h2 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h2><ol>
<li>下载好 Python 后有自带文档</li>
<li><a href="https://www.runoob.com/Python/Python-tutorial.html" target="_blank" rel="noopener">Python 菜鸟教程</a></li>
<li>百度一下，你就知道。不行可以选择 <a href="cn.bing.com">必应</a></li>
<li>网易公开课，我选择的是南京大学的 Python 玩转数据，用手机 app 才能看，建议观看 1-25 集和 43-50 集。 1.5 倍速。</li>
<li>爬虫（下面示例）</li>
<li>Pygame 库的使用（<del>PY 游戏</del>，那也才刺激了吧 0.0）</li>
<li><a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">100 天学会 Python</a></li>
<li><a href="https://github.com/ageitgey/face_recognition" target="_blank" rel="noopener">人脸识别</a></li>
</ol>
<p>基本语法掌握了之后就要掌握类了，Python 的类挺有趣的，哈哈.类中写得变量是类的属性，而每个对象的属性要加 self.的，然后方法里面的变量是方法内部临时变量。</p>
<h2 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initprime</span><span class="params">(n)</span>:</span></span><br><span class="line">    isp = [x%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">for</span> x  <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    isp[<span class="number">1</span>] = <span class="literal">False</span>;isp[<span class="number">2</span>]= <span class="literal">True</span></span><br><span class="line">    p = [<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> isp[i]: p.append(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> p:</span><br><span class="line">            <span class="keyword">if</span>(i*j&lt;=n):  isp[i*j] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i%j == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> isp,p</span><br><span class="line"></span><br><span class="line">print(initprime(<span class="number">100008</span>)[<span class="number">-1</span>][<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="爬虫示例"><a href="#爬虫示例" class="headerlink" title="爬虫示例"></a>爬虫示例</h2><p>总结爬虫方法：</p>
<ol>
<li>观察想要想要爬虫的网站中特定数据的网址，用 F12（适用于 Chorme, Edge 等）打开代码检查。找到数据对应的意义和名称</li>
<li>设计流程图和代码框架</li>
<li>Coding</li>
</ol>
<p>本来就不会写，学习了 <a href="https://leetcode-cn.com/circle/article/gy4iKU/" target="_blank" rel="noopener">leetcode</a> 上的代码后，制作了青春（<del>阉割</del>）版的爬取 lol 所有壁纸到当前文件夹的 lolIamge 文件夹中，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urlrequest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getimage</span><span class="params">(heroID)</span>:</span></span><br><span class="line">    heroId = str(heroID)</span><br><span class="line">    url = <span class="string">'https://game.gtimg.cn/images/lol/act/img/skin/big'</span> + heroId</span><br><span class="line">    heroDir = <span class="string">r'lolImage\\'</span> + heroId</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(heroDir):	os.mkdir(heroDir)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): </span><br><span class="line">        heroEnd = <span class="string">'0'</span> + str(i//<span class="number">10</span>) + str(i%<span class="number">10</span>) + <span class="string">'.jpg'</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            image = urlrequest.urlopen(url + heroEnd).read()</span><br><span class="line">        <span class="keyword">except</span>:	<span class="keyword">break</span></span><br><span class="line">        imageName = heroDir + <span class="string">r'\\'</span> + heroEnd</span><br><span class="line">        <span class="keyword">with</span> open(imageName, <span class="string">'wb'</span>) <span class="keyword">as</span> f:	f.write(image)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'lolImage'</span>):	os.mkdir(<span class="string">'lolImage'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000</span>):	getimage(i)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python 处理字符串的 <code>split</code> 函数强的不行，给爬虫提供了特别便利的条件</p>
</blockquote>
<h2 id="机器学习示例"><a href="#机器学习示例" class="headerlink" title="机器学习示例"></a><a href="# http://open.163.com/newview/movie/free?pid=ME9KEIKS7&amp;mid=MEF16V4ED">机器学习示例</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello ML.py</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree <span class="comment"># https://sklearn.apachecn.org/</span></span><br><span class="line">features = [[<span class="number">140</span>,<span class="number">1</span>], [<span class="number">130</span>,<span class="number">1</span>],[<span class="number">150</span>,<span class="number">0</span>],[<span class="number">170</span>,<span class="number">0</span>]]</span><br><span class="line">lAbels = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">clf = tree.DecisionTreeClassifier()</span><br><span class="line">clf = clf.fit(features,lAbels)</span><br><span class="line">print(clf.predict([[<span class="number">160</span>,<span class="number">0</span>]]))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有需求再去这里学习吧：<a href="https://www.bilibili.com/video/BV164411S78V?from=search&amp;seid=1436888055285204045" target="_blank" rel="noopener">B 站视频</a>，<a href="http://www.ai-start.com/ml2014/html/" target="_blank" rel="noopener">对应笔记</a></p>
</blockquote>
<h2 id="有趣的-Python-特征"><a href="#有趣的-Python-特征" class="headerlink" title="有趣的 Python 特征"></a>有趣的 Python 特征</h2><ul>
<li>内联表达式：[i**2 for i in range(10)]</li>
<li><a href="https://raycoder.me/post/5mrednz2a/" target="_blank" rel="noopener">exec 函数</a> 执行 Python 代码（一般用于文件读取）</li>
<li>元组（tuple）可以做加法和乘法来改变它的值！但是本质上元组的值并没有改变，只是新开了一段连续的内存，然后用刚刚那个指针指向了这段内存！！！所以<strong>元组是不可变的</strong>这句话没毛病</li>
<li>一个元素构成的元组要写成<code>(a,)</code>形式，是因为否则到处都是元组 0.0（因为我们在处理优先级的时候经常加<code>()</code>）</li>
<li>上述说明了为什么内联表达式不支持用 tuple，用的是 list（列表）</li>
<li>生成器可以用 list and tuple，搞完生成器就空了</li>
<li><code>map(func,data)</code> 一次算一堆的值。</li>
<li>Python 中没有<code>++,--</code> 这类自增自减运算</li>
</ul>
<h2 id="打包成可执行文件（-exe）"><a href="#打包成可执行文件（-exe）" class="headerlink" title="打包成可执行文件（.exe）"></a>打包成可执行文件（.exe）</h2><p> 最简单的方法： pip 安装 pyinstaller (借助豆瓣源，见安装段落)，然后执行</p>
<p><code>pyinstaller -F example.py -w</code></p>
<blockquote>
<p>其中 <code>-F</code> 表示单个文件， <code>-w</code> 表示关闭命令行窗口</p>
</blockquote>
<p>问题是，一个几 kb 的 Python 程序，打包就 10M+ 。。。这谁顶得住啊，<a href="https://www.zhihu.com/question/281858271" target="_blank" rel="noopener">解决方案</a> </p>
<blockquote>
<p><a href="https://blog.csdn.net/ZhaDeNianQu/article/details/87717293" target="_blank" rel="noopener">反解析和防止被反解析</a></p>
</blockquote>
<h2 id="datetime-包学习（哈哈哈）"><a href="#datetime-包学习（哈哈哈）" class="headerlink" title="datetime 包学习（哈哈哈）"></a>datetime 包学习（哈哈哈）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">day = now - datetime.datetime(<span class="number">2019</span>,<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">print(<span class="string">'喜欢茶茶子妹妹的第'</span>+str(day.days)+<span class="string">'天'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>每个包都有各自的代码规范，使用的时候注意一点可以省很多麻烦。个人比较喜欢的代码规范方式：</p>
<ol>
<li>逗号后面加空格 <code>,</code></li>
<li>类的手写字母大写，例如：<code>class MyHoney():</code></li>
<li>函数或者类的方法全小写</li>
<li>变量或者类中属性首单词字母小写，后面单词首部大写，例如 <code>myName</code></li>
<li>常量全大写</li>
<li>个人不是很喜欢用下划线，不过也是一个不错的选择</li>
<li>函数，类中方法，模块隔行显示</li>
<li>用 tab 缩进，用空格对齐 (强烈抵制用 4 个空格代替 tab！！！)</li>
<li><a href="/syntacticSugar/" title="多用语法糖">多用语法糖</a>
</li>
</ol>
<h2 id="Python-之禅（Zen-of-Python）"><a href="#Python-之禅（Zen-of-Python）" class="headerlink" title="Python 之禅（Zen of Python）"></a>Python 之禅（Zen of Python）</h2><p>在 Python 命令行中输入 <code>import this</code> 就会出现：</p>
<blockquote>
<p>The Zen of Python, by Tim Peters</p>
<p>Beautiful is better than ugly.<br>Explicit is better than implicit.<br>Simple is better than complex.<br>Complex is better than complicated.<br>Flat is better than nested.<br>Sparse is better than dense.<br>Readability counts.<br>Special cases aren’t special enough to break the rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In the face of ambiguity, refuse the temptation to guess.<br>There should be one— and preferably only one —obvious way to do it.<br>Although that way may not be obvious at first unless you’re Dutch.<br>Now is better than never.<br>Although never is often better than <em>right</em> now.<br>If the implementation is hard to explain, it’s a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>Namespaces are one honking great idea — let’s do more of those!</p>
</blockquote>
<p>就不翻译了，最喜欢的一句:</p>
<p> <strong>Now is better than never although new is often better that <em>right</em> now</strong></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-gui 之 wxPython 做拼图游戏</title>
    <url>/pythonGui/</url>
    <content><![CDATA[<blockquote>
<p>一定要先写逻辑代码，再写用户界面代码</p>
</blockquote>
<h2 id="GUI-的共性"><a href="#GUI-的共性" class="headerlink" title="GUI 的共性"></a>GUI 的共性</h2><blockquote>
<p>好读不好写！！！，因为一看类名函数名就知道每行代码是干嘛的，但是因为大小写还有单词选择可选的很多， 所以一定要配置  <strong>代码补全！！！</strong></p>
</blockquote>
<p>其实任何语言的 GUI 都是类似的，基本就是使用操作系统提供的窗口 API 接口，然后就是时间响应机制，这样就导致了语言特点其实用的特别少，然后真正开发都是使用别人的引擎。</p>
<a id="more"></a>
<p>例如 C++ 开发就会用到 cocos2d， Unity 等（5 年前去游戏公司实习过），还有 MATLAB 的 GUI 开发是真的方便，框架设计特别简单，添加按钮什么的拖拽就可以了，还有就是添加响应函数的时候右键就可以自动帮你定位到要写响应函数的地方，简直就是神器。好了废话不多说了，学习 Python 的 GUI 设计，选的是 wxPython 和 pygame。学习两个库的一些基本操作，然后分别用两种包写拼图游戏。</p>
<h2 id="wxPython-学习"><a href="#wxPython-学习" class="headerlink" title="wxPython 学习"></a>wxPython 学习</h2><p>先用 pip 安装 wxPython</p>
<p><code>pip install wxPython -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com</code></p>
<p>wxPython <a href="https://wxPython.org/pages/overview/#hello-world" target="_blank" rel="noopener">官网</a> 给了 hello World 两个简单示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wx; a=wx.App(); wx.Frame(<span class="literal">None</span>, title=<span class="string">"Hello World"</span>).Show(); a.MainLoop()</span><br></pre></td></tr></table></figure>
<p>一行代码做一个 GUI 界面，可能这就叫做人生苦短，请用 Python 吧！</p>
<p>推荐<a href="http://xoomer.virgilio.it/infinity77/wxPython/Widgets/wx.Bitmap.html#GetSubBitmap" target="_blank" rel="noopener">wxPython 库查阅</a> 和 <a href="https://www.cnblogs.com/ajucs/p/3903690.html" target="_blank" rel="noopener">键盘事件列表</a></p>
<h2 id="pygame-学习"><a href="#pygame-学习" class="headerlink" title="pygame 学习"></a>pygame 学习</h2><p>这一张图就够了感觉！</p>
<p><img src= "/img/loading.gif" data-lazy-src="pygamecheatsheet.png" alt="pygame"></p>
<p>然后还有 <a href="Python_ext pygame.pdf">ppt</a>  以及<a href="pygame_docs.pdf">库查询手册</a> </p>
<h2 id="拼图游戏开始了"><a href="#拼图游戏开始了" class="headerlink" title="拼图游戏开始了"></a>拼图游戏开始了</h2><p>本来是想用 wxPython 和 pygame 两种方式实现同一个拼图游戏，后来 wxPython 的编写（主要是函数查询）把我搞的生无可恋，就不想写 pygame 版本的实现了。下面是源码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># JigsawGame.py writed by dna049 at 2020/2/28  last update: 2020/3/14</span></span><br><span class="line"><span class="comment"># 这是个加注释的版本，有些望文生义的我就不注释了</span></span><br><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64 </span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urlrequest 	<span class="comment"># 用于从网上加载图片</span></span><br><span class="line"><span class="keyword">import</span> webbrowser <span class="comment">#打开网页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk 		<span class="comment"># 用于选择文件夹</span></span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> filedialog <span class="comment"># 用于选择文件夹</span></span><br><span class="line"><span class="keyword">from</span> wx.lib.embeddedimage <span class="keyword">import</span> PyEmbeddedImage 	<span class="comment"># 用于把数据变成位图</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JigsawGame</span><span class="params">(wx.Frame)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kw)</span>:</span> <span class="comment">#这个方法只会在最开始调用一次</span></span><br><span class="line">        super(JigsawGame, self).__init__(*args, **kw)</span><br><span class="line">        self.Centre()  	<span class="comment"># 整个窗口出现在屏幕正中心</span></span><br><span class="line">        <span class="comment"># 选择文件</span></span><br><span class="line">        self.fileOpen = <span class="literal">False</span> 	<span class="comment"># 标记是否选择了正确(.png, .jpg, .jpeg, bmp)的文件</span></span><br><span class="line">        self.fileLoad = <span class="literal">False</span> 	<span class="comment"># 标记是否读取了文件(因为只需读取一次)</span></span><br><span class="line">        self.order = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)] 	<span class="comment"># 0-8这9个位置的初始值都是0-8，后面会变动</span></span><br><span class="line">        self.eB = <span class="number">8</span> 	<span class="comment">#标记空白块的位置，8就是右下角</span></span><br><span class="line">        <span class="comment"># 创建面板（面板上可以放按钮，文本框，静态文本，图层等等东西）</span></span><br><span class="line">        <span class="comment"># style 参数设置是让他可以接收到上下左右键！</span></span><br><span class="line">        self.pnl = wx.Panel(parent = self, style = wx.BORDER_NONE)</span><br><span class="line">        <span class="comment"># 这个就是左下角的欢迎界面，还有字体的设置</span></span><br><span class="line">        welcome = wx.StaticText(self.pnl, pos=(<span class="number">20</span>, <span class="number">521</span>), \</span><br><span class="line">            lAbel = <span class="string">'欢迎来到我的博客:'</span>, \</span><br><span class="line">            style = wx.aligned_RIGHT)</span><br><span class="line">        blog = wx.StaticText(self.pnl, pos = (<span class="number">180</span>, <span class="number">521</span>), \</span><br><span class="line">            lAbel = <span class="string">'dna049.com'</span>)</span><br><span class="line">        blog.SetForegroundColour(<span class="string">'pink'</span>)</span><br><span class="line">        font = blog.GetFont()</span><br><span class="line">        font.PointSize += <span class="number">2</span></span><br><span class="line">        font = font.Bold()</span><br><span class="line">        welcome.SetFont(font)</span><br><span class="line">        blog.SetFont(font)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个是操作提示的静态文本</span></span><br><span class="line">        self.hint = wx.StaticText(self.pnl, pos=(<span class="number">710</span>, <span class="number">20</span>), \</span><br><span class="line">            lAbel = <span class="string">'操作：\n\n↑\n← ↓ →\n\n\nW\nA S D'</span>, \</span><br><span class="line">            style = wx.aligned_CENTER)</span><br><span class="line">        self.hint.SetFont(font)</span><br><span class="line">        self.hint.SetForegroundColour(<span class="string">'red'</span>)</span><br><span class="line">        self.hint.Hide()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 一开始的界面中提示按鼠标的静态文本，贼大的那个</span></span><br><span class="line">        self.st = wx.StaticText(self.pnl, pos =(<span class="number">200</span>, <span class="number">200</span>), \</span><br><span class="line">            lAbel = <span class="string">'鼠标点击空白处\n选择一个照片来玩拼图吧'</span>, \</span><br><span class="line">            style = wx.aligned_CENTER)</span><br><span class="line">        font.PointSize += <span class="number">16</span></span><br><span class="line">        self.font = font.Bold()</span><br><span class="line">        self.st.SetFont(self.font)</span><br><span class="line">        self.st.SetForegroundColour(<span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绑定鼠标左键和下面的onleftdown方法</span></span><br><span class="line">        self.pnl.Bind(wx.EVT_LEFT_DOWN, self.onleftdown)</span><br><span class="line">        <span class="comment">#绑定键盘事件和下面的onkeydown方法</span></span><br><span class="line">        self.pnl.Bind(wx.EVT_KEY_DOWN, self.onkeydown)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onleftdown</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> self.fileOpen):</span><br><span class="line">            self.fileName = self.myfile()</span><br><span class="line">            <span class="keyword">if</span> os.path.basename(self.fileName).split(<span class="string">'.'</span>)[<span class="number">-1</span>] <span class="keyword">in</span> [<span class="string">'png'</span>, <span class="string">'jpg'</span>, <span class="string">'jpeg'</span>, <span class="string">'bmp'</span>]:</span><br><span class="line">                self.fileOpen = <span class="literal">True</span></span><br><span class="line">                self.st.Destroy()</span><br><span class="line">                self.run()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果已经完成了，那就不让你再玩了，否则就开始按键检测然后还是移动</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onkeydown</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(self.fileLoad <span class="keyword">and</span> <span class="keyword">not</span> self.isfinish()):</span><br><span class="line">            myKey = [wx.WXK_LEFT, ord(<span class="string">'A'</span>), wx.WXK_RIGHT, ord(<span class="string">'D'</span>), wx.WXK_UP, ord(<span class="string">'W'</span>), wx.WXK_DOWN, ord(<span class="string">'S'</span>)]</span><br><span class="line">            keycode = event.GetKeyCode()</span><br><span class="line">            self.move(myKey.index(keycode)//<span class="number">2</span> <span class="keyword">if</span> (keycode <span class="keyword">in</span> myKey) <span class="keyword">else</span> <span class="number">-1</span>)</span><br><span class="line">        self.pnl.Layout()</span><br><span class="line">        self.isfinish()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 出现让你选择图片的界面，返回文件绝对路径的文件名</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myfile</span><span class="params">(self)</span>:</span></span><br><span class="line">        chooseFile = tk.Tk()</span><br><span class="line">        chooseFile.withdraw()</span><br><span class="line">        fileName = filedialog.askopenfilename()</span><br><span class="line">        <span class="keyword">return</span> fileName</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从网上下一个表情包，返回值是位图用来加载</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onlinefile</span><span class="params">(self)</span>:</span></span><br><span class="line">        url = <span class="string">'https://dna049.com/PythonGui/yes.png'</span></span><br><span class="line">        image = urlrequest.urlopen(url).read()</span><br><span class="line">        bData = base64.b64encode(image)</span><br><span class="line">        pData = bData.decode()</span><br><span class="line">        self.urlYes = PyEmbeddedImage(pData).GetBitmap()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把从本地选择出的图片进行调整大小，调整完之后切成3*3的块，然后在画板上画出来</span></span><br><span class="line">        <span class="comment"># 并且进行标记好更新，逻辑代码很短归功于Python的短小精湛！</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writefile</span><span class="params">(self)</span>:</span></span><br><span class="line">        tmp = wx.Image(self.fileName)</span><br><span class="line">        im = tmp.ConvertToBitmap()</span><br><span class="line">        (sizeW, sizeH) = im.GetSize()</span><br><span class="line">        t = max(<span class="number">0.2</span>, sizeW/<span class="number">720</span>, sizeH/<span class="number">521</span>)+<span class="number">0.02</span></span><br><span class="line">        im = tmp.Scale(int(sizeW/t), int(sizeH/t)).ConvertToBitmap()</span><br><span class="line">        (sizeW, sizeH) = im.GetSize()</span><br><span class="line">        sizeW //= <span class="number">3</span>;sizeH //= <span class="number">3</span></span><br><span class="line">        self.img = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            self.img += [im.GetSubBitmap(( (i%<span class="number">3</span>)*sizeW, (i//<span class="number">3</span>)*sizeH, sizeW, sizeH))]</span><br><span class="line">        self.img += [wx.Bitmap.FromRGBA(sizeW, sizeH, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>)]</span><br><span class="line">        self.lastPart = im.GetSubBitmap(( <span class="number">2</span>*sizeW, <span class="number">2</span>*sizeH, sizeW, sizeH))</span><br><span class="line">        ps = [((x%<span class="number">3</span>)*(sizeW +<span class="number">1</span>), (x//<span class="number">3</span>)*(sizeH+<span class="number">1</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        self.sbt = [wx.StaticBitmap(self.pnl, bitmap = self.img[i], \</span><br><span class="line">            pos=ps[i], size=(sizeW, sizeH) ) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)] </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检测到鼠标左键按下，就开始看文件打开过没有，打开了就无视，没打开就开启文件选择</span></span><br><span class="line">        <span class="comment"># 打开成功之后就把部分提示关闭，然后开始为下一步拼图做准备</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> self.fileLoad):</span><br><span class="line">            self.fileLoad = <span class="literal">True</span></span><br><span class="line">            self.writefile()</span><br><span class="line">            self.disorder()</span><br><span class="line">            self.pnl.Layout()</span><br><span class="line">            self.hint.Show()</span><br><span class="line">            self.pnl.SetFocus()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disorder</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">111</span>): self.move(randint(<span class="number">0</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self, direction)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> direction == <span class="number">0</span>:   self.moveleft()</span><br><span class="line">        <span class="keyword">elif</span> direction == <span class="number">1</span>: self.moveright()</span><br><span class="line">        <span class="keyword">elif</span> direction == <span class="number">2</span>: self.moveup()</span><br><span class="line">        <span class="keyword">elif</span> direction == <span class="number">3</span>: self.movedown()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#判断是否是合理移动，合理就丢给下面函数更新</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span>	<span class="title">checkmove</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(end <span class="keyword">not</span> <span class="keyword">in</span> range(<span class="number">9</span>)):         <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span>(start%<span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> end%<span class="number">3</span> == <span class="number">2</span>): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span>(start%<span class="number">3</span> == <span class="number">2</span> <span class="keyword">and</span> end%<span class="number">3</span> == <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveleft</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(self.checkmove(self.eB, self.eB+<span class="number">1</span>)): self.sbtnew(self.eB, self.eB+<span class="number">1</span>);self.eB+=<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveright</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(self.checkmove(self.eB, self.eB<span class="number">-1</span>)): self.sbtnew(self.eB, self.eB<span class="number">-1</span>);self.eB-=<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveup</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(self.checkmove(self.eB, self.eB+<span class="number">3</span>)): self.sbtnew(self.eB, self.eB+<span class="number">3</span>);self.eB+=<span class="number">3</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movedown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(self.checkmove(self.eB, self.eB<span class="number">-3</span>)): self.sbtnew(self.eB, self.eB<span class="number">-3</span>);self.eB-=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果操作合理，那就更新每个格子上的图片，并更新order列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sbtnew</span><span class="params">(self, posB, posA)</span>:</span></span><br><span class="line">        (x, y) = self.order[posB],self.order[posA] </span><br><span class="line">        self.order[posB], self.order[posA] = (y, x)</span><br><span class="line">        self.sbt[posB].SetBitmap(self.img[y])</span><br><span class="line">        self.sbt[posA].SetBitmap(self.img[x])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每次有按键的时候检测是否拼好了，拼好了就贴上最后一块并把表情包打印出来</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isfinish</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.order == [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]:</span><br><span class="line">            self.sbt[<span class="number">8</span>].SetBitmap(self.lastPart)</span><br><span class="line">            self.onlinefile()</span><br><span class="line">            wx.StaticBitmap(parent = self.pnl, bitmap = self.urlYes, pos=(<span class="number">500</span>, <span class="number">300</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 程序入口，进入__init__ 函数后，就开始进行鼠标和键盘的监听循环中</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    loveDays = datetime.now() - datetime(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">20</span>) </span><br><span class="line">    app = wx.App()</span><br><span class="line">    <span class="comment"># 创建上面类的对象，标题是喜欢zly妹妹，窗口不允许最大化，也不能调整大小</span></span><br><span class="line">    myGame = JigsawGame(<span class="literal">None</span>, \</span><br><span class="line">        title=<span class="string">'dna049 喜欢zly妹妹的第'</span>+str(loveDays.days)+<span class="string">'天'</span>, \</span><br><span class="line">        size = (<span class="number">800</span>, <span class="number">600</span>), \</span><br><span class="line">        style=wx.DEFAULT_FRAME_STYLE ^ wx.RESIZE_BORDER ^ wx.MAXIMIZE_BOX)</span><br><span class="line">    myGame.Show()</span><br><span class="line">    app.MainLoop()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>wx.EVT_KEY_DOWN 不响应 <code>Tab Enter → ↑ ↓ ←</code></p>
<p>wx.EVT_KEY_UP 响应所有键</p>
<p>wx.EVT_CHAR 仅响应<code>F1 - F12 PrintScreen  ScrollLock PauseBreak</code></p>
<p><strong>wx.Button 和 wx.EVT_KEY_DOWN 等冲突让我懵逼了吐了</strong> </p>
</blockquote>
<h3 id="还是解释一下代码吧"><a href="#还是解释一下代码吧" class="headerlink" title="还是解释一下代码吧"></a>还是解释一下代码吧</h3><ol>
<li>首先创建窗口，窗口名是喜欢 zly 妹妹的第 xxx 天，日常表白 0.0</li>
<li>窗口上放一个面板（panel）然后在上面放很多静态文本，比如我的博客呀，还有操作提示</li>
<li>然后绑定监听鼠标左键，按下了就会让你选择一个文件来玩拼图游戏</li>
<li>然后选择好了图片后，把图片平均切成 <code>3*3</code> 的块，最后一块（右下角)用黑白填充</li>
<li>把这些块打乱，打乱方式是随机的移动（防止随便打乱拼不回去）</li>
<li>监听 键盘 WASD 和上下左右键并写好相应的响应函数</li>
<li>每次接受到监听就检测是否拼好</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 和 Linux Shell</title>
    <url>/vimWithLinuxShell/</url>
    <content><![CDATA[<p>Windows10+WSL(Ubuntu20.04LTS) 用的越来越多，就想系统的入门一下： vim 和 Linux Shell</p>
<a id="more"></a>
<h2 id="Vi-m-入门"><a href="#Vi-m-入门" class="headerlink" title="Vi(m) 入门"></a>Vi(m) 入门</h2><p>所有类Unix系统都自带vi，所以学习vi收益满满！</p>
<blockquote>
<p>参考：<a href="https://codeshellme.github.io/2020/04/vim-use/" target="_blank" rel="noopener">如何高效使用Vim</a>，<a href="https://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">Linux vi/vim | 菜鸟教程</a></p>
</blockquote>
<h3 id="vi-m-工作模式图解"><a href="#vi-m-工作模式图解" class="headerlink" title="vi(m) 工作模式图解"></a>vi(m) 工作模式图解</h3><p><img src= "/img/loading.gif" data-lazy-src="vim-vi-workmodel.png" alt="vimWorkMod"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常见命令（区分大小写)</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gg</code></td>
<td>移动到当前文件的第一行</td>
</tr>
<tr>
<td><code>G</code></td>
<td>移动到当前文件的最后一行</td>
</tr>
<tr>
<td><code>M</code></td>
<td>移动到当前文件的中间一行</td>
</tr>
<tr>
<td><code>Ctrl + o</code></td>
<td>移动到上一次编辑的地方</td>
</tr>
<tr>
<td><code>:n</code> ， 其中n为数字</td>
<td>输入一个<code>:</code>，再输入一个<code>数字</code>，按回车，快速跳到某一行</td>
</tr>
<tr>
<td><code>ndd</code>，其中n为数字（不写默认为1）</td>
<td>删除光标所在的行，并且内容在剪切板</td>
</tr>
<tr>
<td><code>nyy</code>，其中n为数字（不写默认为1）</td>
<td>复制光标所在的行，并且内容在剪切板</td>
</tr>
<tr>
<td><code>D</code></td>
<td>删除<code>光标</code>到行<code>末尾</code>所有的内容，并且内容在剪切板</td>
</tr>
<tr>
<td><code>p</code></td>
<td>粘贴剪切板的内容到光标处</td>
</tr>
<tr>
<td><code>/word</code></td>
<td>向光标之下寻找一个名称为 word 的字符串</td>
</tr>
<tr>
<td><code>?word</code></td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td><code>n</code></td>
<td>这个 n 是英文按键。继续搜索下一个目标</td>
</tr>
<tr>
<td><code>N</code></td>
<td>这个 N 是英文按键。与 n 刚好相反</td>
</tr>
<tr>
<td><code>Ctrl + v</code></td>
<td>进入列选择模式</td>
</tr>
<tr>
<td><code>Shift + v</code></td>
<td>进入行选择模式</td>
</tr>
<tr>
<td><code>u</code></td>
<td>复原前一个动作</td>
</tr>
<tr>
<td><code>Ctrl+r</code></td>
<td>重做上一个动作</td>
</tr>
<tr>
<td><code>Ctrl+n</code></td>
<td>常规（Normal）补全</td>
</tr>
<tr>
<td><code>Ctrl+o</code></td>
<td>全能（Omni）补全</td>
</tr>
</tbody>
</table>
</div>
<h3 id="vimrc-超简洁设置："><a href="#vimrc-超简洁设置：" class="headerlink" title=".vimrc 超简洁设置："></a><code>.vimrc</code> 超简洁设置：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">syntax on    " 语法高亮</span><br><span class="line">set nu       " 行数显示</span><br><span class="line">set ts=4     " tab宽度</span><br><span class="line">set spell    " 语法拼写检测</span><br><span class="line">set noexpandtab       " 不将tab转换成空格</span><br><span class="line">colorscheme darkblue  " 颜色主题：  /usr/share/vim/vimxx/colors (xx: 版本号)</span><br></pre></td></tr></table></figure>
<h3 id="vi-m-键盘图"><a href="#vi-m-键盘图" class="headerlink" title="vi(m)键盘图"></a>vi(m)键盘图</h3><p><img src= "/img/loading.gif" data-lazy-src="vi-vim.png" alt="vim-vim"></p>
<h3 id="vi-m-命令思维导图"><a href="#vi-m-命令思维导图" class="headerlink" title="vi(m) 命令思维导图"></a>vi(m) 命令思维导图</h3><p><img src= "/img/loading.gif" data-lazy-src="vim.png" alt="vim"></p>
<h2 id="Linux-Shell-入门"><a href="#Linux-Shell-入门" class="headerlink" title="Linux Shell 入门"></a>Linux Shell 入门</h2><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <code>#!/bin/sh</code>，它同样也可以改为 <code>#!/bin/bash</code>。</p>
<blockquote>
<p>参考：<a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">Shell 教程 | 菜鸟教程</a>，<a href="https://zhuanlan.zhihu.com/p/65106362" target="_blank" rel="noopener">这些Shell编程必备知识你都掌握了吗？</a></p>
</blockquote>
<h3 id="Hello-Shell"><a href="#Hello-Shell" class="headerlink" title="Hello Shell"></a>Hello Shell</h3><p><code>vim test.sh</code> 编辑下面内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Hello Shell "</span><br></pre></td></tr></table></figure>
<p><code>esc</code> + <code>:wq</code> 保存，执行下面命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使脚本具有执行权限</span></span><br><span class="line">$ chmod +x test.sh</span><br><span class="line"><span class="comment">#执行脚本，若报错则输入 chmod u+x test.sh</span></span><br><span class="line">$ ./test.sh</span><br><span class="line"><span class="comment">#无执行权限时</span></span><br><span class="line">$ sh ./test.sh</span><br></pre></td></tr></table></figure>
<h3 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello=123 # 变量定义</span><br><span class="line">readonly my_blog="dna049.com" #只读变量（常量）定义</span><br><span class="line">echo $my_blog   #变量引用方式一，不推荐</span><br><span class="line">echo $&#123;my_blog&#125; #变量引用方式二，推荐</span><br><span class="line">for skill in C++ Python SageMath; do</span><br><span class="line">    echo "I am good at $&#123;skill&#125;Script"</span><br><span class="line">done</span><br><span class="line">unset my_blog   #删除变量</span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量定义 <code>=</code> 两边不能有空格！</p>
</blockquote>
<h3 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a>Shell 字符串</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myBlog='dna049.com' #单引号里的任何字符都会原样输出, 不支持转义</span><br><span class="line">str="My Blog is \"$myBlog\"! \n"</span><br><span class="line">echo -e $str # -e 开启转义</span><br><span class="line">echo 'hello, ' $&#123;myBlog&#125; " Welcome!" #单引号双引号都可以做字符拼接</span><br><span class="line">echo $&#123;#myBlog&#125; #获取字符串长度</span><br><span class="line">echo $&#123;myBlog:0:6&#125; # 输出dna049</span><br></pre></td></tr></table></figure>
<h3 id="Shell-传递参数"><a href="#Shell-传递参数" class="headerlink" title="Shell 传递参数"></a>Shell 传递参数</h3><ul>
<li><code>$n</code>：传入参数，例如：<code>$0 $1 $2</code> 分别表示，脚本名，第一个参数，第二个参数</li>
<li><code>$#</code>：脚本后面跟的参数个数（不包含脚本名)</li>
<li><code>$@</code>：所有参数，并且可以被遍历</li>
<li><code>$*</code>：所有参数</li>
<li><code>\$$</code>：当前脚本的进程ID (没有<code>\</code>)</li>
<li><code>$?</code>：上一条命令的退出状态</li>
</ul>
<h3 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array=(A B "cpp" D)</span><br><span class="line">echo $&#123;array[2]&#125;</span><br><span class="line">echo "数组元素个数为: $&#123;#array[*]&#125;" # @* 都对应着全部内容</span><br><span class="line">echo "数组元素为: $&#123;array[@]&#125;" </span><br><span class="line">echo $&#123;array[@]:1:4&#125; </span><br><span class="line">echo $&#123;array[@]::3&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Shell-运算符"><a href="#Shell-运算符" class="headerlink" title="Shell 运算符"></a>Shell 运算符</h3><ul>
<li>算数运算符： <code>+ - * / % = == !=</code></li>
<li>关系运算符：<code>-eq -ne -ge -lt -gt -le</code></li>
<li>布尔运算符：<code>! -o -a</code> （取否，or，and）</li>
<li>逻辑运算符：<code>&amp;&amp; ||</code> ，需要： <code>[[ expr ]]</code></li>
<li>字符串运算符：<code>= != -z -n $</code></li>
<li>文件测试运算符：<code>-b -c -d -f -g -k -p -u -r -w -x -s -e</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=11;b=22</span><br><span class="line">val=`expr $a + $b`</span><br><span class="line">echo "a + b : $val"</span><br><span class="line"></span><br><span class="line">if [ $a == $b ];then</span><br><span class="line">   echo "a 等于 b"</span><br><span class="line">elif [ $a -gt $b ];then</span><br><span class="line">   echo "a 大于 b"</span><br><span class="line">elif [ $a -lt $b ];then</span><br><span class="line">   echo "a 小于 b"</span><br><span class="line">else</span><br><span class="line">   echo "没有符合的条件"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]];then</span><br><span class="line">   echo "返回 true"</span><br><span class="line">else</span><br><span class="line">   echo "返回 false"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">a="abc"</span><br><span class="line">if [ -n $a ];then</span><br><span class="line">   echo "-n $a : 字符串长度不为 0"</span><br><span class="line">else</span><br><span class="line">   echo "-n $a : 字符串长度为 0"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<blockquote>
<p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作</p>
<p>条件表达式要放在方括号之间，并且要有空格，例如:<code>[$a==$b]</code>是错误的，必须写成 <code>[ $a == $b ]</code></p>
</blockquote>
<h3 id="Shell-printf-命令"><a href="#Shell-printf-命令" class="headerlink" title="Shell printf 命令"></a>Shell printf 命令</h3><p><code>printf  format-string  [arguments...]</code></p>
<p>例如： <code>printf &quot;%-8s = %10.4f\n&quot; pi 3.141592653</code></p>
<blockquote>
<p><code>%s %c %d %f</code> 都是格式替代符</p>
<p><code>%-8s</code> 指一个宽度为8个字符（<code>-</code>表示左对齐，没有则表示右对齐），如果不足则自动以空格填充，超过也会将内容全部显示出来。</p>
</blockquote>
<h3 id="Shell-流程控制"><a href="#Shell-流程控制" class="headerlink" title="Shell 流程控制"></a>Shell 流程控制</h3><h4 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h4><ul>
<li><p><code>if else-if else</code> 已经在上面例子中提过了。</p>
</li>
<li><p><code>case esac</code> 的奇葩写法，吐了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo '输入 1 到 4 之间的数字:'</span><br><span class="line">echo '你输入的数字为:'</span><br><span class="line">read aNum       </span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo '你选择了 1'</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo '你选择了 2'</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo '你选择了 3'</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo '你选择了 4'</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo '你没有输入 1 到 4 之间的数字'</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>read</code> 输入快乐啊！</p>
</blockquote>
</li>
</ul>
<h4 id="循环控制：for-while-until-break-continue"><a href="#循环控制：for-while-until-break-continue" class="headerlink" title="循环控制：for while until break continue"></a>循环控制：<code>for while until break continue</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 例子来自 https://www.runoob.com/linux/linux-shell-process-control.html</span></span><br><span class="line">for str in 'This is a string'</span><br><span class="line">do</span><br><span class="line">    echo $str</span><br><span class="line">done</span><br><span class="line">for((i=1;i&lt;=5;i++));do</span><br><span class="line">    echo "这是第 $i 次调用";</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo '按下 &lt;CTRL-D&gt; 退出'</span><br><span class="line">echo -n '输入你最喜欢的网站名: '</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo "是的！$FILM 是一个好网站"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="Shell-函数"><a href="#Shell-函数" class="headerlink" title="Shell 函数"></a>Shell 函数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">funWithParam()&#123;</span><br><span class="line">    echo "第一个参数为 $1 !"</span><br><span class="line">    echo "第二个参数为 $2 !"</span><br><span class="line">    echo "参数总数有 $# 个!"</span><br><span class="line">    echo "作为一个字符串输出所有参数 $* !"</span><br><span class="line">&#125;</span><br><span class="line">echo "-----函数开始执行-----"</span><br><span class="line">funWithParam 3 . 1 4 1 5 9 2 </span><br><span class="line">echo "-----函数执行完毕-----"</span><br></pre></td></tr></table></figure>
<h3 id="Shell-输入-输出重定向和文件包含-特别好用！"><a href="#Shell-输入-输出重定向和文件包含-特别好用！" class="headerlink" title="Shell 输入/输出重定向和文件包含(特别好用！)"></a>Shell 输入/输出重定向和文件包含(特别好用！)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ echo <span class="string">"菜鸟教程：www.runoob.com"</span> &gt; users</span><br><span class="line">$ cat users</span><br><span class="line">$ echo <span class="string">"菜鸟教程：www.runoob.com"</span> &gt;&gt; users</span><br><span class="line">$ cat users</span><br></pre></td></tr></table></figure>
<ul>
<li><p>test2.sh中调用test.sh：<code>source ./test.sh</code></p>
</li>
<li><p>管道运算符 <code>|</code>，是unix一个很强大的功能。</p>
<p>command 1 | command 2</p>
<p>把第一个命令command 1执行的结果作为command2的输入，例如:</p>
<p><code>$ ls -s|sort -nr</code> </p>
</li>
</ul>
<h3 id="Linux-工具："><a href="#Linux-工具：" class="headerlink" title="Linux 工具："></a>Linux 工具：</h3><ul>
<li><a href="https://www.runoob.com/linux/linux-remote-login.html" target="_blank" rel="noopener">Linux 远程登录</a></li>
<li><a href="https://www.runoob.com/linux/linux-forget-password.html" target="_blank" rel="noopener">Linux 忘记密码解决方法</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>悄悄话</title>
    <url>/scrite/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">悄悄话</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="7236d63e58662a055157002f32631b681ec0a1b0bde6d71223ec7d4ba49f3d8b">de0af34fc90a03bd4aa89b914dc3631985adf10cfbbd2c0c17c3da3aff4ff3553c18cc8e17755c6d30455e4191fc2a2a76dadb6da84eaf419e5a63b12b3a3d805545f31bae52ee026be4299894d7fbeefdb79ed5270a2b826e2cd90a76ccc448ec6650e1eac14c5e12176b21e5ec19740762455d4d58f1f6c422a104bb445071dab75846c51e41d1ca2d31e136d534a53802afbd320dec8f332c39c2ae6890c9f8f506ef2dd7c8bef61a89c861b37001f1b8f5f8dd98ee73c6e0dc1dabf5e7abcbfdba429525544c51276f3838d75b191a1a92d1b0006c2780b09f6d1d5ae18b66339ee86811097350cd48cdfe26e4130ecc486c594f86630133d34bb861b72d31ff53a1ae28d1ffdcca5a2dfea58267e3a5a16123ba17d2a83e006acfbd3c4e622fd6806c5e1291f1fa39e7cfb63fd34ab956491523aa3be54b37a02118573aa9827fc2d4f7bce8ae8574fca055e3a3077988cf5dac15524491c88f494aa76a01ca785bd11a0bf83bb472f0cb4546a58bcaf060f7349da4d86fd1227f5a6c2759bcf27068373822b143f59f76a0318a2de55664ff1126c6a517c13088c338cce82bef83394426ffe9607d260fe0633c97e915e25fdb7e1a2394aef05874737fcfcd32e981076956ac42e1046b0e7c287855980e0775a72c38a473ad9452b66a97d6ff917974b77bd04bbaa9b1e47833e2acfbe5a3b91aa37b8009a07c7ba9fd12d0f29a7ad41430d4d9b60963326fbc4da624dda21a66e38b004337c2f7f6244f54c209b38ec70f145c92a4a52f864d57e2f4b79eba6d3ac9489e979ea75a86b5b20ef6089a530f6d4a1e5eb37a107da9625efcd3ac88733f42ed295b31976e37279a96fc762ca3587b62a2892d2ee1fbe516a084f5e4d712ddf44eb2003db9f1e425bf94e4fd6b1f2e62899d0039da0e89c7cc724d975d1dbb54f683a022596ae8e79e844b7792cea1a54b1d6a20f23d29f68346b31a7b9a9bece96de9299c22856a8a0fcf75e62f5b5715238c9a7b118babe2e882a9ac0f6bd2451c3640238c782da8a422c25a5e7d53ffd4eb52fbcd158feef251b962ded6af79bed4f71f29c17f491391e8bcefaaf4af94c1f830868e7933477c10381fe6ccb1122b63eafe5f93c6a5708cabb37c7c08f2bb2383930de4f93ddbb0a67df9c547a93c243b4465ea09506df606f225047110953c9610f5585483c5c30aec450072617cc127220243fc9cee5983da33a7d648732d308f1b7364886cef950a80cf094039b81193ed3ae2d3676d57eaa7d55098b5d24f893f2eb2e3975564503680bcbb783c4539928d9142335fb9d0b75fa07dfb0bbc7acf77ee35fb165dafbc0146028f8171ddc84a2c046ed9940592c701c5ad8729ae3d3e597a2dd85cc9c86e051e536af4e2811f4857f7bf65d618677d6e8ad2955e8ac1197a8e6b5eaa9441b1ee9d5ce57a118535b17334178f1536e31743ff1bc066e0e745623d9b3eb19fb25de71f948126decb02086b9de72b75c73aa27647d80ee06b84374667ec43b903f1e59f800ecd0a441b4550518faf4563d22064497208ae5241bdd8dbaebb4daacd746277adf2ae1d431d175dd16bcd71720d29971de0d3bc381ae0b86877fc7148a5fad940a0a19e359bf58af63ae571c4ee4d867cdf4f0bf62afe4f1ead6f27f40e5b204cd78c7504521c12dd871e9951e71d1413f1fc28396435a0a63b66da30c0d92c0df9b204e09f79d3c3aa99893e477c1a2395d877bd948f4e34d59b1c25542554a9a879b3eac3e0b8de871e796a46a70977e39bd2d55e398b69ff5f466d7c824080f0dd3bf256ea4ded718cfbad5e9bb4dba92ebbd8f1aa7383c949af47d30af0b510a35fbbdc8f55e9128326f429e9e26eb63c3136a095668ab3c68229c9fd4fb8da10f1b96e6a18c94430d0e6e5b588a33a05b5bdc85085d5a714a5d8676797aae94bfd4a21b53ae2d3c84f033ae142256c636fb00cb2e87a66ffbd696cad99ea39c888b421328d7e878cba4763d8878e8c594823deffd35f7eb6c05315afe3f8fbd15200960ac0afe61a98099e2ff9547d4a888c530e0f395148065cdf9c4963f9dde616cad72015d26f3b49ea0bdf7348c7f0afd709310b179218e56fbfbd31e2ac15f6097e9ff37300f40acc7264f881d93d09a90cacf7081c6d73b18850e28fb60d3847053b3e5c1dfaf513b794abf3dc0616ef35f4cee61e11c9f32a02eea5f5c4c9e8b6a563561084d1a6d3b294445476e5a4dfa7f943f1fbd7dda03ddb002fdec054e4d690c70da25e053186c7c82fd5a287a6660741677d3752705c0cc8f8956fd31f25932aed7634d04d78e4aac03a4ce3ac16b63c8403456fb92f4d4bf81ff644a8abf545cf0aab5d7c1c33525091ac358af159ee181cad1cc77de968de15b9742864a3ccb129bba764030a2cdb63d60b394476a9adcd391610ae97f735cababbd5962a53cbc7b21c6dfcf77be4ad5c6f7325c071d50e728575caa017a401d3e35eb014389236c11a97de34d303f0949584d72894e3c19d7ba86612746d81165f2be2696633b4a88e794bde3d4651a1b1a84d39f9d1fa2b533bf027a8f794c2fb491e867c679a6b765016599dc249fc856a1af0bab5d2e99deb18bb68fee9fbc27f3e5789b9a4df01c8254cc623a2e9a0599851312f4884028c3bd75a8705ed1e5d4459c50c0449501484e31d1189fc7078bb4309214637eb9c22efabec8aa3af51c4f43e5afbc72e473bf5c202142d6fb8409366e126ca59e09b5cff2449e0eb706d59ef087ecbf8ee2b07e431f8feac427e7cec2d56533e225d32773e5fc214ce32b840362855679823b3ffb116e4632a5f8dae30f3e4caace1298df43e0a6f5cd1ea4a60ddb243ef11ab5942b825502fa5e3651713e2aab2bf3b236711ef229e68134552e8018d57b9c419a345e2fa953f5f0136da360d7851b253fdd2bff38611b5865027ced8dabb29bd2272eb434c6891ba9978654eacec560b926a9a735081a658a6245b3b1eb5a2f31109999735d0af4059174c99f0246024e4fb45f5a88d97693fd38dc3b6f53aac53b672ed4204c71dcd5a905be135d9a418f83b2b23317aeff8aaac352afc7aea41522aa2662627b86c14547070c832bfc0db61504bfb46228848e63ab8cffb10842bb1820f683e50ba71c09a51bc370098e67afa701f4cc2b6a14d1c9b9e7199adace353a312a3a8b0457687ead9a5fbeec1c4a64e28f219aef8a868658890df927009f672b37131336e7d7702517bd21ed904d730cc0518ceab9909bb4c5f19a1f1f78fa5cec8aa56c5eadca42bc6df3733a56bf886856404f67d610b67a2b2d95fd14e9c2432d2f1a7ac8d45a818e11c54ef147938176378de83f63ab9993a867e0168da55c8ae8f4dbf7a62891b4ce9a7f6e2b19c327d7ce7dd232e0ac72bd3a9f98949a5ffed77fa3ffcfd2e091cb321b0bcf1a97108db23ba9e83c2359e9656043f7e515cb961a1a3ab54581b86a34a586dc7d3006d677befe4cc9deb4d919246a5460025ea2ad12ec8d28f468793756a2e6c0d910278b7044dfd4f19d6191282c28dd9306150312b5bb0f22fb450502e73e30feece1c8832de6eb114673c7147c31c3946c5a02563109fd60f1173906d719178a37ec344a9674c4b4f8eec5cccf30f5cddbc57e99cffcaa757b795b13e88c2a7b0ccca0731082a06d50e5de1b415379c904a06e2055a5dfb9dc5074484438e836eef064edc66e81bf8b8140a6ce3db7687f2e90a88376ee528f6e1f7dd3378e0c5097631633f023cdf5409dcd42a68e868aafeb37d6a149924d50b1cb9289cb8a7ec28cccceb2e38d40130881e323266e0c196f00810741c86145ffe30e62effe510f7654e5c947df28695d80bcb6630cfb6cb0de8dd810f81d64ff198b9bd4fc4df2aad8227a7ea5140f4ac43c6813957efbadfd7e8284f074e7d28b84e2dc1e63ed6e0607cc36f633e32aee4e22c172a911a8acb5b44f49666842bd99ddbb20df4482142a570fe7d064e4ab1272ae047139d5cd99bad4c7cb272a4b43846dab99421aba7edbb300a7edc1d9192b0d58e009a29449739bf46e012e3fe4231e05c80d776cf199184fc186b63a155c5ef375ee7d64d4a4d192fcdcb35a430668434c5d22d32bde6c6f0809be212a06721b7d094794a94bacb5f40365e5444f3be1ffcff04983fc7a58f5ed203ba0fdfea54e082b7dccdd147f2fa8481fd8c5e5d85bae268f08b4ce121e558f909cc7b871e62bbeb9a13ecfe759585cb08b855f69f1a0922d2aea565c2ad92f119a24a5783843bd28949ce4a828471dc1f97b0397c3d9b9536fc6e417812d9895e585cd736d65ac661167aa2437fa32ad20b0a90c619f8affce552f0bbfc9a8091019c79dc73c72254d273729ecf5c2aeb32c62192bceec851f86a3eaae545c3b53ea71e0d630b6bd8e1fc9c04a1905f966071492d2829e4d665d00645c8614a42cc899839a34478e35ff15d4e1c608ba8f2448493bdf77bee5a42072b850431e0c2a8264ee29c64d93b0ff8f2eb46b18fdae8018e0c2f2bc4807574329861b94a78786bdb207cda3b0f17aa301be7f87ec65c77a86ddf0aa66493692a0a08d6df15fe0903083a8105ce94b780867fd25b9410e7ac83ff17e27a2b19438a66c11de2147fe74d1b604ff2c95f787a8a890b926206f823f9ce4560af3723c19951bed129a485f3014f6a2ea85fdfa4dc92c7a137fa0e8d749ae31ad79ad40b1d895abb78a3403917cb7212200e432b127a7d092dcb02ebdfc15f20626fcd7ed0e101f947637372006259661c9c00e3e9c23dd2ee60ad0f777ed9cf5b1cdb5df7b064cd745d6cea9054687122ba7beb47c44d40b113a4f18a31ff4d99eea354197b569839adb7a122bb630b8848081e4111da99ea3cf9e66e87b8bce9a96c8d77cbaf5faa27025f2a943fe6dcde4e3241dbe0309257f1cc0cef8a8e8fa300758dcb94eae4e484bbc4b1280beea080b264f03339157287813eb811e588bb8508cd3444931b37e4b51e47bb7da2458f1b882a77f74edc3c76b304a967e6bdca1e0c4de7cc571f4a1af575b98d5226fe72b0bc6242940c89f2d11741a57f10763dcf138d5cf9c1f58dc93410a44a3905b5edc977dd12028f06828abbdcabbb0c2c7905b7bbcf048f4962531f0f687713ea990463b80e4d00b8a07607ecdeee9d43a40a3f28c4bdfdf909c6cbfe46d039e4bce70d26c7f162f840f0982a03ac66fc634c6420ab1d61eda9aa0a84505cfd78431eb78e603b5e321e746115e8598c43b2cfcb4d16a9318f8a59c8accaa3a03f66de910eac3075e84b124530eaa73241dee41b17a6827141588a5e28b95fd9c375e81d8c1abe885e32fb5b8c9af15cbbad94741abb4a0f387be4898fdb458709813782003cae23e9ba0d6de9e581afd8d9ac478e37a01dcd3a3c233c6e6cd7431e2720ff1c1496d72d5a2b070f0e4e7be6750a671061cff3ee47040ce9c9779d04ae72fd8ec63b1e3d84d65f5c85a3f91d72ebf72cf21588814dbef3e322192c1ecf51575c732f7ca0572389bcbb9221152b20135354f33cc283ca5d4c614433073eed6d04c1804cb0eb322aec84c79c4f9768d4e705210d0381fe510ebd32bfdca70117a806f34d46b3b4aae1bccef1e541d482273ed57dadec9f89426ad0db23f7b6089af701bca2c2e62be4cd0a0c7632be113b121239b021969a7249ee0f29b976b879923ef55ae324c9e62a8b1095b683f60454f74bd684411181337bdf16dae4011095f822cd0fa3594bbe0a24a2d83eeae311f6f44b2a877b799e291c061bea29a33cc91faa1ed17a6272366b01521473bbdc365470be198caf9552e4202f2c01ceed32c270b799f5b4567ea754c069ef436a3602a4f4302beb9e1ffe3496b132fcbad75d6f39746f59a49691e941a9f2b803f7f3c9aed6846aabfd310e33381cf2437baabee0a5ab1a73f2303d976721bfbebbdbe1550eae6013e3aac57ff7789219ba92b589fecaa46d7f1c485f8c1917010e5000cd0c59f0d8c4fd44660164b0da7d7a1a8070667d2b0280149bc2f4b91e626762141c695d40153790de7ec784a424e23a046d22f3345c1e683f69834da2650f33648f0a60bb0a0f34be073d2bb7abb73b2203a833129c9d46d472d2ecba7c455c7e504046261f27c8a55723ba1569676bd14f9143a182b0ddba82b5a6fe92fb91f45f13a80e6ccbcb8363f417fbb555023a5d84e97c13e92b8193a6f6066aaaab7b53411fefa5ecd2447b9c54a360b8cd5da86d5b6acbb099de7a8ee6613ed7a9e445eaaf67f74484cac20c9689fad56eecbd232f3e4ac50cd8cc7d8d7178e820fa4206d904c260a40deaa7e6821bbc98c4e328e64799b4d613e0e1acca691f796867908294a162a7180bed892cbbc10a6f8cc7cbbd218a3a09db0db5bb32c039cc6c80954d144a867d24e89180a36d0765de3b967949008311b93eb9fff8ced371e98abb9a7edc29b62ba5aa13d79d0bb928c530e30affe53736ac7b044736ba4a24c5023d7ad6396b3bd9f9a4a80a8f5e9fc6e4de2439b2a210ccc368ecf215bb529ff07f7f0995f17007fa4b667a98855505f0f12fbf17951aea5d03d425c4a71e537c2b6766b67da321630994a5e920d1bc9ea5dece81c0191bc2ee13f8c7bc3fa2f98d8d2a95be417ea56b8c4b7e5285a2c2ce8549cd41bec7d414ffbeeab78a9712281b25ff8038cc3b7954709ece2286366a73c2fb8ff411be1f02f1d1a21ea58dd8ee98841d514bb3e2a8ff128bbf60d9f1e24d92a04e66ccff7c6222eabf42fafdb995ad9c87affdb6f11a6dabbba0d00f11c36753ccfa1ba40dcfbd6b416d5985140320761c371d079540ba10e0621b4d0575027f5da0eefd507344b506659812d6f89ab14079b3c5b45ac03787c47f87aa673816132cb97886d3afe7e576132692e5b642d1f35623a95ebad57fe33d1d325dc5a94b772a8866afaad943486478a52c0973d22f6845d5fabbe787617c0e8f900f5701923853b224b91b445dd045b5392c7abc3520b2b3371dad7881d9a616115bc94089dfa94e134e7e9fe44566105d6d67bdc6710c35b14a2d77deae0a937b3bea28b3f33fd160a63126680335c6b87a230aa70454fd6ed85f3cb78e88d9f6aefcbe6462aadb89b087d32dd8010fa3ca523301c511a677cf90f5722f92ac29857dfd03038689cc9bab08b0e383c95f6661d6668a9d76ecc5c47c410bf162707facb1a562467b5624e35ff522c55e4b1fec1cbd339ce8c6e54b9d4815fda83148a100fa62755cb7f049512e097a79fe46e7589bffc4322a99f999f30bb81d559fbd89c57bf16d0ccb365600cea6f61afacf8748f827035970572c04e4d727ca16eef4913b860719587ab62e684e81b116b1698297593a015b2a6ca41565f7f6cacdf359a95e3b2a080827818b9ad29859ff8c15260718588aaae1c8ae38283faa1550e45135eb5e6a5146319ae4ab34686dc9e1e9e6f98c03cc438e4a712d9a0098487fbca2282d08c4c8346d6d33c521e26c988c5d9b1d093ba9f0597f6be31ebceafbb84552c47a050dc1103ec3b21cda93895aaaad7194bce984129380336e16a7bf34f1e8a9cc81cc1e4a5f5235ac2b67b210c69ed7a1089a92881f5168eb9847697b2eb9ac27d63719a6c9f2c824b957966dcd74ef85c812b505daab579742b5df589db1c0dfa2934d67fa90d9e4608d9d37899de5b73722dae9dba65b269d5046608fd6b5f57af268a756fb183b4db42b98a6b20d9ec162b83d71d59dd0c6c9d4a9a0e636d12ce41fd681792deb2ba8e342d5e7d8cb8ea65e1fe9faf6c9d96706f30acdfe01a7a0d1876e698595d7897b29efa75e923a2b784b155f9ca5406100f3fbfa893a1202076bfbd249271bb41ecf5ec89cc06984a14c31061b944f5bf27d974bb9bc2e5802f8ec37f9c1edd34ef16785a29fe117692274f62435617693b28455a7bdb90d6aed716184c986dd55a1bb11e8f589cf81683b09390bc3d338d5460b367b0f3fcd735d87ce7994fee02d56f5b87755d0d23da1e97fdd359392a6bce25ae01551f7be1eef734f6a8fa2b884d4bc693b5114eda3b472ba5761c55024a966fccd212ad9d5505ea92acab0d5a7ab369c3c8efa67faeae3d883177f92eb24c005054dcfc76d8dec25f24836601e43a706d8ebb4affdb08ef2ba404e9ad78a298848b462360291a5b1c39f7a10f602ac340a1f7387fe6dffc96dbcb51eb4659b8b1129d9480bdc7418f23e180dfa367541147dbe1833556ff68d1766e40b05c30fbb2e5c219ca1b280804d4d9767a605a35870103b59cbeac2a6c577cd7aafb1d8f03f00f355150775239d5048faefc6998adf3b27b7fd3f0adefbe8440f7ac3a7adec5567164e471e48c3de37ad1050478e4459bb4ea558b79f2ef612a10031e6683146fb7ac67d18e56e58190fdda0e4b0412447020034c91795e7640f048354db1824f353ad256a4861a25f2bec64c9b8d895e9a8268fa5c3368f8bb295c19d8e03a956050384eb4bce146b52cbb1a8b06b6265f82f8c3de1c32ef88736fd26b5e6a938feb8427add7fc80e42b31f47781ba61196f15a4adce678473e0b464cb11c4ccb68db5f1ee6630ceb4499a8848db79b9c1ba6efc213b3ab752f6f5795b1700f2d2437a0924803d9238fa0289b01ffa515bbd634492af5f3d462e5aa1ca9fca095df18942346af0fdf8aa6216dd63981301e106857389b1e0899a2ec4891bd5681e1bec7f47e939fd5da6705e4bc1ffd070f8ce640127159b69f21b8ca37251a40a1f8178672c960a4e7885c4f5752f63cdfac35999fb383eb28b024aedb213529992771f882584e3a03159353e182c4c8c4027829986bbfd1cf0f78c01a48c953e19835128f2d043566a11bd4825f752cf5c4aed0ec5671cb7bb388ce8248cd2f2e0639c62d8ce74de1d60beab37e0dc790e84ef48833d989050f4f4b662776d72df075d29db143817cd657d5e0b421f52b825b277f04ae718e4d155aab961d7755859e99d04435385ffefe04dc698ad075b6cf6404be73f2c15907844f4064102f2aa948d546211f25f904f1699cd2a594eb108e254c2ece1eed68f26a30812ee09147db79c07330744934ecd290fffd4521a2673aa2a23a6fb2d2b0648a17874be8b0460ce0470d07faee5a14e31a66e9f792e8b4756351242372908189491d39f34251ffa2861a174b4913c0e9db0000fa0cd0100b09203b3743a0631d70ed484770b87423b88d86ae6ed8ffa1ac6950f463e77ac6a22bd353fa57f6886ae17b96f47895e7010453de4024856cbb3b9463f7bc188602a321c407354ceaea54e2b32d77437b0f3875305b90b235429457950e86563d81caa19dcc3f650d7b28a041fb4a2b32b6e29c46c8cd950195fffb73cd1301ab6445e3ee7678a132f7eabf69b47b00b2b2dcade6ac4aee4eb6c257e48c492ee352e795ef9a3e1cd993789985af5f4ac4333683876b1e46e00bbeeb7ba7bad4996c2f2a8a2fa281d91f5951d5c4c1d3991cd01ecd317be6877fffe2e6f32b77a3f1a4b15fb1530771c5da637abf4023c983e52e46c2b2ad1508d438952071c7e3497759adb16ae7e8f3e586c9434bf375a97d126cf1e9ebe0253f32de98922832f0ba5cc3eebc9bfc6cc10060d61a8d0a8a459d806c448aaf4c08d6887f4030622cf9d46db10e5c93c6a53c4ad58d33cbc8787b7e0b3a614be079ce0b62e3d8268afec6d8d5b02c1c73163bf295d7acd62626407496e421a4c8230b95017ad6ab03ec028fc929616f010f9e0263e239fe215d376f0a18f576dc9302fff3002b07a209ac84496d06c687432f33c9d3204e7602b6f7e5d67d906e526f30075f2da21d0088cf2d4f1c3eb8087c72aff6526ea6af5d0d068bd250ddbde4415d4ef2ec97bdee41f57a8dae7a3c66977bd5ba4b376664f958b7516b84e186c36dc031c95d3235345965ceb7798aec47682ed98a0f731155777a63567bc59e68ddf85fdd7d90458d11a68a7ab4f95e9f6fd608c331d3c9050c225b99a47de86743e27ee83461b5278395ca7c7f1a4562273d21a782295ebc33c6e64af9c9512bfe82d0cd58ac473d5f468a97b7a90c6927fb0d43e7814cfc84beaa991207429b72b0371cf49aff6966212cd65cdbf1fa034d33d64df3c4fc465d1be9428fcb6b7d30c8c0d6995b6dcc6283e981ffdac5ef79e73537764f64aabf76583eed23465e4eff3176ba169c16c5fc6293f751a7ed389606e1b8b26fef8c93c9ea20f2011b24efacc5d32c13174f0331a7d926b98ba97d916c8b5d99f8bfcde54d930037fb574fa009b04c267deed3609b2bafe2c8ded910c8f313eb3cf8cfed33e34b8d7f836f784add1f86d9d16a5c5a7e11e80cf7a757822a8059e532b2912def7e83899c846c48210d2c6375b19dfe4321c0450200d319f484606bd4d5586bf5f22c9c0855c1a1e5518b454a5c3e8659a209d34d5f7909208894294db1ad082ad4716b9b3fcb7222f76cbbb06e5ea95d03e39da954d226d33e71f824d828fac8e8cbbb4f4bb2e558eaabdea28e268809bd2ae9e48d8d06e33f022f60bd5535eb2bdfe819c3de0894185c6e09ad0d2ba820a17dd0510a26307e4747374a38f357b7a56970b7e220c523b1f5cb5cbab1e5b05c7e7627bf987358c23f97d6f4f291edf3772ae3f0db3c6de9f7d7e99d82a8b2f90ef29048fbf92cdca7f95bae9138d0d2b8e4ae0ac90a5351234cf2ce34b79b9aa8ec3f9d6aff52dd203c0fdb900f6dc4e5b305b67db41bf6fb1719f38d8fd782e1c7d2cd309e6e85bb3075cb4d51516426c2a80573df3ad08643fa10116b702e6e46b90761f627f3ed331b2c59269b630cad60b8d09bd9fce87fcfd35fd4f94f3f2170d758344474197f82460be0c4619c7728b73b31de6b5479cf357854477bccf9a6ed0cb2592a5a6e77d9ab32026a2b918eb918f6a7a33817e47553da7ed237170092eff16295099b990a1ecd8b83e22c05a0c69e9a5399701fe7a00fa4c71cd6963f7d3688f2214aa00454b7cc6e61d6eba440279da3074d400d47edcff36400eceb3e144382f9361854e5df2292640dfd420ec2cd99358a98dcca57502f351fdf834a49837db7285d306306d83e7fc7f366f0abf43b32802fc1af754c62566bbe9461906e6e3f6cd21cc8cb64db616ecc7e1902cccb50d4b4495ee83995cef30367ec81efe5906bccd8b169acaf602e1a9cd83b6d293a03f580c5ee0168ed7545dddc58a735900c84df57afdddf3cd8f6c13bfb40204fa4b7d6264a818c633e5341046e13008005219135b3c90db126f008a87d13302f4795cc97bc584c96311c78141a9d0b721630de54865cfc13f299eb84d939dd1a2080a241a390ba3c951116efb70999bfbb4a551af2db43c4749a07054529d8041957478909f7a964cc0129c1c7d9f9db7dc6e8cc9e830d04a4c791a4fd90382a2c81dcc809c15952739b1fb69f1d20296b63551016528301ba9dbe62245cecdc0ff8ef9592fca7dd69c15c3ec79ac06fc1fd2b4be4d2826ff52d5e58893b8df1df8b9454bef58e9bc78df3d7f6b2ad95fc8ac282bb5abed23cda7236e1255e0efae93b35e35392ff91e7def416965d8b9da63f6804933d4adecd6a7613f16cf4b81b018845d2b11dd60fb5e026b3ac859e83c3c7463c6e15527293d06a71a5b6b34e9e7ba9d56395bb0b82532aee176b7bb77b756a4948dfe5606278f813f2e1c228370fee7e7383f6b379692950c691e6d6a1998a2b770346123eaa5647df70cc0795b992129bf471723bf33aace829e7134c1bddccd90d6a7959ccc2a8c189482c4b3c06e6e5ddf2e12a4b7f82d62f3ad9d1230c0ed792cc03ae98c2e9a36d76d590a99314d8201adc219e6828afb381ba46b16ae038fb1217532016d4bb6d7f5ede18c77911010cd12344030fc087afd6f8b8e632f3b3f1c1550f11c4b1fc9c0a723c74f1132a4fff2767c816e34e84fe5a0faecef0df5567ef23eeb6b59de0d1544effe5b92ec90a1d168ed0f0678eafa69929c6d1db1fa6d3cf367fe1208c417fae0524ae239d039a323f0a8734271c9ce400add96fda4eb2752718ecee06b5107b9fe4a70c94fc35885f11c7d6f6c6c772f0197da1aa75d8a8a6ad29813cf5a24072d9dc1e38a3cf33073261415bb73f285f2ef13805b937c6c2c9f51d1324cdc58404e83d7f37346ee9c77ad6e929d4f0e9305fd6a72f6639118a1f9e2cdb7bdf78e8ee203c14c54d9cdd3d6cdfe69187b374623d5ef9026a3aeba527d637e336531d90f51088c3be421eb7bbc330c2b5bc0404e6596255e330a3c9c2203376f69529119cdd7221ab95f18a68f160acc7eaec1a82e090eeed750d226644ca53f9fb502f0a3bd67b468fbad690743b6a9f6af765c400a9e8559e6d90b9726f41ff3134ecd42d3cc92a897af2b4a7878b221fa58caeceade6b2ead2b7ef543b40e554e0dbe1664c4751d319c5c936c454e377408333b45718c9352b2416f5f4a7d04613a54ce2f96ba9c974103eb51428c2788de3d954d4c606ed7575d1942c04b27821d3c49d798621ac905bae659abec48565faf3410a5f2b33a5fe33b59fab0af7250440b137423ea3bfbe3d24ec0e78181a4e6f133ca317c146f5ebe4e491ecbf32098c66ec8c8fc39ae56289b7bea9c30bc3301c23cbe14323dcb9240a41c1a6a295046b4584021293c5e365c5c4cd51e63a4aebb8e3ca15e421358fc226fbf1194aa882e53fb14198510aacb62085163d6b8817d9b09dd7a9374db5cb4523f5044e2196a6edc39ebcd7d040f467463ac21b0afef308ec4b5881fc25d962011f20543621dedc3485411afb1fc9e87562c5c62115545d651452a12873a76fe6eccab6e1276cf47908b92f5e2da8ada675855344ac083263354abb96f4da757ad06cddde48f06fd0b1d58742d609296330f46a0d282fef91c499f28cb8c5146fb49af0b344055b3a06bc5b022976a80e7782226929cd80e4e02da463864f5449e3344cb076ed01f64dbda3a9402c5f7795925fec929b034b9494df2030323d399a6544ba7b043e2ae841c49da3912d49af10c9d807261cb343b2dfe017039fcd0a79db9f0f312d5301f882d620d044f61e8db1fb9e84c1a36f298294d7b14d331f3a45f2f6b5bf7a4191aeae451652c40ab83d4eaac4f0339d8aeef8adc67780bedb21dfd2817cf6be2625a92e10bf3a16e8f707d8ac9567d35c8db18a94a419cb63592a4c29f26742c3e539e91e7c12f7dcc5d503f61b48739ccd43338676620f22c318d77d615b7429e4e7fbb60f2fa3695d42ca27ef085a27fcd2d1050ab8b60809a22ed57bb4db45a11dc66993525e15f00a38a71983c84b6e2e3263a32419d1d7619ebcf05553a2e125592c05b9a7215cf9e1287a22669f428adc8e0fd6ca032f87071125a475a4a3a1b2da8fd4c78bee5be85d693a02f612b4dde601be3624e467fa4701c91f6c1503e67c52b1f676a41628c1a16654a569385d8d859c422ffc453c8dc73b3ca98e968c1150d08d48a5e1a1deb952d22516e939f9f44a65af4faa0cbcc58cd29fa11643ff56ba92df46c86a1f32c9a6eb489a8f11b92778be6f3f25010db08a725e2d2fb08ce2399efee27cea9feca36854c8eb94ecf2d4ce26385b72c70c1b6ba0bc4e56e27ddc759d2cdb89bf8db83921b342c689c1308daf837363100217e6505ba0e1b1e4d442b3d73382ec1b0fdf4fab688e6a9438758d3b77ab35a45573380e6206b4c15854c104e35ea6a6ec8379bb0db4638ae249aa3b833fc47e6804db1757535161a3f8ac2fb62422f3545178f290e03babdd7bf6c9312f34522c14f7013c52bc66a912b3b6773a4bcec0e4abf850fe7b8db52f6ebf4964d30495416db8d10fbc209c7e1393eec440c3d3f38ce3460c3c5da4ee8d36c7658f1b3028ab4cf43bf8dee65ebfc9d926b48c3b8e31cec1bc43145c9925d4d52030f7dd2ed691d876184c8b9429e8b951de6ade04db0d83d6e3bdb64287c8f301ee13706db9b60684e408fb2266c62fb6196766a66698df6af3a0946e545539dbc51bac5d3c55f10e165a747273459f6efb12f435af49dade5cbc9ce5162b6bebf0d15c51232939e2dad0e93be5d4fea830cac5349bf9919b2c62ce88a5a2c0321135a269df2bd1b08c696465d9cb265f77b25e8d5a31638f005000b17050f80abec5c83be83e9c7fd478ba148f158c06a16f5c73605ea4d6db7300aea038016288000e9927b5a191d27c2b8dac271bcd21bef7bf7784ff793dcb2b1fea0efaf953602945a14d52d2006137182a2fc23969fe75a67e48098d737e3997765aafbee1cbc6056ebd24044feb6429cdcb6b6b7aa5d3c305b89a05f565f40653be5dcc34617381b031a7a36ed20675856d110e6ee21bfbabd35cd2dcd979b6b1f0b84da367af2ab3c19ef5c0d1283db1e405131d8bb140116634bebdf1c64ed3daf0e9b6246b516f692176154af05c40a0b69c290eb0b7ea7761c3b226f5d824d6c80560a4c40afd01ea725b1707d6a63beb641162c6a560e9bc700379ffd6d8a19679a7033e9e5a19755b930bcffdf380b027572b1613ccf92bc1ae0dbc69f38f8806bbe40b04846b974cf8cddf9fea3791208c7d98316eda78e179d8c62ce91cf58c3589b3368283263dee2099803f8bf8276ecfaddbe92ff625c32a2940bc70a5d2012a00e6dfde494207be2abe7e7309a53a9abd1a6eda60d690788f946e8da08804158fe1effa26e6e7e5209a7a8b6d80ef67ed82e34b303bfa4400724af93db3acf652193cf2cda9bdfbfa3c1b5e6505abab525ed35bd543d18e320ee320163824d8f76d5d35e64baac3caf9ea815bb98c14c0d8b24eb48103a952a866c57cce04b05bae2905fe15a2846adb102ad97e83f73626da8712ebcda55eb7815fe0002e7df8960a5ac375777edffbe58db940edef1b0d0ad2c5debb6aff3e0784582185ad29fb90b941a1780634a51b2aabe08068cac5cef7ae77e138890acb62dbbdae08823be9ee56582cca570898646c2a3e1eee22c29bdb2a4c9f258b320ccb42b32e041dee7e4ab7d9244fc49526a96d20759b1fb5e6813ce5c974189619542d9bad3580e100d54607f5c6ad711217d7d6ee69047a9bc0f8214cf477004c195860ca7abbc4ceae6269b0e174a17503addc09e9dc8ef6ee05774d9abb52f3bd9b93e0aeed4bbdae370ae0d522b94ac8631300c9fade697abe71a1ce028c9ebe0e1d45e7b1680ba16122970defa333a5d3c065f4a3013cea2a5d84b5dfd8f1ffeb1f1911ddacadaa3faa662f60b1ae18b95e5f0701578c145274a965c3f571b37a1326a0a0547abc740bf5c24da5d70791bb4acb7e7309cfd26f7543f86dd50d91976b3ae0059525855eb779939458884ea98148d38f2af82a5eb0c96a93761d2564d8d778eaf97fb95751dad50a75c4e8aeee06811072d244b47c71da4ad8773805eece4f69f5c698a9b418dab42cc74a4dc5853ee1b1666ece50fdc012e211b02b2c51b34403148e8b2286f3fb9489b5e6fcfae50d896e1970b96e82bc5abc2a58765608bbdeb51b5fe1c39f57b2b331f83db223232f20513eef3e8657cfc48820f4c2bba01b9a49e169ed602471375f7adfcc351229a3cf29f532c1711ee8db4db44a0ee099e5d96109190082f20d1d6049df8b29df8f3a7c4b42a516a99fd9fd573ba64b440df99e3f6b321c10382329c51d4961103997132bed6c39b2f7162a5f8c86a41a0047111158167b6ebcf6ffab4a004cb9467cfede7fdd243149cf5a06246ac662f1ec7a66c8ccc7c4cd7e3b39778be57e4e1f983f04e421e0593310a83f9516ce788073c8018cda655c3a5e7c5bf57588ea33a433361af6e0a265b7bbb667ddfb7085e64e0c3a15217e32b1ba32f7cb4e23d4798778a657b005ce9e87616bc41993610b4e7386592b847bf02a1c5db487391b067e5049f184ddd3defd69225b219709305d7a9737ad20745fcda83ecc4558b0cc53de7dff30d83e118e917cec63857c28cc1e771932ae6734658e0f903b5a87991a4ca29cd0cacb9a1df661199125ae9cc92675c76462e75aebb2605fb29b446e0b6186e3e05a9f99b141af17f6ea59c7e48cc95044110831fa576865973f97648cc4e1df03bd483f9cd492f4fffa32bf9a376e8e084172c04caf409994b06970e81319e2e8cde331f544c308a3507f9612d8f2fdad7bb93a6134ac452630f178b7843511db1daac3b6c5358372176f871638abfefc842af3cf93a019a1c2eacd2d9820499efaa33b6150946fde3e1ce2771045b5b88b935f07c97d414568563f2648eee884e0c38cdf42effa415e3ff0178fccccde63a483f215373d297d5164a0e1289a094a79300298a2c5f52195605e36c33db7f1cb8ff67afe4fbecc014fb907a390cc8314667313f018bdaa025226864f6cdd76507c3378cc3077c8c242de4f8dd01be69ed1d2911ccf89270f9ddb29d80e2287d995492a15f228f1f9ae374d4504330f24b249ece201f595ad49648dc7d41328e0232c04f27b4a611c1189dd6064d33da2f0eeda42f51ff178f39e072e70d68ca000bc52a0994bc8c346016266a086d33ef376913dae442053e35b3119d7a420b61149faf5444202ac0fe8c4c47d9b2dc8c9a5f9e46234c8ebc21bb8f929f95c848010fe6923a6d3972a3e27df9093abf4dcfbddcd4a0dfd66e57b53d5958790aebf1c5178811935be96322698d9b9737712b8725dcb5cac1f1046a80eca1821bf4ddb2cabfe156bbe16a8fec3ea51be115489871131c281df502e49aabd8ff4a00cba35be47d9e3bec169b190078bc551962ae87d2213c57daacc506474d84ff4f298e5eec843ebf094db93c1f3a22f5328ac68a454135da778c23b99e8bc28c64e0bdbfb83e10eebf05c3d06ab776d99fbd71d96cfe2fcf39d570ab767480a9f56cd1f7b9eb118e46dc544953635b76fdd85923218aab14feb8ae5d7b03f3c64fe724c7c345aed1de0f1b536e892cd4211945b12a648dff491a3f0b4f7ee8c3e45b98ab708178ee61752ecf14a9e5eb32cab2a899e8d0e420969bb8ca3b8e00a7c830cc5746d957d834d3b6f77da13af25d69978e54529cf7a73cbcfc50780f0806785930487d884723f6921809d25c7ae8ca5dd68f942c38ffe011405feecc68be0f1a9761ad54dd9151813555a62fd4349931904eca8c0cb74eecccf50041af5c9f341426c20baefe321ba04cd623725fefd90620f8a770722c3a74b2ee345073212a817e9409cfe2eef509ca33adf0c675a0b2ef57ce64139c7cd4406694c8991c85b90ce494474410bca6302795209ecdbc668f39eceba2e5518a732440de23cfd4935b3e45078b57550510e1c0f8f1e601697ef39da10aed8ba9b5989a619dab310b7a82ee8271cf99b3776dabcc8b8de62593b8dbb38cb6335797e754cb1e49d16094f55277c8bf119c9aaa7080eb773aefcba3a4ea522581a0b73e67eec4ec10da6f2b80b034a9bd0b28e611e48da1d0c3f2de41b1ef5118f92db638373a04a13a44af06c7ff711c4484411fde917c044f51a132e73fff270e0303167f3b1efa1981c4cb962b26d581415e0613b74161c80a2254076a62e19ac4b466c74efb36035367860a3cfad73c65aff34f143b7c09c5189d9a85de93236524d74c3f122d556afd00979c20749cb352bb35e9bfc9cb79c823f3175f248ea3a86084de757675b6d1ce6d7b396aa598a72e8c0f7ec3f68f8c84008a78a9f9bec5032759e740e1ab7e34a8e29caf75b3f802de13d601dc7722592978b31faa4a78b28228cba971397796256218a201c0646fc1211260bc3f8be3f563475b5587fdfdd2ccb6993d74712fcea265fdfee8b27bfc65aab10954d3e96a97008855a2094b0fbf561e3a671ab862b6292d40ed11ceb12cc2de838df55ed4b345d17f18c00072f58804f357145dc74c6451fc6f185db2384d41a150a28c3d33cf1babe7da0a01eef5cc2fe805d0f4f0e7498a4419357d9a167c16b63de99b0d435bbaf0ef1ac852e0efa6f55d8d4e9dee7824768b2815595fb657d98baff98bd2754c133a6106ca89c85bc145a77700202b732eb63a466256c8c1e441eb3124fbc4dda10e9b7962e619596854e242b3dc8647156fae1f7f8f318d5fc057367cf8b0652061a778ccbd9e6fd3564c2eb7567e5c18d341d69d6820ead7fb9029e8410927a2cdc2b67ddb5c99be1e563b9ae0c81443937f0eec9add2bd395a4fc86eb25558092e508a9ece026a4a1dba5044d186cbf8e37ec90c788e9102edfac089f7007a3e0146753730f1a394db810e6aa3c10fd48b458500dfea2ffd96824e0876350f50cabc0fb77c7c6271292d511460a88477d04f9b533b1927b60245e035b5b59b3263b9eceda6e80af960b89d4e60f5dfccd35eb24d159d936231bc7e1bfc111038986f6c7a8b4040dfb7e696f6f6c285c14565eb7ab1b0c31f296719feb4dc57565ba3eab8cbc41797b6f8e6b4f69e47280f3efa03da22f33d72fcfbd36f0b6ecf99f9c11f488a1c3901e6975d93d35ededd056a4bac172a4420fb0853d3442abd60c6d9b5ca3ea4ceb0291835838abc77aacead2cb41216653a0ee3f18db8896b569bb514dbdb9211c15b21d4de8fb58dce5070296cd3dbd32f53666c41505bf9929e9b0c6e324ffc4ae6484c1c1c726aef97fb469f50d7ffaff1b1f266781abdb7c994d046d263db36ca3a2393cb35e2b3880f89eb25a9a53b397cc14da1e8fd310b482e144152012ab8a8b77d9681aeb7a393dd8ed75e1334b5494b1bf77c856d2ff9b30a92eb9abf255300e5e7ed75f608f27c4927f536cd83f47d4c6fa6f67626edfe191eb6d7f5f0f7415a2171ce1af6986ae0b4e82837e80758293079a678eba94df0f1acb5da73f15456f939ea4b30a05dc43de6aa821ed201068d77168300f71998caf85d646c9dca9cd100c3b74be4e64a8f6eec272f3e716e3f83f2f4b7e1006b022adf607fdb686390ee4ed23f26f0eb75cfa200bf25299c3e6049fa890b25cc33bbdd9b22a0abcc33e21b9cca380c1704ae8cab43303eb29a27efbb4478249322c7c059ea8f4d0dc32556557aabe89e8f818f5ee3939a61905e6fdbc9a865cd91f13527441cf561e33ba6c4c4c48152e2dd4543ee28c716b02e6d9e203501455255679aea79abdd281845bbe513d1764674ad0f73508e1f0db708fd8528d02a8ec235abbb8594f47ef53425623d0a90e5f685958525e675a9537776035648b68499ef4cb5f0d04116e98e79688f6a295e84fac70362d5fa89b9e3361388eb723b88c3ce688d10f1816ca33dfa0604b3ac9675c632ed1f08c122ce9b90c1d1d84edf37087f3d435a222d3db7e9109d640a603be24935c0f26502d9a6ef63fd661059bab9d14265ef2f3034ac33b3dc20616efcbd9600e87cd4c450c47401eb2aba78d253a972ea3d0f158378d07fd84215fbf2d59c6897ea7d2b9fd4a373c35a413203faf4caa9229f9bf87c861f6571e7ad876310e8cbf1705fdd79c7bbd322986f8cec26e249d587af24629735935ac08a2d10796e05539ad44a6d150cec9d73f470b3dcf0b545426b6e5c0dc99fe70e87de6a7925438d804ac4ef7abaed88ddfffd305b64b6636df2f81a2b93b9b7fa97101c7d26f71d8dbca8ee85c172dbf1e75d2a88116df7976d74f33b3a54d1125d0664b50a2074341a3a41fe7b45e1cc0770194710eb868adb47e2d9ba178256c00b89f68f8ebd63587852f524803a13e97bec103c9eae103949fb79f80d0b480be54225ae4f182c895d14475f8548a655b850979a87710232aec951c150f65c4f99bbbc145846cd15e1acc166760f9073f244090af31b36f787ff79f7652d537745b2cc6da08f108821ddace06f55f2ce1155b5bddde4edc25ffc947551e0e711cfea03921c8a71eac254816bf101b7f5c7513c4e0b95e6ead906e63e6c8b847f671c4a22c88127947951c8538bbcdeb8dc83c8aae59f0c745a3356c6697d6d321ca82cd52fc95848846d68f855328e755278b7a44be8dea71fdbe4cf6be52fd6c2249772ce54153dfde5af2a648c33c18f99d12b249f4b7963227a27f937b974af7c12d7c64fb27979c2ee720fa7894d867efed3a97b38a64a9ccb5c568b529f00a8ac9a110e78bad5fd74bf92666612ad7f88010a04542df652932f8c71565d73f3dc3e04005f8dca49cdf2e2d5a36e93367d13a4a28e5eaab8199a0913c41e9a1020fece4d48611ca519b77c8683253c7828be0b826e4cc0a565922bfee1e571c18afd3f2fb3d3239110e436f24fe0c3e8017d8edb3f4041e11c34445b9df928709c17f15169a8da4bce121e1fa209d833aac74aee73c7b628bd21dd70b80193570c51a7a2ef5dc0e3ea89094d9b5da4b42d2ccf4f02497127b292b3440e16c2cbee79c9387fddf540e794986188ad290b92f4849a8d844c51d594c3af60a1c5cd23aec118c40f254ce487079d9b528285ac02f04d48acf0fbe5cc724b62eadf50e797c773aac37b95107b16db54b19a63a5cdf03d8190f0da89e828d674425d38e7c3c40e0a8c30ed223aded82c7b12df747c7765951329693961fde47d8c59ec4283b24908b541b8f4d2cf6637b09b3bc8e08190e917e8e7c745d0c24642bbc3b8fe1dab0313c5b6edc5e34efc917c5f158ec72f61d1a8feb5a656a204cb871388d4567daf97cdce0d3fca1898d597ff7fd5ffef906a95ff0228f39e18ae5542637df4c4a57bd50cce9dd872ff0f7e4046ea7e7b25d9138df331ec97117150cb34d7b0a4b612cb366a95ee7f2c94639328ab62cc67caef2aa833373fd65eeddf02f6816724c59fd74b29e488968f1393233a580a7ed36dffbddb44a78d8eb2d62f6c89b7972cd68ed39d27c11fb5d981d0ba621aab1e8f41b4008c275acf0129fd6ea89dfac5780d3c2cd1fb2b4df00942880aff00dc25a50c9169c4bb531f63cdaf41b43cd6e1ff75d8470aecca02d3b92bd60cb90876fdeb8a9db16ae9651d39f635bce27b140ea5e97f7d2f0c76e5c716c26ac966bd840721f2dbba582a45e90857c7ff8d50a29cbb642206d81bfcbb9bb3a349fe1bae240d35285d1476d97683048773852a0c3895a898df34204d55965cdb856275397799ff8879dfe35a5885461e3aa777d1fe38e4d2815823166d8c2848f7933fd08a55a16b99037069f6eff824a7ee6912417160ed6f7d116e6cfdacc27ccaeb2241dedcc09df83f4c9c482920247bf79c473c64dea58eb1f7df759cbf99daced2a63a970b0bc402b99a190c5499aa6234fe9f613e008b78037c2668c44095922166d53ddb4cad6472305cbb4978d6e41f5b8657b4fb8c5949402c9cd2337f0878fb7cdc4c3a3153b42863a6ffdf8c18a38e1f29fe714bcbf632ca7b99f716250d57eb32d75c673a75ea273d02c2df02dafd3cd60e3c9ed0ff6df194562cec9cac7b5172e5d099e495018a6cfdb565dd0b01ab66591739c5c27c668d1e03e55715ec9dd5a8704b4fb5ee94f9b693a5012c3a46cb6abd3236da163065204deeb6259d53029f3e509cd16a9c33500b335744349eccef1a6490f379da9d0de75b0194498393d3f35fa46b813123180fd4bab4a9483a614aa9f6ced9af7ef3cfa218bc5e9895276f74794e4d3b36448009adc064ce1c1789bd087aab7be392bec93da3af38d0a77e75e77ad6535238c1cafeaf866678051c7b5c18f845f06252290a7cb291b16797f895919d2f3d3a0ce83ffb74d95b8df6e0ae2d8b77c22c0e5afd53b10a89f9ffc86de1c47c529daecc9d3d9412d14fd551d43ca428fb40501e28562ad888a4c445d1aae49f6787ab9899ab565bbd9610d85663718a70045baf4182cd747dc6716131d1817b644456ea6a0153a01d8911a7e74f93a8ef1e3947642b2503fd9638dde327889c4d28fe3d872f6fbda0108fad47c224872441525ed869cced34b424c5f5b105eca263d5e934c1700ed0b8ad096f6f538d649f3de63e76b0d4e7fd5562c155262f645f56525988ce5cd051892b21dbfa7897d6cf7d11036189395f057760f5857f9b76ace9a34972da7a5d19cd9e8c13d31560dcba100a7a66e81dc1ed541fcbf7f7cdfe372362d97d76fef053f33a938a942f211d8ac02b4ec9ec3518fee1c97cb552cf600a62472bc42e2a104fd29b17698c4db35ba9c7381fca421330580b27239776eedd33ad798403232966145832805423fba1950b94e1467ebc060ad422381d3c35f28762afc13e7989a078820e56f1f6f877557b9cc8e55add31bbdec2ced2350ac326af4fc56ac79ab6937497e1c6c5508dc4fc621b17fc66cdd2d86b6a4e9f0d7a4b1e8e575de2f7d31d74e1df398de717a39e7f3cb8ac3ff20ea507d7ccfe964d2eb6dba172f676486c7cd2a8c2d55f9110435d78bda87d38bdfb51088be78d99d1f63233e3ad0c7e9529d2ee166a7b6d0baa81c01e4b89fb16fb06dee745ac25c1df67c6d0bceaa204573446d892f9f8a5ba2c0218ee5f4bf0b2c254184c3897f55412cfe405162e7edfced4b77b4cc9aacd518fdf48338da88673b328e13b7e1b531c0c5ecf373b0df2d1faacdcd80f3124cd6d25227b198bd76b6204d4a72225e9493df97ccc52ff495340ca6184c46ec423ccd3c4f7d6607469210de73cc564a7750e3dc7e046c9bf4d2f3187e24b2fa5773d56ae8474d485cb76e0bd8be85b9a414ff72b32422c6a762486b1679e2d06956770f6fe8983610fcc641f7151d9b14c144b1d3d4944efc54cddf396524763fcd39289212d6fb61c51521e376eb1e213a729e58c6192fb2004c135dc7d5c7b9de832b75d013f17d725e97db99d6c6767f46c52430f8ddbed659eccbb03b360f54b8cd29ab91c8cee60fad4185abc6f5d21402bee358feb0129e1602a654b520fc4e7e5335b0cc79fd6b76fb20e9f633ea8b18138977842bc849bf521d56531b8122c8d0a651047635fac96a6d86956ee6f15a27c3e69524c1bd360e44661a1b41d7291370eb1e5feb4182050939305911f5a3fdc574809d7f079d62e8e36846b5d9904b0a8fe2b5a2b883fafec014a25851d5780a836eb27a4aad783cb688a2ce247b16e3055f4e79c5b741520ffb3bd8bab68b6a7c67c5ba095cd6a89135a1b9a5224e9dbb0503f38f2e23b37c711bcb23e21148fd397176a97286df632a01c5b45c3fa9363c9465a2ca829b388d4c0c2cdf61f52b3f621b3f22f48acd2429bd1bcf020445ba9b1274697213a563146a9e3da6cc6ee40fd626438d6a51287de27bf0c9dc0e7113b6655831863b90f734617055a6eef135f160faf829936682edccd051000a58426fb253fe5aadb9fde87ada65415ecb8f5853ca0445a3c6b4859948b2a34a911032dc5f9c698bf8ec8696e88ea3eb2a1bba26e5f2e66fc06516cd10ca98130b0e541c26c4cd2689e43cfc5840a3da32ce94d6ba0672ebc2abb2ae3dfbea146b476c71f9565a9d68dbb8a29546349143765726999636b141932a32c02909643af9939ef43f3b9ed7fe5fc70d581e6e076ac8193c2ba51029da408ad441c7ae9095bddc5ed35bdd5dca5204a2a5aa98f5a61405878650a95a7ceb7185f65a016f339fe88977c0943d10307ef2f955c1028e8ea2eb619a18e7a3d201e247193bedd16164035d07fb4a02d80f8da277868192a23f389e20db116c24e2979a3aaeaef91f853efa6a980665e5d2219f0424fd89823caeb0ecf4283601738306647e4c4f83af3274b95535cbc2464e758b32b0fee0202a7ab20bfcee531d641d95223f4d870988bcb681c121be0c90f6f3c6301bfa06c3a49bbe96c031cdf09fd292e2b650f9f1e9f2ce8e8e3c9e439cbf19dce4292cf5c94ab4c11779bb1b3234f9a688d23b3a82ec40ee6927aa6347b75e24849535f359707b7e9d3c9ab83a5806e88e72d233d7494289f738950890c61f7f3312a5f6650258124b7c4cacced762916346b875972bfecbf4dbd8b67e1e8cf21bbab5adab1cd262fab4d87ae350f0fb9df2263db2b451431c082a9a986f3fdff85c575915570aaf6772d15a5bbbc59b0e7d8ed82161c1930a0cb45b1a0737307b702450a63461c9aa359114dce4c4a4fff78aacd596af38442b6aaa04b24a3cbbe953bc6914e3de7a4865e0d353a9d03fecdb8f12c1d4ea3cafeca2243f3aab955539fb3ac286ec1c30ed9c1ab8a52030bb58a57bc4054451fb95233daa0c63a945fe00730f28c6cef7a58c5911648a8162ef5211db1eb9c4f30a4647c9e680d66b3bb34637733789184f1207acc6b4ffe775f90068e6996dfcbb3c429d4754d17117f87fefb45854fde3a1ce20a25bdf91b0d7deca0a41567267abfa3c434823ffcb8446cf134bda1a71f71a3a1a8b183e0748e35e521acf2c48abeb983ef9e3986b35a0ec9bbcd13c2b7a04eee7110023a7e65c43773790d77a41b352b8632ae098d00d4012d991d88511d927f3295950c2ea6667cc9408b6a5a6ed9caa6df45f968fcca0383008ea1926b5e2a053cabea3dcb842c2b81a158306e69e02fd5c6ea76d200a2c9ea118a16ea336b4d60dd936299773f152785097ec7437791fc2cc7c8330e7945bc4d2530017bee60e95a8fa84f0aaa5b056177ac0a17a80c0a164f4741934020cef50b17910dea585079c7fd06a2a3cfd89b9f4cabc1933bf608ac25d1119b7df382652cccd299a710b5794a38805839c3ae54c8bc0595fcba216a1dc50e2e35772c96366be77ee1f7ad5c595e22b86e0f2b89a762b057dd16e3f562834fe010f82b1afc1da23b7ddb1fa3453052ec9578f6681319cd9a6ba6a383614ea37adc5a6fc80547d4894efddfcc9f43cf69791d3a804d3038978b9e75c239749442200a76ace027307dcaf14928f43f4d22737340b053779479375a0de38d98e1fd58c394f9ad075d1c46811acfd1d74fe826ef7a1e899665783e5300d38d0fdbbe0091a44095892b110b5830214e08981d890b326060332d6cdc14e6c1adac6f1ca79f7dbfd8127a674a915d8b6a16749fdaf0a7808199a6a3dd4f2ac2872ff71d10e5760cfe8caa9a91820283733b843d18331b800e71e83c9416c8c0af2f7ab75cce9799be94b21dde0f717855c25e2c7535918c04c3ffae5d96410bc4ebc1d6b045bc4bd61857cba35f4352fb8011b0074f9e2314a12d94ea6b603f0efbbc3e8a81bd31f2cae3dda24fd98d723804f2feb484dabe7b192b024104cc68e076b4e21ccd4f404fda8d425cffcb3cd398f71cf6d45e72ff65ad6ca14e90b6c016d5116fe1b26b7148ceafaa2f4a1217a3ac21d1f6374fa7b9b461bdc4c2fb3f90f76aeda648442317179ddf9661788c1397c221627250f8f2e2ef6f16eba7080009ef5c1cd5187a85c3ba67d071620122c7ae81f637bf1c6d964e6ae8d0c1ddb810e7375eade2772f4562195320b1ff255b787be0bb96552c0beb127da54b25162cf16b077b2a1f454192b4e192b21ede950300896dfbe7fd06b7de47cbbb326aa18e9c7b7876a774866b0c3f50d1729b325aa57c854587b6480d44b8fc12eded09ea4e6c82c26a52602615ad143abd4672cfb5052727cd91ed3cc049346a89cce343de1229730c73e4bc1126ff09386fa1751224effa2b449d2eaa9f366b440d1c1819339ae5035aa66bd78fceb8028598972bc73c921b3d6b352b20992c8a72132f6d81427c9172f0ea1ea6d69b53f5c834423ddc2643639cfaab4e2d43a329b920fca052e8c6044a92d4ffe2084e58f402e32d89a122b1d39f02aa7c370f1b852820d7fe4961e2741fb75da717b6eace270a530b3be28a3c39b6fa5fda7f40180551d488e549b5ef883ebd9cc0e0f36281a97abd14e8e2694489a609b9dd03dbccf5e7fdd574afa3b0a05c190480ed8c7ff96e7783142a2ad0da05d2efee4a1e3317dd99a7aa58aabe7e0abb9b4b14d045caba7d0cb8026262dd029405dc86018440725422aa0075a83a2932e39c29b2cd1e8688c44f5584c2dae86dddea777704e540c97407bb0b7f896389f7817db262530b6f0d4f868d79d762d54f892b48fa60d84ed47baf80f8e27fe19478ccd9047cd9fcdbeb32f92a59b164f7d83c5e38227d916ba404a492f0cef4a09e0291901fec41174578deb2b5078433c47db97b82bca1c8c5ccbf4d2ccfe1a34f814e2166085669e71b09078e1ee4fc2b765477ac83ae44d9f2f8e7422f9564ea4c509af665fca5a3faf060be01db58a9057bea5c1f99886f6b6cfa4b1a59d8a636d8fb161976df95ba77ac1f5a33c68e189e6f1f07d24dd19116c070c792d1499ce361e1e65b219ceb8da4107f4175580b57dfeed81314b2b5b7eb3dba96d51b81ad061b4a5c6b585ce555c5e141263d21608bee6587e55d9139867c4b969d6e76f037958fcc8e9b211efbf1aeec2fe0c2b7f9f124d8cc258cff539f7d606de978c89a7c1bdc57828be0b7f9a28e1286a32651c4255672260d8f2826ad93accaf103b080f0d1fda511e23f5efef041c906f38759679a22ceb9595ae61788caac7dd07cd840e24430ffc7b642507fd7013f381f882a003f0e67182ca85761de195296a3dea3d8208d484591b7e7f253589ecd9e9a6778b3265db9d7a137d3da2764fd5e1c96a1887c81c2f65827c959455ba3f4efda22c5b4286a3dc0e9de91aef9a16ea3e91935a8cf2a4d8dc803a11541e3e513a7446d65685cf126d20dbf00d94ea38c80bc632f07c2ac5d78e54f09826c4d195b996196f3f36261463d6eb6ad889a00762a7f33f66ad98811554ac11c394ca138933f428c7ebdb76b0b920b</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>从数列极限到点集拓扑学(from array limit to point set topology)</title>
    <url>/pointSetTopology/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">某大公司的名字(全小写)</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="5cb9e6fb74bc4950ce7cc22be784c99b4795d4b9efcab857a870e3b2a2598783">eb13ed5cc53f32b13a591c515215c6c9b04495d56f4dd642ab5b3ed84f1aeb319c6599dcdaa8ab8dce6ddfbef3f8916abcc9cdec9899d142dc190201995995fbf97b77c60fbbe94b53975bdfc889f42d305dc4f121dfb1ee56e4b0361c64b063ed8b90972ad78dfec439d3eaa065c3858018214252a56fd91928e2bd81d5d4fe9ecf454b2e6088d9156bbc2c66e13b364bb3d4cd364a5ad48f9f8c75127b1073e685d0966ed8a1333d75f36a085ad6c03179503e282923eceb59b269548cf3b3c51970855a73c659a7d8c306846eb8bc7c7d3348acda417a0a37015f43fb070e60e2e112b7e91d9dd63257cfcfe5917481f580364e4e5c449e1512646878b730a13ff53b81f4bfc3f24a7966d1cee82d9ec257f9ed6f4e5e9f42da28c65868aa70af92ecafc6916889b0e858653d067a86c822350328f3f0c255cc728a7685ed12478a46bdf34ed971fab4cfac5fb6e16447701c0aa62aec93d2ea5b2e023b7ba75d68a582728ee67b9b7a88b6dd445498b8c2186a4ea0c2a01d27a2579a8c619420528f8e8a4f4ccbe79a4026db9bf39e5a8a3498d4ae233314737c543f1cede04115a73cc264757adc6a1943a60005e9b073413a04d9e86f63f29ae162dc7b5523b3269e7bad25a6394ac375ae210e8ff832f4b557b4becdf43489ebccf04553cd65568a1a4fcc1ebd5a1f201a24bf2dc8e0a1335fe893ac1509063b1a731c2ce09d82fa3950b7a09f620af787e791136bca2f25bf7fbe4dba63fd4aa00624e0a44342b5584498c902520804be3a80f2836906bd51dee0634b664c3b86cbe308a41d4a1a6cbcb86bee18a169cf4900723f2e748a5ef279adc31930c023f4508da73ad158a84539e475bf3aed92ed07304477dd61828949c50f37dba9983b3e5c1ca7ffcd5bdccc95d23857e959f71bdb22409e80fbceb04e9573a22bcdf95557a74c95aa6cdd83e5ea7d825612290c172106050b0f7ee65bc5e5ba285d7d0c70ccd938ed3674153642fed2f001e33387b8f67f03393e6a93f2b5d6fc3e2842124cfc6725f34cb1a425976d0f3fb5872d942ebebb98f462ef58d5296ccc5be583c28bba08832a0a06b3ed5ef8c12ed3a381a7ba30307714204afaa5c1d35a363e4af05421288bb995cc6560c1e6955c1bd8394e407658d943eeb216a20d205e8671dab3739cff99f3eca901b2ce7888fb0297afb7dad9d09a384212a219beaa16c1da49f982ed27bc5699b2c78e5bcc51ae0c367511366aea179383a3467f7c565fc39cc68df3bc184ada2e7feeea9dd5fe284e661383e589ab54907157bd8d1ed92adca74c239d06ac92fd4a33e478a85e6611ce0e45bff57f972eb2244c4fc8c975b2aedf07b89b3253a08ec9fb2524c109a0ede766a8dd317b32300780473fb8e36cf2fa13d23a985f7d8825421715ee8e6429f69c230f5212db398712f11ff207d5a0766746df65621777fb181f4711df53dfe0f85cbc2607ed850837e941ce5721405d0274d8a1d8989a1cdb3d487bf04f390b9727609dbadbf84c19edd8511db8093e48bf7f6f1ab57781249fa94cf3eb518620ba73047fe8ba4f9a6d72b7139cda13a77ce6ae620f6205555bcadfcb01c25e41bd7f9a02330972592aaf74203d3c0bf36a00ac920dd2ddd8a35327b18d5a67758149358d8eed261676b794d9ceaa73f48cff108b4423497335d47924af9ece68e9b65e3772dd92dc3ca7c19eee4be4059e612cc9be1451bbfd3f8a05237936b8f43a12b4586223b174e1181358b625c75fc432009197633042a275ec9d8306ab94ac6869d9362caedb979e6a193a6f7cae0fcac685ac34b34b7c0fba936b26a714a283b3d7f301ff3ef6944ced6022f3651b93843d8a5b2a0e645a4e9b41f84ac4b3676cf09879b2be8d34c44b10b2a5a85c6a5dda2e02eafec7462a929048ad38f7962b784b8f41b5aa208dc351939e030bf31dba61a1c876309279d49c682de3e39bd7a3db3f82312bce608011376d54b65691c6ed12648473de4c2d2b35a3dacfe6b4af619a4df368076f53216ec13e773373b6c662b9f8f8e796d7f051c755de7f3db87250c34b67b3019fa3c889d36f9eb8f06b77736de1d97985eb00059de5bbb92cc526af95f9f46029c08b1777d64a1fcc448d6d85f0aa7fffc72a2b39e015398225bfe47815975aa6a07976513af11fdc0f3550938553775c2b4df2d7fb328e68721aa8b6b6e2fc0e66d298d284096766f0dbfa106e97605ae9d4499783c4b620c447a0c4d138962bcacb6edda08c8cd10161fbdc650b934906c99bec4275da1fa858acc869f80916f26c9eee7e2324e6e31fdaf7ab26e561050e5f8b7e7df7f70ee64b3fdc8eeb8a3aeb64a7eb722708af4425f08d16ffaf9c34b1a5599506d3e5f60831f933c0877272ac33994ff842ce94d4be06067d1a2836890e40a382e28df2c132f8b2969074e0436f7342ed546a4c45147c3e43a889451e90cbfab2c96b422bfa5836b8c380cc99c266433b6a799e4d6d880e98fd0cdaece92be15569516f35885b6046debe8b222715b9725204db365e16541345590932c20a6b61d1f5d81982bc1fb8efa8c781ff07a6a487743238c44a6d4b0b6ba0385c00530e55560aa3d75b5acb0963389633b3ca2f526e2b0696d1207f8d54c50ed3cd8f1c9238c80f9c3d2ce55aa5e784b5dee5a034b7f90908f653fb1d7ac36670a327b7fd88b5fec2e190f81fcdf8ad97363f5e3b615dbba567162a1ba36990c1a31d89d188efc42a1212a00bb893be21d182627354dc54c6c05dcb961bdbea68213c7c1f7dc40325dcc3c7638c480d70f02620b217e5d4a11811e65e8d43a9095efbeebf32f37627999736e7882e15f9f05cd05237e1b4507194a58c2119031245841246f4155d7c09901325c9f6a2ffa9024b3e93701ed9821172e74842df9b8f28ee40c81a12755410d8c7bb58b5507941fca78245ec0b12c00b8fee9b07f24f75a3966a55bc08abe28e31846e1d739b16932ee7b445515583e8bc9c2800e861f6615ccaad15403ff67ff050d97e115a40170c2f8f18623866a4d928ba82c6a4e9e8401552e33d3774b961bc46d64cce23fb7491d307187562263758f0dc6f584d79432ae1c8cc66b70a70d9d4714bc9925e7a99d1689d1acbadead4f406f6b67ff74d31b679f02ef2ca990e9ec4807cb614b7034804050dbeeb22e64e8ac5b9e3be03565646cfaba4bfb8de3106b07e47cad53ef0de185e4467b381848327611e7fb69012a295a2f2292e6f3482ae951c742bef2f05639dc5b72a99527c8510aa02fc06167eb16c17fd57647f767be5462ab685b40013c839599440584ac2e1ceda1c21109dd8be3e65e796e37ce47ce483e7e4f7d64765385e40b3da494a8fb683c5775aae02a6ab1df7b27fe35b497beac25e4808fdc8a715f4f0cea3cb2ac8245c0708e23caaed7531124979779a65b10b9825a279f6ceafd5f46cbac42dffbed117479e9744604b4f3f5059d203e04e33aecd73d9acdb7d6c2da26a0519788a34f66e7694876340f66311ebcf6866ca37f4d0d406a48440ca6c0d439fc4eaa2efd5bde77a5c9170186982029d46d87fc11d2ad062b5485a05accb6be1b9701de8d863299318a9e2c11e1ffbd24f86bfc3d45f9f9c4c61e1b3ac10af098c5f60465007dde8ffce5c9623cd9aa707a0bf5bc1c31ee8c8b2a7b4318129353f1d8fe79e2e9bf64ad271cd3d060e08cb6d13794953aca28ddbccd74a244afb5fc89768f12ee44e2ef30db10c3ffefafeb25a5aa488b3fdea28ea602cd39f9268a03a0b9f47bfe67db2ed5c48840010e86b8638fffa93985cc08ed548656655752b57798df0ab26475448615f4ef510ccbd59946748ba77343fdf721be91eee54ffd3a26018ae0caed40efd5807c820b145fbda6a63ce4c9bb683b8f3229b526767fa405da39ea9dd2715646676e29da874f3ffe06bda7bef29a0fbfb060bc276d3559b92c7d9212c4d14844acd24e1712e35f62bd1d7d1c19efd896f762a22c4cbe1c73d09c47606ac300070dfcf858bb6b0ac255e98a4c4f02b895e8b336593b7d8cabe624d37138b9ead668e68b071168dad8ab63954e8519afaf498ae43c4a05ad6ae354ec52bf58a8801a5ec7576f49a74eaf178d656042fc55f42da2356ed94d42ab1e6c69a6d22c8a02b59894f259629fc64ece04cf57c3ac419b3920accddf7ead0998b3a9b30712810447b9d5d6ee376993a6db4bf8deb3e0756291bb72953dd4d65dfe775cefca7946b056847d993bb1017f03639cccdae6347a3a5c23c979385137c14275d93b15d1075e541551170478065424468c71eeeb2fbd41356d8a1ad6e1738352f1aeaf85ca9d038b880b3dab0ba7713cb0c15e542f0b192e96dee728e4082d78e24afce1e5157ddc369c05d7654f4de4654dd67fe21e4866238a8f6baf51bdb647160cf95f84c4e5b77124495e419a7e382fd3d9f27ad18a2af6d4e29107e1dfacd20844b7cb53ef09b2feebfdd290d57155ce6cb711ec7b5ae7b2c7bfc3f55a0df392d6b426a96205b444b07fae5d2e6a4c95721b125196fd79796ad1c6b5d916db30538197158877bab32c2a5616055e01284314db5c5b8f9f1a0eef783fa89e664b7c5e38f1aab9b019eb515c1322ba60bb5ba28aed69e0cf3969d328d8dee72e47972b5638b430faf8f5a543ddf5037e16903e43c2ad3b49269c91b7ff311b1597a498e16a43d122392c8f7ddb14aa4390ef87645aa0095986b9bf6119c34044b74ae6b5e5abb225e4134590af97601d9e975651685b8af213dca1dd43930e43bbe5e539067c15cb48bcf93d4071b59c6ce45c5f599ee48d1b3ab59c73f9d1238a6465061ae15f2ad626df7f7d13426d5ed44643314d7020c14c18da494686582b37c69c38d2513850f1bd14d55f465c72e511175c1ed5cfe48d418d29966efbe6a0745813ed702de9b8bfc0cb163d4a0fc0a6b9244748d5920abf7b8efed8f7f73f5a06c0d35d0075ec2fe4f3ff2616a6a7f82817debf11b28bd6817adeaae89e8c06d82c1878f4a403d34d295f52b49096184406afb887982bc2db19bc88ee4063089423a27d3ef297d2201c9c41b4746163629716bea59e31491b99ada3e39a2f999a662aed6189a53c51008cdfe97da0fd1fbcb78f8e0c2cd861e2b82461115a17f60be1cc491960143cf21a28d3cc96c63ec25508eaa31e90f5252d7a9a9a7e8e08754004d741c378126750394b6994ac47b0669e9b75480c727e72d314cadae1594ff5abfcb78a8141f4de7a0a317fb4ff4697aac69896700a73368874b3a1ee2184b96ab03269271ac5ec228b199f0980d078434c748fcb8357b3f84c25ac88e59bef50215b03d328ea1e401289239c9bf7c7ef74582608fe720ec67a6e694be7dddd0866838ce688222400b0f9acf31b39f3de334cb59f7ba70bf28203b75250c553cd0d615e4bd9e324f4c90b58cba751fcf2259ea21b23a8a5a4e2b5695f9ce79f667d0e11dae2a124f06488bacaae616e732565366796ec1d1a8bc1bd0d3dee36a08511a835b0d272ffbce4607e4b1358b4ec6bb1895860931a24743ae5a18a5cc063b7115a1749f3ca8c4c622530ab08b6ec6bd98c26ef51f2d1943a611f8c549b7057feb681d6069c5d0556c9f5e0d554e1365b39356d24ef68c784e56d9535131f15f7afc11d2efb7d218ab2fbb82bab7fb96e642f51c73f848af6cb4098fa40cc705c6bfecb3c87b8ea41510fcaf50a902c1ea0b997d9e75e2cec33b2decd8ca9ecbf6e8030a99f63c5965c70fe2800f53e0aa0b3d45ba2df6013a7ed69106d3c21bc921e097d58fa1a869c869cea2d214f3976f57cab3d0766d358b543e4243469deba296fe9eab2ba3bd60e472ee4a635b5949bce778c46633e3decad34fab370042cdbd797fbca7b45ba9881051711a0588579055d77d891c4fbb14e21c4e7d75cf4521b9f3a977cb63e170b7f7752fa0284ba25e3745c04233a9497f76421574747406ea2a2794ec2780a949c8e4e73a56c8b1482b87bb710135e0c73569fdb19fd2c131de5f3676ada3205f71d89bb3d7b5cd9b8ad1a4f197ee2b7a63a01fefc6a3cbf35b859543e2fd872c751a409086d83d53435fb78cdb1738de5b34ece44a9089f708324b68dffb3afad262f08c08c843c62c54c5f1bbf87aaf44b21eb752a9550fa97f467d0b89965af70c6f8be7346442b002e18c47feaf959b7861d481c6d6e814ac7918a3bc59c2b7b80d1140f3bca362cbc7473440953d2e3a7afdfd9029934cf42652ee36fa728c4129de743159ac8463014d4454cf7c2970112f85494b309af01ec5ad7a38b8384c7f6b221c99212317273d7a54cc3f819a2a3691498a8f2648604f00cff0d53fa29bacd030d2fb9604cfecee23a81c71f21be7eab866ea8fa6d597ca812c5fb314599825d4f65a5c9a91bcc09440d1bc6bbee805ba80fa9401ee6747a57a59e0776c415336a5589eb5fc357c3c7591321e682bf12c4ca0b23d50b9d36d88668602a0eef5b919c40eed23558920b4af29f5c5df0836b66caabd2d9d1b045c87409adc17198df4b9605de8d544abe77437ed8c8b837df481c88206db3a647a8b6301348af2d833ae06bce398e76c39d8b01ca25321039f40dc3f96edd17b842e5bd9b44f6992038316e759a178b438d7135beb4a1f51c8ceb16f9085ae239820def2e7f53388a147064a02dc06326fca1c9e22a6089d73863b67716ff7361f591ee548b42466f4af4256c7a475cf7215b7e19c039409b4316834f4f1b6fb7afe13c269bebab2e5403650904cb26a54b965dabc2398baf715023ac0a54b41aa66c65d26678407bc9ddcdc0142051b1a458a19954bea74873f6b7e0ec29798eea907c4cca36b23739b3a4e70a9efbf3e33a7b63fcee77a9f0bcdd12ffb9dadd46d2a12619d9a62cf9e1c9db94f373f13469c0e61e4dbdae477d5abbee0cde8c38e6c025cb791f7c02e26514b08c11cf396f1477ff7368d90e64618fa6d6e36980affec9725c69ca361a2bd8d28c90e4ee1f961cfce17eed2d1afe6294eefa55c15ba4601c9f3c397b12f7b8a68941827110cacae7c581fe1be1f6ca19a68c032356f548af7e8cc6f831e0168d02bf1ce8eac2d5cc372f6fa618375298454928b0cd93aad3011fc63fe75b706c92cb3a0ea49b5b6b0aa2d6da35ed525f93db97972c9c88740ca62fc6c5c3b665184431f8b0b0d9537144eeff560e9e947e10b8903e4a3eccdfdb13730b947e3a666ad0897e9bbc122830e36c53340c3652267b1ce68496b4b2fcf34036e89252faba883148205dcd214d812d46dceddd571ef6144ddf33647093b8b5359c5de17c9e7206b62e927ed0b7a613fca000aec0074aeac47b467114188cb62463f73b9be2ca003e05d1f524da299397b83be2a39adb05035bec617db103cb0e5767db837488975fa94e5ad2a8dc3533b0801fe2ddcc920bf6449b64cf785c5eed76ccf70116140d13abe3ee7dbb7ea64cb0e40c143b42bd7273490e1dedc48d1b19f3fc0e76813273c50215aa15189d8d668292cfc91ac497e7ec3f8a81efd9d60b046ca25841ff3f9d7b9c99c2016333811e92fe058b41e2e40c237d061539bf14c2b6b8f69cff95e841820a2a1698c1c9db35d1fae104fd221fce515c73c59cfffe6ab85b99b7b3857b56ae4365c271b335bdf0985f9f094c0a62398b6514018d67dd2460b3c909d2ffd84794a2d480a6ee283a4d4a9bacf98eb088a0c349825c932426054fe191133fde1545967eafb3d8eb2e39d35651fa2b3a71e3524e202d252097b17e692895060650efb260365df809ce23230927d93336ddb5aa0ea12ba38488bbfe230ca550421996df7f9b2a81b44ef17a7451ef908feb389531917f354ab1643e9d94bdad7ebe927a29b213de9f28eba6470e62d8dd545f68aed374e26830eff358aba6b9fb330e2c11732cfa4ff4e14d9e7af11267c899e09a37931e6082cfee1c2e520d7822dd8cd0ae5731dfcf92c8ab7f31c276896fb34b6c926eb5c67a5adfc3851fe77541ef6705fea5a4d896679678376c1f81492af693c7a1fa66dbae784868e15680352bee34675d2b8f35dc4b0ce2ff9001218bbabe826913a8bb7947cdc4b16d2304420ad08fcf7db932615c4666e7f55e12aea8a6afccece2d1d16e465c01ee429358b470b8f91865525487817090b33b4bf822dc16cae0af10e6088d0eb5a4ae38e4f78812c8551052783bee7d37e2099a6152baffbe5fe17d4d465eaedaf0b595e6ee7b212106226415e047778c88e68e92dafda182dc853af31bf6922398d60e169e3f6685e769a24283ba6f24577a27a5469b23f19baf1a7876c83b9dd4799937fa20c4b85d9cfbca28fe41c17f07a3d82fdf0cd5627812ca2145febc441a3296cec305415f1641205559b365a17be7e28e55a8916520d32a2d1ceeb7202de5a245bf049735fd924b13e44e1216319f4b50b76737bbc4505729f86af2fe7f1b93840d75d84a07b4abb8a55f48d0be75f0bb42176c88dabfc1cef716d2a79eeeeafab6027e823f12ba398e9938f586c7f2e941021eeebfbf99c29bd5fbf3bbda6121d3607e0b73c7b08fcfbc0a7a10cb68d11f37cadc3517d8a8fee3c2dc1ef6658edeb25caa7fd136975948ceefd793844b9d0e8c83a829eb0d9efcc5701a3b2d04b080cc52bdfed270f1af775ba16af06efcaf7881e859ff7c09eab712d542b6d4f83130449448c5a511d78266007ea99f8841d949c1887c648f77e4e347b5007f977770967338eff17397d6bacbf71eba5406f602232503a527dd58406626433d801cad7530c1ebc923c239b64c7849c88b7202ce72349209775c54bb86689f87bb4a5f02c7211155a67cd95f84398fd6701caacc9307216b3a3bf83483dd7b2600114acf5ff87369cbef4d79df807d22a3d2814e697b174eff646d7e106e37ab4840690568ca330fa36cc48e5546c7f527f723bcaa568fa69dde230e2a140c01626630539e73ef5830f75a3e517ef57dee75f937494fe047dfcb19b75580f014a9e441dc4697c693f7924d83dcae49f72e3032b45e53d83cb48e092e7ba8e9f7b827b2e9602a4180e52b683d9439648e1cdfa94bef906ca56270cb9d8f7f2c824ec3bf242dffbb2a946e53367c0c9e42102e2793f19ea4f8e4bd4981ebe924065c38b2312a4702159848e49d21cab1e8f2b084551b3f1770c82a36a18dd95cf0b8adcd6adf2adfd763720982e724bb449c374db23b516e38db9693a730a2edac78f64a2f97251c1020594b56e46dac47416f26d46afb50e6d0d746bd2a33751e5ff6c5501bdc63f112a87fabdfcceca005d209666a95b17f68820ee54523d338435d798757b3b39ad3807f45e71a0dd3f6e021866bbe49b8d238de91700814564c7293b739721cc9a4bf2410fc1502b268b39055c8f914d5892827f3160ff3e7fe0913e5aa0cb74c48f1234e18b0a09fdb3cab21782175b5a987f77d797dbe59652968b1f78da4247c80caf31544002f8ff4a93aeceef99a67a67f3e9db9d3dd10d2accee07b28a1883fd4970695dcd045261706bd994d8aa0420922e00b5f2ea29e729451edc52da26d9e533691b142e46df56b483601c1d1acfb04dc0c4a8aacee914f6fb2759953339acb9826912cfe52d688a8a599ee6cec8f20d91a0b9c4cf7bc3f45c7a7c914526e696c0e960eca239b9676dbf631f73352f3af7962597b643bab1b6be89c81ab3f29aeebe5b5c85d30dce4abce6b39e5fd12a6b8117e65a38f2851f2273dde48402673099f0a2f505fd6b719d1cbf5bd394945b6caf30bc529c13bc96131f0e65d4897c5f12a3299f8d6e1469b03e3e173f964066222e0f8d633916513d4464726809b043a77f655e4a29d83b32468275508077ee90b27a0197aed3b6ba36daf66f6257f8bfeac57bece7cac8f583d2d5cbd360ee663ae7bedd46b3fd03062a7cc96ff63da16499060a56b325858f4ae9b0ee66b45c8f815d374280973bee00413fc2c6753f91405f10411825391bfd58c103c020c8f7f101e130a6b9bae69884a8a94efc04c89a0842d3b5742046c3baa275acd0966da6c4cc621df89ec8966beccbee9d3d0913e24168ed661096bad5e98b7f169e98d887c431caf5becde1472522d94214afc4e37f9cb37073233dd8f3f9354987a854f491ff51fd71449e26bd74d2836000940aa5f39ca00b5159b6a20e970fc4f9f2d56d2b88e8f4812f1d1cd4b0e1f84afd90a0805348922ba9aad147ff3bd1d413a6476f24e35c2e1bc235724ac4107f2cca91a65af4cb0cf69a16078dc5fe0339cbe29445f34d3d9ea52f7d01fd3278ee2f3814efee94961476c068d1e7cdb5e50aa6b79fc23170ff51ab39b249b133d5f5439dadb8154bd876183e06f41bbd3733b6d19a038bc68d5eef1d82a66c84e85eb0cade0f6e2bf0953a22ba04f255c23b88b952d116e745ad124fd93ab33a8ee8855559ffd4dc4a93d4fed657466733ec4d0ca5da517c635e6acaf4f84067ceb9650ec940f6a8833ebcb1a656f42aad92a1ef5c491de40dc9aa022bab63997b14213929b8cbd7097129d88dce351a0d0dec8f677682f85d8ffe4d79f522084fad486e2168094991ed38c2f048de93070154c8ff0e5202c05ee0ee62bcdd6dcdbc67343067d6033f1e04605a21abb7cfe931e828bdb71be3ab0aa588eaa3af68a7e81088d40a7cfe5d8660ee1ec2ec2c302069319866f98b47172534d66a7229c6ce7295342b6c78d2de7118ec3494b693a93596d671d4ab803a5b9eb290990a7b74f15720fc331933e503db9185ff68f374cdf93faa9a7fc7c027c3db0c0619753a1246c24687ec40ee80bbcfb24e986a5ec2413960735fb4e8af65b14d4f3b0a28b7dec3f0574aa200e0859c63df1c5535016eeb55262734794ba4997b8371c1de52f0d0b144723b6eb8784c11e9dc12f66c33512f66d25f03505c419c9f5221972648c203fcbc505df7262b69159bc498ac1a3c6a66f997a37c9055d4b8de74898c8e951aebb0f0862ccb166da86a448c15873e9231f321ceeb52f512ee1b66071ab52fb5f1ea29fd1dc336f5eb2ad21e77456d8ad35f31b946da9dc7fc96e1523a5f9a95e7b8116c8310c62d68bc200724170d3d904a0aa58b107f7be5896efdfa461de17460707cda35a2b053af5c73a01e17e65560bc7dc8769d4ce8b8a5a482d2dbff95028140ef315f07600baf2232dfe5e533568cf9bd5662537c114835e8e1302a9293a4e49bc9ae05390cace14c7122ef21eccdec1cf06d347c2886eb3c85b10f92403f0d76bcf7c24fa3159a52c048df0e9b9d162ea9ac2cab949cf9fbf12ff45d8e69fe82102a44a69c25bda8a413a11f0f750c74652e3278044eb0404593a74ca8c91b846bab6b97a1bd3815c0a7ac02315cd55bdca26c0bad4b74f7c51d3163bda2bb64550d37a3b79b6c657d745833c69555458f3aacfe0cf96065928c43048a7289ae127927ad52c8e800ab800f72d6ff4e92ccbb83fc85bbf83913bdddc353ff758ac56e1381a73fd6d86602e4816da92b0d04f3b3d850023f58c0457eb71db9451176b549f337f01eaac9e808ae53254a54b227b63f4c6172f6f271bc215f4c1d72f0305d2f4c6f0c3b7baedab30d1eed9cdba3703ab82a7011cb62d92e612740b1d49fd99583cb508975a2ae1b5de9c5b1ba2eef2723941cbfb4e8846c8435fd8886d8095104ef68309eac51e916a0106e19036bbc5c17d91debfa79b1438802aafc4d168d32d3beeea32e0e1d968792aa44d92632fd1e299a0c7cd244f0fff2d9a83cd96479470a4162deb9af4c81aa41864a5c271207e7d321e882eee0ff971aaef7aa56796855ea8a5d3bb853c4d9d7697c5dcd9c66d02ccdb2fa3ad65e129707532a6aed2ffe62e6cfd8da3f190b2aacab6abd8c335cad0999b68c317b5fbbc72841eb8ee0639abc7a1aca7ab9c52cf2054bd9f7a91aeb316f49e297a4374420a6b84a51a34d1a8f289eaf55cf4c12eabac602a7dd2f68262d1d7316642bad77f725d5be8c6fb0e20fa4b4d8bc149f1fa513cd2c60eb803e60ff7db12d53f52f181215e5991bb651a868c30abc5ea025621dd16fdb580859d8ca0e96d39963808e997b8b6f91f77b66b228a2de8c8aa1e75640c0dde0ed35d1648aecdb9cdde13b321cdf8d25ff97e188dfe84e8650e5c501427c2bc5354c6235dca148abe483caa8ce1e38b63fb237ca81018b0dd1decc8686212665f0b4c82d93457ea8246a4094e2ccbdc46ea1eeb93eebeff06d3775a3736e73f6eaf00331015e1c88c22495b3163ffac26942e515db4f7c4f3809c7eef9b8c1f6318b7fe2cdcb69eed4b38d3303b4bef9cd7d2f859f42cf6284b4ec51a89cc9cfdd907d55b4d2239249ba6ca0f521493b53db4cad1e612ba68da08b310b7bb338dcc96bf1f519dd7430b82fca0790c7406f13df98df64ab4c1eeb696c2e520072b77f4f634a8c8da05e38bdedfe01cf9d55c9e4267cd9a5bd7f1c4adc97d7fcae9d1b060b6acedee80ce17e89a7b23e1acdcd0c1bd22d9fc3ef59e029f2abb7a447ce90aecd05ba64c25c379202a5f66eef94c8f54047dfc4cce74e731eb34538e722bcbd9ae15abe8e2f2bd9e22e63ad6540ceca90f023c2b078022f5151f5f1748696df8bab1dc6bf3f0f168bca70b6a333669fbc1180909bcc2c692a046a0b6225b2f350c7397adc1b65ecf15c81df1b6dcb90784d50c21573105fab492f2edffb1b1105b4215e322e065405e49f580c194cf366bab776b8814d8d5473f8b73f4fc84f719ae4306a35591253eab2b4b9d4f4e6ec9c24d4ce1a0aeaaa4223c6963ab8c76eb3fedd23fb0d84e604865d0b2a2f7cb85f42462321bf9d75afcb7fceb4eb98c7a6327cbf5538531369b899051a0e56548630e1d0ab330fa8b9c2a256404998ea3d90355410a884e71278d4bc789e9f8bd20b742f81581c28366c68e34f83253e9b015212614f045e89bf69765147d4d0dd2fc07ca3e3d3b213a5988321794c248391c4537fef8e69c350737e2f5abdab6ed05e10ddd5e92f169dea164ebf7e3053f909ce7aef3a2019282d4207d2651ae230d087a3c24d3b568198614b6daaa2de7282fb6df36db3fe8fc3ea20e02b27e98e5e63d901a69a6f1fbec96f4d893cac649d069814caaf3f2d00b8a08a11402836549ae4009c3f348814b9514efab85ae244528a04e76be05ac54701b347d62432031188447f96f3422627f9b7311d28c83977b42be4c474b5016371268a214dd5ce344df01950ef68b9f8bce5d57443937007d0de385a9cdb2420d642d0ba862fb56d34f00593b2f518c577e8e02c3ce6940e79ae4e3dbcbde2d55cd63a7939c01e604591e3bf65616e3003c0174ba5f335bd02016a31cd3c0d11dcaa4aee32818f142c5f77f7002223cb3c2d7e4c5811540b95c8ade047a46f21412badc33f22e651731bc5d4421b5102cc8e60393347475ebc5cf8c26efc70adbd91561ba27a3d7579461deb08d62ae22fb03d0e151c5c94b5f8cfd7b91a8cc7247a9a863950daef16fde0fde988c604f82213b4f6d23b5dc86e00a297d81cc9634f4280640b522961e00db4d8e385eb911ae2a3845e6f33337929ab853a06637af55b14bf16dd14935a6cb43db664bb459e23ef2c6b40ddd990dcdb8771598b4f2148e2da053bc349303721b72025c4ea4f34b692619a95a38692ab0acfe13b58bc0b226c3febfec0504de9f9d7ec70bb6d117c0f8f0e4ab2bed8b1dbcafe270cc272f4133c6ce08f62ce95b24176775156eec4b27aceabb674676d6a85d273f5c7f6b21f368a7fd8e127c96654f2a54af32080375d3c2e998e52d7258e1f4b53bf0ca804663e5901d432749b5710558e4aab51075dc2fca5195634aa2717a5784fca97a6c9c1b7dee215a79f2554c947126a5f3fe925d51c0080f6163b35028450db9f70d27ca9fa9835dce7721abce5a5cfe05c763be270aabda42700605c4b88bc6a8ad5882192ffe4ca70b352cc47b1c5945b50aaba7eece946d606ba08e74aa28f588886ba872ebef5ebd11a386e5971e1993258895327bb6af00f4937bdeee96db52811a3ae80c83b992d7d8b41df667c0d03ed679d39d62825b6c775029b0af33fa2cdc56c17b516c7aa43fb568cf4db9b2b060479d9a0c32ff77fd8ea849d6e7ea90207045a42005bed605f00e50c9fa816af3ed66ba0023f70a42b5a595b4adcb7cfc95f18c632d20395d620e5b8247b66f1728b0c12f76640599531b00d3022237dc28b73e1af2fc0d2e480e442aba8e18debeec5efe49b681bbe37ec623cbfe98b3bfebfeb6e8d158540fb6b51bff39a946ed51e43fe59aafa0ba251fc36b87cd28f136e0ed3351a3e960eb66e9182f37b68764471b8a5ea89c9b57250e822de3e31ddd4f47817c12c43b8959ce2cd592a960aa0c605fdc90a7aa9bcd36b729f23d2837cbd65c1d0973b7bba2ddf7d1cea26e5c2409de31410d6694a7146ea3decec1dab2b5da0f5896cfde6909e963da5a98e978a87cdafc2e40b192c62e412eb09456ffc9901b90f405b38343433ac108b2ac00c93890c28f11099f007a3f09e1825a1f3390db2ac7ef98a84627907b3b5608726f36c331615ecd8820b636b735f6184494fccff28517066aecf3d860c874dacf342d9465033f8992d677d3df96bcf65f636f8732b5c893776cff56c0dcbea41c8ddc90310b21e9279b3426664012ab1fc10b540a2b2b4f03796ea255a5a59feea75ce193fc14ff26964b7f64b55d6608612536dc754480cb442463296427e5a6c5cbf310dd25afdde53f6cb575d6a95596bf0cd816d0eb30abf3c699ff8cd605aa09bc6c7122054af7b92b68560e132d6ff154006fd4e0a5db7cddd83c947c6fbbd86d525c201ac4e1bb2c20c4b4c6d2c01bc92ddca593a618991cab8a999</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>《Lecture on Modules and Rings》读书笔记</title>
    <url>/LectureOnModuleAndRing/</url>
    <content><![CDATA[<p>为了把看过的知识变成自己的东西，在此理一下思路（导师建议学的东西记录一下，不然以后过不了多久又忘了，花了时间就要有收获）</p>
<a id="more"></a>
<h2 id="自由模"><a href="#自由模" class="headerlink" title="自由模"></a>自由模</h2><p>给定一个环 $R$，其上(右)自由模</p>
<script type="math/tex; mode=display">
F_R = R^{(I)} = \bigoplus_{i \in I} R_i, \quad R_i = R</script><p>有两种等价刻画：</p>
<ol>
<li><p>$F_R$ 有一组基 $\lbrace e_i : i \in I \rbrace \subset F$ 使得 $F_R$ 上任意元素都可以唯一的写成 $e_i$ 的 $R$-线性组合</p>
</li>
<li><p>$F_R$ 有一组基 $\lbrace e_i : i \in I \rbrace \subset F$ 满足“universal property”: 对 $M_R$ 中任意 $\lbrace m_i : i \in I \rbrace$ 有唯一的 $R$ 模同态 $f: R_R \to M_R$ 使得 $f(e_i) = m_i ,i \in I$</p>
<blockquote>
<p>$R^I$ 表示 $R$ 的 $I$ 次积, 当指标集 $I$ 有限时, 积与直和(余积)等价,此时 $R^{(I)}$ 通常写成 $R^n$</p>
</blockquote>
</li>
</ol>
<h3 id="IBN-Invariant-Basis-Number-性质"><a href="#IBN-Invariant-Basis-Number-性质" class="headerlink" title="IBN (Invariant Basis Number) 性质"></a>IBN (Invariant Basis Number) 性质</h3><p><strong>Generation Lemma</strong> 表明，对任意模，若 ${e_i : i \in I}$ 是其一族极小生成集，且 $I$ 是无限集，则 $M$ 不能由基数小于 $I$ 的集合生成。</p>
<p>由 <strong>Generation Lemma</strong> 可知，若 $R^{(I)} = R^{(J)}$,且 $I$ 无限，那么 $|I| = |J|$，但是当 $I$ 有限时，结论并不一定成立，例如 $R = End(_kV)$,其中 $V$ 为可数无穷维空间，则 $R \simeq R^2$. 因此提出 <strong>IBN​</strong> 的概念：</p>
<p><strong>IBN (Invariant Basis Number)</strong> 称环 $R$ 满足 <strong>IBN</strong> 性质，如果对任意</p>
<script type="math/tex; mode=display">
m,n \in \mathbb{N}, R^m \simeq R^n \Longrightarrow m=n</script><p>由定义不难看出，$R$ 不满足 IBN 性质，当且仅当, 存在 $R$ 上 $m×n$ 矩阵 $A$ 和 $n×m$ 矩阵 $B$ 使得</p>
<script type="math/tex; mode=display">
AB = I_n, BA =I_m</script><p>因此 IBN 性质是对称概念.</p>
<blockquote>
<p>由 IBN 上述等价定义知 $f: R \to S \neq 0$ 为环同态，则 $S$ 满足 IBN 性质可推出 $R$ 满足 IBN 性质。</p>
</blockquote>
<p>由上面的结论又可以给出很多满足 IBN 性质的例子：<br>Divison rings, local rings, semilocal rings, nonzero commutative rings, finite rings.</p>
<h3 id="stably-finiteness"><a href="#stably-finiteness" class="headerlink" title="stably finiteness"></a>stably finiteness</h3><p>称环 $R$ 为 stably finite，如果对任意 $n$</p>
<script type="math/tex; mode=display">
R^n \simeq R^n \oplus N \Longrightarrow N=0</script><p>等价定义: </p>
<ol>
<li>对任意 $n$, $R^n$ 是 hopfian</li>
<li>对任意 $n$, $M_n(R)$ 是 Dedekind-finite 的.</li>
</ol>
<p>由 2 可知 stably finite 是对称概念.</p>
<blockquote>
<p>由 $Mn(R)$ Dedekind-finite 可知:<br>若 $g:R→S$ 是嵌入(单射)同态(不要求幺元映成幺元), 那么若$S$  stable finite, 则 $R$ 也是.</p>
</blockquote>
<p>由上可知:</p>
<script type="math/tex; mode=display">
\prod _{i \in I} R _i \quad \text{ stably finite } \iff R _i \quad \text{ stably finite for all } i</script><p><strong>例子</strong>: Commutative Rings, Noetherian Rings</p>
<p><strong>性质</strong>:<br>若环 $R$ 不是 stably finite, 我们可以做一个最大的商环 $\bar{R}$ 使得 $\bar{R}$ stably finite.<br>$\bar{R}$可以如下构造, 并可以说明它确实 stably finite.<br>设 $T$ 为所有形式 $I-YX$ ( 方阵$X$,$Y$满足$XY = I$的中元素生成的理想。可以证明: $\bar{R} = R/T$</p>
<p>自然地, 我们要问啥时候 $\bar{R} = 0$? 这当且仅当存在 $C,D \in M_m(R)$,行向量$x$,列向量$y$ 使得</p>
<script type="math/tex; mode=display">
x(I-DC)y = 1</script><h3 id="rank-condition"><a href="#rank-condition" class="headerlink" title="rank condition"></a>rank condition</h3><p>称环 $R$ 满足 rank condition, 如果对任意 $n$, $R_n$ 中生成元的个数都大于$n$.<br>等价定义 1: 任意满同态 $f: R^m \to R^n$可推出 $m \geq n$.<br>等价定义 2: 环 $R$ 不满足 rank condition, 当且仅当, 存在 $n&gt;k \geq 1$, 那么存在 $n \times k$ 矩阵 $A$ 和 $k×n$ 矩阵 $B$使得$AB=I_n$</p>
<blockquote>
<p>由上面等价定义 2 知道 rank condition 是个对称的概念.</p>
</blockquote>
<p>若有环同态 $f:R→S$, 其中 $S$ 满足 rank condition, 那么 $R$ 也满足.</p>
<p>rank condition 与 stably finite 以及 IBN 之间的关系 $R \neq 0$:</p>
<script type="math/tex; mode=display">
\text{stably finite} \Longrightarrow \text{rank condition} \Longrightarrow \text{IBN}</script><p>套用一下定义,以及它们各自的等价定义,逆反命题就可以证明.</p>
<blockquote>
<p>stably finite 与 rank conditon 的密切联系</p>
</blockquote>
<p>对任意环 $R$, 下面结果等价:</p>
<ol>
<li>$R$ 满足 rank condition</li>
<li>$\bar{R} \neq 0$</li>
<li>$R$ 有一个非零 stably finite 的同态像 </li>
<li>对任意 $n \in \mathbb{N}, \quad C,D \in M_n(R)$，若 $CD=I_n$, 则对任意行向量 $x$ 和列向量 $y$, $x(I-DC)y \neq 1$</li>
</ol>
<p>这里难点在于 1 推出 4, 可以用反证法, 用增广矩阵得到</p>
<script type="math/tex; mode=display">
\begin{pmatrix} C \\ x(I-DC) \end{pmatrix} \left(D ,(I-DC)y \right) = \begin{pmatrix} CD & 0 \\ 0 & x(I-DC) \end{pmatrix} = I_{m+1}</script><blockquote>
<p>在 simple ring 中 stably finite 等价于 rank condition</p>
</blockquote>
<h3 id="strong-rank-condition"><a href="#strong-rank-condition" class="headerlink" title="strong rank condition"></a>strong rank condition</h3><p>称环 $R$ 满足 right strong rank condition, 如果对任意$n$, $R^n$ 中任意线性相关的元素个数不超过 $n$.<br>等价定义 1: 任意单同态 $f: R^m \to R^n$ 可推出 $m \leq n$<br>等价定义 2: 任意 $m$个未定元 $n &lt; m$ 个方程的线性方程组在 $R$ 中必有非零解.(用线性相关的定义可知)</p>
<blockquote>
<p>实际上 strong rank condition 不是对称概念, 所以严格上, 我们要指出 left, right.</p>
</blockquote>
<p>由 (strong) rank condition 的等价定义可知:</p>
<blockquote>
<p>由于 $R^n$ 是自由$R$- 模,因此,可以推出 right strong rank condition 可推出 rank condition.</p>
</blockquote>
<p><strong>注意</strong> right strong rank condition 不像之前的满足 $f: R \to S$, 满足”性质”, 则 $R$ 满足”性质”.</p>
<p>$A \times B$ 满足 (right) strong rank condition (RSRC) 当且仅当 $A$ 或者 $B$ 满足 RSRC </p>
<p>由上面性质知道, stably finite 和 strong rank condition 是两个独立的概念, 彼此不搭嘎. 例如: </p>
<ol>
<li>$R = \mathbb{Q}<x, y>$ 是 stably finite, 但不满足 RSRC.</li>
<li>而由上面性质知道, 我们只要构造一个满足 RSRC 和一个不满足 stably finite 的积即可.</li>
</ol>
<p>满足 RSRC 的例子:<br>Noetherian rings, Commutative Rings.</p>
<blockquote>
<p>最后给出一个线性无关的等价定义:</p>
</blockquote>
<p>$u_1,\cdots,u_m$ 在 $M = R^n$ 中线性无关, 当且仅当</p>
<script type="math/tex; mode=display">
0 \neq u_1 \wedge \cdots \wedge u_m \in \bigwedge ^m (M)</script><h3 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h3><p>自由模下的关系(任意箭头一般都不可逆):</p>
<p><img src= "/img/loading.gif" data-lazy-src="MRing1.png" alt="MRing1"></p>
<p>一般地, Dedekind finite + Rank condition 依然无法推出 stably finite. 例如:</p>
<p>设 $R$ 为由元素$s,t,u,v;w,x,y,z$ 生成的 $k$ 代数,设 $A = \begin{pmatrix} s &amp; u \\ t &amp; v \end{pmatrix}, B = \begin{pmatrix} x &amp; y \\ z &amp; w \end{pmatrix}$ ,其中生成元满足关系: </p>
<script type="math/tex; mode=display">
AB=I_2</script><p>由此可知, $R$ 是 domain, 但是一般地, $BA \neq I_2$ 因此 $M2(R)$ 不是 Dedekind finite 的. 因此 $R$不满足 stably finite 条件.<br>定义 $f: R \to k$ 为 $f(s)=f(v) = f(x) = f(w) = f(1) = 1$, $f(u) = f(t) = f(y) = f(z) = 0$. 因此由 $k$ 满足 rank condition, so is $R$.</p>
<h2 id="投射模"><a href="#投射模" class="headerlink" title="投射模"></a>投射模</h2><h3 id="投射模的定义"><a href="#投射模的定义" class="headerlink" title="投射模的定义"></a>投射模的定义</h3><p>称一个右 $R$-模 $P$ 为 projective module（投射模）,如果<br>对任意 $R$ 模满同态 $g:B\to C$ 和任意 $R$ 模同态 $h:P\to C$,存在 $R$ 模同态 $h’: P \to B$ 使得 $h = gh’$</p>
<blockquote>
<p>由定义显然自由模都是投射模.</p>
</blockquote>
<p>等价定义: 从右模范畴到 Abel 范畴 $\hom(P,-)$ 的函子是 exact functor(正合函子).<br>由定价定义易知:</p>
<script type="math/tex; mode=display">
\bigoplus_{i \in I} P_i \text{ 投射当且仅当 } P_i, i\in I \text{ 投射 }</script><p>由之前说明的自由模都是投射模可知以下条件等价</p>
<ol>
<li>$P_R$ 投射</li>
<li>$P_R$ 是某个自由 $R$ 模的直和因子</li>
<li>任意满同态 $B_R\to P_R$ 可裂</li>
</ol>
<p>由此可知:(Eilenberg’s Trick) 若 $P_R$ 投射,则存在自由模 $F_R$ 使得 $P \oplus F \simeq F$</p>
<blockquote>
<p>Proof: 由 $P_R$ 投射模,所以存在 $Q_R$ 使得 $P \oplus F \simeq F$ 为自由模, 取 $F$ 为 $E$ 的可数直和即可.</p>
</blockquote>
<p>不是投射 $\mathbb{Z}$ 模的例子:</p>
<script type="math/tex; mode=display">
\mathbb{Z} / 2 \mathbb{Z}, \quad M = \mathbb{Z} \times \mathbb{Z} \times \cdots</script><p>一个有趣的结果:<br>设 $P = \mathbb{Z} \oplus \mathbb{Z} \oplus \cdots \subset M$, 则 $\hom_{\mathbb{Z}}(M/P,\mathbb{Z}) = 0$<br>证明关键点在于 $M = A_2 + A_3$, 其中 $A_k = \lbrace (k a_1,k^2 a_2,\cdots,k^n a_n,\cdots): a_i \in \mathbb{Z} \rbrace$,<br>然后说明 $A_k\in P$, 且 $f(M)=f(A_2)+f(A_3) \subset f(P)$ 即可.    </p>
<h3 id="Dual-Basis-对偶基"><a href="#Dual-Basis-对偶基" class="headerlink" title="Dual Basis(对偶基)"></a>Dual Basis(对偶基)</h3><p>$P_R$ 是投射模, 当且仅当它有对偶基, 即存在一族元素 $\lbrace a_i: i\in I \rbrace \subset P$ 和线性函数 $\lbrace f_i: i \in I \rbrace \subset P^{\star} = \hom(P,R)$ 使得对任意 $a \in P$, 只有有限个 $f(a_i)$ 非零, 且 $a = \sum a_i f_i (a)$.</p>
<p>对任意 $R$-模 $M_R$, $M^{\star} = \hom(M,R)$ 是左 $R$-模, $M^{\star \star} = \hom(M^{\star} ,R)$ 是右 $R$-模, 我们有自然的右模同态, $\epsilon : M \to M^{\star \star}$ 定义为: $\epsilon(a) = \hat{a}$, 其中 $\hat{a} (f) = f(a)$ 为求值函数.</p>
<blockquote>
<p>特别地, 当 $M_R$ 是投射的, $\epsilon$ 是单同态, $M_R$ 是有限生成投射时, $\epsilon$为同构.</p>
</blockquote>
<p>例: $e \in R$ 为幂等元, 则 $R = eR \oplus (1-e)R$, 所以, $P = eR$ 为有限生成投射模.</p>
<h3 id="Invertible-Modules-and-Fractional-Ideals-可逆模-可逆理想"><a href="#Invertible-Modules-and-Fractional-Ideals-可逆模-可逆理想" class="headerlink" title="Invertible Modules and Fractional Ideals(可逆模,可逆理想)"></a>Invertible Modules and Fractional Ideals(可逆模,可逆理想)</h3><blockquote>
<p>此小节中默认 $R$ 为交换环</p>
</blockquote>
<p>很大一类的交换环上的投射模是由环扩张 $S \supset R$ 得到的.<br>现在, 给定(交换)环扩张 $S \supset R$. 考虑模 $S$ 的 $R$-子模, 设 $P,Q$ 为模 $S$ 的 $R$-子模, 定义:</p>
<script type="math/tex; mode=display">
PQ = \lbrace \sum p_i q_i : p_i \in P, q_i \in Q \rbrace, \quad Q:P = \lbrace s \in S: sP \in Q \rbrace,\quad P^{-1} = \lbrace s \in S : sP \subset R \rbrace = R:P</script><p>注意到 $P^{-1}$ 依赖于环扩张 $S$ 的选取.</p>
<p>由上面定义,我们立即有下面引理(条件 <code>1,2</code> 等价):</p>
<ol>
<li>存在 $S$ 的 $R$-子模 $Q$ 使得 $PQ = R$</li>
<li>$PP^{-1} = R$</li>
</ol>
<p>由于上述定价,我们把满足条件的 $P$ 称为 <strong>Invertible  $R$-submodule</strong> of $S$<br>在此条件下,我们有:</p>
<ol>
<li>$P$ 是有限生成投射 $R$-模 (利用 $\sum p_i q_i = 1$)</li>
<li>任意 $R$-子模 $M \in S$, 自然映射 $f: P \otimes _R M \to PM$ 是 $R$-模同构</li>
<li>$P^{\star} \simeq P^{-1}$ (因此 $P^{\star}$ 可以成 $S$ 的子模)</li>
<li>$P_R$是自由模,当且仅当存在$s \in R$使得$P = sR$(此时$s$必然是$s$中的可逆元)<blockquote>
<p>结论 4 经常用于说明一个模是投射模但不是自由模.</p>
</blockquote>
</li>
</ol>
<p>下面有一个很精彩的例子:<br>设$R \subset S$ 为交换环, $g \in S$满足 $g^2,g^3 \in R$, 即 $g^n \in R$ 对 $n&gt;1$ 成立. 定义$P_r = (1+rg, g^2)$, 那么</p>
<script type="math/tex; mode=display">
P_r P_s = (1+rg,g^2)(1+sg,g^2) = (1+(r+s)g+rsg^2,g^2+sg^3,g^2+rg^3,g^4)</script><p>显然上面集合包含 $g^2(1+(r+s)g+rsg^2)-rsg^4 = g^2 +(r+s)g^3$,<br>因此包含 $rg^3,sg^3,g^2,1+(r+s)g$, 因此</p>
<script type="math/tex; mode=display">
P_r P_s = (1+(r+s)g,g^2,rg^3,sg^3)</script><p>再由 $g^3(1+(r+s)g) - (r+s)g^2g^2 = g^3$ 可知: </p>
<script type="math/tex; mode=display">
P_r P_s = (1+(r+s)g,g^2) = P_{r+s}</script><p>因此 $P_r P_{-r} = P_0 = (1, g^2) = R$, 即 $\lbrace P_r: r \in R \rbrace$ 是一族 Invertible $R$-submodule of $S$(因此投射), 且 $P^{\star} = P_r^{-1} = P_{-r}$. $P_r$ 是 $R$-free 当且仅当 $u(1+rg) \in R$ 对所有的 $u \in U(R[g])$</p>
<blockquote>
<p>之前说过 $P^{-1}$ 依赖于 $R$ 的扩张 $S$ 的选取,现在我们在 $R$ 的所有 regular element(正则元)这个乘闭子集 $C_R$ 上做局部化得到环 $K$, 那么自然映射此时是单同态, 因此局部化得到的环可以看做 $R$ 的扩张(由 $R$ 唯一决定). 且对任意 $k \in K$, 都存在 regular element $u$ 使得 $u_k \in R$.</p>
</blockquote>
<p>称 $K$ 的 $R$-子模为 <strong>fractional ideal(分次理想)</strong> 通常记为 $\mathfrak{A}$</p>
<p>引理: 对任意 fractional ideal $\mathfrak{A} \subset K$ 且 $\mathfrak{A} \cap C_R \neq \emptyset$, 则有 $\hom(\mathfrak{A}, K) \simeq K$.</p>
<p>Proof: 作映射 $\lambda : K \to \hom_R(\mathfrak{A},K)$ 为: $\lambda(k)(a) = ka$, 证明单满即可.</p>
<p>对任意 fractional ideals $\mathfrak{A},\mathfrak{B} \subset K$, 我们也有类似引理的证明: 当 $\mathfrak{A} \cap C_R \neq \emptyset$</p>
<script type="math/tex; mode=display">
\hom_ R(\mathfrak{A},\mathfrak{B}) \simeq \mathfrak{B}:\mathfrak{A}</script><blockquote>
<p>特别地, 若 $\mathfrak{A} \cap C_R \neq \emptyset$, 则 $\mathfrak{A}^{\star} = \mathfrak{A} ^{-1} = R:\mathfrak{A}$.</p>
</blockquote>
<p>对任意 fractional ideal $\mathfrak{A} \subset K$, 下面等价:</p>
<ol>
<li>$\mathfrak{A}$ 是 invertible module($\mathfrak{A} \mathfrak{A}^{-1} = R$)</li>
<li>$\mathfrak{A}$ 是投射模,且 $\mathfrak{A} \cap C_R \neq \emptyset$</li>
<li>$\mathfrak{A}$ 是有限生成投射模,且 $\mathfrak{A} \cap C_R \neq \emptyset$<blockquote>
<p>此条件下 $\mathfrak{A}$ 自由模当且仅当 存在 $s \in K$ 使得 $\mathfrak{A} = sR$(此时 $s \in U(K)$)</p>
</blockquote>
</li>
</ol>
<p>由上可知: 若 $R \neq K$, 则 $K$ 不是投射模.</p>
<p>Proof: 如果是, 那么必然有限生成投射, 因此</p>
<script type="math/tex; mode=display">
K= \sum _{i=1} ^n R c _i d _i ^{-1} (c _i \in R, d _i \in C _R)</script><p>那么 $d = d_1 \cdots d_n \subset U(K)$, 我们有 $K = dK \subset R$ 矛盾于条件.</p>
<blockquote>
<p>因此 $\mathbb{Q}_{\mathbb{Z}}$ 不是投射模.</p>
</blockquote>
<h3 id="交换环上的-Picard-Group"><a href="#交换环上的-Picard-Group" class="headerlink" title="交换环上的 Picard Group"></a>交换环上的 Picard Group</h3><p>实际上, 第二小节和第三小节中的 Invertible Module 都是”秩为 1”的有限生成投射模, 对于交换环, 秩的概念定义如下:</p>
<p>由于若 $P,Q$ 为$R$-模, $P \otimes Q$ 也是 $R$-模, 且当 $P,Q$ 投射时, $P \otimes Q$ 也是投射模.</p>
<p>当 $P$ 是有限生成投射$R$-模时, 对于 $R$ 的任意素理想 $\mathfrak{p}$, 在其上局部化得到 $P_{\mathfrak{p}} = P \bigotimes_{R} R_{\mathfrak{p}}$ 也是有限生成投射的. 由于 $R_{P}$ 交换局部环, 因此 $P_{\mathfrak{p}}$ 是自由的(交换局部环上有限生成投射模是自由模).因此就有秩, 也就是说我们有从 $R$ 的素谱到 $\mathbb{Z}$(带离散拓扑)的一个连续映射. 当这个映射是常值映射时(这要求 $R$ 中无非平凡幂等元),就称这个常值为投射模 $P$ 的秩.</p>
<blockquote>
<p>注意到若 $rk(P)=n,rk(Q)=m$ 那么 $rk(P^{\star})=n, rk(P \otimes Q) = mn$</p>
</blockquote>
<p><strong>引理</strong> 设 $R \subset S$ 为交换环, 那么在任意 $S$ 的可逆 $R$-子模都是秩为 1 的投射模.</p>
<p>Proof: 用一个 Invertible Module(可逆模)的定义, 以及成为自由模的条件, 即可证明.</p>
<p>设 $Pic(R)$ 为 $R$ 上所有秩为 1 的有限生成投射模的同构等价类. 将 $P$ 的等价类记作 $[P]$<br>我们定义乘法(满足结合律, 交换律):</p>
<script type="math/tex; mode=display">
[P][Q] = [P \otimes Q]</script><p>$[R]$ 成为 $Pic(R)$ 中的幺元, $[P]^{-1} = [P^{\star}]$.<br>即 $Pic(R)$ 关于上述乘法构成 Abelian group. 称为交换环 $R$ 的 Picard group.</p>
<blockquote>
<p>实际上 “Pic” 还是交换环范畴到 Abelian group 范畴的函子.</p>
</blockquote>
<p>具体到 $R \subset K$, $K$ 中所有 invertible fractional ideals 是 $R$ 上秩为 1 的有限生成投射模(记为 $I_{R}$) 但是一般地 $R$ 上所有秩为 1 的有限生成投射模并不一定同构与某个 invertible fractional ideal.</p>
<p><strong>定理</strong> 对自然映射$f: R \to K$, 我们有正合列</p>
<script type="math/tex; mode=display">
 1 \to U(R) \to U(R) \to I_{R} \to Pic(R) \to Pic(K)</script><h3 id="semi-Hereditary-Rings"><a href="#semi-Hereditary-Rings" class="headerlink" title="(semi)Hereditary Rings"></a>(semi)Hereditary Rings</h3><p>在交换环中, Dedekind (domain) ring 定义为交换整环 $R$, 所有理想都是 Invertible Ideal(或者说投射的). 这说明 $R$ 必然是 Noetherian domain. 因此 Dedekind ring 也可以定义为 Noetherian domain 中整闭的 Krull 维数为小于等于 1 的环, 也可以定义为满足每个理想都是一些素理想的有限积的交换整环.</p>
<p>把上述 Dedekind ring 推广到非交换的情形, 我们有如下 <strong>Hereditary ring</strong> 的定义:<br>A ring $R$ 称为右(左)Hereditary ring, 如果它的每个右(左)理想都是投射的, 如果它既为左又右,那么就成为 Hereditary ring.</p>
<p><strong>Kaplansky’s Theorem</strong> 设 $R$ 为 right Hereditary ring. 任意 $R$-自由模的子模 $P$ 都同构于 $R$ 的一些理想的直和. 特别地, $P$ 是投射的.</p>
<p>由于每个模都可以看成自由模的同态像, 投射模是某个自由模的直和因子, 又由 Kaplansky 定理知:</p>
<ol>
<li>在一个 right hereditary $R$ 上, 一个 $R$-模 $P_R$ 投射, 当且仅当它能嵌入到一个自由模中.</li>
<li>环 $R$ 投射, 当且仅当, 每个投射$R$-模的子模都是投射的.</li>
<li>若环 $R$ 是 PRID(principal right ideal domain), 那么每个自由 $R$-模的子模都是自由的.</li>
</ol>
<p>类似于 Hereditary ring 的定义, 我们称一个环 $R$ 为 <strong>semihereditary ring</strong>: </p>
<p>$R$ 称为右(左)semihereditary ring, 如果 $R$ 的每个 f.g.(finitely generate 有限生成)右(左)理想都是投射 $R$ 右(左)模. 如果既左又右, 称为 semihereditary ring.<br>我们称交换的 semihereditary ring 为 Prufer ring.</p>
<p>类似于 <strong>Kaplansky’s Theorem</strong> 我们有 $R$ 为 right semihereditary ring. 任意 $R$-自由模的有限生成子模 $P$ 都同构与有限个 $R$ 的理想的直和.</p>
<blockquote>
<p>right semihereditary 的等价刻画:</p>
</blockquote>
<p>$R$ 为 right semihereditary ring 当且仅当投射右 $R$ 模的有限生成子模都是投射的.</p>
<p>例子:</p>
<ol>
<li>Semisimple ring is hereditary.</li>
<li>PRID is right hereditary, 例如 $D[x]$, 其中 $D$ 是 division ring.</li>
<li>$M_n(R)$ is semihereditary, 其中 $R$ 为 Dedekind ring.</li>
<li>von Neumann regular ring is semihereditary.</li>
<li>$\begin{pmatrix} \mathbb{Z} &amp;  \mathbb{Q} \\ 0 &amp; \mathbb{Q} \end{pmatrix}$ 是 right hereditary, left semihereditary, but not left hereditary. Note that this example is also left artinain but not right Noetherian.</li>
</ol>
<h3 id="Hereditary-Artinian-Ring"><a href="#Hereditary-Artinian-Ring" class="headerlink" title="Hereditary Artinian Ring"></a>Hereditary Artinian Ring</h3><p>Hereditary Artinian ring 十分的重要(因为简单 0.0), 一般一个概念加上 Artinian 条件就会变得特别简单, 例如 Artinian commutative domain is field.</p>
<p>设 $J = rad R$ 为环 $R$ 的 Jacobison radical. 若 $R$ 是 Artinian ring. 以下结论等价:</p>
<ol>
<li>$R$ is right hereditary.</li>
<li>$J$ 作为右 $R$-模是投射的.</li>
<li>对任意幂等元 $e$, $eJ$ 是投射右 $R$-模.</li>
<li>$R$ 的任意极大右理想都是投射右 $R$-模.<blockquote>
<p>证明难度还是有的, 要用到任意有限生成 Artinian 模都是有限长的.</p>
</blockquote>
</li>
</ol>
<p>例子:</p>
<p>设 $R$ 是 divison ring $D$ 上的 $n \times n$ 上三角矩阵全体, 则 $R$ 是 hereditary Artinian ring.</p>
<h3 id="Trace-Ideal"><a href="#Trace-Ideal" class="headerlink" title="Trace Ideal"></a>Trace Ideal</h3><p>Definition: 对任意 $P_R$, 定义 $tr(P) = \sum im(f)$ 其中, $f$ 跑遍 $P^{\star}$. 容易看出 $T = tr(P)$ 是 $R$ 的理想, 称为 Trace Ideal. 它满足:<br>若 $P_R$ 是投射的, 则 $PT = P, T^2 = T, ann(P) = ann_r(T)$<br>特别的, 若 $P_R$ 是有限生成投射的, 那么其对偶基 $\lbrace a_i f_i \rbrace_{1\leq i \leq n}$. 那么 $tr(P)$ 可由有限集 $\lbrace f_j(a_i) \rbrace$ 生成.<br>另外,若 $tr(P) = R$, 我们称 $P$ 是生成子.</p>
<p><strong>引理</strong> 设 $T$ 是交换环 $R$ 的有限生成幂等理想, 则存在幂等元 $e \in R$ 使得 $T=eR$.<br>Proof: 关键在于把 $T$ 写成 $T = \sum_{i=1} ^n Tx_i$</p>
<p>由上述引理和 $T = Tr(P)$ 的性质, 不难证明下面定理:<br><strong>定理</strong> 设 $P_R$ 是交换环 $R$ 有限生成投射模, 那么存在幂等元 $e$ 使得 $T=Tr(P)=eR, N = ann(P) = (1-e)R$, 特别地, $R = T \otimes N$, 投射模 $P_R$ 是 faithful(忠实的)当且仅当 $T = R$.<br>当 $R$ 无非平凡幂等元时, 则 $P \neq 0$ 是(有限生成投射)生成子. </p>
<blockquote>
<p>定理中条件缺一不可, 且幂等元 $e$ 可以根据有限对偶基显式表达出来.</p>
</blockquote>
<p>Trace ideal 的应用:<br><strong>引理</strong> 设 $R \subset S$ 是环(不要求交换), 则 $R$ 是 $S_R$ 的直和因子, 当且仅当, $Tr(S_R) = R$.<br>Proof: 若 $R$ 是 $S_R$ 的直和因子, 则 $Tr(S_R) \supset Tr(R_R) = R$, 所以 $Tr(S_R) = R$.<br>若 $Tr(S_R) = R$, 那么存在 $f_i \in S_R^{\star},s_i \in S, (1 \leq i \leq n)$ 使得 $\sum f_i(s_i) = 1$.<br>定义映射 $\lambda: S \to R$ 为: $\lambda(s) = f(s_i s)$. 为环同态, 且在 $R$ 上限制为恒等映射.(因此 $R$ 是 $S_R$ 的直和因子).</p>
<p><strong>定理</strong> 设 $R \subset S$, 其中 $R$ 是交换环, $S$  是 f.g. 右 $R$-模. 则 $R$ 是 $S_R$ 的直和因子.<br>Proof: 由$ann(S_R) = 0$, 在由上面引理即证。</p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>dna049 的 C++模板</title>
    <url>/templateOfCpp/</url>
    <content><![CDATA[<p>此处包含 C++ 代码规范，C++ 模板，C++ STL 的使用。</p>
<p><strong>欢迎使用或转载代码块，唯一要求添加一行注释</strong>: <code>https://dna049.com</code></p>
<blockquote>
<p>编译器比你想象中的聪明，所以写让 <strong>编译器好优化</strong> 并且 <strong>易读</strong> 的代码，很多位运算，除法都是可以被优化的！<br>优质的代码本身就是一种解释，添加完全不必要的注释只会让人恶心<br>以后尽量使用 <code>Vector</code> 而非数组，虽然数组长度现在不用一开始给定，但是用 <code>Vector</code> 结合 <code>C++17</code> 可以简化代码！<br>以前觉得 <code>main</code> 函数 <code>return 0</code> 只是标准写法，现在(2020/5/22)才知道能返回就能提前优雅的结束！<br>全局变量数组元素自动默认初始化为 0，局部变量要加 <code>= {}</code> 才会初始化为 0</p>
</blockquote>
<a id="more"></a>
<h2 id="C-代码规范"><a href="#C-代码规范" class="headerlink" title="C++ 代码规范"></a>C++ 代码规范</h2><p>此规范参考：Codeforces 上 <a href="http://codeforces.com/profile/jiangly" target="_blank" rel="noopener">Jiangly</a> 的码风，<a href="https://oi.men.ci/code-style-oi/" target="_blank" rel="noopener">Menci</a> 代码规范，知乎 <a href="https://www.zhihu.com/question/398008181/answer/1259561408" target="_blank" rel="noopener">pansz</a> 的回答</p>
<h3 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h3><ul>
<li>不再使用 <code>using namespace std</code></li>
<li>不建议使用 <code>#include &lt;bits/stdc++.h&gt;</code></li>
<li>Tab 用于缩进，空格用于对齐（可不对齐）</li>
<li>左大括号不换行（左大括号前有且仅有一个空格）</li>
<li>头文件必须全部写在开头，C 的头文件必须以 c 开头而非<code>.h</code> 结尾</li>
<li><code>main</code> 函数必须在整个程序末尾</li>
<li>常用函数尽量写成类和模板形式</li>
<li>尽量使用 STL 减少代码量</li>
<li>尽量不要用 <code>C-type</code> 代码</li>
</ul>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><ul>
<li>不能有两个连续空行</li>
<li>独立的代码块之间要有空行</li>
<li>头文件块、函数、成员函数、结构体、类，全局变量块之间必须用空行隔开</li>
</ul>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>空格的作用：识别族群的位置</p>
<ul>
<li>前后必须都有空格：冒号、双目运算符、三目运算符</li>
<li>前加后不加：<code>* &amp;</code></li>
<li>后加前不加：关键字，逗号</li>
<li>前后都不加：<code>. -&gt; ::</code></li>
</ul>
<h3 id="函数和变量"><a href="#函数和变量" class="headerlink" title="函数和变量"></a>函数和变量</h3><ul>
<li>传参时按照实际需要传 引用、const 引用、值</li>
<li>尽量不使用全局变量</li>
<li>局部变量在用时定义</li>
<li>在合适的时间使用<code>static</code>变量</li>
</ul>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul>
<li>统一使用驼峰命名法</li>
<li>常量，<code>typedef</code>定义的类型 全部大写</li>
<li>类私有变量以<code>_</code>开头</li>
<li>函数和变量统一使用小驼峰</li>
<li>结构和类统一使用大驼峰</li>
<li>以 Core 结尾的核心代码是在约束条件下的高效代码</li>
<li>以 S 结尾的是简单且效率较低的代码</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>代码尽量自注释</li>
<li>在函数最开始注释，解释输入输出变量</li>
</ul>
<h3 id="代码优先级"><a href="#代码优先级" class="headerlink" title="代码优先级"></a>代码优先级</h3><ul>
<li>普通代码：正确，可行，可读，通用</li>
<li>Core 代码：正确，高效，通用，可读</li>
</ul>
<h3 id="STL-的使用"><a href="#STL-的使用" class="headerlink" title="STL 的使用"></a>STL 的使用</h3><ul>
<li><code>vector&lt;bool&gt;</code> 不是<code>vector</code>类型，谨慎使用</li>
<li>尽量用<code>vector</code>取代用户输入的数组，而非开足够大的数组</li>
<li>尽量使用 <code>emplace_back</code> 取代 <code>push_back</code>，有些取代不了，就不取代了</li>
<li>多使用 <code>pair, tuple, sort, stable_sort, iota, accumulate, for_each, lambda函数</code> 使得代码更加优雅</li>
</ul>
<h3 id="代码规范的说明"><a href="#代码规范的说明" class="headerlink" title="代码规范的说明"></a>代码规范的说明</h3><p>空格的作用是区分，空格缩进理论上是不合理的，<strong>强烈抵制四个空格代替 Tab</strong> </p>
<p>双目运算符两边加空格是为了 区分运算符 和 变量，虽然<code>a+b</code>（这种代码不必加空格，但是为了养成好习惯，还是加上较好），关键字后面加空格是为了避免像 函数调用</p>
<p>工程中不推荐使用 <code>using namespace std</code> ，而且不用的时候你就会知道一些陌生的函数原来是 <code>std</code> 中的，并且以后修改起来很麻烦</p>
<p>不建议使用万能头文件，但是本人用了是因为，打 CF 等比赛的时候你一个个的敲头文件或者写一大堆头文件，还不如就写这一个，并且以后修改成不用万能头文件也很容易</p>
<p>左空格不换行完全是个人喜好，换不换都可以，固定就好</p>
<p>其它总纲的代码规范完全是为了代码通用美感，大道至简</p>
<p>尽量避免全局变量是因为防止程序不可控，降低代码耦合性，局部变量用的时候定义是为了增加代码可读性，<code>static</code>变量也是为了避免全局变量</p>
<p>驼峰命名的好处在于 “顾名思义，望文生义”（贬义褒用）<br>遵守代码规范，养成编程好习惯~</p>
<h2 id="C-模板-by-dna049"><a href="#C-模板-by-dna049" class="headerlink" title="C++ 模板 by dna049"></a>C++ 模板 by dna049</h2><h3 id="通用代码块"><a href="#通用代码块" class="headerlink" title="通用代码块"></a>通用代码块</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="comment">//using LL = long long;</span></span><br><span class="line"><span class="keyword">using</span> BI = __int128; <span class="comment">// for g++(64 bit)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">end</span> = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time used: "</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;(<span class="built_in">end</span> - start).count() &lt;&lt; <span class="string">" (ms)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/*------ Welcome to my blog: http://dna049.com ------*/</span></span><br><span class="line">                   _ooOoo_</span><br><span class="line">                  o8888888o</span><br><span class="line">                  <span class="number">88</span><span class="string">" . "</span><span class="number">88</span></span><br><span class="line">                  (| -_- |)</span><br><span class="line">                  O\  =  /O</span><br><span class="line">               ____/`---'\____</span><br><span class="line">             <span class="number">.'</span>  \\|     |<span class="comment">//  `.</span></span><br><span class="line">            /  \\|||  :  |||<span class="comment">//  \</span></span><br><span class="line">           /  _||||| -:- |||||-  \</span><br><span class="line">           |   | \\\  -  <span class="comment">/// |   |</span></span><br><span class="line">           | \_|  ''\---/''  |   |</span><br><span class="line">           \  .-\__  `-`  ___/-. /</span><br><span class="line">         ___`. <span class="number">.'</span>  /--.--\  `. . __</span><br><span class="line">      ."" '&lt;  `.___\_&lt;|&gt;_/___.'  &gt;'"".</span><br><span class="line">     | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">     \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">======`-.____`-.___\_____/___.-`____.-'======</span><br><span class="line">                   `=---='</span><br><span class="line">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">            佛祖保佑       永无BUG</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐</span></span><br><span class="line"><span class="comment"> * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐</span></span><br><span class="line"><span class="comment"> * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘</span></span><br><span class="line"><span class="comment"> * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐</span></span><br><span class="line"><span class="comment"> * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │</span></span><br><span class="line"><span class="comment"> * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤</span></span><br><span class="line"><span class="comment"> * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │</span></span><br><span class="line"><span class="comment"> * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │</span></span><br><span class="line"><span class="comment"> * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter  │               │ 4 │ 5 │ 6 │   │</span></span><br><span class="line"><span class="comment"> * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤</span></span><br><span class="line"><span class="comment"> * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │</span></span><br><span class="line"><span class="comment"> * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││</span></span><br><span class="line"><span class="comment"> * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│</span></span><br><span class="line"><span class="comment"> * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="int128-的使用"><a href="#int128-的使用" class="headerlink" title="int128 的使用"></a>int128 的使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__int128 <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __int128 x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printS</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>) printS(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    printS(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __int128 a = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">print</span>(a * a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="负数下标技巧"><a href="#负数下标技巧" class="headerlink" title="负数下标技巧"></a>负数下标技巧</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> aa[N];</span><br><span class="line"><span class="keyword">int</span> *a = (aa + N / <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="优雅的输出技巧"><a href="#优雅的输出技巧" class="headerlink" title="优雅的输出技巧"></a>优雅的输出技巧</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" \n"</span>[i == n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向下取整-lfloor-frac-a-n-rfloor-和-向上取整-lceil-frac-a-n-rceil"><a href="#向下取整-lfloor-frac-a-n-rfloor-和-向上取整-lceil-frac-a-n-rceil" class="headerlink" title="向下取整 $\lfloor \frac{a}{n} \rfloor$ 和 向上取整 $\lceil \frac{a}{n} \rceil$"></a>向下取整 $\lfloor \frac{a}{n} \rfloor$ 和 向上取整 $\lceil \frac{a}{n} \rceil$</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">floor</span><span class="params">(LL a, LL n)</span> </span>&#123; <span class="comment">// n &gt; 0</span></span><br><span class="line">    <span class="keyword">return</span> a &lt; <span class="number">0</span> ? (a - n + <span class="number">1</span>) / n : a / n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ceil</span><span class="params">(LL a, LL n)</span> </span>&#123; <span class="comment">// n &gt; 0</span></span><br><span class="line">    <span class="keyword">return</span> a &lt; <span class="number">0</span> ? a / n : (a + n - <span class="number">1</span>) / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到 C/C++ 中 ，整数除法 <code>/</code> 是向 <code>0</code> 取整(<code>int(x)</code>也是向 0 取整)，但是 Python（Sagemath） 整数除法<code>//</code> 是向下取整。</p>
</blockquote>
<h3 id="Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释"><a href="#Barrent-reduction-快速模，弃用，因为并不会变快…-：wiki-镜像解释" class="headerlink" title="Barrent reduction 快速模，弃用，因为并不会变快… ：wiki 镜像解释"></a><a href="https://en.wikipedia.org/wiki/Barrett_reduction" target="_blank" rel="noopener">Barrent reduction 快速模，弃用，因为并不会变快…</a> ：<a href="https://en.jinzhao.wiki/wiki/Barrett_reduction" target="_blank" rel="noopener">wiki 镜像解释</a></h3><blockquote>
<p>对于给定常数$M$求 <code>a % M</code>，并要求 $ 0 \leq a &lt; M^2$，并且 $a &lt; 2^k$。因此下面 $k$ 的取值还是需要注意的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> LL M  = <span class="number">1e9</span> + <span class="number">7</span>; <span class="comment">// too big, M should satisfy M * M &lt; int</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span>  k = <span class="built_in">std</span>::__lg(M) + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">constexpr</span> LL m = (<span class="number">1L</span>L &lt;&lt; k) / M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> mod = [&amp;](<span class="keyword">int</span> a) &#123;</span><br><span class="line">    LL r = a - ((a * m) &gt;&gt; k) * M;</span><br><span class="line">    <span class="keyword">return</span> r &gt;= M ? r - M : r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="输出全排列"><a href="#输出全排列" class="headerlink" title="输出全排列"></a>输出全排列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x[n];</span><br><span class="line">    <span class="built_in">std</span>::iota(x, x + n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::for_each(x, x + n,[](<span class="keyword">int</span> &amp;i)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">std</span>::next_permutation(x, x + n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出全排列对应的-Python-原理版本"><a href="#输出全排列对应的-Python-原理版本" class="headerlink" title="输出全排列对应的 Python 原理版本"></a>输出全排列对应的 Python 原理版本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutaion</span><span class="params">(n)</span>:</span></span><br><span class="line">    ans = [list(range(<span class="number">1</span>,n+<span class="number">1</span>))]</span><br><span class="line">    r = list(range(<span class="number">1</span>,n+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">while</span> list(range(n,<span class="number">0</span>,<span class="number">-1</span>)) != r:</span><br><span class="line">        i = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> r[i<span class="number">-1</span>]&gt;r[i]: i-=<span class="number">1</span></span><br><span class="line">        r[i<span class="number">-1</span>],r[i] = r[i],r[i<span class="number">-1</span>]</span><br><span class="line">        b = r.copy()</span><br><span class="line">        ans.append(b)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    print(permutaion(i))</span><br></pre></td></tr></table></figure>
<h2 id="C-模板之初等数论"><a href="#C-模板之初等数论" class="headerlink" title="C++ 模板之初等数论"></a>C++ 模板之初等数论</h2><h3 id="Greatest-Common-divisor"><a href="#Greatest-Common-divisor" class="headerlink" title="Greatest Common divisor"></a>Greatest Common divisor</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简洁写法，不推荐，推荐使用内建 __gcd</span></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lambda 表达式写法，开头不能是auto因为递归</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; gcd = [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 快速版本 https://cp-algorithms.com/algebra/euclid-algorithm.html 也没啥用，仅仅记录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a || !b) <span class="keyword">return</span> a | b;</span><br><span class="line">    <span class="keyword">unsigned</span> shift = __builtin_ctz(a | b);</span><br><span class="line">    a &gt;&gt;= __builtin_ctz(a);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        b &gt;&gt;= __builtin_ctz(b);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">std</span>::swap(a, b);</span><br><span class="line">        b -= a;</span><br><span class="line">    &#125; <span class="keyword">while</span> (b);</span><br><span class="line">    <span class="keyword">return</span> a &lt;&lt; shift;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通版拓展GCD</span></span><br><span class="line"><span class="function">LL <span class="title">exGcd</span><span class="params">(LL a, LL b, LL&amp; x, LL&amp; y)</span></span>&#123;  <span class="comment">// ax + by = gcd(a,b)</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++17版拓展GCD，优雅了不少!</span></span><br><span class="line">std::tuple&lt;LL, LL, LL&gt; exGcd(LL a, LL b) &#123;  // ax + by = gcd(a,b)</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> &#123;a, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [d, y, x] = exgcd(b, a % b);</span><br><span class="line">    <span class="keyword">return</span> &#123;d, x, y - a / b * x&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n"><a href="#Sum-of-least-common-multiple-s-n-sum-i-1-n-lcm-i-n" class="headerlink" title="Sum of least common multiple  $ s_n =  \sum_{i=1} ^n lcm(i,n) $"></a>Sum of least common multiple  $ s_n =  \sum_{i=1} ^n lcm(i,n) $</h3><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1} ^n lcm(i,n) 
&= \sum_{i=1} ^n \frac{i \cdot n}{\gcd(i,n)} \\
&= n \sum_{d|n} \sum_{\gcd(i,\frac{n}{d})= 1} i \\
&= \frac{n}{2} \sum_{d|n} \frac{n}{d} \psi(\frac{n}{d}) \\
&= \frac{n}{2} \sum_{d|n} d \psi(d)
\end{aligned}</script><p>所以，我们可以在 $O(n \log n)$  处理好 $s_n$ 的前 $n$ 项。</p>
<h3 id="Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-n-lcm-i-j"><a href="#Double-sum-of-least-common-multiple-ds-n-sum-1-leq-i-leq-j-leq-n-n-lcm-i-j" class="headerlink" title="Double sum of least common multiple $ ds_n = \sum_{1 \leq i \leq j \leq n} ^ n lcm(i,j) $"></a>Double sum of least common multiple $ ds_n = \sum_{1 \leq i \leq j \leq n} ^ n lcm(i,j) $</h3><p>本来这个也挺麻烦，但是可以借助 $s_n$ 计算：$ds_n =  \sum_{j=1} ^n s_j$，所以复杂度就一致了。当然也可以直接化简成：</p>
<script type="math/tex; mode=display">
\sum_{1 \leq i \leq j \leq n} ^ n lcm(i,j) = \sum_{i = 1} ^ n \frac{i}{4} \psi(i) \lfloor \frac{n}{i} \rfloor (\lfloor \frac{n}{i} \rfloor + 1)</script><blockquote>
<p>不借助$s_n$ 其实也能暴力搞出来的。</p>
</blockquote>
<h3 id="模乘法逆元"><a href="#模乘法逆元" class="headerlink" title="模乘法逆元"></a>模乘法逆元</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a, LL p)</span></span>&#123; <span class="comment">// 0 &lt; a &lt; p and gcd(a,p) = 1</span></span><br><span class="line">    <span class="keyword">return</span> a == <span class="number">1</span> ? <span class="number">1</span> : (p - p / a) * inv(p % a, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码主要用于线性时间预处理所有$p$以内的逆元，对于较小的常数$a$, 可以直接试除 <code>b p mod a == 1</code></p>
</blockquote>
<h3 id="快速模乘法"><a href="#快速模乘法" class="headerlink" title="快速模乘法"></a>快速模乘法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">powMod</span><span class="params">(T x,U n,T p)</span></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r = r * x % p;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>; x = x * x % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以用for循环写的更短一点，但没必要</span></span><br></pre></td></tr></table></figure>
<h3 id="快速模加法"><a href="#快速模加法" class="headerlink" title="快速模加法"></a>快速模加法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mulMod</span><span class="params">(LL x, LL n, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="function">LL <span class="title">r</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    x %= p;</span><br><span class="line">    <span class="keyword">auto</span> inc = [&amp;](LL x, LL y) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x += y) &gt;= p) x-=p;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>) inc(r,x);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>; inc(x,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速模加法下的快速模乘法"><a href="#快速模加法下的快速模乘法" class="headerlink" title="快速模加法下的快速模乘法"></a>快速模加法下的快速模乘法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n, LL p)</span></span>&#123;</span><br><span class="line">    <span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r = mulmod(r, x, p);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>; x = mulmod(x, x, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阶乘、组合数、Lucas-定理"><a href="#阶乘、组合数、Lucas-定理" class="headerlink" title="阶乘、组合数、Lucas 定理"></a>阶乘、组合数、Lucas 定理</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">2</span>;</span><br><span class="line">LL fac[N], ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % M;</span><br><span class="line">    ifac[N - <span class="number">1</span>] = powMod(fac[N - <span class="number">1</span>], M - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i; --i) ifac[i - <span class="number">1</span>] = ifac[i] * i % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if (n &lt; k) return 0;</span></span><br><span class="line">    <span class="keyword">return</span> fac[n] * ifac[k] % M * ifac[n - k] % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lucas</span><span class="params">(LL n, LL m, LL p)</span> </span>&#123; <span class="comment">// C(n,m)%p, 仅在p较少时发挥作用</span></span><br><span class="line">    LL r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &amp;&amp; m) &#123;</span><br><span class="line">        LL np = n % p, mp = m % p;</span><br><span class="line">        <span class="keyword">if</span> (np &lt; mp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        r = binom(np, mp);</span><br><span class="line">        n /= p, m /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="乞丐版素数判断"><a href="#乞丐版素数判断" class="headerlink" title="乞丐版素数判断"></a>乞丐版素数判断</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-n-log-n-素数筛"><a href="#O-n-log-n-素数筛" class="headerlink" title="$O(n \log n)$ 素数筛"></a>$O(n \log n)$ 素数筛</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =  <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> isP[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isP[<span class="number">2</span>]) <span class="keyword">return</span>;</span><br><span class="line">    isP[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isP[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isP[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span> * i; j &lt; N; j += i * <span class="number">2</span>) &#123;</span><br><span class="line">            isP[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性素数筛"><a href="#欧拉线性素数筛" class="headerlink" title="欧拉线性素数筛"></a>欧拉线性素数筛</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrimeP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isp[<span class="number">2</span>]) <span class="keyword">return</span>;</span><br><span class="line">    p.emplace_back(<span class="number">2</span>);</span><br><span class="line">    isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isp[i]) p.emplace_back(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j != p.<span class="built_in">size</span>() &amp;&amp; p[j] &lt; t; ++j) &#123; <span class="comment">// 用除号是防止溢出</span></span><br><span class="line">            isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 不要下面的一步的话，复杂度 O(nloglogn), 但是不用除法，常数小</span></span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大素数-Miller-Rabin-概率判别法"><a href="#大素数-Miller-Rabin-概率判别法" class="headerlink" title="大素数 Miller-Rabin 概率判别法"></a><a href="http://blog.miskcoo.com/2014/07/miller-rabin-primality-test" target="_blank" rel="noopener">大素数 Miller-Rabin 概率判别法</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">witness</span><span class="params">(LL a, LL n, LL m, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    LL x = powMod(a, m, n);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        x = mulMod(x, x, n);</span><br><span class="line">        <span class="keyword">if</span> (x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LL m = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>, cnt = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(m &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        ++t;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        LL a = <span class="built_in">std</span>::rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Witness(a, n, m, t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-1-（执行）时间复杂度判断一个数是否为素数"><a href="#O-1-（执行）时间复杂度判断一个数是否为素数" class="headerlink" title="$O(1)$ （执行）时间复杂度判断一个数是否为素数"></a>$O(1)$ （执行）时间复杂度判断一个数是否为素数</h3><blockquote>
<p>奇技淫巧来源：<a href="https://codeforces.com/blog/entry/79941#comment-659202" target="_blank" rel="noopener">https://codeforces.com/blog/entry/79941#comment-659202</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sieve</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isP[N];</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Sieve</span><span class="params">()</span>: <span class="title">isP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isP[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isP[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) <span class="keyword">if</span> (isP[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span> * i; j &lt; N; j += i * <span class="number">2</span>) &#123;</span><br><span class="line">                    isP[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// MAXN 默认最大值为1&lt;&lt;18=262144, 调节参数 -fconstexpr-loop-limit= 例如：</span></span><br><span class="line"><span class="comment">// g++ main.cpp -std=c++17 -fconstexpr-loop-limit=12345678 -fconstexpr-ops-limit=1234567890</span></span><br><span class="line"><span class="comment">// 使得 MAXN = 1e7+2</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fast_is_prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> Sieve&lt;MAXN&gt; s;</span><br><span class="line">    <span class="keyword">return</span> s.isP[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-n-最小素因子预处理"><a href="#O-n-最小素因子预处理" class="headerlink" title="$O(n)$ 最小素因子预处理"></a>$O(n)$ 最小素因子预处理</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e8</span>; <span class="comment">// 再大内存吃不消了 </span></span><br><span class="line"><span class="keyword">int</span> sp[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) sp[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sp[i] == i) p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt;= sp[i] &amp;&amp; i * p[j] &lt; N; ++j) &#123; <span class="comment">//防止乘法溢出</span></span><br><span class="line">            sp[i * p[j]] = p[j]; <span class="comment">// 注意到sp只被赋值一次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大整数的最小素因子"><a href="#大整数的最小素因子" class="headerlink" title="大整数的最小素因子"></a>大整数的最小素因子</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">pollardrho</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    LL x = <span class="built_in">std</span>::rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    LL y = x, i = <span class="number">1</span>, k = <span class="number">2</span>, c = <span class="built_in">std</span>::rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        x = (mulMod(x, x, n) + c) % n;</span><br><span class="line">        LL d = <span class="built_in">std</span>::__gcd(y - x + n, n);</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">        <span class="keyword">if</span> (++i == k) &#123;</span><br><span class="line">            y = x;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; n) <span class="keyword">return</span> n;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findp</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rabin(n)) &#123;</span><br><span class="line">        ans = <span class="built_in">std</span>::<span class="built_in">min</span>(ans, n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL p = n;</span><br><span class="line">    <span class="keyword">while</span> (p == n) p = pollardrho(n);</span><br><span class="line">    findp(p);</span><br><span class="line">    findp(n / p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mobius-function"><a href="#Mobius-function" class="headerlink" title="Mobius function"></a>Mobius function</h3><blockquote>
<p>另类递推公式： $ \mu(i) = -\sum_{d|i,d&lt;i} \mu(d) $。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 乞丐版</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">        r = -r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= i;</span><br><span class="line">            <span class="keyword">if</span>(n % i  == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            r = -r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">1</span> ? -r : r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(n log n) 预处理版本</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e6</span> +<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt; N; j += i) &#123;</span><br><span class="line">            mu[j] -= mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n) 预处理版</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N  = <span class="number">1e6</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="keyword">int</span> p[N], mu[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mu[<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    isp[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) isp[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isp[i]) mu[i] = <span class="number">-1</span>, p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = (N - <span class="number">1</span>) / i + <span class="number">1</span>; j &lt;= cnt &amp;&amp; p[j] &lt; t; ++j) &#123;</span><br><span class="line">            isp[i * p[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            mu[i * p[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">4</span>) mu[i] = -mu[i &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mobius-function-前缀和"><a href="#Mobius-function-前缀和" class="headerlink" title="Mobius function 前缀和"></a>Mobius function 前缀和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sumMu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSumMu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mu[<span class="number">1</span>] != <span class="number">1</span>) initmu();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) sumMu[i] = sumMu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSumMu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// M(n) = M(n-1) + mu(n)</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> sumMu[n];</span><br><span class="line">    <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">        j = n / (n / i);</span><br><span class="line">        r -= (j - i + <span class="number">1</span>) * sumMu(n / i);</span><br><span class="line">    &#125;</span><br><span class="line">    mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Mobius function 绝对值前缀和</span></span><br><span class="line"><span class="function">LL <span class="title">getSumAbsMu</span><span class="params">(LL n)</span> </span>&#123; <span class="comment">// Q(n) = Q(n-1) + |mu(n)|</span></span><br><span class="line">    LL r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>, t; (t = i * i) &lt; n; ++i) &#123;</span><br><span class="line">        r += mu[i] * (n / t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Euler-‘s-totient-function"><a href="#Euler-‘s-totient-function" class="headerlink" title="Euler ‘s totient function"></a>Euler ‘s totient function</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> phi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPhi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phi[<span class="number">2</span>] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) phi[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i += <span class="number">2</span>) phi[i] = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phi[i] != i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; N; j += i) phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPhi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = (n % <span class="number">2</span> == <span class="number">0</span> ? n/<span class="number">2</span> : n);</span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>) n/=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i  == <span class="number">0</span>) &#123;</span><br><span class="line">            r = r / i *(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) r = r / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">LL sumPhi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSumphi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phi[<span class="number">2</span>] != <span class="number">1</span>) initPhi();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) sumPhi[i] = sumPhi[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, LL&gt; mp;</span><br><span class="line"><span class="function">LL <span class="title">getSumphi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> (LL) sumPhi[n];</span><br><span class="line">    <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    LL r = LL(n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">        j = n / (n / i);</span><br><span class="line">        r -= (j - i + <span class="number">1</span>) * getSumphi(n / i);</span><br><span class="line">    &#125;</span><br><span class="line">    mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pi-x-函数"><a href="#pi-x-函数" class="headerlink" title="$\pi(x)$ 函数"></a>$\pi(x)$ 函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span> * <span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">11</span> * <span class="number">13</span> * <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM + <span class="number">1</span>][M + <span class="number">1</span>], sz[M + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initprime();</span><br><span class="line">    pi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        pi[i] = pi[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isp[i]) ++pi[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sz[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= PM; ++i) phi[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        sz[i] = p[i] * sz[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= PM; ++j) &#123;</span><br><span class="line">            phi[j][i] = phi[j][i - <span class="number">1</span>] - phi[j / p[i]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span></span>;</span><br><span class="line"><span class="function">LL <span class="title">primephi</span><span class="params">(LL x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= M) <span class="keyword">return</span> phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];</span><br><span class="line">    <span class="keyword">if</span> (x / p[s] &lt;= p[s]) <span class="keyword">return</span> primepi(x) - s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x / p[s] / p[s] &lt;= p[s] &amp;&amp; x &lt; N) &#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[(<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>))];</span><br><span class="line">        LL ans = pi[x] - (s2x + s - <span class="number">2</span>) * (s2x - s + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt;= s2x; ++i) &#123;</span><br><span class="line">            ans += pi[x / p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primephi(x, s - <span class="number">1</span>) - primephi(x / p[s], s - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; N) <span class="keyword">return</span> pi[x];</span><br><span class="line">    <span class="keyword">int</span> ps2x = primepi(<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x + <span class="number">0.2</span>)));</span><br><span class="line">    <span class="keyword">int</span> ps3x = primepi(<span class="keyword">int</span>(cbrt(x + <span class="number">0.2</span>)));</span><br><span class="line">    LL ans = primephi(x, ps3x) + LL(ps2x + ps3x - <span class="number">2</span>) * (ps2x - ps3x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ps3x + <span class="number">1</span>, ed = ps2x; i &lt;= ed; ++i) &#123;</span><br><span class="line">        ans -= primepi(x / p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pi-x-函数计算的另一种做法"><a href="#pi-x-函数计算的另一种做法" class="headerlink" title="$\pi(x)$ 函数计算的另一种做法"></a>$\pi(x)$ 函数计算的另一种做法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">2</span>;</span><br><span class="line">LL L[N], R[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">primepi</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    LL rn = (LL) <span class="built_in">sqrt</span>(n + <span class="number">0.2</span>);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= rn; ++i) R[i] = n / i - <span class="number">1</span>;</span><br><span class="line">    LL ln = n / (rn + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= ln; ++i) L[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL p = <span class="number">2</span>; p &lt;= rn; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[p] == L[p - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (LL i = <span class="number">1</span>, tn = <span class="built_in">std</span>::<span class="built_in">min</span>(n / (p * p), rn); i &lt;= tn; ++i) &#123;</span><br><span class="line">            R[i] -= (i * p &lt;= rn ? R[i * p] : L[n / (i * p)]) - L[p - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (LL i = ln; i &gt;= p * p; --i) &#123;</span><br><span class="line">            L[i] -= L[i / p] - L[p - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求奇素数的一个原根"><a href="#求奇素数的一个原根" class="headerlink" title="求奇素数的一个原根"></a>求奇素数的一个原根</h3><blockquote>
<p>代码懒得贴，实际上暴力就可以了</p>
</blockquote>
<p>首先，模 $m$ 有原根的充要条件是：$m=2,4,p^a,2p^a$，其中$p$为奇素数。</p>
<p>对于求模$p$的原根方法：对 $p-1$ 素因子分解：$p-1 = p_1^{a_1} \cdots p_s^{a_s}$ 若恒有 </p>
<script type="math/tex; mode=display">
g^{\frac{p-1}{p_i}} \neq 1(\mod \; p)</script><p>则 $g$ 是 模 $p$ 的原根。对于 $p^a$ 可以用 $p$ 的原根简单构造，而 $2p^a$ 的原根为 $p^a$ 的原根与 $p^a$ 的原根和 $p^a$的和中奇数者。(证明见 P150《数论基础》潘承洞)</p>
<blockquote>
<p>求所有原根见 </p>
</blockquote>
<h3 id="数论函数的-Dirichlet-乘积"><a href="#数论函数的-Dirichlet-乘积" class="headerlink" title="数论函数的 Dirichlet 乘积"></a>数论函数的 Dirichlet 乘积</h3><p>以前的代码不想贴了，不优雅，下次有题做的时候补上。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><a href="/chineseRemainTheorem/" title="中国剩余定理">中国剩余定理</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;LL,LL&gt; crt2(LL a1,LL m1,LL a2,LL m2)&#123; // x = ai mod mi, m_i &gt;0</span><br><span class="line">    LL t1,t2,ans = a2-a1;</span><br><span class="line">    LL d = exgcd(m1,m2,t1,t2);</span><br><span class="line">    assert(ans%d == <span class="number">0</span>);</span><br><span class="line">    LL m = m1/d*m2;</span><br><span class="line">    ans = (a1+ans/d*t1%m2*m1)%m; <span class="comment">// %m2 是避免溢出</span></span><br><span class="line">    <span class="keyword">return</span> make_pair(ans&gt;<span class="number">0</span>?ans:ans+m,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span>;</span><br><span class="line">LL a[N],m[N];</span><br><span class="line">pair&lt;LL,LL&gt; crt(int n)&#123; // x = a[i] mod m[i], m[i] &gt;0</span><br><span class="line">    pair&lt;LL,LL&gt; ans = make_pair(a[<span class="number">0</span>]%m[<span class="number">0</span>],m[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        ans = crt2(ans.first,ans.second,a[i],m[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a><a href="http: //blog.miskcoo.com/2015/05/discrete-logarithm-problem">离散对数</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">baby_step_giant_step</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123; <span class="comment">// a^x = b mod p</span></span><br><span class="line">    a %= p, b %= p;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b % p ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL cnt = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL g = <span class="built_in">std</span>::__gcd(a, p); g != <span class="number">1</span>; g = <span class="built_in">std</span>::__gcd(a, p)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        p /= g, b /= g, t = t * (a / g) % p;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (b == t) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;LL, LL&gt; mp;</span><br><span class="line">    LL m = LL(<span class="built_in">std</span>::<span class="built_in">sqrt</span>(p + <span class="number">0.1</span>) + <span class="number">1</span>);</span><br><span class="line">    LL base = b;</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">0</span>; i != m; ++i) &#123;</span><br><span class="line">        mp[base] = i;</span><br><span class="line">        base = base * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    base = powMod(a, m, p);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        t = t * base % p;</span><br><span class="line">        <span class="keyword">if</span> (mp.count(t)) <span class="keyword">return</span> i * m - mp[t] + cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模素数开根号"><a href="#模素数开根号" class="headerlink" title="模素数开根号"></a>模素数开根号</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">modsqrt</span><span class="params">(LL a, LL p)</span> </span>&#123; <span class="comment">// find x s.t x*x=a mod p;</span></span><br><span class="line">    a = (p + a % p) % p;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">2</span>) <span class="keyword">return</span> (a &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    LL q = (p - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (powMod(a, q, p) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q &amp; <span class="number">1</span>) <span class="keyword">return</span> powMod(a, (q + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line">    LL b, cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (powMod(b = rand() % p, q, p) == <span class="number">1</span>); <span class="comment">//find a non quadratic residue</span></span><br><span class="line">    <span class="keyword">while</span> (!(q &amp; <span class="number">1</span>)) ++cnt, q &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    b = powMod(b, q, p);</span><br><span class="line">    LL x = powMod(a, (q + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line">    <span class="keyword">for</span> (LL s = <span class="number">1</span>, t = powMod(a, q, p); t != <span class="number">1</span>; s = <span class="number">1</span>) &#123; <span class="comment">//keep x*x=t*a;t^&#123;2^&#123;cnt-1&#125;&#125;=1</span></span><br><span class="line">        <span class="keyword">for</span> (LL tt = t * t % p; s &lt; cnt &amp;&amp; tt != <span class="number">1</span>; ++s) tt = tt * tt % p;</span><br><span class="line">        LL d = powMod(b, <span class="number">1</span> &lt;&lt; (cnt - s - <span class="number">1</span>), p);</span><br><span class="line">        x = (x * d) % p;</span><br><span class="line">        b = d * d % p;</span><br><span class="line">        t = t * b % p;</span><br><span class="line">        cnt = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mod_sqrt</span><span class="params">(LL a, LL p, <span class="keyword">int</span> k = <span class="number">1</span>)</span> </span>&#123; <span class="comment">//find smallest x&gt;=0 s.t x*x=a mod p^k</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ka = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a % p == <span class="number">0</span>) a /= p, ++ka, --k;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ka &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">pow</span> = [](LL x, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        LL r=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>, x *= x)  <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r *= x;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;;</span><br><span class="line">    LL n = <span class="built_in">pow</span>(p, k), x;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span> || k == <span class="number">2</span>) x = a == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a % <span class="number">8</span> != <span class="number">1</span>) x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x * x) % (<span class="number">1</span> &lt;&lt; i) == a % (<span class="number">1</span> &lt;&lt; i)) <span class="keyword">continue</span>;</span><br><span class="line">                x += <span class="number">1</span> &lt;&lt; (i - <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> x = mod_sqrt_p(a, n, p, k);</span><br><span class="line">    <span class="keyword">return</span> x == <span class="number">-1</span> ? <span class="number">-1</span> : <span class="built_in">pow</span>(p, ka &gt;&gt; <span class="number">1</span>) * (x &lt; n - x ? x : n - x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于模一般的 $n$，先素因子分解分别求出答案，然后用中国剩余定理求最终解。</p>
</blockquote>
<h3 id="自然数方幂和-O-k-算法"><a href="#自然数方幂和-O-k-算法" class="headerlink" title="自然数方幂和 $O(k)$ 算法"></a>自然数方幂和 $O(k)$ 算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> sp[N], p[N];</span><br><span class="line">LL inv[N], AP[N], AS[N], f[N];</span><br><span class="line"><span class="function">LL <span class="title">getPowSum</span><span class="params">(LL n, <span class="keyword">int</span> k, LL mod)</span> </span>&#123; <span class="comment">// mod &gt; k</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> n % mod;</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">2</span>) spf();</span><br><span class="line">    <span class="keyword">int</span> nk = k + <span class="number">1</span>;</span><br><span class="line">    LL tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk; ++i) tmp = tmp * i % mod;</span><br><span class="line">    inv[nk] = powMod(tmp, mod - <span class="number">2</span>, mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sp[i] == i) f[i] = powMod(i, k, mod);</span><br><span class="line">        <span class="keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">        f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (f[i] &gt;= mod) f[i] -= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= nk) <span class="keyword">return</span> f[n];</span><br><span class="line">    AP[<span class="number">0</span>] = AS[nk] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) AP[i] = AP[i - <span class="number">1</span>] * (n + <span class="number">1</span> - i) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) AS[i] = AS[i + <span class="number">1</span>] * (n - i - <span class="number">1</span>) % mod;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) &#123; <span class="comment">// because f(i)=0</span></span><br><span class="line">        LL x = f[i] * AP[i] % mod * AS[i] % mod * inv[i] % mod * inv[nk - i] % mod;</span><br><span class="line">        <span class="keyword">if</span> ((nk - i) &amp; <span class="number">1</span>) res -= x; <span class="comment">// be careful</span></span><br><span class="line">        <span class="keyword">else</span> res += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res % mod + mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自然数方幂和精确版"><a href="#自然数方幂和精确版" class="headerlink" title="自然数方幂和精确版"></a>自然数方幂和精确版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> BINT = boost::multiprecision::cpp_int;</span><br><span class="line"></span><br><span class="line">BINT f[N];</span><br><span class="line"><span class="function">BINT <span class="title">getpowsum</span><span class="params">(LL n, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// k&lt;1000</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> BINT(n);</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != <span class="number">2</span>) spf();</span><br><span class="line">    <span class="keyword">int</span> nk = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> bPow = [](BINT x, <span class="keyword">int</span> n) -&gt; BINT &#123;</span><br><span class="line">        BINT r(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (; n; x *= x, n &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span> (n&amp;<span class="number">1</span>) r *= x;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nk + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sp[i] == i) f[i] = bPow(BINT(i), k);</span><br><span class="line">        <span class="keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nk; ++i) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= nk) <span class="keyword">return</span> f[n];</span><br><span class="line">    BINT res = <span class="number">0</span>, tl = <span class="number">1</span>, tr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) tr = tr * (n - i - <span class="number">1</span>) / (nk - i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nk; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nk - i) &amp; <span class="number">1</span>) res -= f[i] * tl * tr;</span><br><span class="line">        <span class="keyword">else</span> res += f[i] * tl * tr;</span><br><span class="line">        tl = tl * (n - i) / (i + <span class="number">1</span>);</span><br><span class="line">        tr = tr * (nk - i) / (n - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要下载<a href="https: //www.boost.org/">boost 包</a> 类似的包还有 NTL，GMP</p>
</blockquote>
<h3 id="NFT-正式可用版-last-updated-2020-7-9"><a href="#NFT-正式可用版-last-updated-2020-7-9" class="headerlink" title="NFT 正式可用版(last updated: 2020/7/9)"></a>NFT 正式可用版(last updated: 2020/7/9)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>, ROOT = <span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">    <span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = x * x % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = a.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            (j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a, <span class="keyword">bool</span> isInverse = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    LL g = powMod(ROOT, (M - <span class="number">1</span>) / a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (isInverse) &#123;</span><br><span class="line">        g = powMod(g, M - <span class="number">2</span>);</span><br><span class="line">        LL invLen = powMod(LL(a.<span class="built_in">size</span>()), M - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) x = x * invLen % M;</span><br><span class="line">    &#125;</span><br><span class="line">    bitreverse(a);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != w.<span class="built_in">size</span>(); ++i) w[i] = w[i - <span class="number">1</span>] * g % M;</span><br><span class="line">    <span class="keyword">auto</span> addMod = [](LL x, LL y) &#123;</span><br><span class="line">        <span class="keyword">return</span> (x += y) &gt;= M ? x -= M : x;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">2</span>, half = <span class="number">1</span>; half != a.<span class="built_in">size</span>(); <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>, half &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, wstep = a.<span class="built_in">size</span>() / <span class="built_in">step</span>; i != a.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j != i + half; ++j) &#123;</span><br><span class="line">                LL t = (a[j + half] * w[wstep * (j - i)]) % M;</span><br><span class="line">                a[j + half] = addMod(a[j], M - t);</span><br><span class="line">                a[j] = addMod(a[j], t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">mul</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (sz &lt; tot) sz *= <span class="number">2</span>;</span><br><span class="line">    a.resize(sz);</span><br><span class="line">    b.resize(sz);</span><br><span class="line">    nft(a);</span><br><span class="line">    nft(b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != sz; ++i) a[i] = a[i] * b[i] % M;</span><br><span class="line">    nft(a, <span class="number">1</span>);</span><br><span class="line">    a.resize(tot);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="siyuan-的-FWT-模板"><a href="#siyuan-的-FWT-模板" class="headerlink" title="siyuan 的 FWT 模板"></a><a href="https://blog.orzsiyuan.com/archives/Fast-Walsh-Hadamard-Transform/" target="_blank" rel="noopener">siyuan 的 FWT 模板</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x += y) &gt;= P &amp;&amp; (x -= P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    (x -= y) &lt; <span class="number">0</span> &amp;&amp; (x += P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FWT</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; N &lt; n; N &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j + m], a[i + j]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j + m], a[i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rev) add(a[i + j], a[i + j + m]);</span><br><span class="line">                <span class="keyword">else</span> sub(a[i + j], a[i + j + m]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FWTxor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">bool</span> rev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), inv2 = (P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, m = <span class="number">1</span>; l &lt;= n; l &lt;&lt;= <span class="number">1</span>, m &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += l) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = a[i + j + m];</span><br><span class="line">                <span class="keyword">if</span> (!rev) &#123;</span><br><span class="line">                    a[i + j] = (x + y) % P;</span><br><span class="line">                    a[i + j + m] = (x - y + P) % P;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[i + j] = <span class="number">1L</span>L * (x + y) * inv2 % P;</span><br><span class="line">                    a[i + j + m] = <span class="number">1L</span>L * (x - y + P) * inv2 % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Or</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">And</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTand(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTand(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTand(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Xor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">std</span>::<span class="built_in">max</span>(a1.<span class="built_in">size</span>(), a2.<span class="built_in">size</span>()), N = extend(n);</span><br><span class="line">        a1.resize(N), FWTxor(a1, <span class="literal">false</span>);</span><br><span class="line">        a2.resize(N), FWTxor(a2, <span class="literal">false</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = <span class="number">1L</span>L * a1[i] * a2[i] % P;</span><br><span class="line">        FWTxor(A, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; fwt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    std::vector&lt;int&gt; a1(n), a2(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a2[i]);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    A = fwt.Or(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A = fwt.And(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A = fwt.Xor(a1, a2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵类"><a href="#矩阵类" class="headerlink" title="矩阵类"></a>矩阵类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LL mod;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line">    LL a[N][N];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Matrix() &#123;&#125;</span><br><span class="line">    Matrix(<span class="keyword">int</span> _n, <span class="keyword">int</span> x = <span class="number">0</span>): n(_n) &#123; <span class="comment">// xIn</span></span><br><span class="line">        all(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            a[i][i] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">all</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                a[i][j] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> + (<span class="keyword">const</span> Matrix &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                R.a[i][j] = a[i][j] + A.a[i][j];</span><br><span class="line">                <span class="keyword">if</span> (R.a[i][j] &gt;= mod) R.a[i][j] -= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j] + a[i][k] * A.a[k][j]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">R</span><span class="params">(A.n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>) R = R * A;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>; A = A * A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到，矩阵乘法一定要写成上面的循环形式，这样利用高速缓存执行时间是原有的 1/4</p>
<p>另外有序数组的累和要比无序的快很多，也是因为高速缓存（这个不太懂原理）</p>
</blockquote>
<h3 id="求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法"><a href="#求-m-阶线性递推关系式第-n-项：时间复杂度-O-m-2-log-n-，本质是做多项式的带模乘法" class="headerlink" title="求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法"></a>求$m$阶线性递推关系式第$n$项：时间复杂度$O(m^2 \log n)$，本质是做多项式的带模乘法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1003</span>;</span><br><span class="line">LL c[M], ans[<span class="number">2</span> * M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecSeq</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LL a[<span class="number">2</span> * M];</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    RecSeq(<span class="keyword">int</span> _m, LL x = <span class="number">0</span>): m(_m) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> (a));</span><br><span class="line">        a[<span class="number">0</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    RecSeq <span class="keyword">operator</span> * (<span class="keyword">const</span> RecSeq &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="function">RecSeq <span class="title">R</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                R.a[i + j] = (R.a[i + j] + a[i] * A.a[j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * m - <span class="number">2</span>; i &gt;= m; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                R.a[i - m + j] += (R.a[i] * c[j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            R.a[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            R.a[i] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">    <span class="function">T <span class="title">tPow</span><span class="params">(T &amp; A, LL n)</span> </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">R</span><span class="params">(A.m, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) R = R * A;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            A = A * A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initC</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> (c));</span><br><span class="line">    c[<span class="number">0</span>] = c[m - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        ans[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[m] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt; <span class="number">2</span> * m; ++i) &#123;</span><br><span class="line">        ans[i] = ans[i - <span class="number">1</span>] + ans[i - m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(LL n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    initC(m);</span><br><span class="line">    <span class="function">RecSeq <span class="title">A</span><span class="params">(m)</span></span>;</span><br><span class="line">    A.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    RecSeq R = tPow(A, n - m);</span><br><span class="line">    LL r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        r += (R.a[i] * ans[i + m]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用<a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">多项式带模除法：Division with remainder</a>的$O(m \log m)$算法，可优化到 $O(m \log m \log n)$，</p>
<p>但是如果递推关系中仅有常数个不为 0，比如通常是两个，也可以不用多项式带模除法来搞，只需 NFT 就可以优化到 $O(m \log m \log n + m^2)$ （暂时不知道如何去掉$m^2$）</p>
</blockquote>
<h2 id="C-模板之数据结构"><a href="#C-模板之数据结构" class="headerlink" title="C++ 模板之数据结构"></a>C++ 模板之数据结构</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = x;</span><br><span class="line">    <span class="keyword">while</span> (ans != p[ans]) ans = p[ans];</span><br><span class="line">    <span class="keyword">while</span> (x != ans) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = p[x];</span><br><span class="line">        p[x] = ans;</span><br><span class="line">        x = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">2</span>;</span><br><span class="line">    LL s[N];</span><br><span class="line">    <span class="keyword">int</span> Size;</span><br><span class="line">    TreeArray() &#123;&#125;</span><br><span class="line">    TreeArray(<span class="keyword">int</span> _S): Size(_S) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Size; ++i) s[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (id &lt;= Size) &#123;</span><br><span class="line">            s[id] += p;</span><br><span class="line">            id += lowbit(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        LL r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (id) &#123;</span><br><span class="line">            r += s[id];</span><br><span class="line">            id -= lowbit(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若设原始数组为 $a$， 设数字 $i$ 的二进制表示为 $d_1 \cdots d_n0 \dots 0, d_n = 1 $ 本质上树状数组 $s[i] $ 保存的其实是前 $n - 1 $ 位和 $i$ 一致， 且不超过 $i$ 的位置元素之和。</p>
</blockquote>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lrt rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rrt rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, m, lrt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m + 1, r, rrt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">LL sum[N * <span class="number">3</span>], col[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    sum[rt] = sum[lrt] + sum[rrt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (col[rt]) &#123;</span><br><span class="line">        col[lrt] += col[rt];</span><br><span class="line">        col[rrt] += col[rt];</span><br><span class="line">        sum[lrt] += (m - (m &gt;&gt; <span class="number">1</span>)) * col[rt];</span><br><span class="line">        sum[rrt] += (m &gt;&gt; <span class="number">1</span>) * col[rt];</span><br><span class="line">        col[rt] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp; sum[rt]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    col[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) &#123;</span><br><span class="line">        sum[rt] += p * (r - l + <span class="number">1</span>);</span><br><span class="line">        col[rt] += p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) update(L, R, p, lson);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; m) update(L, R, p, rson);</span><br><span class="line">    pushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> sum[rt];</span><br><span class="line">    pushDown(rt, r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= m) ans += query(L, R, lson);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; m) ans += query(L, R, rson);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>吊打线段树的<a href="https: //blog.csdn.net/CC_dsm/article/details/98166835">珂朵莉树（ Chtholly Tree）</a></p>
</blockquote>
<h3 id="RMQ-求区间最大值"><a href="#RMQ-求区间最大值" class="headerlink" title="RMQ 求区间最大值"></a>RMQ 求区间最大值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMQ</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a[N][<span class="number">20</span>]; <span class="comment">//a[i][j]=max(s[i]---s[i+2^j-1])</span></span><br><span class="line">    RMQ(<span class="keyword">int</span> * s, <span class="keyword">int</span> _n): n(_n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) a[i][<span class="number">0</span>] = s[i];</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(n)) / <span class="built_in">log</span>(<span class="number">2.0</span>)) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != len; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - (<span class="number">1</span> &lt;&lt; i); ++j) &#123;</span><br><span class="line">                a[j][i] = <span class="built_in">max</span>(a[j][i - <span class="number">1</span>], a[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 0 &lt;= l &lt;= r &lt; n</span></span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(r - l + <span class="number">1</span>)) / <span class="built_in">log</span>(<span class="number">2.0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(a[l][len], a[r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/nondecraseSubsequence/" title="最长（ 严格） 递增子序列">最长（ 严格） 递增子序列</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// longest increasing subsquence</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> * b = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    b[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; b[k]) b[++k] = a[i];</span><br><span class="line">        <span class="keyword">else</span> b[lower_bound(b, b + k, a[i]) - b] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lower_bound(first,end,val) 表示在单增 [frist,end) 中首次大于等于 val 的位置</span></span><br><span class="line"><span class="comment">// upper_bound(first,end,val) 表示在单增 [frist,end) 中首次大于 val 的位置</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们经常用二分答案的思想， 但是其实二分答案是仅仅知道其单调的情况下的策略， 实际上， 对于具体的问题， 我们完全可以对 $m$ 的值进行不同的处理， 而非单纯的 $m = (l + r) &gt;&gt; 1 $。</p>
</blockquote>
<h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> r[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pack</span><span class="params">(<span class="keyword">int</span> cash, <span class="keyword">int</span> num, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> || w == <span class="number">0</span> || v == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123; <span class="comment">//  0-1背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cash; i &gt;= v; --i)</span><br><span class="line">            r[i] = <span class="built_in">max</span>(r[i], r[i - v] + w);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num * v &gt;= cash - v + <span class="number">1</span>) &#123; <span class="comment">//完全背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v; i &lt;= cash; ++i)</span><br><span class="line">            r[i] = <span class="built_in">max</span>(r[i], r[i - v] + w);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q[MAX], s[MAX], head, tail;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123; <span class="comment">//多重背包</span></span><br><span class="line">        q[<span class="number">0</span>] = r[j];</span><br><span class="line">        s[<span class="number">0</span>] = head = tail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = j + v; k &lt;= cash; ++i, k += v) &#123;</span><br><span class="line">            q[i] = r[k] - i * w;</span><br><span class="line">            <span class="keyword">while</span> (s[head] &lt; i - num) ++head;</span><br><span class="line">            <span class="keyword">while</span> (head &lt;= tail &amp;&amp; q[tail] &lt; q[i]) --tail;</span><br><span class="line">            s[++tail] = i;</span><br><span class="line">            q[tail] = q[i];</span><br><span class="line">            r[k] = q[head] + i * w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆与-STL-优先队列"><a href="#堆与-STL-优先队列" class="headerlink" title="堆与 STL 优先队列"></a>堆与 STL 优先队列</h3><p>可以使用<a href="http: //www.cplusplus.com/reference/">C++STL</a> 的 priority_queue，查找可用 lower_bound 和 upper_bound。C++ STL 中优先队列是用堆来实现的。用途十分广泛，例如加速最小生成树，拓扑排序，等等。<br>堆的实现一般是用数组。 我们可以用 1 作为树的根， 对每一个节点 $x$， 它的两个节点分别就是 $2x$ 和 $2x + 1 $ 平时都用 $x &lt;&lt; 1, x &lt;&lt; 1 | 1 $ 表示。 堆只支持三个操作:</p>
<ol>
<li>插入一个节点(我们实现时是插入最尾部， 这样保证了是一个完全二叉树) $O(\log n) $ </li>
<li>删除最大键值节点（ 删除根元素的值） $O(\log n) $ </li>
<li>输出最大键值节点（ 查看根元素的值） $O(1) $</li>
</ol>
<blockquote>
<p>单调队列， 单调栈， 树状数组， 堆， 线段树， 红黑树 是我掌握的也很喜欢的几个数据结构了。</p>
</blockquote>
<h3 id="拓扑排序反字典序输出"><a href="#拓扑排序反字典序输出" class="headerlink" title="拓扑排序反字典序输出"></a>拓扑排序反字典序输出</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], sc, d[N], ans[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ed;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;</span><br><span class="line">e[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[sc].ed = y;</span><br><span class="line">    e[sc].next = head[x];</span><br><span class="line">    head[x] = sc++;</span><br><span class="line">    ++d[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    sc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">        v[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// after read data</span></span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span> &gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (v[u]) <span class="keyword">continue</span>;</span><br><span class="line">        v[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--d[e[i].ed] == <span class="number">0</span>) q.push(e[i].ed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树-red-black-tree"><a href="#红黑树-red-black-tree" class="headerlink" title="红黑树 red-black tree"></a>红黑树 red-black tree</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBT</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> elemType;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> RED = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> BLACK = <span class="number">1</span>;</span><br><span class="line">        Node * ch[<span class="number">2</span>], * fa; <span class="comment">// x-&gt;fa-&gt;ch[x-&gt;rs] = x</span></span><br><span class="line">        <span class="keyword">int</span> sz;</span><br><span class="line">        elemType key;</span><br><span class="line">        <span class="keyword">bool</span> color, rs; <span class="comment">// is rightson</span></span><br><span class="line">    &#125;;</span><br><span class="line">    Node * root; <span class="comment">// root has no father</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">faSon</span><span class="params">(Node * x, Node * y, <span class="keyword">bool</span> rs)</span> </span>&#123;</span><br><span class="line">        y-&gt;fa = x;</span><br><span class="line">        y-&gt;rs = rs;</span><br><span class="line">        x-&gt;ch[rs] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newNode</span><span class="params">(Node * x, elemType val, <span class="keyword">bool</span> rs)</span> </span>&#123; <span class="comment">// x-&gt;ch[rs]=null</span></span><br><span class="line">        Node * p = <span class="keyword">new</span> Node;</span><br><span class="line">        p-&gt;ch[<span class="number">0</span>] = p-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">        p-&gt;sz = <span class="number">1</span>;</span><br><span class="line">        p-&gt;key = val;</span><br><span class="line">        p-&gt;color = Node::RED;</span><br><span class="line">        faSon(x, p, rs);</span><br><span class="line">        ++x-&gt;sz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(Node * x, <span class="keyword">bool</span> rs)</span> </span>&#123; <span class="comment">// x must not null</span></span><br><span class="line">        Node * y = x-&gt;ch[!rs];</span><br><span class="line">        <span class="keyword">if</span> (y == null) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == root) root = y;</span><br><span class="line">        <span class="keyword">else</span> faSon(x-&gt;fa, y, x-&gt;rs);</span><br><span class="line">        faSon(x, y-&gt;ch[rs], !rs);</span><br><span class="line">        faSon(y, x, rs);</span><br><span class="line">        y-&gt;sz = x-&gt;sz;</span><br><span class="line">        x-&gt;sz = x-&gt;ch[<span class="number">0</span>]-&gt;sz + x-&gt;ch[<span class="number">1</span>]-&gt;sz + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insMaintain</span><span class="params">(Node * x)</span> </span>&#123; <span class="comment">// x-&gt;color is RED</span></span><br><span class="line">        <span class="keyword">if</span> (x == root || x-&gt;fa-&gt;color == Node::BLACK) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;fa-&gt;fa-&gt;ch[!x-&gt;fa-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;rs ^ x-&gt;fa-&gt;rs) rotate(x-&gt;fa, x-&gt;fa-&gt;rs);</span><br><span class="line">            <span class="keyword">else</span> x = x-&gt;fa;</span><br><span class="line">            x-&gt;color = Node::BLACK;</span><br><span class="line">            x-&gt;fa-&gt;color = Node::RED;</span><br><span class="line">            rotate(x-&gt;fa, !x-&gt;rs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = x-&gt;fa-&gt;fa;</span><br><span class="line">            x-&gt;color = Node::RED;</span><br><span class="line">            x-&gt;ch[<span class="number">0</span>]-&gt;color = x-&gt;ch[<span class="number">1</span>]-&gt;color = Node::BLACK;</span><br><span class="line">            insMaintain(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delCase1</span><span class="params">(Node * x, Node * y)</span> </span>&#123;</span><br><span class="line">        y-&gt;color = Node::BLACK;</span><br><span class="line">        y-&gt;fa-&gt;color = Node::RED;</span><br><span class="line">        y = y-&gt;ch[!y-&gt;rs];</span><br><span class="line">        rotate(x-&gt;fa, x-&gt;rs);</span><br><span class="line">        delCase2(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delCase2</span><span class="params">(Node * x, Node * y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y-&gt;ch[y-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y-&gt;ch[!y-&gt;rs]-&gt;color == Node::BLACK) &#123;</span><br><span class="line">                y-&gt;color = Node::RED;</span><br><span class="line">                delMaintain(y-&gt;fa);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                y-&gt;color = Node::RED;</span><br><span class="line">                y-&gt;ch[!y-&gt;rs]-&gt;color = Node::BLACK;</span><br><span class="line">                rotate(y, y-&gt;rs);</span><br><span class="line">                delCase3(y-&gt;fa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> delCase3(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delCase3</span><span class="params">(Node * y)</span> </span>&#123;</span><br><span class="line">        y-&gt;color = y-&gt;fa-&gt;color;</span><br><span class="line">        y-&gt;ch[y-&gt;rs]-&gt;color = y-&gt;fa-&gt;color = Node::BLACK;</span><br><span class="line">        rotate(y-&gt;fa, !y-&gt;rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delMaintain</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == root || x == null) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;color == Node::RED) &#123;</span><br><span class="line">            x-&gt;color = Node::BLACK;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node * y = x-&gt;fa-&gt;ch[!x-&gt;rs];</span><br><span class="line">        <span class="keyword">if</span> (y-&gt;color == Node::RED) delCase1(x, y);</span><br><span class="line">        <span class="keyword">else</span> delCase2(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node * <span class="title">pred</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// max elem &lt;= val</span></span><br><span class="line">        <span class="keyword">if</span> (x == null) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;key &gt; val) <span class="keyword">return</span> pred(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] == null) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> pred(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node * <span class="title">succ</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// min elem &gt;= val</span></span><br><span class="line">        <span class="keyword">if</span> (x == null) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;key &lt; val) <span class="keyword">return</span> succ(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] == null) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> succ(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node * x, elemType val)</span> </span>&#123; <span class="comment">// count elem &lt;= val</span></span><br><span class="line">        <span class="keyword">if</span> (x == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;key &gt; val) <span class="keyword">return</span> rank(x-&gt;ch[<span class="number">0</span>], val);</span><br><span class="line">        <span class="keyword">return</span> x-&gt;ch[<span class="number">0</span>]-&gt;sz + <span class="number">1</span> + rank(x-&gt;ch[<span class="number">1</span>], val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node * <span class="title">select</span><span class="params">(Node * x, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// k-th smallest elem</span></span><br><span class="line">        <span class="keyword">if</span> (x == null || x-&gt;sz &lt; k) <span class="keyword">return</span> null;</span><br><span class="line">        <span class="keyword">int</span> sz = x-&gt;ch[<span class="number">0</span>]-&gt;sz + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sz == k) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (sz &lt; k) <span class="keyword">return</span> select(x-&gt;ch[<span class="number">1</span>], k - sz);</span><br><span class="line">        <span class="keyword">return</span> select(x-&gt;ch[<span class="number">0</span>], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) <span class="built_in">clear</span>(x-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) <span class="built_in">clear</span>(x-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (x != null) <span class="keyword">delete</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node * x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"key = %d, sz = %d "</span>, x-&gt;key, x-&gt;sz);</span><br><span class="line">        <span class="built_in">puts</span>(x-&gt;color == Node::RED ? <span class="string">"RED"</span> : <span class="string">"BLACK"</span>);</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) <span class="built_in">print</span>(x-&gt;ch[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) <span class="built_in">print</span>(x-&gt;ch[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    Node * null;</span><br><span class="line">    RBT() &#123;</span><br><span class="line">        null = <span class="keyword">new</span> Node; <span class="comment">// no key, rs, father</span></span><br><span class="line">        null-&gt;ch[<span class="number">0</span>] = null-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">        null-&gt;sz = <span class="number">0</span>;</span><br><span class="line">        null-&gt;color = Node::BLACK;</span><br><span class="line">        root = null;</span><br><span class="line">        null-&gt;key = INF; <span class="comment">// for convenient</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node * <span class="title">search</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">        Node * x = root;</span><br><span class="line">        <span class="keyword">while</span> (x != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val == x-&gt;key) <span class="keyword">return</span> x;</span><br><span class="line">            x = x-&gt;ch[val &gt;= x-&gt;key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> Node; <span class="comment">// no father, rs</span></span><br><span class="line">            root-&gt;ch[<span class="number">0</span>] = root-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">            root-&gt;sz = <span class="number">1</span>;</span><br><span class="line">            root-&gt;color = Node::BLACK;</span><br><span class="line">            root-&gt;key = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node * x = root;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;ch[val &gt;= x-&gt;key] != null) &#123;</span><br><span class="line">            ++x-&gt;sz;</span><br><span class="line">            x = x-&gt;ch[val &gt;= x-&gt;key];</span><br><span class="line">        &#125;</span><br><span class="line">        newNode(x, val, val &gt;= x-&gt;key);</span><br><span class="line">        insMaintain(x-&gt;ch[val &gt;= x-&gt;key]);</span><br><span class="line">        root-&gt;color = Node::BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">        Node * x = search(val), * y;</span><br><span class="line">        <span class="keyword">if</span> (x == null) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;ch[<span class="number">0</span>] != null || x-&gt;ch[<span class="number">1</span>] != null) &#123;</span><br><span class="line">            <span class="keyword">bool</span> rs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;ch[rs] == null) rs = !rs;</span><br><span class="line">            y = x-&gt;ch[rs];</span><br><span class="line">            <span class="keyword">while</span> (y-&gt;ch[!rs] != null) y = y-&gt;ch[!rs];</span><br><span class="line">            <span class="built_in">std</span>::swap(x-&gt;key, y-&gt;key);</span><br><span class="line">            x = y;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;color == Node::RED) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        delMaintain(x);</span><br><span class="line">        root-&gt;color = Node::BLACK;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">while</span> (y != root) &#123;</span><br><span class="line">            y = y-&gt;fa;</span><br><span class="line">            --y-&gt;sz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == root) root = null;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">0</span>] != null) faSon(x-&gt;fa, x-&gt;ch[<span class="number">0</span>], x-&gt;rs);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;ch[<span class="number">1</span>] != null) faSon(x-&gt;fa, x-&gt;ch[<span class="number">1</span>], x-&gt;rs);</span><br><span class="line">        <span class="keyword">else</span> x-&gt;fa-&gt;ch[x-&gt;rs] = null;</span><br><span class="line">        <span class="keyword">delete</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">elemType <span class="title">pred</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pred(root, val)-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">elemType <span class="title">succ</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> succ(root, val)-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(elemType val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">elemType <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(root, k)-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">clear</span>(root);</span><br><span class="line">        root = null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;sz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != null) <span class="built_in">print</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// for particular use</span></span><br><span class="line">        <span class="keyword">return</span> select(root, rank(root, a) + k)-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="C-模板之图论"><a href="#C-模板之图论" class="headerlink" title="C++ 模板之图论"></a>C++ 模板之图论</h2><blockquote>
<p>图论还是一个特别强的工具。 为什么没有图论的 STL？</p>
</blockquote>
<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head, nxt, to;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; w;</span><br><span class="line">    LinkStar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        nxt.<span class="built_in">clear</span>();</span><br><span class="line">        to.<span class="built_in">clear</span>();</span><br><span class="line">        head = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL val)</span> </span>&#123;</span><br><span class="line">        nxt.emplace_back(head[u]);</span><br><span class="line">        head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">        to.emplace_back(v);</span><br><span class="line">        w.emplace_back(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="知乎上看到YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）"><a href="#知乎上看到YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）" class="headerlink" title="知乎上看到YYYYLLL 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）"></a>知乎上看到<a href="https: //www.zhihu.com/people/yyyylll-37">YYYYLLL</a> 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">j</span>] 表示只经过 1～k 号节点优化，i 点到 j 点的最短路径长度。</span><br><span class="line">则 DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">j</span>] = min( DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">j</span>], DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">k</span>]+DP[<span class="string">k-1</span>][<span class="symbol">k</span>][<span class="string">j</span>] ) </span><br><span class="line">= min( DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">j</span>], DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">k</span>]+DP[<span class="string">k</span>][<span class="symbol">k</span>][<span class="string">j</span>] ) </span><br><span class="line">DP[<span class="string">0</span>][<span class="symbol"></span>][<span class="string"></span>] 是初始图的邻接矩阵，DP[<span class="string">n</span>][<span class="symbol"></span>][<span class="string"></span>] 就是最终求得的最短路长度矩阵了</span><br></pre></td></tr></table></figure>
<p>本来一开始是没法做空间优化的， 但是第二个等式， 就保证了可以做空间优化<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line">LL dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k!=n;++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i&lt;<span class="number">0</span>; i!=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j!=n;++j)</span><br><span class="line">                dp[i][j] = <span class="built_in">std</span>::<span class="built_in">min</span>(dp[i][j],dp[i][k] + dp[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="dfs-序"><a href="#dfs-序" class="headerlink" title="dfs 序"></a>dfs 序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ncnt = <span class="number">0</span>; <span class="comment">// init every case</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">// dfs order</span></span><br><span class="line">    L[x] = ++ncnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].ed != fa) dfs(e[i].ed, x);</span><br><span class="line">    &#125;</span><br><span class="line">    R[x] = ncnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="笛卡尔树-：我去，竟然是-O-n-复杂度的建树"><a href="#笛卡尔树-：我去，竟然是-O-n-复杂度的建树" class="headerlink" title="笛卡尔树 ：我去，竟然是 $O(n)$ 复杂度的建树"></a><a href="https: //oi-wiki.org/ds/cartesian-tree/">笛卡尔树</a> ：我去，竟然是 $O(n)$ 复杂度的建树</h3><blockquote>
<p>从<a href="https: //oi-wiki.org/ds/cartesian-tree/">OI - wiki</a> 中看到的讲解和复杂度分析!，注意到右链是从尾巴网上查找的。<br><a href="http: //acm.hdu.edu.cn/showproblem.php?pid=1506"><strong>hdu 1506</strong></a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, val, par, ch[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _id, <span class="keyword">int</span> _val, <span class="keyword">int</span> _par)</span> </span>&#123;</span><br><span class="line">        id = _id, val = _val, par = _par, ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cartesian_build</span><span class="params">(Node * tree, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tree[k].val &gt; tree[i].val) k = tree[k].par;</span><br><span class="line">        tree[i].ch[<span class="number">0</span>] = tree[k].ch[<span class="number">1</span>];</span><br><span class="line">        tree[k].ch[<span class="number">1</span>] = i;</span><br><span class="line">        tree[i].par = k;</span><br><span class="line">        tree[tree[i].ch[<span class="number">0</span>]].par = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>].ch[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        Node tree[n + <span class="number">1</span>];</span><br><span class="line">        tree[<span class="number">0</span>].init(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            tree[i].init(i, x, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = cartesian_build(tree, n);</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        function &lt; <span class="keyword">int</span>(<span class="keyword">int</span>) &gt; dfs = [ &amp; ](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sz = dfs(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">            sz += dfs(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, LL(sz + <span class="number">1</span>) * tree[x].val);</span><br><span class="line">            <span class="keyword">return</span> sz + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就给出了一个$O(n) $复杂度求出包含 <code>i</code>且以 <code>a[i]</code> 为最小值的区间的方法。 太强了！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> root = cartesian_build(tree, n);</span><br><span class="line"><span class="keyword">int</span> l[n + <span class="number">1</span>], r[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; getinterval = [ &amp; ](<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree[tree[x].par].ch[<span class="number">0</span>] == x) &#123;</span><br><span class="line">        r[x] = tree[x].par - (tree[x].val != tree[tree[x].par].val);</span><br><span class="line">        l[x] = l[tree[x].par];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l[x] = tree[x].par + (tree[x].val != tree[tree[x].par].val);</span><br><span class="line">        r[x] = r[tree[x].par];</span><br><span class="line">    &#125;</span><br><span class="line">    getinterval(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">    getinterval(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br><span class="line">l[root] = <span class="number">1</span>;</span><br><span class="line">r[root] = n;</span><br><span class="line">getinterval(tree[root].ch[<span class="number">0</span>]);</span><br><span class="line">getinterval(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; l[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; r[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>洛谷 T126268 「SWTR-05」Subsequence 有一个典型的应用</p>
</blockquote>
<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, w, next;</span><br><span class="line">&#125;</span><br><span class="line">a[N * N];</span><br><span class="line"><span class="keyword">int</span> n, ss, head[N], p[N], flow[N], c[N], h[N], numh[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    a[ss].t = y;</span><br><span class="line">    a[ss].w = w;</span><br><span class="line">    a[ss].next = head[x];</span><br><span class="line">    head[x] = ss++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow, ans = <span class="number">0</span>, neck, k;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span> (h));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memset</span>(numh, <span class="number">0</span>, <span class="keyword">sizeof</span> (numh));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span> (p));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = head[i];</span><br><span class="line">    numh[<span class="number">0</span>] = n;</span><br><span class="line">    <span class="keyword">int</span> u = s;</span><br><span class="line">    <span class="keyword">while</span> (h[s] &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == t) &#123;</span><br><span class="line">            flow = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i != t; i = a[c[i]].t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flow &gt; a[c[i]].w) &#123;</span><br><span class="line">                    neck = i;</span><br><span class="line">                    flow = a[c[i]].w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i != t; i = a[c[i]].t) &#123;</span><br><span class="line">                a[c[i]].w -= flow;</span><br><span class="line">                a[c[i] ^ <span class="number">1</span>].w += flow;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += flow;</span><br><span class="line">            u = neck;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = c[u]; k != <span class="number">-1</span>; k = a[k].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[k].w &amp;&amp; h[u] == h[a[k].t] + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="number">-1</span>) &#123;</span><br><span class="line">            c[u] = k;</span><br><span class="line">            p[a[k].t] = u;</span><br><span class="line">            u = a[k].t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == --numh[h[u]]) <span class="keyword">break</span>;</span><br><span class="line">            c[u] = head[u];</span><br><span class="line">            k = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = a[i].next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i].w) k = <span class="built_in">std</span>::<span class="built_in">min</span>(k, h[a[i].t]);</span><br><span class="line">            &#125;</span><br><span class="line">            h[u] = k + <span class="number">1</span>;</span><br><span class="line">            ++numh[h[u]];</span><br><span class="line">            <span class="keyword">if</span> (u != s) u = p[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Stoer-Wagner-最小割"><a href="#Stoer-Wagner-最小割" class="headerlink" title="Stoer - Wagner 最小割"></a>Stoer - Wagner 最小割</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], dis[N], mp[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mincut</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) p[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != n; ++i) &#123;</span><br><span class="line">            dis[p[i]] = mp[p[<span class="number">0</span>]][p[i]];</span><br><span class="line">            <span class="keyword">if</span> (dis[p[i]] &gt; dis[p[t]]) t = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> (vis));</span><br><span class="line">        vis[p[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ret &gt; dis[p[t]]) ret = dis[p[t]];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != n; ++j) &#123;</span><br><span class="line">                    mp[p[j]][p[s]] += mp[p[j]][p[t]];</span><br><span class="line">                    mp[p[s]][p[j]] = mp[p[j]][p[s]];</span><br><span class="line">                &#125;</span><br><span class="line">                p[t] = p[--n];</span><br><span class="line">            &#125;</span><br><span class="line">            vis[p[t]] = <span class="literal">true</span>;</span><br><span class="line">            s = t;</span><br><span class="line">            t = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j != n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[p[j]]) &#123;</span><br><span class="line">                    dis[p[j]] += mp[p[j]][p[s]];</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="number">-1</span> || dis[p[j]] &gt; dis[p[t]]) t = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路-SPFA"><a href="#最短路-SPFA" class="headerlink" title="最短路 SPFA"></a>最短路 SPFA</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1004</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], rehead[N], dist[N], sc, v[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> g;</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> x, <span class="keyword">int</span> y): id(x), g(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> g + dist[id] &gt; a.g + dist[a.id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ed;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;</span><br><span class="line">e[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    e[sc].ed = y;</span><br><span class="line">    e[sc].w = z;</span><br><span class="line">    e[sc].next = head[x];</span><br><span class="line">    head[x] = sc++;</span><br><span class="line">    e[sc].ed = x;</span><br><span class="line">    e[sc].w = z;</span><br><span class="line">    e[sc].next = rehead[y];</span><br><span class="line">    rehead[y] = sc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> (v));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> (dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    v[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span> &lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rehead[u]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> ed = e[i].ed;</span><br><span class="line">            <span class="keyword">if</span> (dist[ed] &gt; dist[u] + e[i].w) &#123;</span><br><span class="line">                dist[ed] = dist[u] + e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!v[ed]) &#123;</span><br><span class="line">                    v[ed] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(ed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v[u] = <span class="literal">false</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维凸包"><a href="#二维凸包" class="headerlink" title="二维凸包"></a>二维凸包</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">int</span> vc[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Node &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x != A.x || y != A.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; A) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y == A.y) <span class="keyword">return</span> x &lt; A.x;</span><br><span class="line">        <span class="keyword">return</span> y &lt; A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N], q[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLeft</span><span class="params">(<span class="keyword">const</span> Node &amp; op,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> Node &amp; sp,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> Node &amp; ep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (sp.x - op.x) * (ep.y - op.y) &gt; (sp.y - op.y) * (ep.x - op.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">graham</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    sort(p, p + n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = p[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>] = p[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    q[<span class="number">2</span>] = p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i != n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; crossLeft(q[top], p[i], q[top - <span class="number">1</span>])) --top;</span><br><span class="line">        q[++top] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = top;</span><br><span class="line">    q[++top] = p[n - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">3</span>; i != <span class="number">-1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top != len &amp;&amp; crossLeft(q[top], p[i], q[top - <span class="number">1</span>])) --top;</span><br><span class="line">        q[++top] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="几类根号算法"><a href="#几类根号算法" class="headerlink" title="几类根号算法"></a>几类根号算法</h2><h3 id="s-n-sum-i-1-n-lfloor-frac-n-i-rfloor"><a href="#s-n-sum-i-1-n-lfloor-frac-n-i-rfloor" class="headerlink" title="$ s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $"></a>$ s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">        j = n / (n / i);</span><br><span class="line">        sum += (j - i + <span class="number">1</span>) * (n / i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i"><a href="#sum-i-1-n-lfloor-frac-n-i-rfloor-lfloor-frac-m-i-rfloor-f-i" class="headerlink" title="$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$"></a>$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// g[i]=f[i]+g[i-1]</span></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= <span class="built_in">min</span>(n, m); i = j + <span class="number">1</span>) &#123;</span><br><span class="line">        j = <span class="built_in">min</span>(n / (n / i), m / (m / i) sum += LL(n / i) * (m / i) * (g[j] - g[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor"><a href="#h-n-frac-n-n-1-n-2-3-sum-i-2-n-h-lfloor-frac-n-i-rfloor" class="headerlink" title="$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$"></a>$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">int</span> r = LL(n) * (n - <span class="number">1</span>) % M * (n - <span class="number">2</span>) % M * inv3 % M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">        j = n / (n / i);</span><br><span class="line">        r -= LL(j - i + <span class="number">1</span>) * getans(n / i) % M;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) r += M;</span><br><span class="line">    &#125;</span><br><span class="line">    mp.insert(<span class="built_in">std</span>::make_pair(n, r));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归算法复杂度分析"><a href="#递归算法复杂度分析" class="headerlink" title="递归算法复杂度分析"></a>递归算法复杂度分析</h2><p>下图取自算法导论</p>
<p><img src= "/img/loading.gif" data-lazy-src="complexAnalysis.png" alt="complexAnalysis"></p>
<h2 id="STL-学习记录"><a href="#STL-学习记录" class="headerlink" title="STL 学习记录"></a>STL 学习记录</h2><p>为了更加 <strong>优雅</strong> 的写 C++，在学了一点 C++17 皮毛之后，重新探索了一下 C++ STL，总结一些好用的特征。</p>
<p><code>static_cast&lt;T&gt;, optional&lt;T&gt;</code> 是两个好东西。</p>
<p>等到 Codeforces 支持 <code>C++20</code> 后开始学习 <code>C++2x</code></p>
<blockquote>
<p>没有必要关心你自己不用的特征！用的就一定要搞清楚。</p>
</blockquote>
<p>以下示例中，凡是 Vector 类型的 <code>a.begin(),a.end()</code> 对应的数组类型都可以改成 <code>a,a+n</code>。</p>
<h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p><code>min,max,minmax</code> 都是参数个数为 2，返回的是值。所以不举例了没注意到<code>minmax</code>返回的是<code>pair</code></p>
<p><code>min_element,max_element,minmax_element</code>参数都是<code>Vector</code>，且返回的是索引。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *max_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span> lr = minmax_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//不能取*,因为返回的是pair类型</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *lr.first &lt;&lt; <span class="string">" "</span> &lt;&lt; *lr.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">auto</span>[l, r] = minmax_element(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">//自动解析也行</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *l &lt; <span class="string">" "</span> &lt;&lt; *r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="累积运算-accumulate-（长没关系，有代码补全）"><a href="#累积运算-accumulate-（长没关系，有代码补全）" class="headerlink" title="累积运算  accumulate （长没关系，有代码补全）"></a>累积运算  accumulate （长没关系，有代码补全）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//默认累和</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//可选加减乘除</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="built_in">std</span>::minus&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>, <span class="built_in">std</span>::multiplies&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>, <span class="built_in">std</span>::divides&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; accumulate(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>, [](<span class="keyword">auto</span> &amp; x, <span class="keyword">auto</span> &amp; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * x + y;</span><br><span class="line">&#125;) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>用 <code>stable_sort</code> 是稳定排序，即不改变原有相互不小于的元素的相对位置</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 默认从小到大排序</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 手动从小到大排序（不一定是int，具体问题具体修改）</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.rbegin(), a.<span class="built_in">end</span>()); <span class="comment">// 从大到小排序</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 从大到小排序</span></span><br><span class="line"><span class="comment">//对于 tuple 和 pair 大小关系都是从按照字典序比较的</span></span><br><span class="line"><span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="keyword">int</span> &amp; x, <span class="keyword">int</span> &amp; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> (x ^ <span class="number">4</span>) &lt; (y ^ <span class="number">4</span>); <span class="comment">// 位运算的优先级好低呀</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="集合交并运算"><a href="#集合交并运算" class="headerlink" title="集合交并运算"></a>集合交并运算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::et&lt;<span class="keyword">int</span>&gt; x&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; y&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line"><span class="built_in">std</span>::set_intersection(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>(), y.<span class="built_in">end</span>(), <span class="built_in">std</span>::inserter(t, t.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// 若x,y,t是vector等有push_back 的容器，就可以使用</span></span><br><span class="line"><span class="comment">// set_intersection(x.begin(),x.end(),y.begin(),y.end(),back_inserter(t));</span></span><br><span class="line"><span class="comment">// set_union,set_difference,set_symmetric_difference 等同理</span></span><br></pre></td></tr></table></figure>
<h3 id="lambda-表达式递归写法"><a href="#lambda-表达式递归写法" class="headerlink" title="lambda 表达式递归写法"></a>lambda 表达式递归写法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; gcd = [ &amp; ](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="comment">// 注意最前面不能用auto</span></span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; gcd(<span class="number">102</span>, <span class="number">210</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::__gcd(<span class="number">102</span>, <span class="number">210</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="C-STL-内建的一些好用的函数"><a href="#C-STL-内建的一些好用的函数" class="headerlink" title="C++ STL 内建的一些好用的函数"></a>C++ STL 内建的一些好用的函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::__builtin_parity(uint n):   返回n的二进制<span class="number">1</span>的个数奇偶性</span><br><span class="line"><span class="built_in">std</span>::__builtin_clz(uint n)：     返回n的二进制前置<span class="number">0</span>的个数</span><br><span class="line"><span class="built_in">std</span>::__builtin_ctz(uint n):      返回n的二进制后置<span class="number">0</span>的个数</span><br><span class="line"><span class="built_in">std</span>::__builtin_ffs(<span class="keyword">int</span> n)：      返回n的二进制从后往前第一次出现<span class="number">1</span>的位置</span><br><span class="line"><span class="built_in">std</span>::__lg(<span class="keyword">int</span> n):                返回log2(n)的整数部分</span><br><span class="line">= <span class="built_in">std</span>::__builtin_ctz(uint n)+<span class="number">1</span></span><br><span class="line"><span class="built_in">std</span>::__builtin_popcount(uint n): 返回n的二进制<span class="number">1</span>的个数，以上函数仅在GCC中有</span><br><span class="line">lowbit(uint n): n&amp;(-n)      返回使得最大的<span class="number">2</span>^i|n <span class="comment">// 这个不是内建的</span></span><br><span class="line"><span class="comment">//产生大的随机数</span></span><br><span class="line"><span class="built_in">std</span>::mt19937 rnd(<span class="built_in">std</span>::chrono::steady_clock::now().time_since_epoch().count());</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h2><h2 id="日常表白-zly"><a href="#日常表白-zly" class="headerlink" title="日常表白 zly"></a>日常表白 zly</h2>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Matsumura《Commutative Algebra》读书笔记</title>
    <url>/commutativeAlgebraByMatsumura/</url>
    <content><![CDATA[<p>在学习非交换环论的过程中, 发现交换环有些东西依然没搞清楚, 复习一下, 顺便再理一理 Matsumura 这本言简意赅的《Commutative Algebra》. 以下环都是指 <strong>含幺交换环(commutative ring with identity)</strong></p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>可以说书中没一句废话, 开头直接给出下面概念, 并且叙述一些常见等价刻画: </p>
<ol>
<li><p>理想的 radical 的定义</p>
</li>
<li><p>prime ideal 的(等价)定义</p>
</li>
<li><p>primary ideal 的定义, 说明 primary ideal 的 radical 是 prime ideal (反之不尽然), 并给出一个理想成为 primary ideal 的充分条件: 包含某个极大理想的某次幂.</p>
</li>
<li><p>定义了环 $A$ 上的 Zariski 拓扑(素谱) $Spec(A)$, 极大谱 $\Omega(A)$, 包含某个集合的素理想全体构成闭集(容易验证确实构成拓扑空间), 给出素谱的基本开邻域基. 由于每个理想都包含在某个极大理想中, 极大理想都是素的, 因此 $Spec(A) = \emptyset \Leftrightarrow A = 0$, 也就是说 $Spec$ 的定义是没有毛病的. $Spec(A)$ 连通当且仅当 $A$ 中无非平凡幂等元.</p>
<script type="math/tex; mode=display">
V(I) = V(J) \Longleftrightarrow \sqrt{I} = \sqrt{J}</script></li>
<li><p>说明环之间的同态映射 $f: A \to B$ 可以诱导 $Spec(B) \to Spec(A)$ 之间的连续映射, 也就是说 $Spec$ 定义了一个环范畴到拓扑空间范畴的一个逆变函子.</p>
</li>
<li><p>给出了一个关于素理想并的常见引理: 一个理想包含在最多两个不是素理想的理想的并中, 则它必然包含在其中一个理想中. 当然这也说明了任意两个真理想的并不会是整个环.</p>
</li>
<li><p>给出了两个理想互素的定义(和为整个环), 并说明此时它们的积等于交. 证明用到 $(I+J)(I \cap J) \subset IJ$.</p>
</li>
<li><p>定义乘闭子集 $S$ 准备做局部化, 应用 Zorn 引理说明与 $S$ 不相交的理想中任意极大元都是素理想, 由此可以证明: $A$ 中幂零元全体 $nil(A)$ 是 $A$ 中所有素理想的交, 也等于 $A$ 中所有极小素理想的交. 再由此结论, 可以说明每个理想 $I$ 的 radical: $\sqrt{I}$ 是所有包含 $I$ 的素理想的交.</p>
</li>
<li><p>定义环 $A$ 在 $S$ 处的局部化 $S^{-1}A$. $S^{-1}A = 0 \Leftrightarrow 0 \in S$. 并且我们有自然映射 $\phi : A \to S^{-1}A, \quad a \mapsto a/1$, 它满足泛性质: 若 $f: A \to B$ 是环同态, 且 $f(S)$ 均为 $B$ 中可逆元, 那么有 $g: S^{-1}A \to B$ 使得 $f = g \phi$</p>
</li>
<li><p>$A$ 中与 $S$ 不交的理想(素, 准素)和 $S^{-1}A$ 中的理想(素, 准素)有保序一一对应.</p>
</li>
<li><p>类似于环, 可以对模 $M$ 作局部化$S^{-1}M \simeq S^{-1}A \otimes M$, 这个同构可以由两个自然的合理的互逆映射给出. 并且我们还有同构 $S^{-1}(M \otimes N) = S^{-1} M \otimes S^{-1}N$. 由于张量函子右正合, 用定义可以证明 $S^{-1}A \otimes -$ 是正合函子. 也就是说 $S^{-1}A$ 是平坦 $A$-模.</p>
</li>
<li><p>给出有限表示(finite presentation)的定义: 即一个有限生成模, 且其生成关系也是有限生成的. 等价于说有正合列: $A^m \to A^n \to M \to 0$ 此时我们有:</p>
<script type="math/tex; mode=display">
S^{-1}(\hom(M,N)) \simeq \hom(S^{-1}M, S^{-1}N)</script><p>证明的关键在于对于自由模$M=A^n$时有上述自然同构, 再由有限表示, 应用 five lemma 证明上式.</p>
</li>
<li><p><strong>局部整体关系</strong> $M \to \prod_{\max p} M_{p}$ 是单的. 其中 $M_{p} = (A - p)^{-1} M$. 证明应用定义说明 $Ann(x) = A$ 即可.</p>
</li>
<li><p><strong>整环的特殊情形</strong> 当 $A$ 为整环时, $A$ 在任意乘闭子集处的局部化都可以看做它的分式域的子环, 实际上我们有</p>
<script type="math/tex; mode=display">
A = \bigcap_{\max p} A_{p}</script><p>证明类似整数作有理数. 定义 $D = \lbrace a \in A | ax \in A \rbrace$ 说明若 $x \notin A$ 可知 $D \subset A$ (真包含), 因此 $D$ 在某个极大理想 $P$ 中, 可推出 $x \notin A_{P}$.</p>
</li>
<li><p>我们有自然的同构 $A/I \otimes M \simeq M/IM$, 同构可由正合列 $0 \to I \to A \to A/I \to 0$, 用 $- \otimes M$ 作用上去, 再由定义有 $I \otimes M \to IM$ 的自然满同态( $M$ 平坦时可以说明是同构), 得到正合列: $0 \to IM  \to M \to A/I \otimes M \to 0$<br>特别地, 我们有: $S^{-1}(A/I) = S^{-1}A / I(S^{-1}A)$</p>
</li>
<li><p><strong>Jacobson radical</strong>: $rad(A) = \lbrace x| 1+xy \in U(A) \rbrace$ 为所有极大理想的交.</p>
</li>
<li><p><strong>局部环</strong>: 若环 $A$ 只有一个极大素理想 $\mathfrak{m}$, 则称 $A$ 为局部环, $A/\mathfrak{m}$ 称为 $A$ 的 residue field.<br>局部环之所以重要是因为, 任意环 $A$ 在素理想 $p$ 处作局部化都是一个局部环 $A_p$. 此时 $A_p$ 的 residue field 记作 $k(p)$. 它恰好是整环 $A/p$ 的分式域 $K(A/p)$. 由 $A \to A/p$ 到 $A_p \to K(A/p)$ 因此, 我们有 $k(p) \simeq K(A/p)$</p>
</li>
<li><p><strong>局部映射</strong>: 若环 $(A, \mathfrak{m}, k)$ 和 $(A’, \mathfrak{m}’, k’)$ 为局部环, 且有环同态 $\phi: A \to A’$ 使得 $\phi(\mathfrak{m}) \subseteq \mathfrak{m}’$, 则称为局部映射, 此时 $\phi$ 自然诱导了环同态 $k \to k’$.<br>现在对任意环同态 $\phi: A \to B$, 考虑连续映射</p>
<script type="math/tex; mode=display">
\hat{\phi}: Spec(B) \to Spec(A), \quad P \to \phi^{-1}(P) = P \cap A = p</script><p>此时 $\phi(A-p) \subseteq B-P$, 即 $\phi$ 诱导了局部映射 $\phi_P: A_p \to B_P$.</p>
</li>
<li><p><strong>半局部环</strong> 若环 $A$ 只有有限个极大理想 $\mathfrak{m}_1, \mathfrak{m}_2, \cdots , \mathfrak{m}_r$, 则称 $A$ 为半局部环(semilocal ring).<br>由于不同极大理想必然互素, 因此</p>
<script type="math/tex; mode=display">
rad(A) = \mathfrak{m}_1 \cap \cdots \cap \mathfrak{m}_r = \prod \mathfrak{m}_i</script></li>
<li><p><strong>NAK lemma</strong> 设 $I$ 是环 $A$ 的理想, $M$ 是有限生成(f.g.) $A$-模. 若 $IM = M$, 则存在 $t \in I$ 使得 $(1+t)M = 0$, 特别地, 若还有 $I \subseteq rad(A)$, 则 $M=0$.<br><strong>Proof</strong>: 设 $M=Am_1 + \cdots + Am_s$, 对 $s$ 数学归纳, $s=0$ 时, 结论显然, 设 $M’ = M / Am_s$, 则由归纳假设, $\exists x \in I$ 使得 $(1+x)M’=0$, 即 $(1+x)M \subseteq Aw_s$, 由于 $M = IM$, 我们有 $(1+x)M = I(1+x)M \subseteq I(Aw_s) = Iw_s$, 因此存在 $y \in I$ 使得 $(1+x)w_s = yw_s$. 所以<br>$(1+x-y)(1+x)M = 0$, $t = x-y+x+(x-y)x$ 即为所求.<br><strong>NAK lemma</strong> 常用如下应用形式: $I$ 为环 $A$ 的理想, $N \subset M$ 为 $A$-模, 若 $M = N + IM$, 且 $I$ 幂零或 $M$ 有限生成, 则 $M=N$.</p>
</li>
</ol>
<blockquote>
<p>不要以为有限生成, 理想幂零, 环是整环或者 reduced 条件很苛刻, 其实实际碰到的也都是这些环, 主要问题在于有没有丰富的结果, 这些条件在何时发挥着作用. 有限生成可以用数学归纳, 幂零理想可以用于幂次和根理想.</p>
</blockquote>
<ol>
<li>给定局部环 $(A, \mathfrak{m},k)$ , $M$ 是 $A$-模, 若 $\mathfrak{m}$ 幂零(例如 $A$ 是 Artinian)或者 $M$ 有限生成, 则 $M$ 的子集 $G$ 生成 $M$, 当且仅当它在 $M/\mathfrak{m}M = M \otimes k$ 下像 $\bar{G}$ 生成 $M \otimes k$.</li>
</ol>
<blockquote>
<p>由于 $M \otimes k$ 是域 $k$ 上的向量空间, 因此它的一组基提升之后就能生成 $M$, 但是一般地并不能保证这些生成元线性无关.</p>
</blockquote>
<ol>
<li><p>$M$-regular: $a \in A$ 称为 $M$-regular, 若 $0 \to M \xrightarrow{a} M$, 显然, $M$-regular 元全体构成了一个乘闭子集. 设 $S_0$ 为 $A$-regular 元全体, 则 $S_0^{-1}A$ 称为 $A$ 的 total quotient ring. 此时 $\phi: A \to S_0^{-1} A$ 是环单同态.</p>
</li>
<li><p>若 $M$ 是 Noetherian 环 $A$ 上有限生成模,那么我们有投射表示:</p>
<script type="math/tex; mode=display">
\cdots \to X_i \to X_{i+1} \to \cdots X_0 \to M \to 0</script><p>其中 $X_i$ 为有限自由 $A$-模, 特别地, 此时 $M$ 是有限表示(finite presentation). 此时多项式环 $A[x_1, \cdots, x_n]$ 也是 Noetherian, 类似的形式幂级数环 $A[[x_1, \cdots, x_n]]$ 也是 Noetherian, $A$ 上的有限维代数也是 Noetherian.</p>
</li>
</ol>
<blockquote>
<p>任意环中, 理想链的长度不低于极大理想的个数.</p>
</blockquote>
<ol>
<li><p>环 $A$ 是 Artinian, 当且仅当它作为 $A$-模是有限长的, 当且仅当它是 Noetherian, 并且它的素理想都是极大的.</p>
</li>
<li><p>设 $\mathfrak{a}$ 是环 $A$ 的理想, $b \in A$, 若 $\mathfrak{a} + bA$ 和 $\mathfrak{a}:bA$ 都有限生成, 则 $\mathfrak{a}$ 有限生成.<br><strong>Proof</strong>: 设 $a_i \in \mathfrak{a},\quad b_j \in A$ 使得 $\mathfrak{a} + bA = \sum a_iA + bA$ 且 $\mathfrak{a} : bA = \sum c_j A$. 设 $\mathfrak{a}’ = \sum a_iA + \sum bc_j A \subseteq \mathfrak{a}$. 对任意 $a \in \mathfrak{a}$, 我们有 $a \in \mathfrak{a}’ + bA$, 即 $a \equiv rb \mod \mathfrak{a}’$. 因此 $rb \in \mathfrak{a}$. 即 $r \in \mathfrak{a}: bA$, $rb \in \mathfrak{a}’$, 因此 $a \in \mathfrak{a}’$, 即 $\mathfrak{a} = \mathfrak{a}’$.</p>
</li>
<li><p>(Cohen)环 $A$ 是 Noetherian, 当且仅当它的每个素理想都是有限生成的.<br><strong>Proof</strong>: 记 $A$ 中所有非有限生成理想构成的集合为 $F$, 取 $F$ 中极大元 $\mathfrak{a}$ (Zorn 引理保证可行性), 那么由条件知道 $\mathfrak{a}$ 不是素理想, 因此存在 $a,b \in A$, 使得 $a, b \notin \mathfrak{a}$ 且 $ab \in \mathfrak{a}$. 又因为 $\mathfrak{a}$ 的极大性知: $\mathfrak{a}+bA$ 和 $\mathfrak{a}:bA$ 有限生成, 所以 $\mathfrak{a}$ 有限生成, 所以 $F = \emptyset$.</p>
</li>
<li><p>定义 $Supp(M) = \lbrace p \in Spec(A) | M_p \neq  0 \rbrace$. 若 $M$ 有限生成, 则 $Supp(M) = V(Ann(M))$. 此时 $Supp(M)$ 就是零化 $M$ 的理想的闭包, 没毛病, 完美.</p>
</li>
</ol>
<h2 id="平坦性-Flatness"><a href="#平坦性-Flatness" class="headerlink" title="平坦性(Flatness)"></a>平坦性(Flatness)</h2><p>设 $S: \quad \cdots \to N  \to N’ \to N’’ \to \cdots$ 是任意 $A$-模序列.<br>称 $A$-模 $M$ 是平坦的, 如果 $S$ 正合, 则 $S \otimes M$ 正合.<br>称 $M$ 忠实平坦的(faithful flat), 如果 $S$ 正合当且仅当 $S \otimes M$ 正合.<br>例子: 投射模是平坦的, 自由模是忠实平坦的.</p>
<h4 id="平坦模的等价刻画"><a href="#平坦模的等价刻画" class="headerlink" title="平坦模的等价刻画"></a>平坦模的等价刻画</h4><ol>
<li>$M$ 是平坦的.</li>
<li>若 $0 \to N \to N’$ exact, 则 $0 \to N \otimes M \to N’ \otimes M$ exact.</li>
<li>对任意(有限生成)理想 $I$, $0 \to I \otimes M \to M$ exact. 即 $I \otimes M \simeq IM$.</li>
<li>$Tor_1 ^A(M,A/I) = 0$ 对任意(有限生成)理想 $I$ 成立.</li>
<li>$Tor_1 ^A(M,N) = 0$ 对任意(有限生成)模 $N$ 成立.</li>
<li>若 $\sum a_i x_i = 0$, 则存在 $b_{ij} \in A, y_j \in M$ 使得 $\sum a_i b_{ij} = 0$ 且 $x_i = \sum b_{ij}y_j$.</li>
</ol>
<h4 id="平坦模的基本性质"><a href="#平坦模的基本性质" class="headerlink" title="平坦模的基本性质"></a>平坦模的基本性质</h4><p><strong>Transitivity</strong>: 设 $\phi: A \to B$ 是平坦环同态(即 $B$ 看做 $A$-模是平坦的), 那么平坦 $B$-模 $N$ 也是平坦 $A$-模. (直接用定义证明即可)</p>
<p><strong>Change of base</strong>: 设 $\phi: A \to B$ 是环同态, 若 $M$ 是平坦 $A$-模, 则 $M \otimes B$ 是平坦 $B$-模.</p>
<p><strong>Localization</strong>: $S^{-1}A$ 是平坦 $A$-模. (直接用元素定义可证)</p>
<p><strong>Tor 函子和张量函子交换</strong>: 设 $\phi: A \to B$ 是平坦同态, $M,N$ 是 $A$-模, 则有</p>
<script type="math/tex; mode=display">
Tor_i ^A(M,N) \otimes _A B = Tor_i ^B(M \otimes_A B,N \otimes_A B)</script><p>当 $A$ Noetherian 且 $M$ 有限生成, 则</p>
<script type="math/tex; mode=display">
Ext_i ^A(M,N) \otimes _A B = Ext_i ^B(M \otimes_A B,N \otimes_A B)</script><p><strong>Proof</strong>: 给定 $M$ 的一个投射(自由)表示: $\cdots \to X_1 \to X_0 \to M \to 0$. 由于 $B_A$ 平坦, 我们得到 $M \otimes_A B$ 的投射表示: $\cdots \to X_1 \otimes_A B  \to X_0 \otimes_A B \to M \otimes_A B \to 0$. 因此我们有:</p>
<script type="math/tex; mode=display">
Tor_i ^B(M \otimes_A B,N \otimes_A B) = H_i(X. \otimes_A N \otimes_A B) = H_i(X. \otimes_A N)\otimes_A B = Tor_i ^A(M,N) \otimes _A B</script><p>当 $A$ Noetherian 且 $M$ 有限生成时, 我们可以给 $M$ 的一个有限自由表示, 再由 $B$ 平坦得到了, $M \otimes _A B$的有限自由表示:<br>$\cdots \to X_1 \otimes_A B \to X_0 \otimes_A B \to M \otimes_A B \to 0$ 由此得到复形:</p>
<script type="math/tex; mode=display">
0 \to \hom_B(M \otimes _A B, N \otimes _A B) \to  \hom_B(X_0 \otimes _A B, N \otimes _A B) \to \hom_B(X_1 \otimes _A B, N \otimes _A B) \to \cdots</script><p>由于 $X_i$ 是有限自由模, 因此 $\hom_B(X_i \otimes B, N \otimes B) = \hom_A(X_i, N) \otimes _A B$. 所以</p>
<script type="math/tex; mode=display">
Ext_i ^B(M \otimes_A B,N \otimes_A B) = H_i(\hom_A(X_i, N) \otimes _A B) = H_i(\hom_A(X_i, N)) \otimes _A B = Ext_i ^A(M,N) \otimes _A B</script><blockquote>
<p>特别地, 去 $B = S^{-1}A$.</p>
</blockquote>
<p>设 $M$ 是平坦 $A$-模, 则 $A$-regular 元都是 $M$-regular 元. 这只因为 $0 \to A \xrightarrow{a} A$ 可推出 $0 \to M \xrightarrow{a}M$.</p>
<h4 id="局部环上有限生成模是自由模"><a href="#局部环上有限生成模是自由模" class="headerlink" title="局部环上有限生成模是自由模"></a>局部环上有限生成模是自由模</h4><p>$(A,\mathfrak{m},k)$ 是局部环, $M$ 是平坦 $A$-模, 若 $\mathfrak{m}$ 幂零或 $M$ 有限生成, 则 $M$ 是自由模.<br>在<strong>基本概念 21</strong>中, $G$ 生成了 $M$, 如果 $G$ 中元素线性无关, 那么 $G$ 自然就是 $M$ 的一组基(从而是自由模), 也就是说, 我们只需证明 $G =\lbrace x_1 \cdots x_n \rbrace$在 $M/mM = M \otimes k$下的象线性无关, 则由 $G$ 线性无关. 而<strong>$\mathfrak{m}$ 幂零或 $M$ 有限生成</strong>这个条件本质上是保证 $M/mM \neq 0$ (由 NAK lemma). 然后对 $n$ 应用数学归纳, 并利用 <strong>平坦模等价刻画 6</strong> 说明线性无关性. 从而命题得证.</p>
<blockquote>
<p>局部环上的投射模都是自由模</p>
</blockquote>
<h4 id="平坦模"><a href="#平坦模" class="headerlink" title="平坦模"></a>平坦模</h4><p>设 $A \to B$ 是平坦同态, 设 $I,J$ 是 $A$ 是理想, 则</p>
<ol>
<li>$(I \cap J)B = IB \cap JB$ </li>
<li>$(I : J)B = IB : JB$, 其中$J$是有限生成的.</li>
</ol>
<p><strong>Proof</strong>: 由正合列: $0 \to I \cap J \to A \to A/I \otimes A/J$, 张量上 $B$得到 $0 \to (I \cap J)B \to B \to B/IB \otimes B/JB$. 因此 $(I \cap J)B = IB \cap JB$.<br>当 $J$ 有限生成时, 只需证明 $J = aA$ 的形式: 由正合列 $0 \to (I :aA) \to A \xrightarrow{f} \to A/I$. 其中 $f(x) = ax \mod I$. 张量上 $B$ 即可得到结论, 对于一般情况应用</p>
<script type="math/tex; mode=display">
(I: \sum_{i=1} ^n a_i A) = \bigcap_{i=1} ^n (I : a_i A)</script><blockquote>
<p>平坦映射讲一个保持理想的交, 一种反映平坦的地方吧.</p>
</blockquote>
<h4 id="平坦的局部整体性"><a href="#平坦的局部整体性" class="headerlink" title="平坦的局部整体性"></a>平坦的局部整体性</h4><p>设 $f: A \to B$ 是环同态(即 $B$ 是交换结合 $A$ 代数), 那么下面条件等价:</p>
<ol>
<li>$B$ 作为 $A$-模平坦.</li>
<li>$B_P$ 作为 $A_p$-模平坦, 其中 $p = P \cap A, \quad P \in Spec(B)$</li>
<li>$B_P$ 作为 $A_p$-模平坦, 其中 $p = P \cap A, \quad P \in \omega(B)$<br><strong>Proof</strong>: $1 \to 2 \to 3$ 显然, $3 \to 1$, 只需证明 $Tor_1 ^A(B,N)=0$. 由$Tor_1 ^{A_p}(B_P, N_p) = 0, P \in \omega(B)$. 知道结论成立.</li>
</ol>
<h3 id="忠实平坦-faithful-flat-f-f"><a href="#忠实平坦-faithful-flat-f-f" class="headerlink" title="忠实平坦 faithful flat (f.f.)"></a>忠实平坦 faithful flat (f.f.)</h3><p>一个自然的问题, 平坦模何时成为忠实平坦模呢?<br>设 $M$ 是 $A$-模, 下面条件等价</p>
<ol>
<li>$M$ 是 f.f. $A$-模;</li>
<li>$M$ 是平坦 $A$-模, 且对任意 $A$-模 $N \neq 0$, $N \otimes M \neq 0$;</li>
<li>$M$ 是平坦 $A$-模, 且对任意 $A$ 的极大理想 $\mathfrak{m}$, $mM \neq M$.<br><strong>Proof</strong>: $1 \to 2$: 由 $0 \to N \to 0$ 和 $0 \to N \otimes M \to 0$ 同时正合性证毕. $2 \to 3$: 由于 $A/\mathfrak{m} \neq 0$, 所以 $M/\mathfrak{m} M \simeq A/\mathfrak{m} \otimes M \neq 0$. $3 \to 2$: 对任意 $0 \neq x \in N$, 存在 $I$ 使得 $Ax \simeq A/I$, 设 $\mathfrak{m}$ 为包含 $I$ 的一个极大理想, 于是 $IM \subseteq \mathfrak{m}M \subset M$, 从而 $(A/I)\otimes M = M/IM \neq 0$. 又由 $M$ 平坦知: $0 \to (A/I) \otimes M \to N \otimes M$ 正合, 所以 $N \otimes M \neq 0$. $2 \to 1$: 设 $S: N’ \xrightarrow{f} N \xrightarrow{g} N’’$ 为 $A$-模序列. 若 $S \otimes M : N’\otimes M \xrightarrow{\hat{f}} N \otimes M  \xrightarrow{\hat{g}} N’’\otimes M$. 由于 $- \otimes M$ 函子正合. $Im(gf) \otimes M = Im(\hat{f}\hat{g})=0$. 从而$Im(gf)=0$, 即 $S$ 是复形, $H(S) \otimes M = H(S \otimes M) = 0$, 从而 $H(S) = 0$, 证毕.</li>
</ol>
<h4 id="局部环中平坦和忠实平坦"><a href="#局部环中平坦和忠实平坦" class="headerlink" title="局部环中平坦和忠实平坦"></a>局部环中平坦和忠实平坦</h4><p>设 $(A,\mathfrak{m}), (B,\mathfrak{n})$ 是局部环, $\phi: A \to B$ 是局部同态, 若 $M \neq 0$ 是有限 $B$-模或 $\mathfrak{n}$ 幂零，则</p>
<script type="math/tex; mode=display">
M \text{是平坦模} \Longleftrightarrow M \text{是忠实平坦模}</script><p>由 $\mathfrak{m} M \subseteq \mathfrak{n}M \neq M$ (NAK lemma), 从而由忠实平坦模的等价刻画知结论成立.<br>推论 1: $B$ 在 $A$ 上平坦等价于忠实平坦.(取 $M=B$)<br>推论 2: 若 $M$ 是有限生成 $A$-模或 $\mathfrak{m}$ 幂零, 则 $M$ 平坦等价于忠实平坦(其实本结论可以由 <strong>局部环上有限生成模是自由模</strong> 小节直接推出).</p>
<h4 id="忠实平坦模的性质"><a href="#忠实平坦模的性质" class="headerlink" title="忠实平坦模的性质"></a>忠实平坦模的性质</h4><p>类似于平坦模, transitive, change of base 都成立. 并且它还满足 descent property: 若 $B$ 是 $A$-代数, $M$ 是忠实平坦 $B$-模, 也是忠实平坦 $A$-模, 那么 $B$也是忠实平坦 $A$-模.<br><strong>忠实平坦在环扩张中起了很重要的作用</strong><br>设 $\phi: A \to B$ 是 f.f. 同态 则:</p>
<ol>
<li>对任意 $A$-模 $N$, $N \to N \otimes B, \quad x \mapsto x \otimes 1$ 是单的. 特别地, $\phi$ 是单的, 因此 $A$ 可以看做 $B$ 的子环.</li>
<li>对任意 $A$ 的理想 $I$, 我们有 $IB \cap A = I$</li>
<li>$\hat{\phi}: Spec(B) \to Spec(A)$ 是满的.</li>
</ol>
<p><strong>Proof</strong>: </p>
<ol>
<li><p>$0 \neq x \in N$, 则 $0 \neq Ax \subset N$. 因此 $Ax \otimes B \in N \otimes B$($B$平坦). 又 $Ax \otimes B = (x \otimes 1)(A \otimes B) = (x \otimes 1)B$. 由 $B$ 忠实平坦知 $x \otimes 1 \neq 0$. </p>
</li>
<li><p>由于 $B \otimes _A (A/I) = B/IB$ 在 $A/I$上 忠实平坦, 因此 $A/I \subseteq B/IB$. 因此 $IB \cap A \subset I$. 又反方向显然, 证毕. </p>
</li>
<li><p>设 $p \in Spec(A)$. $B_p = B \otimes A_p$ 在 $A_p$ 上忠实平坦, 因此  $pB_p \neq B_p$ <strong>(这是关键的一步)</strong>. 取 $B_p$ 中一个包含 $pB_p$ 的极大理想 $\mathfrak{m}$. 则 $pA_p \subseteq \mathfrak{m} \cap A_p$, 因此 $pA_p = \mathfrak{m} \cap A_p$. 设 $P = \mathfrak{m} \cap B$. 则</p>
<script type="math/tex; mode=display">
P \cap A = \mathfrak{m} \cap B \cap A = \mathfrak{m} \cap A = \mathfrak{m} \cap A_p \cap A = pA_p \cap A = p</script><p>要理解上面式子关键在于 $0 \to A \to A_p \to B_p = A_p \otimes B$. 最后 $\mathfrak{m}$ 被拉回之后就在 $B$ 中了.</p>
</li>
</ol>
<h4 id="忠实平坦的等价刻画"><a href="#忠实平坦的等价刻画" class="headerlink" title="忠实平坦的等价刻画"></a>忠实平坦的等价刻画</h4><p>之前已经给了一些平坦的等价可以, 都是与张量积有关, 下面给出的都与谱有关. 即与素理想有关.<br>设 $\phi: A \to B$ 是平坦映射, 以下结论等价:</p>
<ol>
<li>$\phi$ 是忠实平坦的;</li>
<li>$\phi$ 是平坦的, 且 $\hat{\phi}: Spec(B) \to Spec(A)$ 是满的;</li>
<li>$\phi$ 是平坦的, 且对任意 $A$ 中极大理想 $\mathfrak{m}$,存在 $B$ 中极大理想 $\mathfrak{m}’$ 使得 $\mathfrak{m}’ \cap A = \mathfrak{m}$.<blockquote>
<p>这注定了它和 NAK lemma 之间密切的联系.</p>
</blockquote>
</li>
</ol>
<p>$1 \to 2$ 已证, $2 \to 3$ 是因为存在 $p’ \in Spec(B)$ 使得 $p’ \cap A = \mathfrak{m}$. 找一个包含 $p’$ 的极大理想 $\mathfrak{m}’$. 则 $\mathfrak{m} \cap A = \mathfrak{m}$ (由于 $\mathfrak{m}$ 极大). $3 \to 1$ 是因为此时 $\mathfrak{m}B \subseteq \mathfrak{m}’B = \mathfrak{m} \subset B$. 因此 $B$ 在 $A$ 上忠实平坦.</p>
<h4 id="忠实平坦上的平坦"><a href="#忠实平坦上的平坦" class="headerlink" title="忠实平坦上的平坦"></a>忠实平坦上的平坦</h4><p>设 $B$ 是 $A$ 上的忠实平坦 $A$-代数. $M$ 是 $A$-模. 则 $M$ 是 $A$ 上的(忠实)平坦模 $\Longleftrightarrow$ $M$ 是 $B$ 上的(忠实)平坦模。</p>
<p>$\Longrightarrow$ 就是 change of base 的结果. $\Longleftarrow$ 成立是因为一般地我们有:</p>
<script type="math/tex; mode=display">
(S \otimes_A M) \otimes_A B = (S \otimes_A B) \otimes_B (M \otimes_A B)</script><h4 id="整环上的忠实平坦"><a href="#整环上的忠实平坦" class="headerlink" title="整环上的忠实平坦"></a>整环上的忠实平坦</h4><p>设 $A$ 设整环, 整环 $B$ 满足 $A \subseteq B \subseteq Q(A)$, 其中 $Q(A)$ 是 $A$ 的分式域. 则 $B$ 在 $A$ 上忠实平坦当且仅当 $B=A$.<br><strong>Proof</strong>: 若 $B \neq A$, 则对任意 $0 \neq x \in B \backslash A$, $x = y/s,\quad y,s \in A, s \notin U(A)$, 从而 $sB \cap A = A \neq sA$. 因此 $B$ 在 $A$ 上不忠实平坦, 所以 $B = A$.</p>
<blockquote>
<p>但是 $A$ 与 $Q(A)$ 之间的任意环都是平坦的(这可以由 <strong>平坦模的等价刻画 6</strong> 得到)</p>
</blockquote>
<h3 id="Going-up-and-Going-down"><a href="#Going-up-and-Going-down" class="headerlink" title="Going-up and Going-down"></a>Going-up and Going-down</h3><p>在这里还是重提以下 Going-up 和 Going-down 是什么鬼吧, 这部分之前一直糊里糊涂的过了.</p>
<p>设 $\phi: A \to B$ 是环同态. 我们说 Going-up 条件成立是指:<br>对任意 $p \subset p’ \in Spec(A)$, 对任意在理想 $p$ 上的 $P \in Spec(B)$(即$P \cap A = p$). 都存在 $P’ \in Spec(B)$, 使得 $P’ \cap A = p’$ 且 $P \subset P’$</p>
<blockquote>
<p>上面 $p \subset p’$ 是真包含, 若上述 $P’$ 存在, 包含关系必然也是真包含的.</p>
</blockquote>
<p>类似地, 我们说 Going-down 条件成立是指:<br>对任意 $p \subset p’ \in Spec(A)$, 对任意在理想 $p’$ 上的 $P’ \in Spec(B)$(即 $P’ \cap A = p’$). 都存在 $P \in Spec(B)$, 使得 $P \cap A = p$ 且 $P \subset P’$.<br>这等价于:<br>对任意 $p \in Spec(A)$, 对任意包含 $pB$ 的极小素理想 $P$ 都有 $P \cap A = p$.</p>
<blockquote>
<p>上面 $p \subset p’$ 是真包含, 若上述 $P$ 存在, 包含关系必然也是真包含的.</p>
</blockquote>
<h4 id="平坦-Going-down"><a href="#平坦-Going-down" class="headerlink" title="平坦 Going-down"></a>平坦 Going-down</h4><p>设 $\phi: A \to B$ 是平坦映射, 则 $\phi$ 满足 Going-down 条件.<br><strong>Proof</strong>: 设 $p’ \subset p \in Spec(A)$, $P \in Spec(B)$ 使得 $P \cap A = p$. 则 $B_P = B_p$ 在局部环 $A_p$ 上平坦, 因此忠实平坦, 所以 $Spec(B_P) \to Spec(A_p)$ 是满的, 设 $P^{\star} \ subset B_P$ 满足 $P^{\star} \cap A_p = p’A_p$. 则 $P’ = P^{\star} \cap B$ 即为所求.</p>
<h4 id="整-Going-up"><a href="#整-Going-up" class="headerlink" title="整 Going-up"></a>整 Going-up</h4><p>设 $A \subset B$ 是环, 且 $B$ 在 $A$ 上整. 则:</p>
<ol>
<li>$Spec(B) \to Spec(A)$ 是满的</li>
<li>$B$ 中在某个 $Spec(A)$ 上的所有素理想互不包含.</li>
<li>Going-up 条件成立.</li>
<li>若 $A$ 是局部环, $p$ 是唯一极大理想, 则 $B$ 中在 $p$ 上的素理想都是极大理想.</li>
</ol>
<p>先证$4$: 设 $\mathfrak{n}$ 为 $B$ 的一个极大理想, 设 $\mathfrak{m} = \mathfrak{n} \cap A$. $\bar{B} = B / \mathfrak{n}$ 是域, 并且在环 $\bar{A} = A/\mathfrak{m}$ 上整, 对 $A$ 中任意非零元 $x$. $1/x \in \bar{B}$. 因此</p>
<script type="math/tex; mode=display">
(1/x)^n + a_1 (1/x)^{n-1} + \cdots a_n = 0</script><p>所以 $\frac{1}{x} = -(a_1 + a_2 x + a_n x^{n-1} \in A$. 即 $\bar{A}$ 是域, $\mathfrak{m} = p$ 为 $A$ 的唯一极大理想. 设 $P \in Spec(B)$ 使得 $P \cap A = p$. 则 $\bar{B} = B/P$ 是整环, 且在域 $\bar{A} = A/p$ 上整, 易知 $\bar{B}$也是域, 即 $P$ 是极大理想.<br>再证 <code>1, 2</code>: 对任意 $p \in Spec(A)$. $B_p = B \otimes _A A_p = (A-p)^{-1}B$ 在 $A_p$ 上整且包含 $A_p$. 又因为 $B$ 中在 $p$ 上的素理想与 $B_p$ 中在 $pA_p$ 的素理想一一对应, 在由 <code>4</code> 知道 它对应于 $B_p$ 中的极大理想, 因此 <code>1, 2</code>得证.<br>最后证明 <code>3</code>: 设 $p \subset p’ \in Spec(A)$, $P \in Spec(B)$ 使得 $P \cap A = p$, $B/P$ 包含 $A/p$ 且在其上整. 由 $1$ 知, 存在 $P’/P$ 使得 $P’/P \cap A/p = p’/p$. 所以 $P’ \in Spec(B)$ 满足 $P’ \cap B = p’$.</p>
<blockquote>
<p>一个有用的结论: 整环 $B$ 在 $A$ 上整, 则 $B$ 是域当且仅当 $A$ 是域.</p>
</blockquote>
<h3 id="代数几何中的-Constructible-Set"><a href="#代数几何中的-Constructible-Set" class="headerlink" title="代数几何中的 Constructible Set"></a>代数几何中的 Constructible Set</h3><h4 id="Noetherian-空间"><a href="#Noetherian-空间" class="headerlink" title="Noetherian 空间"></a>Noetherian 空间</h4><p>称一个拓扑空间 $X$ 为 Noetherian, 如果它满足闭集的降链条件, 等价于开集的升链条件.<br>显然有限个 Noetherian 空间的并还是 Noetherian 空间, Noetherian 空间的子空间还是 Noetherian 空间. Noetherian 空间是紧的.</p>
<blockquote>
<p>由于 Noetherian 环 $A$ 满足素理想的降链条件, 此时 $Spec(A)$ 是 Noetherian 空间.</p>
</blockquote>
<h4 id="不可约闭集-irreducible-closed-set"><a href="#不可约闭集-irreducible-closed-set" class="headerlink" title="不可约闭集(irreducible closed set)"></a>不可约闭集(irreducible closed set)</h4><p>一个闭集称为不可约的, 如果它不能写成两个真闭子集的并. </p>
<blockquote>
<p>在 Noetherian 空间中, 每个闭集都可以写成有限个不可约闭子集的并. 并且这些不可约子集互不包含, 称每一个都为这个闭集的不可约部分.</p>
</blockquote>
<h4 id="局部闭集-locally-closed"><a href="#局部闭集-locally-closed" class="headerlink" title="局部闭集(locally closed)"></a>局部闭集(locally closed)</h4><p>一个集合 $Z$ 称为 locally closed 如果 $\forall z \in Z, \quad \exists U_z$  使得 $U_z \cap Z$ 是开邻域 $U_z$ 中的闭集. 这等价于说 $Z$ 是拓扑空间 $X$ 中某个开集和闭集的交. 特别地, 开集和闭集都是 locally closed.</p>
<h4 id="Noetherian-空间中-constructible-集"><a href="#Noetherian-空间中-constructible-集" class="headerlink" title="Noetherian 空间中 constructible 集"></a>Noetherian 空间中 constructible 集</h4><p>设 $X$ 是一个 Noetherian 空间, 称集合 $Z \subseteq$ 是一个 constructible 集, 如果它是有限个 locally close 集合的并.<br>(非 Noetherian 空间中也可以定义 constructible 集, 但是很复杂)<br>显然 constructible 集关于交并差都是封闭的.</p>
<p>设 $X$ 是一个 Noetherian 空间, 称集合 $Z \subseteq$ 是一个 pro-constructible(对应的 ind-constructible)集, 如果它是任意一族 constructible 集的交(对应的并).</p>
<p><strong>constructible 集</strong> 判定方法, Noetherian 空间 $X$ 的子集 $Z$ 称为 constructible 集的充要条件是:<br>对任意不可约闭子集 $X_0 \subseteq X$, 若 $X_0 \cap Z$ 在 $X_0$ 中稠密, 则 $X_0 \cap Z$ 包含 $X_0$ 中某个非空开集.<br><strong>Proof</strong>: 必要性: 若 $Z$ 是 constructible 集, 则</p>
<script type="math/tex; mode=display">
X_0 \cap Z = \bigcup _{i=1} ^m (U_i \cap F_i)</script><p>其中 $U_i$ 是 $X$ 中开集, $F_i$ 是 $X$ 中不可约闭子集(这是可以做到的是因为 Noetherian 空间中闭集都可以写成有限个不可约闭集的并), 且 $U_i \cap F_i$ 是非空的(如果空就直接踢掉了). 则 $\bar{U_i \cap F_i} = F_i$(这是因为否则 $\bar{U_i \cap F_i} \cup (c(U_i) \cap F_i) = F_i$, 但是 $F_i$ 是不可约闭集). 因此</p>
<script type="math/tex; mode=display">
X_0 = \bar{X_0 \cap Z} = \bigcup _{i=1} ^m F_i</script><p>因此必有某个 $F_i = X_0$. 从而 $U_i \cap X_0 = U_i \cap F_i$ 是 $X_0$ 中的一个非空开集.<br>充分性: 我们对 $\bar{Z}$ 进行应用所谓的超限数学归纳. 首先, $\emptyset$ 是 constructible 集, 其次假设 $\bar{Z}$ 中所有满足条件且 $\bar{Z’} \subset \bar{Z}$(严格包含)的 $Z’$ 都是 constructible 集. 我们证明此时 $Z$ 也是 constructible 集:<br>设 $\bar{Z} =  F_1 \cup \dots \cup F_r$ 是 $\bar{Z}$ 的不可约分解. 那么 $\bar{F_1 \cap Z} =  F_1$(毕竟不可约闭集). 因此, 由条件存在 $F_1$ 中的真子集 $F_1’$ 使得 $\emptyset \neq F_1 - F_1’ \subseteq Z$. 此时定义 $F^{\star} = F_1’ \cap F_2 \cap cdots \cap F_r$. 那么 $Z = (F_1 - F_1’) \cup (Z \cap F^{\star})$. 由于 $F_1 - F_1’$ 是 locally closed, 又因为 $Z \cap F^{\star}$ 满足条件: 若 $X_0$ 是不可约闭集且 $X_0 = \bar{Z \cap F^{\star} \cap X_0} \subseteq \bar{F^{\star}} = F^{\star}$, 从而 $Z \cap F^{\star} \cap X_0 = Z \cap X_0$ 从而包含 $X_0$ 中的一个非空开集. 并且 $\bar{Z \cap F^{\star}} \subseteq F^{\star} \subset Z$. 由数学归纳知 $Z \cap F^{\star}$ 是 constructible 集. 从而 $Z = (F_1 - F_1’) \cup (Z \cap F^{\star})$ 是 constructible 集.</p>
<blockquote>
<p>以上结果对一般地 Noetherian 空间都成立.</p>
</blockquote>
<h4 id="考察上述定义在-Spec-A-上的具体表现"><a href="#考察上述定义在-Spec-A-上的具体表现" class="headerlink" title="考察上述定义在 $Spec(A)$ 上的具体表现"></a>考察上述定义在 $Spec(A)$ 上的具体表现</h4><p><strong>$Spec(A)$ 中的不可约闭集</strong>: 设 $F$ 是 $Spec(A)$ 中的闭集, 则 $F$ 不可约当且仅当, $F = V(p)$, 其中 $p \in Spec(A)$, 可以看出此时 $p$ 由 $F$ 唯一决定。<br>充分性由 $p \in V(p)$ 显然.<br>必要性. $F = V(I)$. 若 $I$ 不是素理想, 则存在 $a, b \notin I, ab \in I$, 即$F = (F \cap V(a)) \cup (F \cap V(b))$. 矛盾于 $F$ 不可约.设 $\phi: A \to B$ 是环同态, 设 $X = Spec(A), Y = Spec(B)$, 由自然的 $f: Y \to A$. 那么 $f(Y)$ 在 $X$ 中稠密, 当且仅当 $\ker(\phi) \subseteq nil(A)$. 特别地, 当 $A$ reduce 时, $f(Y)$ 在 $X$ 中稠密, 当且仅当 $\phi$ 是单同态.<br>证明 $\bar{f(Y)} = V(I)$, 其中 $I = \bigcap_{p \in Y} \phi^{-1}(p) = \phi^{-1}(\bigcap_{p \in Y} p) = \phi^{-1}(nil(B))$. 显然 $\ker(\phi) \subseteq I$.<br>若 $f(Y)$ 在 $X$ 中稠密, 则 $V(I) = X$. 因此 $I \subseteq nil(A)$, 从而  $\ker(\phi) \subseteq nil(A)$. 另一方面, 若 $\ker(\phi) \subseteq nil(A)$, 则 $I = \phi^{-1}(nil(B)) \subseteq nil(A)$. 从而 $\bar{f(Y)} = X$.</p>
<blockquote>
<p>之前提到了, $Spec$ 是环范畴到拓扑范畴的逆变函子, 现在是说, 这个拓扑空间的一些性质可以与环的一些性质有一个对应关系, 这个函子保持了很好的性质.</p>
</blockquote>
<p>之前关于 constructible 集的定义都是在 Noetherian 空间中考虑的, 因此我们下面考虑的环一般是 Noetherian 环:</p>
<p><strong>(Chevalley)</strong> 设 $A$ 是 Noetherian 环, $B$ 是 $A$ 上的有限生成代数(从而也是 Noetherian 环). 设 $\phi: A \to B$ 是自然映射, 记 $X = Spec(A), Y = Spec(B)$ 则 $f: Y \to X$. 则 $f$ 将 $Y$ 中 constructible 集 映成 $X$ 中的 constructible 集.</p>
<blockquote>
<p>先证明 $f(Y)$ 是 constructible 集, 在利用下面的引理.</p>
</blockquote>
<p>另一方面设 $A$ 是 Noetherian 环, $X’$ 是 $X = Spec(A)$中的 constructible 集, 那么存在 $A$ 的有限生成代数 $B$ 使得 $Spec(B)$ 在 $Spec(A)$ 中的像恰好是 $X’$.</p>
<blockquote>
<p>对于 $X’ = D(a) \cap V(I)$, 然后考虑 $B = \lbrace 1,a,a^2,\cdots \rbrace ^{-1} (A/I)$, 然后考虑 constructible 集.</p>
</blockquote>
<p><strong>pro-constructible 集</strong> 设 $A$ 是 Noetherian 环, $\phi: A \to B$, $\bar{\phi}(Spec(B))$ 是 $Spec(A)$ 中的 pro-constructible 集.</p>
<h4 id="f-spec-B-to-Spec-A-成为-开-闭-连续映射"><a href="#f-spec-B-to-Spec-A-成为-开-闭-连续映射" class="headerlink" title="$f: spec(B) \to Spec(A)$成为(开,闭)连续映射"></a>$f: spec(B) \to Spec(A)$成为(开,闭)连续映射</h4><p>设$A$是 Noetherian 环, $B$ 是 $A$ 上的有限生成代数, 假设它们之间的自然映射 $\phi: A \to B$ 满足 Going-down 条件, 则对应的自然映射 $f: Spec(B) \to Spec(A)$ 是开(连续)映射.</p>
<blockquote>
<p>设 $U$ 是 $Spec(B)$ 中开集, 则 $f(U)$ 是 constructible 集, 再由 Going-down 条件知道 $Spec(A) - f(U)$ 是闭集.</p>
</blockquote>
<p>设 $\phi: A \to B$ 满足 Going-up 条件, 且 $B$ 是 Noetherian 环, 则 $f: Spec(B) \to Spec(A)$ 是闭映射.</p>
<h3 id="Noetherian-环上的-Associated-Primes"><a href="#Noetherian-环上的-Associated-Primes" class="headerlink" title="Noetherian 环上的 Associated Primes"></a>Noetherian 环上的 Associated Primes</h3><p>给定一个 Noetherian 环上的模 $M$, 我们称 $A$ 的一个素理想为 $M$ 的 associated prime, 如果它满足下面等价的条件:</p>
<ol>
<li>$\exists x \in M$ 使得 $Ann(x) = p$;</li>
<li>$M$ 包含一个子模同构于 $A/p$.</li>
</ol>
<p>我们把 $M$ 中所有的 associated prime ideal 记为 $Ass(M)$. 有时也用 $Ass_A(M)$ 来防止歧义.</p>
<blockquote>
<p>由下面三个结论说明, $Ass(M)$ 确实是 $M$ 的一个重要不变量.</p>
<p>(本节)环默认为 Noetherian 环.</p>
</blockquote>
<h4 id="Ann-x-全体中的极大元在-Ass-M-中"><a href="#Ann-x-全体中的极大元在-Ass-M-中" class="headerlink" title="$Ann(x)$ 全体中的极大元在 $Ass(M)$ 中"></a>$Ann(x)$ 全体中的极大元在 $Ass(M)$ 中</h4><p>设 $p$ 是 $\lbrace Ann(X) | 0 \neq x \in M \rbrace$. 则 $p \in Ass(M)$</p>
<p>由上, 显然可知道 $Ass(M) = \emptyset \Longleftrightarrow M=0$. 即 $Ass(M)$ 是元素是十分丰富的. $M$ 中的零因子是 $Ass(M)$ 中元素的并.</p>
<h4 id="Ass-M-与局部化可交换"><a href="#Ass-M-与局部化可交换" class="headerlink" title="$Ass(M)$ 与局部化可交换"></a>$Ass(M)$ 与局部化可交换</h4><p>给定一个乘闭子集 $S$, 记 $A’ = S^{-1}A, M’ = S^{-1} B$, 则</p>
<script type="math/tex; mode=display">
Ass_A(M’) = f(Ass_{A’}(M’) = Ass_A(M) \cap \lbrace p | p \cap S = \emptyset \rbrace</script><p>其中 $f: Spec(A’) \to Spec(A)$ 为自然映射.</p>
<h4 id="Supp-M-的极小元全体等于-Ass-M-的极小元全体"><a href="#Supp-M-的极小元全体等于-Ass-M-的极小元全体" class="headerlink" title="$Supp(M)$ 的极小元全体等于 $Ass(M)$ 的极小元全体"></a>$Supp(M)$ 的极小元全体等于 $Ass(M)$ 的极小元全体</h4><p>$Ass(M) \subset Supp(M)$ 且 $Supp(M)$ 中的极小元在 $Ass(M)$ 中(从而 $Supp(M)$ 的极小元全体等于 $Ass(M)$ 的极小元全体).<br><strong>Proof</strong>: 设 $p \in Ass(M)$, 则由正合列 $0 \to A/p \to M$, 从而 $0 \to A_p/pA_p \to M_p$ 正合. 由 $A_p/pA_p \neq 0$, 从而 $M_p \neq 0$, 从而 $p \in Supp(M)$.<br>设 $p \in Supp(M)$, 由于局部化和 $Ass(M)$ 可交换, $p \in Ass_A(M)$ 等价于  $pA_p \in Ass_{A_p}(M_p)$. 因此, 我们不妨设 $(A, p)$ 是局部环, $M \neq 0$. 且对任意 $q \subset p, M_q = 0$, 即 $Supp(M) = \lbrace p \rbrace$. 由于 $Ass(M)$ 非空, 且包含于 $Supp(M)$ 中, 因此 $p \in Ass(M)$.</p>
<blockquote>
<p>设 $I$ 是 $A$ 的理想, 则 $Ass(A/I)$ 中的极小元全体为包含 $I$ 的极小素理想全体. 从而 $\bigcap _{p \in Ass(A/I)} p = \sqrt{I}$</p>
</blockquote>
<p>若 $0 \to M’ \to M \to M’’$ 是 $A$-模正合列, 则 $Ass(M) \subset Ass(M’) \cup Ass(M’’)$<br><strong>Proof</strong>: 设 $p \in Ass(M)$, 则存在 $N \subseteq M$ 使得 $N \simeq A/p$. 若 $N \cap M’ = 0$(本质上是和 $f(M’)$ 的交). 则 $N$ 同构于 $M’’$ 的一个子模, 因此 $p \in Ass(M’’)$. 若 $N \cap M’ \neq 0$, 则任取 $0 \neq x \in N \cap M’$, 则 $Ann(x) = p$.</p>
<p>设 $M \neq 0$ 是 Noetherian 环上的有限生成模, 则存在(长为 $n$ 的)子模链 $(0) = M_0 \subset \cdots \subset M_{n-1} \subset M_n = M$ 使得 $M_i / M_{i-1} = A/p_i$, 其中 $p_i \in Spec(A)$. 从而 $Ass(M) \subset \lbrace p_1 \cdots p_n \rbrace$ 是有限集.<br><strong>Proof</strong>: 由 $M \neq 0$ 则 $Ass(M) \neq \emptyset$, 选择 $M_1 \subseteq M$, 使得 $M_1 \simeq A/p_1$, 若 $M_1 \neq M$, 再对 $M/M_1$ 做同样的事情, 由于 $M$ 是 Noetherian 的, 因此次过程在有限步后终止. 又因为</p>
<script type="math/tex; mode=display">
Ass(M) \subseteq Ass(M_1) \cup Ass(M_2/M_1) \cup \cdots \cup Ass(M_n /M_{n-1})</script><p>再由 $Ass(M_i/M_{i-1}) = Ass(A/p_i)=p_i$ 知结论成立.</p>
<h3 id="Primary-Decomposition-准素分解"><a href="#Primary-Decomposition-准素分解" class="headerlink" title="Primary Decomposition(准素分解)"></a>Primary Decomposition(准素分解)</h3><blockquote>
<p>本节设 $M$ 是 Noetherian 环 $A$ 上的模.</p>
</blockquote>
<p>称一个 $A$-模是 <strong>co-primary</strong> 如果它仅有一个 associated prime ideal. $N \subseteq M$ 称为 $M$ 的 primary 子模, 如果 $M/N$ 是 co-primary. 若 $Ass(M/N) = \lbrace p \rbrace$, 则称 $N$ 为 $p$-primary 或称 $N$ 属于 $p$(的 primary submodule).</p>
<h4 id="co-primary-等价刻画"><a href="#co-primary-等价刻画" class="headerlink" title="co-primary 等价刻画"></a>co-primary 等价刻画</h4><p>$M$ 是 co-primary 的, 当且仅当 $M \neq 0$, 且若 $a \in A$ 是 $M$ 的零因子, 则 $a$ 在 $M$ 上 locally nilpotent($\forall x \in M, \exists n$, such that  $a^n x = 0$).<br><strong>Proof</strong>: 若 $Ass(M) = \lbrace p \rbrace$, 则对任意 $x \in M$, $Ass(Ax) \subseteq Ass(M) = \lbrace p \rbrace$, 若 $Ass(Ax) = \emptyset$(取 $n = 1$ 即可), 若 $Ass(Ax) =  \lbrace p \rbrace$. 因此 $p$ 是 $Supp(Ax) = V(Ann(x))$ 中唯一的极小元素. 即 $p = \sqrt{Ann(x)}$.<br>另一方面, 定义 $p = \lbrace a \in A | a \text{在} M \text{上 locally nilpotent} \rbrace$. 它显然是一个理想. 对任意 $q \in Ass(M)$, 存在 $x \in M$  使得 $q = Ann(x)$. 因此 $p \subseteq \sqrt{q} = q$. 另一方面由于 $p$ 为所有 associated prime 理想的并, 因为 $q \subseteq p$. 从而 $Ass(M) = \lbrace p \rbrace$.</p>
<blockquote>
<p>当 $M = A/q$ 时, 上述条件恰好就是 $q$ 为准素理想的定义.</p>
</blockquote>
<h4 id="p-primary-的交依然是-p-primary"><a href="#p-primary-的交依然是-p-primary" class="headerlink" title="p-primary 的交依然是 p-primary"></a>p-primary 的交依然是 p-primary</h4><p>设 $p$ 是 $A$ 的素理想, $Q_1, Q_2$ 是 $M$ 的 $p$-primary 子模. 则 $Q_1 \cap Q_2$ 也是 $M$ 的 $p$-primary 子模.</p>
<blockquote>
<p>由 $0 \to M / Q_1 \cap Q_2 \to M/Q_1 \oplus M/Q_2$ 显然</p>
</blockquote>
<h4 id="准素分解闪亮登场"><a href="#准素分解闪亮登场" class="headerlink" title="准素分解闪亮登场"></a>准素分解闪亮登场</h4><p>设 $N$ 是 $M$ 的一个子模, 我们称 $N = Q_1 \cap \cdots \cap Q_r$ 是 $N$ 的一个准素分解, 如果 $Q_i$ 是 $M$ 中的 primary 子模. 我们称一个准素分解是 irredundant 如果每个准素子模都不能去掉, 并且 $Ass(M/Q_i)$ 各不相同. 对于任意准素分解, 我们都可以通过有限次剔除之后使得它的每一个准素子模都不可去掉, 而如果有两个准素子模属于相同的 associated prime $p$, 则我们可以把它们交起来构成一个新的准素子模, 从而可知</p>
<blockquote>
<p>任意准素分解都可以化成 irredundant 准素分解.</p>
</blockquote>
<p>设 $N = Q_1 \cap \cdots \cap Q_r$ 是 $N$ 的一个 irredundant 准素分解, 若 $Q_i$ 属于 $p_i$. 则 $Ass(M/N) = \lbrace p_1 \cdots p_r \rbrace$.<br><strong>Proof</strong>: 由自然单同态 $0 \to M/Q_1 \oplus \cdots \oplus M/Q_r$. 因此 $M/N \subseteq \cup Ass(M/Q_i) = \lbrace p_1 \cdots p_r \rbrace$. 另一方面 $(Q_2 \cap \cdots \cap Q_r)/N$ 同构于 $M/Q_1$ 的子模, 从而 $Ass(Q_2 \cap \cdots \cap Q_r)/N) = \lbrace p_1 \rbrace$. 从而 $p_1 \in Ass(M)$. 其它的类似.</p>
<p>设 $N$ 是 $M$ 的一个 $p$-primary 子模. 设 $q$ 是一个理想. 若 $p \subseteq q$,  则 $N = M \cap N_q$, 反之 $N_q = M_q$.<br><strong>Proof</strong>: 由于 $Ass(M/N) = \lbrace p \rbrace$. 若 $p \subseteq q$, 则 $A-q$ 中无 $M/N$ 的零因子, 即 $M/N \to (M/N)_q = M_q / N_q$ 是单射, 从而 $N = M \cap N_q$. 反之 $Ass(M_q/N_q) = Ass(M/N) \cap \lbrace \text{包含于} p \text{的素理想} \rbrace = \emptyset$. 从而 $M_q/N_q = 0$.</p>
<blockquote>
<p>推论 1: 若 $N = Q_1 \cap \cdots \cap Q_r$ 是 $N$ 的一个 irredundant 准素分解, 其中 $p_1$ 是 $Ass(M/N)$ 中的极小素理想. 则 $Q_1 = M \cap N_{p_1}$ 由 $N$ 和 $p_1$ 决定.<br>推论 2: 设 $I$ 是 Noetherian 环 $A$ 的理想 $N = \sqrt{I}$(有限生成). 则存在 $n \in \mathbb{N}$ 使得 $N^n \subseteq I$. 特别地若 $Q$ 是 $R$ 的 $p$ 准素理想, 则存在 $n \in \mathbb{N}$ 使得 $P^n \subseteq Q \subset P$.</p>
</blockquote>
<p><strong>准素分解</strong> 设 $M$ 是(Noetherian 环) $A$-模. 对每个 $p \in Ass(M)$, 我们可以选取 $p$-primary 子模 $Q(p)$, 使得</p>
<script type="math/tex; mode=display">
(0) = \bigcap_{p \in Ass(M)} Q(p)</script><p><strong>Proof</strong>: 给定一个 $p \in Ass(M)$, 我们考虑 $M$ 的一些子模构成的集合:  $\mathfrak{N} = \lbrace N \subseteq M | p \notin Ass(N) \rbrace \neq \emptyset$( $(0)$ 在其中). 由 Zorn 引理可知其存在极大元 $Q(p) \neq M$. 由 $Q(p)$ 的极大性, 知道 $Ass(M/Q(p) = \lbrace p \rbrace$. 从而</p>
<script type="math/tex; mode=display">
Ass(\bigcap_{p \in Ass(M)} Q(p)) = \bigcap_{p \in Ass(M)} Ass(Q(p)) = \emptyset</script><p>由上可知, 若 $M$ 有限生成, 则将上面定理应用于 $M/N$, 再由 $Ass(M/N)$ 是有限集, 从而 $N$ 有 primary decomposition.</p>
<h3 id="分次环和分次模"><a href="#分次环和分次模" class="headerlink" title="分次环和分次模"></a>分次环和分次模</h3><p><strong>分次环</strong>：称 $A = \bigoplus _{n \geq 0} A_n$ 是分次环, 如果 $A_n$ 是 $A$ 的加法子群, 且 $A_n A_m \subseteq A_{m+n}$. 我们称 $A_n$ 中的非零元素 $x$ 为 $n$ 次齐次元, 并记作 $\deg x = n$.</p>
<blockquote>
<p>$A_0$ 是 $A$ 的子环.<br>例子: $A = F[x_1, \cdots x_m]$, 其中 $A_i$ 是 $i$ 次单项式生成的子空间, 此时 $A$ 成为了分次环.</p>
</blockquote>
<p><strong>分次模</strong>：称分次环 $A = \bigoplus _{n \geq 0} A_n$ 上的模 $M$ 称为分次 $A$-模, 如果 $M = \bigoplus _{n \geq 0} M_n$ 满足 $M_n$ 是加群直和, 且 $A_n M_m \subseteq M_{m+n}$</p>
<p>设 $A = \bigoplus _{n \geq 0} A_n$, 则</p>
<ol>
<li>环 $A$ 是 Noetherian 当且仅当 $A_0$ 是 Noetherian, 且 $A$ 作为 $A_0$ 代数式有限生成的.</li>
<li>若环 $A$ 是 Noetherian, $M_A$ 是有限生成分次 $A$-模, 则对任意 $n, M_n$ 是有限生成 $A_0$-模.</li>
</ol>
<p><strong>Proof</strong>: </p>
<ol>
<li>充分性显然, $A_+ = \bigoplus _{n \geq 1} A_n$ 是 $A$ 的一个理想, 且 $A/A_+ \simeq A_0$ 是环同构, 于是 $A_0$ 是 Noetherian 环. 由 $A_+$ 作为理想是有限生成的. 设 $A_+ = Au_1 + \cdots + Au_m$, 其中每个 $u_i$ 都是齐次元. 下面用数学归纳法证明 $A = A_0[u_1,\cdots,u_m]$, 从而 $A$ 是有限生成 $A$-代数. 显然 $A_0 \subseteq A_0[u_1,\cdots,u_m]$. 设 $n &gt; 0, 0 \neq u \in A_n \subseteq A_+$, 从而可设 $u = \sum_{i=1} ^m a_i u_i$, 通过比较次数, 不妨设 $a_i$ 都是齐次元, 且 $\deg a_i + \deg u_i = n$. 于是 $\deg a_i &lt; n$. 由归纳假设 $a_i \in A_0[u_1, \cdots, u_m]$. 从而 $u \in A_0[u_1, \cdots, u_m]$, 即 $A_n \subseteq A_0[u_1, \cdots, u_m]$, 证毕.</li>
<li>由于 $A=A_0[u_1, \cdots, u_m]$, 其中 $u_i$ 为齐次元. 设 $M = Ay_1 + \cdots Ay_t$. 其中每个 $y_i$ 都是 $M$ 中的齐次元. 对任意 $0 \neq m \in M_n$, 记 $m = \sum_{i=1}^t a_i y_i$, 其中 $a_i$ 是齐次元. 且 $\deg a_i + \deg y_i = n = \deg m$, 另一方面, 对任意 $i$, $A$ 中阶为 $n-\deg y_i$ 的”单项式”(作为 $u_1, \cdots, u_m$ 的单项式)只有有限个, 又 $M_n$ 是 $\lbrace f_i y_i | f_i \text{是} A \text{阶为} n - \deg y_i \text{单项式} \rbrace$ 的 $A_0$ 线性组合. 所以 $M_n$ 是有限生成 $A_0$-模.</li>
</ol>
<h4 id="次模的-Poincare-数"><a href="#次模的-Poincare-数" class="headerlink" title="次模的 Poincare 数"></a>次模的 Poincare 数</h4><p>设 $A$ 是分次 Noetherian 环, 且设 $A_0$ 是 Artinian 环. 如果 $M_A$ 是有限生成分次 $A$-模, 则由上面结论知, 每一个 $M_n$ 都是有限生成 $R_0$-模, 从而是有限长的. 记作 $l(M_n)$. 记 $P(M,t) = \sum_{n=0}^{\infty} l(M_n)t^n \in \mathbb{Z}[[t]]$, 称为 $M$ 的 Poincare 级数.</p>
<p>引理: 设 $A$ 是 Artin 环, 若 $0 \to M_0 \to M_1 \to \cdots \to M_s \to 0$ 是有限生成 $A$-模正合列. 则 $\sum_{i=1} ^s l(M_i) = 0$<br><strong>Proof</strong>: $s=0,1$ 时显然, $s=2$ 时, 由 $0 \to M_0 \to M_1 \to M_2 \to 0$, 则有 $l(M_1)=l(M_0)+l(M_2)$. 对于 $M_i \to M_{i+1}$ 有分解: $M_i \to \text{Im} M_i \to 0$ 以及 $0 \to \text{Im} M_i \to M_{i+1}$. 于是有: $l(M_k) = l(\text{Im} M_{k-1} + l(\text{Im} M_k)$. 累加可得到结论.</p>
<p>(Hilbert-Serre) 设 $A$ 是分次 Noetherian 环, $A_0$ 是 Artinian 环, 若 $A = A_0[x_1, \cdots x_m]$, 其 $deg x_i = e_i &gt; 0$, 则对任意有限生成分次 $A$-模 $M$, 存在某个多项式 $f(t) \in \mathbb{Z}[t]$, 使得 $P(M,t)$ 为</p>
<script type="math/tex; mode=display">
\frac{f(t)}{\prod_{i=1}^m (1-t^{e_{i}})}</script><p>的有理展开.<br><img src= "/img/loading.gif" data-lazy-src="Hilbert.png" alt="证明过程"></p>
<p><strong>(Hilbert-Serre)多项式</strong> 设 $A$ 是分次 Noetherian 环, $A_0$ 是 Artinian 环, 若 $A = A_0[x_1, \cdots x_m]$, 其 $deg x_i = 1$, 则对任意有限生成分次 $A$-模 $M$, 存在次数不超过 $m-1$ 的多项式 $\bar{l}(t) \in \mathbb{Q}[t]$, 使得 $n \gg 0$ 时, $\bar{l}(t) = l(M_n)$.<br><strong>Proof</strong>: 应用之前的结果, 以及 $\frac{1}{(1-t)^k}$ 的展开.</p>
<p>命题: 设 $f(x) \in \mathbb{Q}[x]$ 是一个 $n$ 次多项式. 则 $f(x)$ 在 $n+1$ 个相邻的整数取整数值当且仅当 $f(x)$ 是 $C_x ^0 , C_x ^1, \cdots, C_x ^n$ 的整线性组合.<br><strong>Proof</strong>: 设 $f(x) = a_0 C_x ^0 + a_1 C_x ^1 + \cdots + a_n C_x ^n, a_i \in \mathbb{Q}$. 则 $f(x+1) - f(x) = a_1 C_x ^0 + \cdots + a_n C_x ^{n-1}$ 在 $n$ 个相邻的位置取整值. 由归纳假设可知 $a_1, \cdots a_n \in \mathbb{Z}$, 从而 $a_0 \in \mathbb{Z}$.</p>
<h4 id="ring-of-filtration"><a href="#ring-of-filtration" class="headerlink" title="ring of filtration"></a>ring of filtration</h4><p>我们定义环$A$的 filtration 为理想降链:</p>
<script type="math/tex; mode=display">
A = J_0 \supseteq J_1 \supseteq J_2 \supseteq \cdots</script><p>满足$J_n J_m  \subseteq J_{n+m}$.</p>
<p>给定一个 filtration, 我们可以定义一个分次环 $A’$(容易验证)</p>
<script type="math/tex; mode=display">
A’ = \oplus_{n=0} ^{\infty} J_n / J_{n+1}</script><p>特别地, 给定环 $A$ 的理想 $I$, 它的幂定义了一个 filtration, 称为 $I$-adic filtration, 对应的分次环记作 $gr^I(A)$.</p>
<p>若 $I$ 是 Noetherian 环 $A$ 的一个理想, 则 $gr^I(A)$ 也是 Noetherian.<br><strong>Proof</strong>: 由于 $I$ 有限生成, $I = a_1 A + \cdots a_r A$, $A/I$ Noetherian, 所以 $gr^I(A) = A/I[\bar{a_1}, \cdots, \bar{a_r}]$ 为 Noetherian.</p>
<h4 id="module-of-filtration"><a href="#module-of-filtration" class="headerlink" title="module of filtration"></a>module of filtration</h4><p>设 $M$ 是 $A$-模, $I$ 是 $A$ 的理想, 定义 $M$ 的 filtration 为子模降链:</p>
<script type="math/tex; mode=display">
M = M_0 \supseteq M_1 \supseteq M_2 \supseteq \cdots \quad (\star)</script><p>我们称 $(\star)$ 为 $I$-admissible 如果对任意 $n$ 成立 $IM_n \subseteq M_{n+1}$. $I$-adic 若 $M_n = I^n M$, essential $I$-adic 若 $(\star)$ 是 $I$-admissible 且存在 $n_0$, 当 $n &gt; n_0$ 时, $M_{n+1} = IM_n$.</p>
<p><strong>filtration topology</strong> 给定 $M$ 的一个 filtration $(\star)$, 我们可以定义 $M$ 上的拓扑: 对任意 $x \in M$, $x$ 的领域基为 $\lbrace x +M_n | n&gt;0 \rbrace$.</p>
<blockquote>
<p>显然上述拓扑是 Hausdorff 的当且仅当 $\bigcap M_n = (0)$.</p>
</blockquote>
<p>若上述 filtration $(\star)$ 是 $I$-adic 的, 则称上述拓扑为 $I$-adic 拓扑. 显然一个 essential $I$-adic 拓扑也定义了 $M$ 上的一个 $I$-adic 拓扑.</p>
<h4 id="Rees-环"><a href="#Rees-环" class="headerlink" title="Rees 环"></a>Rees 环</h4><p>设 $I$ 是 $A$ 的理想. 记 $T(I) =  A + Ix  + I^2x^2 + \cdots \leq A[x]$.<br>称 $T(I)$ 为由理想 $I$ 决定的 Rees 环可看作是 $A[x]$ 的子代数</p>
<p>引理: 若 $A$ 是 Noetherian. 则 $T(I)$ 是 Noetherian.<br><strong>Proof</strong>: $I = a_1 A + \cdots + a_r A$. 于是作为 $A[x]$ 的 $A$ 子代数. $T(I) = A[a_1 x, \cdots, a_r x]$ 是 $A[x_1, \cdots, x_r]$ 的商代数, 由 Hilbert 基定理, $T(I)$ 是 Noetherian 环。</p>
<h4 id="Rees-模"><a href="#Rees-模" class="headerlink" title="Rees 模"></a>Rees 模</h4><p>对于 $M_A$, $A[x] \otimes_A M$ 是 $A[x]$-模, 其中元素可以唯一表示 $\sum_i x^i \otimes m_i$(和为有限和). 另一方面 $M[x] = \lbrace \sum_i m_i x^i \text{ (有限和) }| m_i \in M \rbrace$. 于是 $M[x]$ 可自然地看做 $A[x]$-模. 并且作为 $R[x]$-模, 有同构</p>
<script type="math/tex; mode=display">
M[x] = R[x] \otimes _R M, \quad \sum_i m_i x^i \mapsto \sum_i x^i \otimes m_i</script><p>记 $T_I(M) = M + MIx + MI^2x^2 \cdots \leq M[x]$. 作为 $T(I)$-模, $T_I(M)$可由 $M$ 生成, $M = \sum_{j=1} ^s m_jA$ 是有限生成 $A$-模, 则 $T_I(M) = \sum_{j=1} ^s m_j T(I)$是有限生成 $T(I)$-模. 从而若 $A$ 是 Noetherian, $M_R$ 是有限生成模, 则 $T_I(M)$ 是 Noetherian $T(I)$-模.</p>
<h4 id="Artin-Rees-引理"><a href="#Artin-Rees-引理" class="headerlink" title="Artin-Rees 引理"></a>Artin-Rees 引理</h4><p>设 $I$ 是 Noetherian 环 $A$ 的理想, $M$ 是有限生成 $A$-模. $M_1, M_2$ 是 $M$ 的子模. 则存在 $k \in \mathbb{N}$ 使得对任意 $n \geq k$,</p>
<script type="math/tex; mode=display">
I^n(M_1 \cap M_2) \subseteq I^nM_1 \cap M_2 = I^{n-k}(I^k M_1 \cap M_2) \subseteq I^{n-k}(M_1 \cap M_2)</script><p><strong>Proof</strong>: 只需证明存在 $k$ 使得对任意 $n \geq k$, $I^nM_1 \cap M_2 \subseteq I^{n-k}(I^k M_1 \cap M_2)$(其它都包含关系显然). 考虑 Rees 环 $T(I)$ 及 Rees 模 $T_I(M)$, 以及 $T_I(M)$ 的子模 $N = M_1 \cap M_2 + (IM_1 \cap M_2)x + \cdots + (I^n M_1 \cap M_2)+ \cdots$. 由 $T_I(M)$ 是 Noetherian 模, $N_{T(I)}$是有限生成模. 不妨设 $N =  T(I)u_0 + T(I)u_1 x + \cdots T(I) u_k x^k$, 其中 $u_j \in I^j M_1 \cap M_2$. 对任意 $n \geq k, u \in I^n M_1 \cap M_2$ 我们有 $ux^n  \in (I^n M_1 \cap M_2)x^n \subseteq N$. 于是存在 $f_j \in T(I)$, 使得 $ux^n = \sum_{j=1} ^k f_j u_j x^j$. 比较 $x^n$ 的系数, 得到 $u = \sum_{j=1} ^k f_j’ u_j$. 其中 $f_j’ \in I^{n-j}$. 由于</p>
<script type="math/tex; mode=display">
I^{n-j}(I^jM_1 \cap M_2 = I^{n-k}I^{k-j}(I^jM_1 \cap M_2 \subseteq I^{n-k}(I^k M_1 \cap M_2)</script><p>从而 $u \in I^{n-k}(I^k M_1 \cap M_2)$. 证毕.</p>
<blockquote>
<p>取 $M_1 = M, M_2 = N \leq M$ 我们可以得到:<br>设 $I$ 是 Noetherian 环 $A$ 的理想, $N$ 是有限生成模 $M$ 的子模, 则存在 $k$ 使得 $n \geq k$ 时, </p>
<script type="math/tex; mode=display">
I^n N \subseteq I^n M \cap N = I^{n-k}(I^k M \cap N) \subset I^{n-k}N</script></blockquote>
<p><strong>Krull 交定理</strong>：设 $I$ 是 Noetherian 环 $A$ 的理想, $M$ 是有限生成 $A$-模, 记 $I^w M = \cap {n=1} ^{\infty} I^n M$, 则 $I(I^w M) = I^w M$, 从而 $I^w M = \lbrace x \in M | \exists b \in I, x = bx \rbrace$.<br>取 $M_1 = M, M_2 = I^w M$, 则存在 $k$, 使得当 $n \geq k$ 时</p>
<script type="math/tex; mode=display">
I^w M =  I^n M \cap I^w M = I^{n-k}(I^k M \cap I^w M) = I^{n-k} (I^w M)</script><p>所以 $I^w M = I(I^w M)$. 显然 $\lbrace x \in M | \exists b \in I, x = bx \rbrace \subseteq I^w M$. 另一方面 $I^w M   = I(I^w M)$ 当且仅当 $I + Ann(I^w M) = A$. 这是存在 $b \in I$, 使得 $1-b \in Ann(I^w M)$. 即对任意 $x \in I^w M , x=bx$.</p>
<blockquote>
<p>当 $A$ 是 Noetherian 整环时, $I^w M = \cap {n=1} ^{\infty} I^n M =(0)$<br>当 $I \subseteq J(A)$ 时, $I^w M = \cap {n=1} ^{\infty} I^n M =(0)$<br>特别地, 当 $A$ 是 Noetherian, $\cap {n=1} ^{\infty} J^n = 0$.<br>当 $A$ 不是 Noetherian 环时, 上述结果可能不成立, 例如实数 $\mathbb{R}$ 上在 $0$处无穷次可导的函数全体 $A$. $J$ 是在 $A$ 中在 $0$ 处取值为 $0$ 的函数全体($A$的唯一极大理想), 则 $e^{-\frac{1}{x^2}} \in A$</p>
<p>非交换环有一个著名的 Jacobson 猜想: $R$ 是左右 Noetherian 环, 则 $\cap_{n=1} ^{\infty} J(R) = 0$.</p>
</blockquote>
<h3 id="Dimension-Theroy"><a href="#Dimension-Theroy" class="headerlink" title="Dimension Theroy"></a>Dimension Theroy</h3><p>设 $A$ 是环, $n+1$ 个素理想构成的序列 $p_0 \supset p_1 \supset \cdots \supset p_n$ 称为长为 $n$ 的素理想链. 对任意 $p \in Spec(A)$, 满足 $p = p_0$ 的最长素理想链的称为 $p$ 的高度, 记作 $ht(p)$. 显然 $ht(p) = 0$表 示 $p$ 为 $A$ 的极小素理想.<br><strong>理想的高度</strong>：设 $I$ 为 $A$ 的真理想, 定义 $I$ 的高度为包含 $I$ 的所有素理想高度的最小值.</p>
<script type="math/tex; mode=display">
ht(I) = \inf \lbrace ht(p) | p \supset I \rbrace = ht(\sqrt{I})</script><p><strong>环的 Krull 维数</strong>：$A$ 的维数定义为最长的素理想链的长度.即</p>
<script type="math/tex; mode=display">
\dim(A) = \sup \lbrace ht(p) | p \in Spec(A) \rbrace</script><p>PID has Dimension $\leq 1$.<br><strong>Proof</strong>: 若 $(p) \supset (q) \supset (0)$. 则存在 $b \neq 0$ 使得$q = pb$, 从而 $(p)(b) \subset (q)$, 所以 $(b) \subseteq (q)$, 所以存在 $c$ 使得 $b = cpb$, 因此 $cp = 1$(domain 中), 从而$(p)=A$. 证毕.</p>
<p>由上述定义可知: 对任意 $p \in Spec(A), ht(p) = \dim(A_p)$, 对任意理想 $I$,  $\dim(A/I) + ht(I) \leq \dim(A)$.</p>
<p><strong>模的 Krull 维数</strong>：设 $M \neq 0$ 是 $A$-模. 定义 $M$ 的维数为:</p>
<script type="math/tex; mode=display">
\dim(M) = \dim(A/Ann(M))</script><p>当 $M = 0$ 时, 记 $\dim(M) = -1$.</p>
<p>若 $M \neq 0$ 是 Noetherian 环 $A$ 上的有限生成模, 则下列条件等价:</p>
<ol>
<li>$M$ 是有限长的.</li>
<li>环 $A/Ann(M)$ 是 Artinian.</li>
<li>$\dim(M) = 0$.</li>
</ol>
<p>由 Noetherian 环成为 Artin 环的充要条件知 $2 \leftrightarrow 3$. 再由有限生成 Artinian 模是有限长的可知 $2 \to 1$. 现在证明 $1\to 3$: 我们不妨考虑 $Ann(M) = (0)$ 的情形, 若 $l(M)$ 有限, 若 $\dim(A) &gt; 0$, 则存在极小素理想 $p$ 不是极大素理想. 由于 $M$ 是有限生成的, 且 $Ann(M)=(0)$, $M_p \neq 0$, 即 $p \in Supp(M)$ 是极小素理想, 因此 $p \in Ass(M)$. 即 $M$ 中包含一个同构于 $A/p$ 的子模. 由于 $\dim(A/p) &gt; 0$, 我们有 $l(A/p) = \infty$(这是因为有限长, 则为 Artinian, 从而维数为 0), 从而矛盾于 $l(M)$ 有限长.</p>
<h4 id="Noetherian-半局部环"><a href="#Noetherian-半局部环" class="headerlink" title="Noetherian 半局部环"></a>Noetherian 半局部环</h4><p>众所周知的几个关于维数的等价刻画本来是在 Noetherian 局部环中考虑的, 这里可以推广到 Noetherian 半局部环.</p>
<p>设 $A$ 是 Noetherian semi-local 环, $\mathfrak{m} = J(A)$. $A$ 的理想被称为<strong>ideal of definition(IOD)</strong>，如果存在 $k&gt;0$ 使得 $\mathfrak{m}^k \subseteq I \subseteq \mathfrak{m}$.</p>
<blockquote>
<p>当 $A$ 是局部环时, IOD 就是 $J$-准素理想.</p>
</blockquote>
<p>$I$ 是 IOD 的等价定义</p>
<ol>
<li>$I \subseteq \mathfrak{m}$ 且 $A/I$ 是 Artinian.</li>
<li>$I \subseteq \mathfrak{m}$ 且 $\dim(A/I)=0$.<br><strong>Proof</strong>: $1 \leftrightarrow$ 显然, 若 $I$ 是 IOD, 即存在 $k&gt;0$ 使得 $\mathfrak{m}^k \subseteq I subseteq \mathfrak{m}$. 从而包含 $I$ 的素理想必然是极大理想, 从而 $\dim(A) = 0$. 另一方面, 若 $I \subseteq \mathfrak{m}$ 且 $A/I$ 是 Artinian. 则 $J(A/I) = \mathfrak{m}/I$ 幂零, 从而 $\mathfrak{m}^n \subseteq I$.<blockquote>
<p>由于此时 $A/I$ 是 Artinian, 所以就可以由 Poincare 数, 以及 Hilbert-Serre 多项式. 完美的一 P.</p>
</blockquote>
</li>
</ol>
<p>设 $I$ 是 IOD, $M$ 是一个有限生成 $A$-模. 设 $A^{\star} = gr^I(A) = \otimes I^n / I^{n+1}$，$M^{\star} = gr^I(M) = \otimes I^n M / I^{n+1} M$</p>
<p>设 $I = A x_1 + \cdots Ax_r$. 那么 $A^{\star}$ 是 $B=A/I[X_1, \cdots, X_r]$ 的同态像. 因此 $F_{M^{\star}}(n) = l(I^n M/ I^{n+1} M)$ 是关于 $n$ 的次数不超过 $r-1$ 的多项式(由 Hilbert-Serre 的结果). 从而<br>​</p>
<script type="math/tex; mode=display">
\chi(M, I;n) \triangleq l(M/ I^{n+1} M) = \sum_{j=1} ^ {n-1}F_{M^{\star}}(j)</script><p>是一个次数不超过 $r$ 的多项式.<br>对于不同的 IOD $I’$, 存在 $s, s’$ 使得 $(I’)^s \subseteq I, I^{s’} \subseteq I’$. 从而 $deg chi(M, I;n) = chi(M, I’;n)$. 即 $chi(M, I;n)$ 是 $M$ 的一个不变量, 记作 $d(M)$.</p>
<blockquote>
<p>若有一个 IOD 被 $r$ 个元素生成, 则 $d(M) \leq r$.</p>
</blockquote>
<p>引理 0: 设 $I$ 是 Noetherian 半局部环 $A$ 的一个 IOD, 给定有限生成模的一个短正合列: $0 \to M’ \to M \to M’’ \to 0$. 则 $d(M) = \max(d(M’),d(M’’))$ 更进一步, 当 $n \gg 0$ 时, $\chi(M,I;n) - \chi(M’,I;n) - \chi(M’’,I;n)$ 的次数小于 $d(M’)$</p>
<p><strong>Proof</strong>: 由于 $l(M’’/I^n M’’) = l(M/M’+I^n M) \leq l(M/I^M)$, 从而 $d(M’’) \leq d(M)$. 更进一步, $\chi(M,I;n)-\chi(M’’,I;n) = l(M’+I^n M/I^n M) = l(M’/M’ \cap I^n M)$. 因此由 Artin-Rees 引理, 存在 $r$ 使得 $M’ \cap I^n M \subseteq I^{n-r} M’$, 从而 $l(M’/I^n M’) \geq l(M’/M’ \cap I^n M) \geq l(M’/I^{n-r} M’)$. 从而 $\chi(M,I;n)-\chi(M’’,I;n)$ 与 $\chi(M’,I;n)$ 有相同的最高次项.</p>
<p><strong>引理 1</strong>: 设 $A$ 是 Noetherian 半局部环, 则 $d(A) \geq dim(A)$<br>对 $d(A)$ 进行数学归纳. 若 $d(A)=0$, 则存在 $k$ 使得 $\mathfrak{m}^k = \mathfrak{m}^{k+1} \cdots$. 由 <strong>Krull 交定理</strong> 知 $\mathfrak{m}^k=(0)$. 从而 $l(A)$ 是有限长的, $\dim(A)=0$.<br>若 $d(A) &gt; 0$. 不妨设 $r = \dim(A)&gt;0$, 设 $p_0 \supset \cdots p_r = p$ 是长为$r$ 的素理想链. 任取 $x \in p_{r-1} \backslash p$. 则 $\dim(A/xA+p) \geq r-1$. 再由正合序列</p>
<script type="math/tex; mode=display">
0 \to A/p \xrightarrow{x} A/p \to A/xA+p \to 0</script><p>我们有 $d(A/xA+p) &lt; d(A/p) \leq d(A)$(这个严格小是因为上面”更进一步”的结论). 因此, 由数学归纳 $r-1 \leq \dim(A/xA+p) \leq d(A/xA+p) &lt; d(A)$, 证毕.</p>
<blockquote>
<p>上述引理表明 Noetherian 半局部环的维数有限, 且对于任意 Noetherian 及其素理想 $p, ht(p) = \dim(A_p)$ 有限, 从而 <strong>Noetherian 环满足素理想的降链条件</strong>, 当然 Noetherian 也可以由无限 Krull 维数, 例如: <img src= "/img/loading.gif" data-lazy-src="NagataNoether.png" alt="Nagata example"> <img src= "/img/loading.gif" data-lazy-src="NoetherJudge.png" alt="补充"></p>
</blockquote>
<p><strong>引理 2</strong>: 设 $M \neq 0$ 是 Noetherian 半局部环 $A$ 上的有限生成模. $x \in J(A)$. 则</p>
<script type="math/tex; mode=display">
d(M) \geq d(M/xM) \geq d(M)-1</script><p>取 IOD $I \ni x$. 则 $\chi(M/xM,I;n) = l(M/xM+I^n M) = l(M/I^nM) - l(xM + I^n M/I^n M)$ 且 $xM + I^n M /I^n M \simeq xM/xM \cap I^n M \simeq M/(I^n M:x)$, 又因为 $I^{n-1} \subseteq (I^n M:x)$ 从而</p>
<script type="math/tex; mode=display">
\chi(M/xM,I;n) \geq l(M/I^nM) - l(M/I^{n-1}M) = \chi(M,I;n) - \chi(M,I;n-1)</script><p><strong>引理 3</strong>: 设 $M \neq 0$ 是 Noetherian 半局部环 $A$ 上的有限生成模. 设 $\dim(A) = r$. 那么存在 $r$ 个元素 $x_1, \cdots, x_r \in J(A)$ 使得 $l(M/x_1 M + \cdots x_r M) \leq \infty$.<br><strong>Proof</strong>: 应用数学归纳法, 并说明在 $J(A)$ 不包含在 $Ann(M)$ 的任意极小素理想即可.</p>
<p><strong>维数等价定理</strong>：设 $M \neq 0$ 是 Noetherian 半局部环 $A$ 上的有限生成模. 则 $d(M) = dim(M)$ 为使得 $l(M/x_1 M + \cdots x_r M) \leq \infty$ 的最小的 $r$. 其中 $x_1, \cdots x_r \in M$.<br>若 $l(M/x_1 M + \cdots x_r M) \leq \infty$ 则由引理 2 知, $d(M) \leq r$. 当 $r$满足条件的最小值, 由引理 3 知, $r \leq \dim(M)$. 从而只需证明 $\dim(M) \leq d(M)$. 取 $M$ 的一个子模链 $M = M_1 \supset M_2 \supset \cdots \supset M_{k+1} = 0$. 使得 $M/M_{i+1} \simeq A/p_i, p_i \in Spec(A)$. 那么 $p_i \supseteq Ann(M)$. 且 $Ass(M) \subseteq \lbrace p_1, \cdots, p_k \rbrace$(这些之前就证明过了). 从而 $Supp(M) = V(Ann(M))$. 包含 $Ann(M)$ 的极小素理想是 $Supp(M)$ 的极小素理想, 从而在 $Ass(M)$ 中, 从而在 $\lbrace p_1, \cdots, p_k \rbrace$. 即 $Ass(M) = \lbrace p_1, \cdots, p_k \rbrace$. 因此(其中第一个等号要对 $M$ 的降链应用引理 0)</p>
<script type="math/tex; mode=display">
d(M) = \max d(A/p_i) \geq \max \dim(A/p_i) = \dim(A/Ann(M)) = \dim(M)</script><p><strong>广义 Krull 维数定理</strong>：$I=(a_1, \cdots, a_r)$ 是 Noetherian 环 $A$ 的理想. 则任意包含 $p$ 的极小素理想 $p$ 的高度不超过 $r$. 特别地, $h(I) \leq r$.<br><strong>Proof</strong>: 由于 $pA_p$ 是 $A_p$ 中包含 $IA_p$ 的唯一素理想, 因此 $\dim(A_p/IA_p)=0$. 从而环 $A_p/(a_1 A_p + \cdots a_rA_p)$ 是 Artinian. 因此 $ht(p) = \dim(A_p) \leq r$.</p>
<h4 id="Noetherian-局部环和-regular-local-ring-正则局部环"><a href="#Noetherian-局部环和-regular-local-ring-正则局部环" class="headerlink" title="Noetherian 局部环和 regular local ring(正则局部环)"></a>Noetherian 局部环和 regular local ring(正则局部环)</h4><p>设 $(A, \mathfrak{m},k)$ 是维数为 $d$ 的 Noetherian 局部环. 此时 IOD 和属于 $\mathfrak{m}$ 的准素理想是一回事. 我们知道 IOD 的生成元个数至少为 $d$ 并且存在 IOD 的生成元个数恰好为 $d$, 若 $\lbrace x_1, \cdots, x_d \rbrace$ 生成了一个 IOD 则称为 <strong>system of parameters</strong>(SOP). 若一个 SOP 生成了唯一极大理想 $\mathfrak{m}$. 则我们称 $A$ 为 <strong>正则局部环</strong></p>
<p>由于 $\mathfrak{m}$ 的极小基个数等于 $\text{rank}_k \mathfrak{m}/\mathfrak{m}^2$. 因此一般地我们有</p>
<script type="math/tex; mode=display">
\dim(A) \leq \text{rank}_k \mathfrak{m}/\mathfrak{m}^2</script><p>等号取得, 当且仅当 $A$ 是 Noetherian 局部环.</p>
<p>设$(A, \mathfrak{m})$是 Noetherian 局部环, $\lbrace x_1, \cdots, x_d \rbrace$ 是一个 $SOP$. 则</p>
<script type="math/tex; mode=display">
\dim(A/(x_1, \cdots, x_i) = d-i = \dim(A) - i</script><p>设 $A$ 是 Noetherian 环, 则 $\dim A[x_1, \cdots, x_n] = \dim A + n$.<br><strong>Proof</strong>: 对 $B = A[x]$ 证明即可. 对任意 $p \in Spec(A)$, 选择 $P$ 为满足 $P \cap A = p$ 中极大元. 则 $ht(P/pB) = 1$. 又 $ht(P) = ht(p) + ht(P/pB) = ht(p)+1$. 再由 $Spec(B) \to Spec(A)$ 是满的. 因此 $\dim(B) = \dim(A) + 1$.</p>
<p>推论: 设 $k$ 是域, 则 $\dim k[x_1, \cdots, x_n] = n$. 理想 $(x_1, \cdots, x_i)$ 是高度为 $i$ 的素理想.<br><strong>Proof</strong>: 由于 $(0) \supset (x_1) \supset (x_1,x_2) \supset \cdots \supset (x_1, \cdots, x_i)$ 是长为 $n$ 的素理想链. 在由 $\dim k[x_1, \cdots, x_n] = n$ 知结论成立.</p>
<h2 id="Depth"><a href="#Depth" class="headerlink" title="Depth"></a>Depth</h2><h4 id="M-regular-sequence"><a href="#M-regular-sequence" class="headerlink" title="$M$-regular sequence"></a>$M$-regular sequence</h4><p>我们称 $a_1, \cdots, a_r$ 是一个 <strong>$M$-regular sequence</strong>: 如果它满足:</p>
<ol>
<li><p>$\forall 1 \leq i \leq r, a_i$ 不是 $M/(a_1, \cdots, a_{i-1})M$ 的零因子;</p>
</li>
<li><p>$(a_1, \cdots, a_r)M \neq M$.</p>
</li>
</ol>
<blockquote>
<p>上述定义与 $a_1, \cdots, a_r$ 的次序有关, 例如 $k$ 为域, $A=k[x, y,z], a_1 = X(Y-1), a_2 = Y, a_3= Z(Y-1)$ 是 $A$-regular sequence, 但 $a_1, a_3, a_2$不是.</p>
</blockquote>
<p>类似地, 可以定义一个理想 $I$ 上的(极大) $M$-regular sequnence.</p>
<p><strong>引理 1</strong>: 假设 $a_1, \cdots, a_r$ 是 $M$-regular 且</p>
<script type="math/tex; mode=display">
a_1 \xi_1 + \cdots a_r \xi_r = 0</script><p>则 $\xi_i \in (a_1, \cdots, a_r)M$.</p>
<p><strong>引理 2</strong>: 假设 $a_1, \cdots, a_r$ 是 $M$-regular, 则 $a_1 ^{n_1} + \cdots a_r ^{n_r}$ 也是.</p>
<p>若 $a_1, a_2, \cdots \in A$ 是一个 $M$-regular sequence. 则由严格子模升链 $a_1 M \subset (a_1, a_2)M \subset \cdots$. 因此有理想严格升链 $a_1 \subset (a_1, a_2) \subset \cdots$. 从而若 $A$ 是 Noetherian 环, 则 $M$-regular sequence 的长度总是有限的, 因此每个理想 $I$ 上 $M$-regular sequence 都可以推展为一个极大 $M$-regular sequence.</p>
<p>定理: 设 $M$ 是 Noetherian 环 $A$ 上的有限生成模. $I$ 是 $A$的理想, 满足 $IM \neq M$. $n$ 为给定正整数. 则下列条件等价:</p>
<ol>
<li>$\text{Ext}_A ^i(N, M) = 0 (i&lt;n)$ 对任意满足 $Supp(N) \subseteq V(I)$ 的有限生成 $A$-模成立;</li>
<li>$\text{Ext} _A ^i(A/I, M) = 0 (i&lt;n)$;</li>
<li>存在一个满足 $Supp(N) = V(I)$ 的有限生成模 $N$ 使得 $\text{Ext}_A ^i(N, M) = 0 (i&lt;n)$;</li>
<li>$I$ 中存在长度为 $n$ 的 $M$-regular sequence $a_1, \cdots, a_n$.</li>
</ol>
<p><strong>Proof</strong>: $1 \to 2 \to 3$ 显然, $3 \to 4$: 我们有 $Ext_A ^0 (N,M) = \hom_A (N,M) = 0$. 若 $I$ 中无元素是 $M$-regular, 则 $I$ 包含在 $Ass(M)$ 全体的 (Noetherian 所以有限)并中, 从而 $I$ 包含于某个素理想 $P$ 中, 从而由单射 $A/P \to M$. 在 $P$ 处作局部化, 我们有 $\hom_{A_P}(k, M_P) \neq 0$, 其中 $k = A_P / P A_P$. 由于 $P \in V(I) = Supp(N)$. 从而 $N_P \neq 0$, 从而由 <strong>NAK lemma</strong> $N \otimes k = N_P / PN_P \neq 0$. 从而 $\hom(N \otimes k, k) \neq 0$. 从而 $\hom_{A_P}(N_P, M_P) \neq 0$. (三个映射的复合, 第一个满第三个单). 然而它 $\hom_A(N,M)=0$ 在 $P$ 处局部化的结果, 矛盾. 从而 $\exists a_1 \in I$, 若 $n&gt;1$, 取 $M_1 = M/a_1 M$. 由模的短正合列</p>
<script type="math/tex; mode=display">
0 \to M \xrightarrow{a_1} M \to M_1 \to 0</script><p>得到同调群的长正合列:</p>
<script type="math/tex; mode=display">
\cdots \to Ext_A ^i (N,M) \to Ext_A ^i (N,M_1) \to Ext_A ^{i+1} (N,M) \to \cdots</script><p>这说明 $Ext_A ^i(N,M_1) =0 (i&lt;n-1)$,  因此 $a_1^r$ 也零化 $Ext_A^i(N,M)$. 从而 $Ext_A(N,M) = 0 (i &lt;n)$</p>
<p>我们将上述 $I$ 中最长的 $M$-regular 序列称为 $I$-depth of $M$. 记作 $depth_I(M)$. 上述定理表明 </p>
<script type="math/tex; mode=display">
depth_I(M) = \min \lbrace i | Ext_A ^i(A/I,M) \neq 0 \rbrace</script><p>当 $(A, \mathfrak{m})$ 是(Noetherian 局部环时), 我们用 $depth(M), depth_A(M)$ 来表示 $depth_{\mathfrak{m}}(M)$ 称作 $M$ 的深度.</p>
<p>对任意 $P \in Spec(A)$, $depth M_P = 0 \Longleftrightarrow PA_P \in Ass_{A_P}(M_P) \Longleftrightarrow P \in Ass(M) \to depth_p(M) = 0$. 一般地, 由于局部化函子正合, 因此 $depth_{A_P} (M_p) \geq depth_P (M)$</p>
<p>若 $M = 0$, 定义 $depth_I(M) = 0$; 若 $IM = M \neq 0$, 定义 $depth_I(M) = \infty$.</p>
<h4 id="Grade"><a href="#Grade" class="headerlink" title="Grade"></a>Grade</h4><p>设 $M$ 是 Noetherian 环 $A$ 上的有限生成模. 定义 $M$ 的 garde 为:</p>
<script type="math/tex; mode=display">
grade M = \inf \lbrace i | Ext_A ^i (M,A) \neq 0 \rbrace</script><p>由上面定义知:</p>
<script type="math/tex; mode=display">
grade M = depth_I(A), \quad I = Ann(M)</script><p>同理, 由定义知: $grade M  \leq proj.dim M$</p>
<p>对于 $A$ 中任意理想 $I$, $depth_I(A)$ 为 $I$ 中最长的 $A$-sequence 序列 $a_1, \cdots, a_r$ 的长度. 又此时 $ht(a_1, \cdots, a_r) = r$. 从而 $depth_I(A) \leq ht(I)$</p>
<p><strong>引理 1</strong>: 设 $M \neq 0 ,N$ 是 Noetherian 环 $A$ 上的有限生成模, 若 $grad M = k$, $proj. dim N = l &lt; k$. 则 $Ext_A ^i(M,N) = 0 (i &lt; k-l)$<br><strong>Proof</strong>: 对 $l$ 数学归纳, $l=0$ 时, $N$ 为自由 $A$-模的直和因子, 因此结论成立. $l&gt;0$ 时, 由正合列: $0 \to N’ \to L \to N \to 0$, 其中 $L$ 自由, 于是$\dim N’ = l-1$. 由归纳法得证.</p>
<p><strong>引理 2</strong>: (<strong>Ischebeck</strong>) 设 $(A, \mathfrak{m})$ 是 Noetherian 局部环, $M \neq 0 \neq N$ 是有限生成 $A$-模. 若 $depth M = k, \dim N = r$. 则</p>
<script type="math/tex; mode=display">
Ext _A ^i (N,M) = 0 \quad (i< k-r)</script><p><strong>Proof</strong>: 对 $r$ 归纳法证明.(并不简单, 都是用模的短正合列, (再由投射分解, 得到复形的短正合列, 从而)导出同调群之间的长正合列, 然后应用数学归纳得出结论)</p>
<p>定理: 设 $(A,\mathfrak{m})$ 是 Noetherian 半局部环, 且 $M \neq 0$ 是有限生成 $A$-模. 那么对任意 $p \in Spec(A), \quad depth M \leq \dim(A/p)$.<br><strong>Proof</strong>: 由于 $\hom(A/p,M) \neq  0$, 上面引理反证即可.</p>
<p><strong>引理 3</strong>: 设 $M,N$ 是局部环 $(A,\mathfrak{m},k)$ 上的有限生成模, 则</p>
<script type="math/tex; mode=display">
M \otimes_A N \neq 0 \Longleftrightarrow M \neq 0 \neq N</script><p>若 $M \neq  0 \neq N$, 则由 <strong>NAK lemma</strong> 知: $M \otimes k =  M/\mathfrak{m}M \neq 0 \neq N \otimes k$. 由于 $k$ 是域. $(M \otimes N) \otimes k = (E \otimes k) \otimes_k  (F \otimes k) \neq  0$. 从而 $M \otimes N \neq 0$.</p>
<p><strong>引理 4</strong>: 设 $E,F$ 是环 $A$ 上的有限生成模, 则 $Supp(E \otimes F) = Supp(E) \cap Supp(F)$.<br><strong>Proof</strong>: 对任意 $p \in Spec(A,\quad (E \otimes F)_p = (E_p \otimes_{A\p} F_p)$.<br>由引理 3, $(E \otimes F)_p \neq 0 \Longleftrightarrow E_p \neq 0 \neq F_p$.</p>
<p><strong>引理 5</strong>: 设 $M \neq 0$ 是 Noetherian 局部环 $A$ 上的有限生成模, $a_1, \cdots, a_r$ 是 $M$-regular 序列. 那么</p>
<script type="math/tex; mode=display">
\dim M/(a_1, \cdots, a_r)M =  \dim M -r</script><p><strong>Proof</strong>: 首先由于此时 $\dim M = d(M)$, 我们有 $\dim M/(a_1, \cdots, a_r)M \geq \dim M -r$, 另一方面, 若 $x$ 是 $M$-regular 元, 那么由引理 4 $Supp(M/xM) = Supp(M) \cap Supp(A/xA) = Supp(M) \cap V(x)$. 由因为 $x$ 不在 $Supp(M) = V(Ann(M))$ 的极小素理想中. 从而</p>
<script type="math/tex; mode=display">
\dim(M/xM) = \dim(A/Ann(M)+xA) < \dim(A/Ann(M)) = \dim(M)</script><p><strong>引理 6</strong>: 设 $M$ 是 Noetherian 环 $A$ 上的有限生成模, $I$ 是 $A$的理想, 则</p>
<script type="math/tex; mode=display">
depth_I(M) = \inf \lbrace depth M_p | p \in V(I) \rbrace</script><p><strong>Proof</strong>: 将等式右边记作 $n$. 若 $n=0$. 则存在 $P \supseteq I$ 使得 $M_P = 0$. 从而 $I \subseteq p \in Ass(M)$. 从而 $depth_I(M) = 0$. 若 $0 &lt; n &lt; \infty$. 此时 $I$ 不包含于任何 $M$ 的 associated 素理想中, 因此存在 $M$-regular 元 $a \in I$. 记 $M’ = M/aM$. 则由 depth 和 $M$-regular 的关系(上面定理)知  $depth (M’)_P = depth M_P/aM_P = depth M_P -1, \text{ for } P \supset I$. 且 $depth_I(M’) = depth_I(M)-1$. 从而归纳法知结论成立, 当 $n = \infty$ 时, 对任意 $P \in V(I), \quad PM_P = M_P$. 若 $IM \neq M$, 对任意 $P \in Supp(M/IM) = V(I) \cap Supp(M)$, 我们有 $(M/IM)_P \neq 0$. 若 $P$ 是 $Supp(M/IM)$ 中的极小素理想, 则 $Supp_{A_P}(M/IM)_P = \lbrace PA_P \rbrace$. 因此 $(M/IM)_P = M_P/IM_P$ 在 $M_P$ 中 coprimary. 又因为 $P$ 是 $M_P$ 的零因子且有限生成, 所以存在 $s&gt;0$ 使得 $P^s \subseteq IM_P$. 因此 $PM_P \neq M_P$ 矛盾. 从而 $IM = M, \quad depth_I(M) = \infty$.</p>
<h3 id="Cohen-Macaulay-Rings"><a href="#Cohen-Macaulay-Rings" class="headerlink" title="Cohen-Macaulay Rings"></a>Cohen-Macaulay Rings</h3><p>设 $M$ 是 Noetherian 环 $A$ 上的有限生成模, 当 $M\neq 0$ 时, $\hom(M,M) \neq 0$, 从而由引理 2(Ischebeck) 知 $depth M \leq \dim M$. 我们称 $M$ 是<strong>Cohen-Macaulay</strong>(C.M.), 如果 $M = 0$ 或 $depth M = \dim M$. 若 $A$ 作为 $A$-模是 $C.M.$, 则称 $A$ 是 $C.M.$环.</p>
<p>设 $(A,\mathfrak{m})$ 是局部环, $M$ 是有限生成 $A$-模. 则:</p>
<ol>
<li>若 $M$ 是 C.M. 模, $p \in Ass(M)$, 则 $depth(M) = \dim(A/P)$. 从而 $Ass(M)$ 中元素没有包含关系.</li>
<li>若 $a_1, \cdots, a_r$ 是 $\mathfrak{m}$中的 $M$-regular 序列, 取 $M’ = M/(a_1, \cdots, a_r)M$. 则 $M$ 是 C.M. 当且仅当 $M’$ 是 C.M.</li>
<li>若 $M$ 是 C.M. 模, 则对任意 $P \in Spec(A)$, $A_P$ 模 $M_P$ 是 C.M. 模, 且当 $M_P \neq 0$ 时, $depth_P(M) = depth _{A_P} M_P = \dim M_P$</li>
</ol>
<p><strong>Proof</strong>:<br>1) 由于 $Ass(M) \neq 0$, 所以 $M \neq 0$, 因此 $depth(M) = \dim M$. 又因为 $P \in Supp(M)$, 我们有 $\dim M \geq \dim A/P \geq depth M$. 证毕.</p>
<p>2) 由 <strong>NAK lemma</strong>, 我们有 $M = 0 \Longleftrightarrow M’ = 0$. 若 $M \neq 0$. 则由引理 5 知 $\dim M’=\dim M -r$. 由 $depth$ 的 $M$-regular 序列刻画知, $depth M’ = depth M - r$.</p>
<p>3) 我们假定 $M_P \neq 0$. 此时 $P \supseteq Ann(M)$. 我们有 $\dim M_P \geq depth_{A_P} M_P \geq depth_P(M)$. 对 $depth_P(M)$ 数学归纳, 若 $depth_P(M) = 0$, 则 $P$ 包含于某个 $P’ \in Ass(M)$. 因为 $Ann(M) \subseteq P \subseteq P’$. 由 1)的结论, 包含 $Ass(M)$ 中的素理想是包含 $Ann(M)$ 的极小素理想, 从而 $P = P’$. 从而 $\dim M_P = 0$. 若 $depth_P(M)&gt;0$, 取一个 $M$-regular 元 $a \in P$, 记 $M_1 = M/aM$. 由于局部化函子是正合的, $a$ 也是 $M_P$-regular. 因此 $\dim (M_1)_P = \dim M_P/aM_P = \dim M_P-1$ 且 $depth_P(M_1) = depth_P(M) - 1$. 由 2) $M_1$ 是 C.M. 从而由归纳法, $\dim (M_1)_P = depth_P(M_1)$, 证毕.</p>
<p>引理 7: 设 $(A, \mathfrak{m})$ 是 C.M. 局部环, 则对任意序列 $a_1, \cdots, a_r \in \mathfrak{m}$, 下列条件等价:</p>
<ol>
<li>$a_1, \cdots, a_r$ 是 $A$-regular 序列</li>
<li>$ht(a_1, \cdots, a_i) = i (1 \leq i \leq r)$</li>
<li>$ht(a_1, \cdots, a_r) = r$</li>
<li>存在 $a_{r+1} \cdots a_n \in \mathfrak{m}, (n = \dim A)$ 使得 $\lbrace a_1, \cdots a_n \rbrace$ 是 SOP.</li>
</ol>
<p><strong>Proof</strong>: $1 \to 2$: 由广义 Krull 定理: $ht(a_1, \cdots, a_i) \leq i$, 再由 $a_1, \cdots, a_r$ 是 $A$-regular 序列知 $ht(a_1, \cdots, a_i) \geq i$. $2 \to 3$ 显然, $3 \to 4$: 若 $\dim A = r$ 则结论是平凡的. 若 $\dim A &gt; r$, 则可以找到 $a_{r+1} \in \mathfrak{m}$ 不在包含 $(a_1, \cdots, a_r)$ 的极小素理想中, 从而 $ht(a_1, \cdots, a_{r+1}) = r+1$. 于是一直这样进行下去即可. $4 \to 1$: 只需证明每个 SOP $x_1, \cdots, x_n$ 都是 $A$-regular 序列. 若 $P \in Ass(A)$, 则 $\dim A/P = n$. 因此 $x_1 \notin P$(否则它在 $A/P$ 下的像怎么生成 $\mathfrak{m}/P$). 因此 $x_1$ 是 $A$-regular. 记 $A’ = A/(x_1)$. 则 $A’$ 是 C.M. 维数为 $n-1$ 局部环. 由归纳法结论成立.</p>
<p>设 $I$ 是 C.M. 局部环 $(A, \mathfrak{m})$ 的真理想, 则</p>
<ol>
<li>$ht(I) = depth_I(A) = \dim A - \dim(A/I)$</li>
<li>对任意素理想 $p \subset q, ht(q) = ht(p) + ht(q/p)$.<br><strong>Proof</strong>: 1. $ht(I) = r$. 我们可以选择 $a_1, \cdots, a_r \in I$ 使得 $ht(a_1, \cdots, a_i) = i \quad 1 \leq i \leq r$. 由引理 7, $a_1, \cdots, a_r$ 是 $I$ 中 $A$-regular 序列. 从而 $ht(I) \leq depth_I(A)$. 另一方面, 若 $b_1, \cdots, b_s$ 是 $I$ 中 $A$-regular 序列, 则 $ht(b_1, \cdots, b_s) = s \leq ht(I)$. 因此 $ht(I) = depth_I(A)$. 由于 $ht(I) = \inf \lbrace ht(P) | P \in V(I) \rbrace$, $\dim(A/I) = \sup \lbrace \dim A/P | P \in V(I) \rbrace$. 若 $ht(P) = \dim(A) - \dim(A/P)$, 对任意 $P \in Spec(A)$ 成立, 那么 $ht(I) = \dim A - \dim(A/I)$ 显然也成立. 由于 $A_P$ 是 C.M. 环, $ht(P) = \dim(A_P) = depth_P(A)$. 从而我们可以找 $P$ 中一个 $A$-regular 序列 $a_1, \cdots, a_r$. $A/(a_1, \cdots, a_r)$ 是维数为 $n-r$ 的 C.M. 环, $P$ 是包含 $a_1, \cdots, a_r$ 的极小素理想. 从而 $\dim(A/P) - n-r$(由上面的性质).</li>
<li>若 $p supset q$ 是 $A$ 的素理想, 则 $A_q$ 是 C.M. 环, 从而 $\dim A_q = ht pA_q + \dim A_q / pA_q$. 即 $ht(q) = ht(p) + ht(q/p)$.</li>
</ol>
<p><strong>Cohen-Macauly Ring</strong> 称一个 Noetherian 环 $A$ 是 Cohen-Macaulay 如果对任意 $A_P \in Spec(A)$, $A_P$ 是 C.M. local ring. 实际上只要在对 $A_P \in \omega(A)$ 成立即可.</p>
<p>设 $A$ 是 Cohen-Macaulay 环, 则多项式环 $A[x_1, \cdots, x_n]$ 也是 Cohen-Macaulay 环.</p>
<h2 id="To-be-Continue"><a href="#To-be-Continue" class="headerlink" title="To be Continue"></a>To be Continue</h2>]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 汇总</title>
    <url>/codeforces/</url>
    <content><![CDATA[<p>最近感觉自己又行了。就很想重新开始打 <a href="https://codeforces.com" target="_blank" rel="noopener">Codeforces</a>，这里罗列一下从 2020/05/16 开始提交的(不是特别水的）AC 代码。想有生之年上一次黄，先定个小目标上个 1900！菜鸡 dna049 加油！</p>
<blockquote>
<p><strong>优雅的代码极大的避免了低级错误</strong>，边界处理至少占三分之一的工作量！</p>
<p><strong>不要急着写代码，不要急着写代码，不要急着写代码，重要的事情说三遍！！！</strong></p>
</blockquote>
<a id="more"></a>
<p>Codeforces 比赛规则：每题有基础分数，每题的分数根据时间线性递减到一半（所以有些大佬先做 CD，再做 AB），在最后一次提交前每次提交减 50 分，然后按照分数排名，有 hack，但是只有你过了初例并且 <strong>锁定题目</strong> 才能 hack。<br>Eductional 比赛规则：与 ICPC 一致，不过一次非 AC 提交罚时为 10 分钟（ICPC 20 分钟）</p>
<p>Codeforces Gobal Round：<del>目前实力不支持做这个，容易掉分！</del> 正常发挥都是能加分的！</p>
<p><a href="https://codeforces.com/problemset/standings?friendsEnabled=on" target="_blank" rel="noopener">查看 Codeforces 上的过题数</a>，<a href="https://codeforces.com/contests/with/dna049" target="_blank" rel="noopener">查看比赛 rating 折线</a>，开始使用 <a href="https://github.com/xalanq/cf-tool/blob/master/README_zh_CN.md" target="_blank" rel="noopener">cf-tool</a> + WSL 打比赛（真香）。</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul>
<li>比赛链接后面加 <code>/problems</code> 可以一个界面看所有题目。</li>
<li>每道题思考时间不得超过 15 分钟，防止卡题！！！（常备闹钟，不骄不躁！）</li>
<li><del>AC 的代码一般过几秒会弹出 Accept 对话框，所以可以值得等 <code>2~5</code>s，没弹再刷新</del>（cf-tool 真香）。</li>
<li>先打开所有题目，大致扫一眼！只做：数论+DP+图论</li>
<li>不要急着写代码！！！不是每一把都要打，不适合自己的强做没意思！！！</li>
<li>计算式要列的清晰，并且最好是好输入的。</li>
<li><strong>仔细</strong> 读完题目有明显思路赶紧写，然后要细心把公式列出来不要跳，再去写代码，过了再看别的题</li>
<li><del><code>caseInput.cpp, nocaseinput.cpp</code> 模板先建好</del> (cf-tool 真香)</li>
<li><del><a href="https://codeforces.com" target="_blank" rel="noopener">codeforces.com</a> 打不开的时候可以换成<a href="https://codeforces.ml" target="_blank" rel="noopener">.ml</a> 或者 <a href="https://codeforc.es" target="_blank" rel="noopener">.es</a> (这个网址就很机智！)</del> 现在（2020/8/19) 主站特别稳定</li>
<li><del><code>A~F.cpp</code>先创建好，用好 <code>fopen</code> 但是记得关</del> (cf-tool 真香)</li>
<li><del>推荐在 submit 界面交题目（不推荐选择文件，<strong>有时候网慢，很可能没交上题</strong>）</del> (cf-tool 真香)。</li>
<li>另外一个浏览器（或另一个主界面）看一下关注 Standing，不要把简单问题想复杂了</li>
<li><strong>不要写这样的代码</strong>：<code>if(a[j++]),while(a[j++])</code> 这种数列下标自加，特别容易出问题还不好查，特别在判断语句中。</li>
<li>在高效和细心中找到一个均衡</li>
<li>$N=10^{18}$ 一般会有公式， $N = 2 \cdot 10^5$ 一般会用到排序、树状数组，线段树，等一系列 $O(n\log n)$ 算法，$N=1000$ 一般会用到 $dp$。模 <code>998244353</code> 可能会用到 NFT。</li>
</ul>
<h2 id="题集"><a href="#题集" class="headerlink" title="题集"></a>题集</h2><h3 id="HDU-6838-Battle-for-Wosneth"><a href="#HDU-6838-Battle-for-Wosneth" class="headerlink" title="HDU 6838 Battle for Wosneth"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6838" target="_blank" rel="noopener">HDU 6838 Battle for Wosneth</a></h3><blockquote>
<p>有两个人记作 Alice 和 Bob，Alice 的生命值很高，所以可以认为是无限的，Bob 的生命值为 m。两个人的攻击命中率分别为 <code>p,q</code>。两个人轮流攻击对方。从 Alice 开始攻击，每次攻击的时候，如果 Alice 命中，那么能让对方的生命值减低 1，同时自己的生命值能恢复 1，如果 Bob 命中，那么能让对方的生命值减低 1，注意 Bob 不会自己回血。直到 Bob 的血量变为 0，游戏结束。Alice 想知道，游戏结束的时候，自己期望生命值。</p>
</blockquote>
<p>不妨设，期望为 <code>a[m]</code>, 则显然<br><code>a[m] = p(1-q)(a[m-1]+1) + pq a[m-1] + (1-p)q(a[m]-1) + (1-p)(1-q)a[m]</code><br>化简一下得到 $a_m =  a_{m - 1} + \frac{p - q}{p}$. 另外 $a_1 = p + (1 - p) q (a_1 - 1)  + (1 - p) (1 - q) a_1$，所以 $a_1 = \frac{p - q + pq}{p}$ 即 $a_m = \frac{p - q}{p} m + q$</p>
<h3 id="HDU-6842-Battle-for-Wosneth2"><a href="#HDU-6842-Battle-for-Wosneth2" class="headerlink" title="HDU 6842 Battle for Wosneth2"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6842" target="_blank" rel="noopener">HDU 6842 Battle for Wosneth2</a></h3><blockquote>
<p>有两个人记作 Alice 和 Bob，生命值分别是 n,m，命中率分别为 p%,q%。两个人轮流攻击对方，从 Alice 开始攻击，每次攻击的时候，如果命中，那么能让对方的生命值减低 1，直到一方的生命值不超过 0 为止。问 Alice 胜的概率</p>
</blockquote>
<p>设 <code>a[n][m], b[m][n]</code> 分别表示表示 Alice, Bob 胜的概率。则<br><code>a[n][m] = p(1-b[n][m]) + (1-p)(1-b[n][m])</code>，<br><code>b[n][m] = q(1-a[m-1][n] + (1-q)(1-a[m][n]</code>，<br>所以我们有<code>(p+q-pq) a[n][m] = p(1-q) a[m][n] + (1-p)q a[m-1][n] + pq a[m-1][n-1]</code></p>
<h3 id="1399D-01序列分组，使得各组相邻元素不同（主要考察复杂度，超级容易-TLE）"><a href="#1399D-01序列分组，使得各组相邻元素不同（主要考察复杂度，超级容易-TLE）" class="headerlink" title="1399D: 01序列分组，使得各组相邻元素不同（主要考察复杂度，超级容易 TLE）"></a><a href="https://codeforces.com/contest/1399/problem/D" target="_blank" rel="noopener">1399D</a>: <code>01</code>序列分组，使得各组相邻元素不同（主要考察复杂度，超级容易 TLE）</h3><blockquote>
<p>可以存储当前 <code>1</code> 和 <code>0</code> 的个数，然后一直跑，就是 $O(n)$ 复杂度了</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>, r[n];</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; id[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (<span class="string">'0'</span> == s[i]);</span><br><span class="line">            <span class="keyword">if</span> (id[t].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                r[i] = id[t].top();</span><br><span class="line">                id[t].pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r[i] = ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            id[<span class="number">1</span> - t].push(r[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1399E1：dfs-建树，然后就知道每条边的权重，然后有限队列贪心即可，注意是所有叶子节点到根的距离和"><a href="#1399E1：dfs-建树，然后就知道每条边的权重，然后有限队列贪心即可，注意是所有叶子节点到根的距离和" class="headerlink" title="1399E1：dfs 建树，然后就知道每条边的权重，然后有限队列贪心即可，注意是所有叶子节点到根的距离和"></a><a href="https://codeforces.com/contest/1399/problem/E1" target="_blank" rel="noopener">1399E1</a>：dfs 建树，然后就知道每条边的权重，然后有限队列贪心即可，注意是所有叶子节点到根的距离和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head, nxt, to;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; w;</span><br><span class="line">    LinkStar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        nxt.<span class="built_in">clear</span>();</span><br><span class="line">        to.<span class="built_in">clear</span>();</span><br><span class="line">        head = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL val)</span> </span>&#123;</span><br><span class="line">        nxt.emplace_back(head[u]);</span><br><span class="line">        head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">        to.emplace_back(v);</span><br><span class="line">        w.emplace_back(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    LL v;</span><br><span class="line">    Node(<span class="keyword">int</span> _d, LL _v) : d(_d), v(_v) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (v + <span class="number">1</span>) / <span class="number">2</span> * d &lt; (A.v + <span class="number">1</span>) / <span class="number">2</span> * A.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        LL s;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">        <span class="function">LinkStar <span class="title">diag</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i) &#123;</span><br><span class="line">            LL w;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            diag.addedge(u, v, w);</span><br><span class="line">            diag.addedge(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::priority_queue&lt;Node&gt; a;</span><br><span class="line">        <span class="keyword">bool</span> vis[n + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">        <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, LL)&gt; dfs = [&amp;](<span class="keyword">int</span> u, LL val) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            vis[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = diag.head[u]; ~i; i = diag.nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = diag.to[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) cnt += dfs(v, diag.w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="built_in">std</span>::<span class="built_in">max</span>(cnt, <span class="number">1</span>);</span><br><span class="line">            s -= val * cnt;</span><br><span class="line">            a.push(&#123;cnt, val&#125;);</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [cnt, val] = a.top();</span><br><span class="line">            s += (val + <span class="number">1</span>) / <span class="number">2</span> * cnt;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; <span class="number">1</span>) a.push(&#123;cnt, val / <span class="number">2</span>&#125;);</span><br><span class="line">            a.pop();</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1399E2-同-E1，只是贪心的时候，枚举费用为-2-的边的个数"><a href="#1399E2-同-E1，只是贪心的时候，枚举费用为-2-的边的个数" class="headerlink" title="1399E2:  同 E1，只是贪心的时候，枚举费用为 2 的边的个数"></a><a href="https://codeforces.com/contest/1399/problem/E2" target="_blank" rel="noopener">1399E2</a>:  同 E1，只是贪心的时候，枚举费用为 2 的边的个数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head, nxt, to, c;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; w;</span><br><span class="line">    LinkStar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        nxt.<span class="built_in">clear</span>();</span><br><span class="line">        to.<span class="built_in">clear</span>();</span><br><span class="line">        head = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL val, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">        nxt.emplace_back(head[u]);</span><br><span class="line">        head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">        to.emplace_back(v);</span><br><span class="line">        w.emplace_back(val);</span><br><span class="line">        c.emplace_back(cost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        LL s;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">        <span class="function">LinkStar <span class="title">diag</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, c; i &lt; n; ++i) &#123;</span><br><span class="line">            LL w;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">            diag.addedge(u, v, w, c - <span class="number">1</span>);</span><br><span class="line">            diag.addedge(v, u, w, c - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, LL&gt;&gt; a;</span><br><span class="line">        <span class="keyword">bool</span> vis[n + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">        <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, LL, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, LL val, <span class="keyword">int</span> cost) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            vis[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = diag.head[u]; ~i; i = diag.nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = diag.to[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) cnt += dfs(v, diag.w[i], diag.c[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="built_in">std</span>::<span class="built_in">max</span>(cnt, <span class="number">1</span>);</span><br><span class="line">            s -= val * cnt;</span><br><span class="line">            a.push_back(&#123;cost, cnt, val&#125;);</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; q[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [cost, cnt, val] : a) &#123;</span><br><span class="line">            <span class="keyword">while</span> (val) &#123;</span><br><span class="line">                q[cost].emplace_back((val + <span class="number">1</span>) / <span class="number">2</span> * cnt);</span><br><span class="line">                val &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(q[<span class="number">0</span>].<span class="built_in">begin</span>(), q[<span class="number">0</span>].<span class="built_in">end</span>(), <span class="built_in">std</span>::greater&lt;&gt;());</span><br><span class="line">        <span class="built_in">std</span>::sort(q[<span class="number">1</span>].<span class="built_in">begin</span>(), q[<span class="number">1</span>].<span class="built_in">end</span>(), <span class="built_in">std</span>::greater&lt;&gt;());</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : q[<span class="number">0</span>]) s += x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = q[<span class="number">0</span>].<span class="built_in">size</span>(); i &lt;= q[<span class="number">1</span>].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s - q[<span class="number">0</span>][j - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                s -= q[<span class="number">0</span>][--j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= <span class="number">0</span>) r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, <span class="number">2</span> * i  + j);</span><br><span class="line">            <span class="keyword">if</span> (i != q[<span class="number">1</span>].<span class="built_in">size</span>()) s += q[<span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1399F-区间-dp-问题"><a href="#1399F-区间-dp-问题" class="headerlink" title="1399F :  区间 dp 问题"></a><a href="https://codeforces.com/contest/1399/problem/F" target="_blank" rel="noopener">1399F</a> :  区间 dp 问题</h3><blockquote>
<p>用 <code>f[m]</code> 表示从 <code>a[i]</code> 的左边界到，<code>m</code> 的区间个数(是被一个大的覆盖了的区间，size 一般不为 1）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// follow the idea of Jiangly</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        std::vector&lt;std::pair&lt;int, int&gt;&gt; a(n);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[l, r] : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        a.push_back(&#123;<span class="number">1</span>, <span class="number">2e5</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[l, r] : a) &#123;</span><br><span class="line">            v.emplace_back(l);</span><br><span class="line">            v.emplace_back(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        v.erase(<span class="built_in">std</span>::unique(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[l, r] : a) &#123;</span><br><span class="line">            l = <span class="built_in">std</span>::lower_bound(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), l) - v.<span class="built_in">begin</span>();</span><br><span class="line">            r = <span class="built_in">std</span>::lower_bound(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), r) - v.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;lhs, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;rhs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lhs.first == rhs.first) <span class="keyword">return</span> lhs.second &lt; rhs.second;</span><br><span class="line">            <span class="keyword">return</span> lhs.first &gt; rhs.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> dp[n + <span class="number">1</span>] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(a[i].second + <span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">int</span> mx = <span class="number">0</span>, x = a[i].first - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j].second &gt; a[i].second) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span> (x + <span class="number">1</span> &lt; a[j].first) mx = <span class="built_in">std</span>::<span class="built_in">max</span>(mx, f[++x]);</span><br><span class="line">                f[a[j].second] = <span class="built_in">std</span>::<span class="built_in">max</span>(f[a[j].second], dp[j] + mx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : f) mx = <span class="built_in">std</span>::<span class="built_in">max</span>(mx, t);</span><br><span class="line">            dp[i] = <span class="number">1</span> + mx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(dp[n] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1389F：二分图"><a href="#1389F：二分图" class="headerlink" title="1389F：二分图"></a><a href="https://codeforces.com/contest/1389/problem/F" target="_blank" rel="noopener">1389F</a>：二分图</h3><p><a href="https://codeforces.com/profile/emorgan5289" target="_blank" rel="noopener">emorgan5289 大佬的代码</a>以及<a href="https://codeforces.com/blog/entry/80723#comment-671203" target="_blank" rel="noopener">解释</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt;&gt; a;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>); <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, t; <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; t;</span><br><span class="line">        a.insert(t<span class="number">-1</span> ? <span class="built_in">array</span>&#123;r, <span class="number">1</span>, -l&#125; : <span class="built_in">array</span>&#123;l, <span class="number">0</span>, -r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [_, t, x] : a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &amp;&amp; s.upper_bound(x) != s.<span class="built_in">begin</span>())</span><br><span class="line">            s.erase(--s.upper_bound(x)), n--;</span><br><span class="line">        <span class="keyword">if</span> (!t) s.insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1384D：两个人轮流取-n-个数，比较它们取的数的异或值，较大的赢"><a href="#1384D：两个人轮流取-n-个数，比较它们取的数的异或值，较大的赢" class="headerlink" title="1384D：两个人轮流取 $n$ 个数，比较它们取的数的异或值，较大的赢"></a><a href="https://codeforces.com/contest/1384/problem/D" target="_blank" rel="noopener">1384D</a>：两个人轮流取 $n$ 个数，比较它们取的数的异或值，较大的赢</h3><p>记 $s$ 为 $n$ 个数的异或值，如果 $s = 0$，那么显然平局，否则看与 $s$ 的最高位 异或不为 0 的数的人数 cnt，显然这个个数是奇数，所以为 $1 \mod 4$ ，那么先手赢，否则，我们看 $n - cnt$ 是否为奇数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) sum ^= x;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DRAW\n"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="built_in">std</span>::__lg(sum);</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="keyword">if</span>((x &gt;&gt; k) &amp; <span class="number">1</span>) ++cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">4</span> == <span class="number">1</span> || (n - cnt) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"WIN\n"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"LOSE\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1384B：很有意思的一道模拟题，我也不知道为什么我要想这么久，太菜了"><a href="#1384B：很有意思的一道模拟题，我也不知道为什么我要想这么久，太菜了" class="headerlink" title="1384B：很有意思的一道模拟题，我也不知道为什么我要想这么久，太菜了"></a><a href="https://codeforces.com/contest/1384/problem/B2" target="_blank" rel="noopener">1384B</a>：很有意思的一道模拟题，我也不知道为什么我要想这么久，太菜了</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k, len;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; len;</span><br><span class="line">        <span class="keyword">int</span> d[n];</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">            <span class="keyword">if</span> (d[i] &gt; len) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i] = len - d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No\n"</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> li = <span class="built_in">std</span>::<span class="built_in">min</span>(k, d[i]);</span><br><span class="line">            <span class="keyword">int</span> ri = <span class="built_in">std</span>::<span class="built_in">max</span>(k, <span class="number">2</span> * k - d[i]);</span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">2</span> * k) &#123;</span><br><span class="line">                l = <span class="number">0</span>;</span><br><span class="line">                r = <span class="built_in">std</span>::<span class="built_in">max</span>(r + <span class="number">1</span>, ri);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (++l &gt; li) flag = <span class="literal">true</span>;</span><br><span class="line">            l = <span class="built_in">std</span>::<span class="built_in">min</span>(l, k);</span><br><span class="line">            <span class="keyword">if</span> (d[i] &gt;= k) r = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (flag ? <span class="string">"No"</span> : <span class="string">"Yes"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷-U122053-选择题：经典问题：每个人说另一个人是不是好人，-好人只说真话，坏人只说慌话，输出有多少种可能的情况，并输出可能的情况下，最多的好人和最少的好人数"><a href="#洛谷-U122053-选择题：经典问题：每个人说另一个人是不是好人，-好人只说真话，坏人只说慌话，输出有多少种可能的情况，并输出可能的情况下，最多的好人和最少的好人数" class="headerlink" title="洛谷 U122053 选择题：经典问题：每个人说另一个人是不是好人， 好人只说真话，坏人只说慌话，输出有多少种可能的情况，并输出可能的情况下，最多的好人和最少的好人数"></a><a href="https://www.luogu.com.cn/problem/U122053?contestId=31675" target="_blank" rel="noopener">洛谷 U122053 选择题</a>：<strong>经典问题</strong>：每个人说另一个人是不是好人， 好人只说真话，坏人只说慌话，输出有多少种可能的情况，并输出可能的情况下，最多的好人和最少的好人数</h3><p><code>val[i]</code> 表示第 $i$ 个人是否为好人， <code>w[i,j]</code> 表示$i$ 说 $j$ 是好人还是坏人，或 $j$ 说 $i$ 是好人还是坏人，那么必然 <code>val[i] ^ val[j] = !w[i,j]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/U122053?contestId=31675</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[N], val[N], cnt, nxt[<span class="number">2</span> * N], to[<span class="number">2</span> * N];</span><br><span class="line"><span class="keyword">bool</span> w[<span class="number">2</span> * N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> (head));</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">-1</span>, <span class="keyword">sizeof</span> (val));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">    nxt[++cnt] = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    to[cnt] = v;</span><br><span class="line">    w[cnt] = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此题BFS更好，不过DFS也能过</span></span><br><span class="line">std::pair&lt;int, int&gt; dfs(int u, int flag) &#123;</span><br><span class="line">    val[u] = flag;</span><br><span class="line">    <span class="keyword">int</span> r1 = <span class="number">1</span>, r2 = flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = to[i];</span><br><span class="line">        <span class="keyword">if</span> (val[v] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[v] != (val[u] ^ w[i])) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> [vr1, vr2] = dfs(v, val[u] ^ w[i]);</span><br><span class="line">            <span class="keyword">if</span> (vr1 == <span class="number">-1</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            r1 += vr1;</span><br><span class="line">            r2 += vr2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;r1, r2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::pair&lt;int, int&gt; bfs(int iu, int iflag) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(&#123;iu, iflag&#125;);</span><br><span class="line">    <span class="keyword">int</span> r1 = <span class="number">0</span>, r2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [u, flag] = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (val[u] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        val[u] = flag;</span><br><span class="line">        ++r1;</span><br><span class="line">        r2 += flag;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = to[i];</span><br><span class="line">            <span class="keyword">if</span> (val[v] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val[v] != (val[u] ^ w[i])) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> q.push(&#123;v, val[u] ^ w[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;r1, r2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    LL r = <span class="number">1</span>, x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>; x = x * x % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n;	</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; flag;</span><br><span class="line">        addedge(i, x, !flag);</span><br><span class="line">        addedge(x, i, !flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>, mx = <span class="number">0</span>, mi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (val[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// auto [r1, r2] = dfs(i, 1);</span></span><br><span class="line">        <span class="keyword">auto</span> [r1, r2] = bfs(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No answer\n"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++now;</span><br><span class="line">        mx += <span class="built_in">std</span>::<span class="built_in">max</span>(r2, r1 - r2);</span><br><span class="line">        mi += <span class="built_in">std</span>::<span class="built_in">min</span>(r2, r1 - r2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; powMod(now) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mx &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷-U122055-出生点-：简单包容排斥"><a href="#洛谷-U122055-出生点-：简单包容排斥" class="headerlink" title="洛谷 U122055 出生点 ：简单包容排斥"></a><a href="https://www.luogu.com.cn/problem/U122055?contestId=31675" target="_blank" rel="noopener">洛谷 U122055 出生点</a> ：简单包容排斥</h3><p><strong>仅考虑 $x$-轴</strong></p>
<p>当$k=0$ 时，那么距离之和就是</p>
<script type="math/tex; mode=display">
m^2 \sum_{i=1}^n i(n-i) = m^2 \sum_{1} ^n i(n-1) - i(i-1) = \frac{m^2(n-1)n(n+1)}{6}</script><p>然后我们减去 $k$ 个障碍点和其它所有点之间的距离</p>
<script type="math/tex; mode=display">
m  \sum _{i=1} ^k \sum_{t=1} ^n |a[i] - t| = m  \sum _{i=1} ^k \frac{(a[i])(a[i]-1) + (n-a[i])(n-a[i] + 1)}{2}</script><p>再加上 $k$ 个障碍点之间的距离</p>
<p>不妨按照 $x$-轴排序，然后把前缀和 <code>sa[i]</code> 求一下，再依次计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL inv2 = (M + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> LL inv6 = (M + <span class="number">1</span>)/<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    LL n, m;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    LL a[k], b[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(a, a + k);</span><br><span class="line">    <span class="built_in">std</span>::sort(b, b + k);</span><br><span class="line">    LL sa[k] = &#123;a[<span class="number">0</span>]&#125;, sb[k] = &#123;b[<span class="number">0</span>]&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++ i) &#123;</span><br><span class="line">        sa[i] = sa[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        sb[i] = sb[i - <span class="number">1</span>] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [](LL m, LL n) -&gt; LL &#123;</span><br><span class="line">        <span class="keyword">return</span> m * m % M * (n - <span class="number">1</span>) % M * n % M * (n + <span class="number">1</span>) % M;</span><br><span class="line">    &#125;;</span><br><span class="line">    LL r0 = (f(m, n) + f(n, m)) * inv6 % M;</span><br><span class="line">    </span><br><span class="line">    LL r1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) &#123;</span><br><span class="line">        r1 += ((a[i] - <span class="number">1</span>) * a[i] + (n - a[i] + <span class="number">1</span>) * (n - a[i])) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    r1 = r1 % M * m % M * inv2 % M;</span><br><span class="line">    </span><br><span class="line">    LL r2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) &#123;</span><br><span class="line">        r2 += ((b[i] - <span class="number">1</span>) * b[i] + (m - b[i] + <span class="number">1</span>) * (m - b[i])) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    r2 = r2 % M * n % M * inv2 % M;</span><br><span class="line">    </span><br><span class="line">    LL r3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        r3 += (sa[k - <span class="number">1</span>] - sa[i] - a[i] * (k - <span class="number">1</span> - i)) % M;</span><br><span class="line">        r3 += (sb[k - <span class="number">1</span>] - sb[i] - b[i] * (k - <span class="number">1</span> - i)) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    r3 %= M;</span><br><span class="line"></span><br><span class="line">    LL r = (r0 - r1 - r2 + r3) % M;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span>) r += M;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷-U122054-强迫症-圆上-n-个点构成的无交错边的图的个数-f-n"><a href="#洛谷-U122054-强迫症-圆上-n-个点构成的无交错边的图的个数-f-n" class="headerlink" title="洛谷 U122054 强迫症 : 圆上 $n$ 个点构成的无交错边的图的个数 $f_n$"></a><a href="https://www.luogu.com.cn/problem/U122054?contestId=31675" target="_blank" rel="noopener">洛谷 U122054 强迫症</a> : <a href="http://oeis.org/A054726" target="_blank" rel="noopener">圆上 $n$ 个点构成的无交错边的图的个数 $f_n$</a></h3><p>$f_0 = 1, f_1 = 1, f_2 = 2, f_3 = 8$，考虑 $n+1$ 个点，如果第 $n+1$ 点与其他点没有边相连有 $f_n$ 种，如果相连，设最小的数为 $i$, 那么一边有 $f_i$ 种（注意到 $n+1$ 这个节点可以不管，因为它不跟小于 $i$ 的节点相连），另一边有 $\frac{f_{n+2-i}}{2}$，即</p>
<script type="math/tex; mode=display">
f_{n + 1} = f_n + \frac{1}{2}\sum_{i = 1} ^ n f_i f_{n+2-i}</script><p>化简一下，可知 </p>
<script type="math/tex; mode=display">
f_{n+1} = 2f_n + \sum_{i=2} ^n f_i f_{n+2-i}</script><p>我们令 $g_n = f_{n+1}$，则 $g_n = 2g_{n-1} + \sum_{i=2} ^ n g_{i-1} g_{n+1-i} = 2 g_{n-1} + \sum_{i=1} ^{n-1} g_i g_{n-i}$，所以 $g_n = \frac{2}{3} g_{n-1} + \frac{1}{3} \sum_{i=0} ^n g_i g_{n-i}$。考虑 $g_n$ 的生成函数 $g(z)$：</p>
<script type="math/tex; mode=display">
g(z) = \sum_{i = 0} ^ {\infty} g_n z^n = g_0 + \frac{2}{3}  \sum_{i = 1} ^ {\infty} g_{n-1} z^n + \frac{1}{3} \sum_{i = 1} ^ {\infty} \sum_{i=0} ^ n g_i g_{n-i} z^n = g_0 + \frac{2}{3} z g(z) + \frac{1}{3} (g^2(z)  - g_0 ^ 2)</script><p>因此 $\frac{1}{3} g^2(z) + (\frac{2}{3} z - 1) g(z) + \frac{2}{3} = 0$，从而 $g(z) = \frac{3-2z \pm \sqrt{1 - 12 z + 4z^2}}{2}$, 由 $g_1 = 2$ 知 $g(z) = \frac{3-2z - \sqrt{1 - 12 z + 4z^2}}{2}$，从而 $f(z) = f_0 + z g(z) = 1 + \frac{3}{2} z - z^2 - \frac{z}{2} \sqrt{1 - 12 z + 4 z^2}$。</p>
<script type="math/tex; mode=display">
g'(z) = -1 - \frac{2z - 3}{\sqrt{1 - 12 z + 4 z^2}} = \frac{3-2z - \sqrt{1 - 12 z + 4 z^2}}{\sqrt{1 - 12 z + 4 z^2}}</script><script type="math/tex; mode=display">
(1 - 12z + 4 z^2) g'(z) = (3-2z - \sqrt{1 - 12 z + 4 z^2}) (\sqrt{1 - 12 z + 4 z^2}) = (3 - 2z) (3-2z - 2g(z)) - (1 - 12z + 4 z^2 = (4z - 6) g(z) + 8</script><p>因此 $(n + 1)g_{n+1} - 12 n g_n + 4(n-1)g_{n-1} = 4 g_{n-1} - 6 g_n$，整理得到 $(n+1)g_{n+1}  = (12 n - 6) g_n - (4n-8)g_{n-1}$</p>
<p>从而 $(n+1)f_{n+2} = (12 n - 6) f_{n+1} - (4n - 8) f_n$，即递推公式 $f_{n} = \frac{ (12 n - 30) f_{n-1} - (4 n - 16) f_{n-2} }{n-1}$。</p>
<p>所以原问题的答案就是 </p>
<script type="math/tex; mode=display">
\frac{ \sum_{i = 0} ^{n - 2} \sum_{j = i + 1} ^ {n-1} a_i a_j \frac{f_{j-i+1}}{2} \frac{f_{n+i-j+1}}{2} }{f_n} = \frac{ \sum_{i = 0} ^{n - 2} \sum_{j = i + 1} ^ {n-1} a_i a_j f_{j-i+1} f_{n+i-j+1}}{ 4 f_n}</script><p>仅看分子：</p>
<script type="math/tex; mode=display">
\sum_{i = 0} ^{n - 2} \sum_{j = i + 1} ^ {n-1} a_i a_j f_{j-i+1} f_{n+i-j+1} = \sum_{t = 2} ^ n f_t f_{n-t+2} \sum_{i=0}^{n-t} a_i a_{i+t-1}</script><p>如果我们定义 $b_i = a_{n-1-i}$，$c_t = \sum_{i = 0} ^{t} a_{t-i} b_{i} = \sum_{i = 0} ^{t} a_{i} b_{t-i} = \sum_{i = 0} ^{t} a_{i} a_{n-1-(t-i)}$，则 $c_{n-t} = \sum_{i = 0} ^{n-t} a_{i} a_{n-1-(n-t-i)} = \sum_{i = 0} ^{n-t} a_{i} a_{i+t-1}$ 。即答案为</p>
<script type="math/tex; mode=display">
\frac{ \sum_{t = 2} ^ n f_t f_{n-t+2} \cdot c_{n-t} }{4 f_n}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/U122054?contestId=31675</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>, ROOT = <span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powMod</span><span class="params">(LL x, LL n)</span> </span>&#123;</span><br><span class="line">    <span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) r = r * x % M;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = x * x % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="built_in">std</span>::swap(a[i], a[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = a.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            (j ^= l) &lt; l; l &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; &amp;a, <span class="keyword">bool</span> isInverse = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    LL g = powMod(ROOT, (M - <span class="number">1</span>) / a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (isInverse) &#123;</span><br><span class="line">        g = powMod(g, M - <span class="number">2</span>);</span><br><span class="line">        LL invLen = powMod(LL(a.<span class="built_in">size</span>()), M - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; x: a) x = x * invLen % M;</span><br><span class="line">    &#125;</span><br><span class="line">    bitreverse(a);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != w.<span class="built_in">size</span>(); ++i) w[i] = w[i - <span class="number">1</span>] * g % M;</span><br><span class="line">    <span class="keyword">auto</span> addMod = [](LL x, LL y) &#123;</span><br><span class="line">        <span class="keyword">return</span> (x += y) &gt;= M ? x -= M : x;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">2</span>, half = <span class="number">1</span>; half != a.<span class="built_in">size</span>(); <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>, half &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, wstep = a.<span class="built_in">size</span>() / <span class="built_in">step</span>; i != a.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j != i + half; ++j) &#123;</span><br><span class="line">                LL t = (a[j + half] * w[wstep * (j - i)]) % M;</span><br><span class="line">                a[j + half] = addMod(a[j], M - t);</span><br><span class="line">                a[j] = addMod(a[j], t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">mul</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = <span class="number">1</span>, tot = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (sz &lt; tot) sz *= <span class="number">2</span>;</span><br><span class="line">    a.resize(sz);</span><br><span class="line">    b.resize(sz);</span><br><span class="line">    nft(a);</span><br><span class="line">    nft(b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != sz; ++i) a[i] = a[i] * b[i] % M;</span><br><span class="line">    nft(a, <span class="number">1</span>);</span><br><span class="line">    a.resize(tot);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">b</span><span class="params">(a.rbegin(),a.rend())</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> c = mul(a, b);</span><br><span class="line"></span><br><span class="line">    LL inv[n] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, f[n + <span class="number">1</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) inv[i] = (M - M / i) * inv[M % i] % M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = ((<span class="number">12</span> * i - <span class="number">30</span>)* f[i - <span class="number">1</span>] - (<span class="number">4</span> * i - <span class="number">16</span>) * f[i - <span class="number">2</span>]) % M * inv[i - <span class="number">1</span>] % M;</span><br><span class="line">        <span class="keyword">if</span> (f[i] &lt; <span class="number">0</span>) f[i] += M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        r += f[i] * f[n - i + <span class="number">2</span>] % M * c[n - i] % M;</span><br><span class="line">    &#125;</span><br><span class="line">    r = r * inv[<span class="number">4</span>] % M * powMod(f[n], M - <span class="number">2</span>) % M;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1382D-：0-1-背包问题"><a href="#1382D-：0-1-背包问题" class="headerlink" title="1382D ：0-1 背包问题"></a><a href="https://codeforces.com/contest/1382/problem/D" target="_blank" rel="noopener">1382D</a> ：0-1 背包问题</h3><blockquote>
<p>注意到一段选择了 <code>a[i]</code> 那么后来连续小于 <code>a[i]</code> 的都要被选择。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, maxn;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">2</span> * n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> dp[n + <span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i = j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; <span class="number">2</span> * n &amp;&amp; a[j] &lt;= a[i]) ++j;</span><br><span class="line">            <span class="keyword">int</span> len = j - i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = n; k &gt;= len; --k) &#123;</span><br><span class="line">                dp[k] |= dp[k - len];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (dp[n] ? <span class="string">"YES"</span> : <span class="string">"NO"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1382C-：设-f-0-1string-gt-0-1string将字符串-0-换成-1，1-换成-0，然后倒序。给定长度为-n-的字符串-a-b-。每次可以改变-a-的前缀，给出一种方案（不超过-3n-，或者不超过-2n-）"><a href="#1382C-：设-f-0-1string-gt-0-1string将字符串-0-换成-1，1-换成-0，然后倒序。给定长度为-n-的字符串-a-b-。每次可以改变-a-的前缀，给出一种方案（不超过-3n-，或者不超过-2n-）" class="headerlink" title="1382C ：设 f: 0-1string ---&gt; 0-1string将字符串 0 换成 1，1 换成 0，然后倒序。给定长度为 $n$ 的字符串$a, b$ 。每次可以改变 $a$ 的前缀，给出一种方案（不超过 $3n$，或者不超过 $2n$ ）"></a><a href="https://codeforces.com/contest/1382/problem/C2" target="_blank" rel="noopener">1382C</a> ：设 <code>f: 0-1string ---&gt; 0-1string</code>将字符串 0 换成 1，1 换成 0，然后倒序。给定长度为 $n$ 的字符串$a, b$ 。每次可以改变 $a$ 的前缀，给出一种方案（不超过 $3n$，或者不超过 $2n$ ）</h3><ul>
<li>注意到取 $n$ 再取 $1$，再去 $n$，这样只会改变最后一个，所以就给出了不超过 $3n$ 的方案</li>
<li>可以先将 $a$变成 全$0$，再把 $b$ 变成 全$0$ 的方案反序，然后再复合。变成 $0$ 的做法就是一直让前缀数字相同。</li>
</ul>
<p>方案一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#define watch(x) std::cout &lt;&lt; (#x) &lt;&lt; &quot; is &quot; &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="line">using LL &#x3D; long long;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F;freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    std::ios::sync_with_stdio(false);</span><br><span class="line">    std::cin.tie(nullptr);</span><br><span class="line">    int cas;</span><br><span class="line">    std::cin &gt;&gt; cas;</span><br><span class="line">    while (cas--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        std::string a, b;</span><br><span class="line">        std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        std::vector&lt;int&gt; q;</span><br><span class="line">        while (--n &gt;&#x3D; 0) &#123;</span><br><span class="line">            if(a[n] !&#x3D; b[n]) &#123;</span><br><span class="line">                q.emplace_back(n + 1);</span><br><span class="line">                q.emplace_back(1);</span><br><span class="line">                q.emplace_back(n + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; q.size();</span><br><span class="line">        for (auto &amp;x : q) std::cout &lt;&lt; &quot; &quot; &lt;&lt; x;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方案二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> a, b;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        a += <span class="string">'0'</span>; b += <span class="string">'0'</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; qa, qb;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != a[i<span class="number">-1</span>]) qa.emplace_back(i);</span><br><span class="line">            <span class="keyword">if</span> (b[i] != b[i<span class="number">-1</span>]) qb.emplace_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        qa.insert(qa.<span class="built_in">end</span>(), qb.rbegin(), qb.rend());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; qa.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : qa) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="百度之星-2020-初赛-1008：数论函数题"><a href="#百度之星-2020-初赛-1008：数论函数题" class="headerlink" title="百度之星 2020 初赛 1008：数论函数题"></a><a href="http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=889&amp;pid=1008" target="_blank" rel="noopener">百度之星 2020 初赛 1008</a>：数论函数题</h3><p>已知，$f(n) = \displaystyle \sum_{d|n} d \cdot [\gcd(d,\frac{n}{d}) == 1]$，求 $\displaystyle \sum_{n=1} ^N f(n)$</p>
<p>首先 </p>
<script type="math/tex; mode=display">
f(n) = \sum_{d|n} d \cdot [\gcd(d,\frac{n}{d}) == 1] = \sum_{d|n} d \cdot \sum_{l| \gcd(d,\frac{n}{d})} \mu(l) = \sum_{l^2 | n} \mu(l) \cdot l \cdot g(\frac{n}{l^2})</script><p>其中 $g(n) = \displaystyle \sum_{d|n} d$，所以 </p>
<script type="math/tex; mode=display">
\sum_{n=1} ^N f(n) = \sum_{n=1} ^N \sum_{l^2 | n} \mu(l) \cdot l \cdot g(\frac{n}{l^2}) = \sum_{l=1}^{\sqrt{N}} \mu(l) l \sum_{n=1} ^{\lfloor \frac{N}{l^2} \rfloor} g(n) = \sum_{l=1}^{\sqrt{N}} \mu(l) \cdot l \cdot h(\lfloor \frac{N}{l^2} \rfloor)</script><p>其中 $h(n) = \sum_{i = 1} ^n g(i) = \sum_{d=1}^n d \lfloor \frac{n}{d} \rfloor$，求 $h(n)$ 有众所周知的 $O (\sqrt{n})$ 的算法，所以总时间复杂度为 $O(\sum \frac{\sqrt{N}}{l}) = O(\sqrt{N} \log N)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initmu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt; N; j += i) &#123;</span><br><span class="line">            mu[j] -= mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    initmu();</span><br><span class="line">    <span class="keyword">auto</span> f = [](LL n) &#123;</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = n / (n / l);</span><br><span class="line">            ret += ((n / l) % M) * ((l + r) % M) % M * ((r - l + <span class="number">1</span>) % M) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret % M * ((M + <span class="number">1</span>) / <span class="number">2</span>) % M;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">        LL n, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (LL i = <span class="number">1</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mu[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans += (M + mu[i]) * i % M * f(n / (i * i)) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans%M &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种计算思考：考虑每一个 $d$ 对答案的贡献，则 </p>
<script type="math/tex; mode=display">
\begin{array}{lc}
ans_N &= \sum_{d=1} ^N d \sum_{x d \leq N}  [\gcd(x,d) == 1] \\
&=  \sum_{d=1} ^N d \sum_{x d \leq N}  \sum_{l|gcd(x,d)} \mu(l) \\
&= \sum_{l=1} ^{\sqrt{N}} \mu(l) l \sum_{d = 1} ^{\lfloor \frac{N}{l} \rfloor}  d \cdot \lfloor \frac{N}{l^2 d} \rfloor\\
&= \sum_{l=1} ^{\sqrt{N}} \mu(l) l \sum_{d = 1} ^{\lfloor \frac{N}{l^2} \rfloor} d \cdot \lfloor \frac{ \lfloor\frac{N}{l^2} \rfloor}{d} \rfloor \\
\end{array}</script><h3 id="Atcode：经典生成函数题"><a href="#Atcode：经典生成函数题" class="headerlink" title="Atcode：经典生成函数题"></a><a href="https://atcoder.jp/contests/aising2020/tasks/aising2020_f" target="_blank" rel="noopener">Atcode</a>：经典生成函数题</h3><p>题目很容易转化成，满足所有$(a_1+\cdots+a_5)+2(b_1+\cdots+b_5) \leq N$的$a_1 \cdots a_5$之和，其中$a_i,b_i$ 均为非负整数</p>
<p>我一开始把 5 看作变量，从 <code>1,2,3</code> 一直推出 5 的公式，贼麻烦。后来  <a href="https://codeforces.com/profile/querty20002" target="_blank" rel="noopener">querty20002</a> 给出了生成函数做法的 <a href="https://codeforces.com/blog/entry/79978#comment-659438" target="_blank" rel="noopener">题解</a>。答案唯一的依赖于 $N$，即可认为答案是关于 $N$ 的数列，那么它的生成函数即为：</p>
<script type="math/tex; mode=display">
\begin{array}{cl}
\sum a_1a_2a_3a_4a_5(N) x^N &= (x+2x^2+\cdots)^5 (1+x^2+x^4+\cdots)^5 (1+x+x^2) \\
&= (\frac{x}{(1-x)^2})^5 (\frac{1}{1-x^2})^5 \frac{1}{1-x} \\
&=  \frac{x^5(1+x)^{11}}{(1-x^2)^{16}}\\
&= x^5(1+x)^{11} \sum_{n} \binom{n+15}{15} x^{2n}
\end{array}</script><p>所以答案就是 $\sum_{i=N\%2}^{11} \binom{11}{i} \binom{\frac{N-i-5}{2}+15}{15}$，所以我们选择 Python 交题 0.0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">M = <span class="number">1000000007</span></span><br><span class="line">T = int(input())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(T):</span><br><span class="line">    n = int(input())</span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((n<span class="number">-5</span>)%<span class="number">2</span>,<span class="number">12</span>,<span class="number">2</span>):</span><br><span class="line">        r+=math.comb(<span class="number">11</span>,i)%M*math.comb((n-i+<span class="number">25</span>)//<span class="number">2</span>,<span class="number">15</span>)%M;</span><br><span class="line">    print(r%M)</span><br></pre></td></tr></table></figure>
<p>或者 C++ 也行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> LL M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a,LL p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a==<span class="number">1</span>?<span class="number">1</span>:(p-p/a)*inv(p%a,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    LL r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">        r = r*(n-i)%M*inv(i+<span class="number">1</span>,M)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        LL n ,r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(n+<span class="number">1</span>)%<span class="number">2</span>;i&lt;=<span class="number">11</span>;i+=<span class="number">2</span>) &#123;</span><br><span class="line">            r+=C(<span class="number">11</span>,i)*C((n-i+<span class="number">25</span>)/<span class="number">2</span>,<span class="number">15</span>)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;r%M&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1215E：给定长度为-n-数据范围-1-20-的数组，求最少交换相邻位置元素使得相同的数字都紧挨着"><a href="#1215E：给定长度为-n-数据范围-1-20-的数组，求最少交换相邻位置元素使得相同的数字都紧挨着" class="headerlink" title="1215E：给定长度为 $n$ 数据范围 $[1,20]$ 的数组，求最少交换相邻位置元素使得相同的数字都紧挨着"></a><a href="https://codeforces.com/contest/1215/problems" target="_blank" rel="noopener">1215E</a>：给定长度为 $n$ 数据范围 $[1,20]$ 的数组，求最少交换相邻位置元素使得相同的数字都紧挨着</h3><blockquote>
<p>参考 <a href="https://skywt.cn/posts/cf1215e" target="_blank" rel="noopener">cf1215e</a>，注意到交换两个数字，其它数字的相对位置不发生改变</p>
</blockquote>
<p><strong>状态 dp</strong>：设 <code>dp[mask]</code> 表示状态为 <code>mask</code> 的最小交换次数，其中 <code>mask&amp;(1&lt;&lt;i)=1</code> 表示值为 <code>1+i</code> 的数已经被考虑到了。所以 $dp[2^{20}-1]$ 就是我们要的结果。状态转移</p>
<script type="math/tex; mode=display">
dp[mask] = \min_{j \in mask} dp[mask\wedge2^{j}] + \sum_{k \in mask\wedge2^{j}} cnt(j,k)</script><p>其中 <code>cnt(j,k)</code> 表示把    所有的 <code>j</code> 移动到 <code>k</code> 前面需要的次数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line">LL cnt[N][N],s[N],dp[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;--x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j) <span class="keyword">if</span>(x!=j)&#123;</span><br><span class="line">            cnt[x][j] += s[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ++s[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=(<span class="number">1</span>&lt;&lt;N);++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j) <span class="keyword">if</span>(!(i&amp;(<span class="number">1</span>&lt;&lt;j)))&#123;</span><br><span class="line">            LL s = dp[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;++k) <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;k))&#123;</span><br><span class="line">                s+=cnt[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i|(<span class="number">1</span>&lt;&lt;j)] = <span class="built_in">min</span>(dp[i|(<span class="number">1</span>&lt;&lt;j)],s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[(<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码基本 copy <a href="https://codeforces.com/profile/WZYYN" target="_blank" rel="noopener">WZYYN</a> 的<a href="https://codeforces.com/contest/1215/submission/60614830" target="_blank" rel="noopener">代码</a></p>
</blockquote>
<h3 id="1228E：（二维）包容排斥原理"><a href="#1228E：（二维）包容排斥原理" class="headerlink" title="1228E：（二维）包容排斥原理"></a><a href="https://codeforces.com/contest/1228/problem/E" target="_blank" rel="noopener">1228E</a>：（二维）包容排斥原理</h3><blockquote>
<p>在 $n \times n$ 的格子中填不超过$k$的正整数，使得每行每列的最小值都为 1 的填法方案数。下图是 <a href="https://codeforces.com/blog/entry/70162" target="_blank" rel="noopener">官方题解</a></p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="1228E.png" alt="1228E"></p>
<p><strong>无论是 dp 还是包容排斥，定义好状态是最重要的。</strong></p>
<h3 id="1148B：在一次转机的旅行中，取消-k-个航班，使得旅客最晚达到终点"><a href="#1148B：在一次转机的旅行中，取消-k-个航班，使得旅客最晚达到终点" class="headerlink" title="1148B：在一次转机的旅行中，取消 $k$ 个航班，使得旅客最晚达到终点"></a><a href="https://codeforces.com/contest/1148/problem/B" target="_blank" rel="noopener">1148B</a>：在一次转机的旅行中，取消 $k$ 个航班，使得旅客最晚达到终点</h3><blockquote>
<p>一开始被卡住了，想一下子吃个胖子 0.0 其实枚举起点取消的航班数，然后取最大值即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m,ta,tb,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;ta&gt;&gt;tb&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> a[n],b[m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        a[i]+=ta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=k||m&lt;=k)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> id = lower_bound(b,b+m,a[i])-b;</span><br><span class="line">            <span class="keyword">if</span>(id+k-i&gt;=m)&#123;</span><br><span class="line">                ans = <span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,tb+b[id+k-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1251F-组成周长固定的先单调递增后单调递减的序列"><a href="#1251F-组成周长固定的先单调递增后单调递减的序列" class="headerlink" title="1251F:  组成周长固定的先单调递增后单调递减的序列"></a><a href="https://codeforces.com/contest/1251/problem/F" target="_blank" rel="noopener">1251F</a>:  组成周长固定的先单调递增后单调递减的序列</h3><blockquote>
<p>很快就能想到周长为 $2(L+x)$，其中 $L,x$ 分别表示序列最大值和长度。一开始想不明白的地方在于，如果有两个长度相同的怎么计数，后来发现相同的可以标记一个只能放左边，另一个只能放右边。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> LL M = <span class="number">998244353</span>,ROOT=<span class="number">3</span>;</span><br><span class="line"><span class="function">LL <span class="title">powmod</span><span class="params">(LL x,LL n)</span></span>&#123;</span><br><span class="line">    <span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%M;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>; x=x*x%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitreverse</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i!=a.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;j) swap(a[i],a[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=a.<span class="built_in">size</span>()&gt;&gt;<span class="number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; &amp;a,<span class="keyword">bool</span> isInverse=<span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">    LL g = powmod(ROOT,(M<span class="number">-1</span>)/a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">        g = powmod(g,M<span class="number">-2</span>);</span><br><span class="line">        LL invLen = powmod(LL(a.<span class="built_in">size</span>()),M<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) x=x*invLen%M;</span><br><span class="line">    &#125;</span><br><span class="line">    bitreverse(a);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;LL&gt; <span class="title">w</span><span class="params">(a.<span class="built_in">size</span>(),<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=w.<span class="built_in">size</span>();++i) w[i] = w[i<span class="number">-1</span>]*g%M;</span><br><span class="line">    <span class="keyword">auto</span> addMod = [](LL x,LL y)&#123;<span class="keyword">return</span> (x+=y)&gt;=M?x-=M:x;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">2</span>,half = <span class="number">1</span>;half!=a.<span class="built_in">size</span>();<span class="built_in">step</span>&lt;&lt;=<span class="number">1</span>,half&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=a.<span class="built_in">size</span>();i+=<span class="built_in">step</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j!=half;++j)&#123;</span><br><span class="line">                LL t = (a[i+j+half]*w[a.<span class="built_in">size</span>()/<span class="built_in">step</span>*j])%M;</span><br><span class="line">                a[i+j+half]=addMod(a[i+j],M-t);</span><br><span class="line">                a[i+j]=addMod(a[i+j],t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;LL&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;LL&gt; a,<span class="built_in">vector</span>&lt;LL&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz=<span class="number">1</span>,tot = a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(sz&lt;tot) sz*=<span class="number">2</span>;</span><br><span class="line">    a.resize(sz);b.resize(sz);</span><br><span class="line">    nft(a);nft(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=sz;++i) a[i] = a[i]*b[i]%M;</span><br><span class="line">    nft(a,<span class="number">1</span>);</span><br><span class="line">    a.resize(tot);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">2</span>;</span><br><span class="line">LL fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) fac[i] = fac[i<span class="number">-1</span>]*i%M;</span><br><span class="line">    ifac[N<span class="number">-1</span>] = powmod(fac[N<span class="number">-1</span>],M<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>;i;--i) ifac[i<span class="number">-1</span>] = ifac[i]*i%M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">binom</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*ifac[k]%M*ifac[n-k]%M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n,k,x,q;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> cnt[N] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        ++cnt[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;LL&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>*N)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="keyword">int</span> c1=<span class="number">0</span>,c2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;x;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]&gt;<span class="number">1</span>) c2+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt[i]==<span class="number">1</span>) ++c1;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;LL&gt; a(c1+1),b(c2+1);</span><br><span class="line">        <span class="keyword">auto</span> inc = [](LL &amp;a,LL b)&#123;<span class="keyword">if</span>((a+=b)&gt;=M) a-=M;&#125;;</span><br><span class="line">        LL p2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=c1;++i)&#123;</span><br><span class="line">            a[i] = binom(c1,i)*p2%M;</span><br><span class="line">            inc(p2,p2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=c2;++i) b[i] = binom(c2,i);</span><br><span class="line">        a = mul(a,b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=a.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            inc(ans[i+x+<span class="number">1</span>],a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[x/<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1251E-花最少的钱，让所有人都投票给自己（选民跟风且贪财）"><a href="#1251E-花最少的钱，让所有人都投票给自己（选民跟风且贪财）" class="headerlink" title="1251E:  花最少的钱，让所有人都投票给自己（选民跟风且贪财）"></a><a href="https://codeforces.com/contest/1251/problem/E2" target="_blank" rel="noopener">1251E</a>:  花最少的钱，让所有人都投票给自己（选民跟风且贪财）</h3><blockquote>
<p>我们按照 $m$ 分层，然后从大到小记录白嫖的人，然后实在没法白嫖的，就取消费最少的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,x,y;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            a[x].emplace_back(y);</span><br><span class="line">        &#125;</span><br><span class="line">        LL r = <span class="number">0</span>;</span><br><span class="line">         <span class="comment">// q 也可以用 multiset 取代，会稍微快点</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; q; <span class="comment">//白嫖的votes</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a[i]) q.push(x);</span><br><span class="line">            <span class="keyword">while</span>(n-q.<span class="built_in">size</span>()&lt;i)&#123;</span><br><span class="line">                r+=q.top();</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1375D-MEX-once-more，通过修改数组的某一个值成-mex，使得数组最终非降"><a href="#1375D-MEX-once-more，通过修改数组的某一个值成-mex，使得数组最终非降" class="headerlink" title="1375D: MEX once more，通过修改数组的某一个值成 mex，使得数组最终非降"></a><a href="https://codeforces.com/contest/1375/problem/D" target="_blank" rel="noopener">1375D</a>: MEX once more，通过修改数组的某一个值成 mex，使得数组最终非降</h3><blockquote>
<p>不妨最终变成 <code>0~n-1</code>，这是不好想的，特别是紧张的比赛的时候</p>
</blockquote>
<p>如果当前<code>mex = n</code> 即数列正好是一个排列，此时选择任意一个<code>a[i]!=i</code> 的位置，让 <code>a[i]=n</code>，否则 <code>mex &lt; n</code> 此时令<code>a[mex]=n</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin)</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> a[n],v[n],c[n+<span class="number">1</span>]=&#123;&#125;,<span class="built_in">step</span>=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            ++c[a[i]];</span><br><span class="line">            v[i] = (a[i]==i);</span><br><span class="line">            <span class="keyword">if</span>(v[i]) --<span class="built_in">step</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">int</span> mex = <span class="number">0</span>,l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(c[mex]) ++mex;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">step</span>--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mex == n)&#123;</span><br><span class="line">                <span class="keyword">while</span>(v[l]) ++l;</span><br><span class="line">                q.push_back(l+<span class="number">1</span>);</span><br><span class="line">                --c[a[l]];</span><br><span class="line">                ++c[mex];</span><br><span class="line">                mex = a[l];</span><br><span class="line">                a[l] = n;</span><br><span class="line">            &#125;</span><br><span class="line">            ++c[mex];</span><br><span class="line">            <span class="keyword">int</span> nmex = mex;</span><br><span class="line">            <span class="keyword">if</span>(--c[a[mex]]==<span class="number">0</span>&amp;&amp;a[mex]&lt;mex)&#123;</span><br><span class="line">                nmex = a[mex];</span><br><span class="line">            &#125;</span><br><span class="line">            a[mex] = mex;</span><br><span class="line">            v[mex] = <span class="literal">true</span>;</span><br><span class="line">            q.push_back(mex+<span class="number">1</span>);</span><br><span class="line">            mex = nmex;</span><br><span class="line">            <span class="keyword">while</span>(c[mex]) ++mex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:q) <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面算法过度追求效率而丢失了可读性。其实可以缩短一半代码量</p>
</blockquote>
<h3 id="1119C-选取-4-个角，反位，使得-A-矩阵变成-B-矩阵"><a href="#1119C-选取-4-个角，反位，使得-A-矩阵变成-B-矩阵" class="headerlink" title="1119C: 选取 4 个角，反位，使得 A 矩阵变成 B 矩阵"></a><a href="https://codeforces.com/contest/1119/problem/c" target="_blank" rel="noopener">1119C</a>: 选取 4 个角，反位，使得 A 矩阵变成 B 矩阵</h3><blockquote>
<p>把 A，B 异或到 A，然后就转化成 A 矩阵变成 0 矩阵的方案了。这个时候一行行的处理就搞定了！（一开始就是没思路，后来灵光一闪）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">502</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j])&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                <span class="keyword">if</span>(i!=n)&#123;</span><br><span class="line">                    a[i+<span class="number">1</span>][j]^=a[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==n) <span class="keyword">return</span> cnt==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin)</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,x;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            a[i][j]^=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(f(n,m)?<span class="string">"Yes"</span>:<span class="string">"No"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1110：打麻将-0-0"><a href="#1110：打麻将-0-0" class="headerlink" title="1110：打麻将 0.0"></a><a href="https://codeforces.com/contest/1110/problem/D" target="_blank" rel="noopener">1110</a>：打麻将 0.0</h3><blockquote>
<p>就是计算最容易听牌的数量，ABC 和 AAA 的个数和</p>
</blockquote>
<p>考虑 <code>ans[n][i][j]</code> 表示只考虑小于 <code>n</code> 的情况下，有 <code>i</code> 个 <code>(n-1,n)</code>和 <code>j</code> 个 <code>n</code> 剩余的答案。由于三个 <code>(n,n+1,n+2)</code> 可以转化成 <code>(n,n,n),(n+1,n+1,n+1),(n+2,n+2,n+2)</code>，所以 <code>i,j</code> 都小于 3。且 <code>ans[n+1][j][k] = max(ans[n][i][j]+i+(c[n+1]-i-j-k)/3)</code>，最后可以优化一下空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin)</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cnt&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> c[m+<span class="number">1</span>]=&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;cnt;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        ++c[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">3</span>][<span class="number">3</span>],new_dp[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;m;++n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(new_dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(new_dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i+j+k&lt;=c[n+<span class="number">1</span>]&amp;&amp;dp[i][j]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        new_dp[j][k] = <span class="built_in">max</span>(new_dp[j][k],dp[i][j]+i+(c[n+<span class="number">1</span>]-i-j-k)/<span class="number">3</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(new_dp,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1371E：给定长为-n-的数组和素数-p-，记满足-x-i-lt-a-sigma-i-0-leq-i-lt-n-的排列个数为-f-x-，输出所有-x-使得-p-not-n"><a href="#1371E：给定长为-n-的数组和素数-p-，记满足-x-i-lt-a-sigma-i-0-leq-i-lt-n-的排列个数为-f-x-，输出所有-x-使得-p-not-n" class="headerlink" title="1371E：给定长为 $n$ 的数组和素数 $p$，记满足 $x+i &lt; a_{\sigma(i)},0\leq i&lt;n$ 的排列个数为 $f(x)$，输出所有 $x$ 使得 $p \not | n$"></a><a href="https://codeforces.com/contest/1371/problem/E2" target="_blank" rel="noopener">1371E</a>：给定长为 $n$ 的数组和素数 $p$，记满足 $x+i &lt; a_{\sigma(i)},0\leq i&lt;n$ 的排列个数为 $f(x)$，输出所有 $x$ 使得 $p \not | n$</h3><blockquote>
<p>先排序，并且注意到 $x \in (\max a_i-n,\max a_i+n)$ 之间。</p>
</blockquote>
<p>记 $b_i$ 为数组中小于等于 $i$ 的元素个数。则 $f(x) = \prod\limits_{i=x}^{x+n-1} b_i-(i-x) = \prod \limits_{i=x}^{x+n-1} x-(i-b_i)$，所以我们预处理出 $i-b_i$ 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n,p;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">int</span> mx = *max_element(a,a+n);</span><br><span class="line">    <span class="keyword">int</span> bb[n*<span class="number">2</span>+<span class="number">2</span>]=&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> lx = mx-n;</span><br><span class="line">    <span class="keyword">int</span> *b = bb - lx; <span class="comment">// 黑科技，哈哈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) ++b[<span class="built_in">max</span>(lx,a[i])];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n*<span class="number">2</span>+<span class="number">2</span>;++i) bb[i]+=bb[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> mp[n]=&#123;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> modp = [](<span class="keyword">int</span> x,<span class="keyword">int</span> p)&#123;</span><br><span class="line">        x%=p;</span><br><span class="line">        <span class="keyword">return</span> x&lt;<span class="number">0</span>?x+p:x;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lx;i&lt;=mx;++i)&#123;</span><br><span class="line">        ++mp[modp(i-b[i],p)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lx;i&lt;=mx;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[modp(i,p)]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.emplace_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        --mp[modp(i-b[i],p)];</span><br><span class="line">        ++mp[modp(i+n-b[i+n],p)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=q.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;q[i]&lt;&lt;<span class="string">" \n"</span>[i == q.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1245F：经典-XOR-递归"><a href="#1245F：经典-XOR-递归" class="headerlink" title="1245F：经典 XOR 递归"></a><a href="https://codeforces.com/contest/1245/problem/F" target="_blank" rel="noopener">1245F</a>：经典 XOR 递归</h3><blockquote>
<p>在区间 <code>[l,r)</code> 中找 <code>(a,b)</code> 使得 $a+b = a \wedge b$ 的个数 $f(l,r)$。</p>
</blockquote>
<p>显然，$f(x,x) = 0 \; (x\neq 0),\; f(2l,2r) = 3f(l,r)$，若 $l$ 为奇数，那么 $f(l,r) = f(l+1,r) + 2(g(l,r)-g(l,l))-(l==0)$，若 $r$ 为奇数，那么 $f(l,r) = f(l,r-1) + 2(g(r-1,r)-g(r-1,l))-(r==1)$ 。其中 $g(x,n)$ 表示满足下式的 $y$ 的个数：</p>
<script type="math/tex; mode=display">
0 \leq y < n ,\; x+y = x \wedge y</script><p>通过比较 $x,n$ 的二进制，$g(x,n)$ 的计算是容易计算的的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; g = [&amp;](<span class="keyword">int</span> x ,<span class="keyword">int</span> n)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>,zeros=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;i)&#123;</span><br><span class="line">                n^=i;</span><br><span class="line">                <span class="keyword">if</span>(!(x&amp;n)) ret += <span class="number">1</span>&lt;&lt;zeros;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!(x&amp;i)) ++zeros;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    function&lt;LL(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; f = [&amp;](<span class="keyword">int</span> l ,<span class="keyword">int</span> r)-&gt;LL&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        LL ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ret += (g(l,r)-g(l,l))*<span class="number">2</span>-(l==<span class="number">0</span>);</span><br><span class="line">            ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ret += (g(r<span class="number">-1</span>,r)-g(r<span class="number">-1</span>,l))*<span class="number">2</span>-(r==<span class="number">1</span>);</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret + <span class="number">3</span>*f(l/<span class="number">2</span>,r/<span class="number">2</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;f(l,r+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1373F：-f-x-表示非负整数-x-的十进制表示的各位数之和。求最小的非负整数-x-使得-sum-i-0-k-f-x-i-n"><a href="#1373F：-f-x-表示非负整数-x-的十进制表示的各位数之和。求最小的非负整数-x-使得-sum-i-0-k-f-x-i-n" class="headerlink" title="1373F：$f(x)$ 表示非负整数 $x$ 的十进制表示的各位数之和。求最小的非负整数 $x$ 使得 $\sum_{i=0} ^k f(x+i) = n$"></a><a href="https://codeforces.com/contest/1373/problem/E" target="_blank" rel="noopener">1373F</a>：$f(x)$ 表示非负整数 $x$ 的十进制表示的各位数之和。求最小的非负整数 $x$ 使得 $\sum_{i=0} ^k f(x+i) = n$</h3><p>由于 $0 \leq k \leq 9$，也就是说 $x,x+1,\cdots,x+k$，的个位数各不相同。我们可以枚举 $x$ 的个位数，那么 $x/10,\cdots, (x+k)/10$，最多仅有两种取值。若只有一种，即没有进位（不能为 9），那么直接就可以把 $x$ 的位数和求出来，否则 $x/10$ 的个数必为 9。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = <span class="number">1e17</span>+<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">auto</span> csum = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> (a+b)*(b-a+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="keyword">int</span> n)&#123;</span><br><span class="line">        LL r = <span class="number">0</span>,d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            r+=<span class="number">9</span>*d;</span><br><span class="line">            d*=<span class="number">10</span>;</span><br><span class="line">            n-=<span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r+n*d;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> g = [&amp;](<span class="keyword">int</span> a,<span class="keyword">int</span> k,<span class="keyword">int</span> n) -&gt; LL&#123;</span><br><span class="line">        LL r = <span class="number">0</span>,d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;a) <span class="keyword">return</span> inf;</span><br><span class="line">        <span class="keyword">while</span>((n-a)%k)&#123;</span><br><span class="line">            n-=<span class="number">9</span>*(k-a);</span><br><span class="line">            r+=d*<span class="number">9</span>;</span><br><span class="line">            d*=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;a) <span class="keyword">return</span> inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r+d*(f((n-a)/k+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;f(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k*(k<span class="number">-1</span>)/<span class="number">2</span> &gt; n)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL r = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+k&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = csum(i,i+k);</span><br><span class="line">                <span class="keyword">if</span>(n&gt;=t&amp;&amp;(n-t)%(k+<span class="number">1</span>)==<span class="number">0</span>) r = <span class="built_in">min</span>(r,<span class="number">10</span>*f((n-t)/(k+<span class="number">1</span>))+i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> t = csum(i,<span class="number">9</span>)+csum(<span class="number">0</span>,i+k<span class="number">-10</span>);</span><br><span class="line">                <span class="keyword">if</span>(n&gt;=t) r = <span class="built_in">min</span>(r,<span class="number">10</span>*g(i+k<span class="number">-9</span>,k+<span class="number">1</span>,n-t)+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(r==inf? <span class="number">-1</span>:r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上代码按照时间顺序(2020/6/25——now)倒序，以下代码按照时间顺序(2020/5/22 —— 2020/6/25)排序</strong></p>
<h3 id="1355B-：贪心模仿加法进位"><a href="#1355B-：贪心模仿加法进位" class="headerlink" title="1355B ：贪心模仿加法进位"></a><a href="https://codeforces.com/contest/1355/problem/B" target="_blank" rel="noopener">1355B</a> ：贪心模仿加法进位</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        x+=a[i];</span><br><span class="line">        ans+=x/i;</span><br><span class="line">        x%=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas,n,x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            ++a[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;getans(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1354C-：计算包含单位正-n-边形的最小正方形的边长"><a href="#1354C-：计算包含单位正-n-边形的最小正方形的边长" class="headerlink" title="1354C  ：计算包含单位正 $n$ 边形的最小正方形的边长"></a><a href="https://codeforces.com/problemset/problem/1354/C2" target="_blank" rel="noopener">1354C</a>  ：计算包含单位正 $n$ 边形的最小正方形的边长</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="built_in">cout</span>.precision(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> x = <span class="built_in">sqrt</span>(<span class="number">1</span>-<span class="built_in">cos</span>((n/<span class="number">2</span>)*pi/n));</span><br><span class="line">            <span class="keyword">double</span> y = <span class="built_in">sqrt</span>(<span class="number">1</span>-<span class="built_in">cos</span>((n/<span class="number">2</span>+<span class="number">1</span>)*pi/n));</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;(x+y)/<span class="number">2</span>/<span class="built_in">sin</span>(pi/<span class="number">2</span>/n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">1.0</span>/<span class="built_in">tan</span>(pi/<span class="number">2</span>/n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1354D-：模拟操作：-加数字或删除第-k-小的数"><a href="#1354D-：模拟操作：-加数字或删除第-k-小的数" class="headerlink" title="1354D ：模拟操作： 加数字或删除第 $k$ 小的数"></a><a href="https://codeforces.com/problemset/problem/1354/D" target="_blank" rel="noopener">1354D</a> ：模拟操作： 加数字或删除第 $k$ 小的数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> s[N], Size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id &lt;= Size) &#123;</span><br><span class="line">        s[id] += p;</span><br><span class="line">        id += lowbit(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (id) &#123;</span><br><span class="line">        r += s[id];</span><br><span class="line">        id -= lowbit(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = Size;</span><br><span class="line">    <span class="keyword">while</span> (r&gt;l) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum(m) &gt;= k) r = m;</span><br><span class="line">        <span class="keyword">else</span> l = m+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    add(<span class="built_in">find</span>(k), <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> q, x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; Size &gt;&gt; q) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Size; ++i) s[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Size; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(x, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">0</span>) add(x, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                del(-x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;(sum(ans)&gt;<span class="number">0</span>?ans:<span class="number">0</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1354F-：经典-DP-问题"><a href="#1354F-：经典-DP-问题" class="headerlink" title="1354F ：经典 DP 问题"></a><a href="https://codeforces.com/problemset/problem/1354/F" target="_blank" rel="noopener">1354F</a> ：经典 DP 问题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">102</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">bool</span> isin[N][N],chose[N];</span><br><span class="line"><span class="keyword">using</span> node = tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line">node q[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+(k<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;i &amp;&amp; j&lt;=k;++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = dp[i<span class="number">-1</span>][j]+(k<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i]);</span><br><span class="line">            <span class="keyword">int</span> y = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(j<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i])+<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(q[i]);</span><br><span class="line">            <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">                dp[i][j] = x;</span><br><span class="line">                isin[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = y;</span><br><span class="line">                isin[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=k)&#123;</span><br><span class="line">            dp[i][i] = dp[i<span class="number">-1</span>][i<span class="number">-1</span>]+(i<span class="number">-1</span>)*<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(q[i])+<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(q[i]);</span><br><span class="line">            isin[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n,j=k;i;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isin[i][j])&#123;</span><br><span class="line">            chose[i]=<span class="literal">true</span>;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            chose[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas,n,k,a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            q[i] = &#123;i,a,b&#125;;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        sort(q+<span class="number">1</span>,q+n+<span class="number">1</span>,[](<span class="keyword">const</span> node &amp; x, <span class="keyword">const</span> node &amp; y)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(x)&lt;<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(y);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(<span class="number">2</span>*n-k)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        getans(n,k);</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chose[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(++last == k)&#123;</span><br><span class="line">                    last = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!chose[i])  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>&lt;&lt;-<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[i])&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(q[last])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1345F-：经典二分，利用二阶偏导（离散偏导，即增量）是常量"><a href="#1345F-：经典二分，利用二阶偏导（离散偏导，即增量）是常量" class="headerlink" title="1345F ：经典二分，利用二阶偏导（离散偏导，即增量）是常量"></a><a href="https://codeforces.com/problemset/problem/1345/F" target="_blank" rel="noopener">1345F</a> ：经典二分，利用二阶偏导（离散偏导，即增量）是常量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    LL k,x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;LL&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            q.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> <span class="built_in">get</span> = [](LL x ,LL mx)&#123;</span><br><span class="line">            LL l=<span class="number">0</span>,r=x<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                LL m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(x-m*(m+<span class="number">1</span>)*<span class="number">3</span> == mx)  <span class="keyword">return</span> make_pair(m,m+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(x-m*(m+<span class="number">1</span>)*<span class="number">3</span> &gt; mx)  l = m+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>  r = m<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> make_pair(l,l);</span><br><span class="line">        &#125;;</span><br><span class="line">        LL l = <span class="number">-3e18</span><span class="number">-3e8</span>, r = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            LL m = (l+r)&gt;&gt;<span class="number">1</span>,x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:q)&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = <span class="built_in">get</span>(i,m);</span><br><span class="line">                x+=tmp.first;</span><br><span class="line">                y+=tmp.second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;k) l = m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(y&lt;k) r = m<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                y-=k;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:q)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = <span class="built_in">get</span>(i,m);</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;endl&lt;&lt;tmp.first&lt;&lt;" "&lt;&lt;tmp.second&lt;&lt;endl;;</span></span><br><span class="line">                    <span class="keyword">if</span>(tmp.first&lt;tmp.second &amp;&amp; y--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;tmp.first&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;tmp.second&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1325B：Set-的用法举例"><a href="#1325B：Set-的用法举例" class="headerlink" title="1325B：Set 的用法举例"></a><a href="https://codeforces.com/problemset/problem/1325/B" target="_blank" rel="noopener">1325B</a>：Set 的用法举例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas,n,x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            q.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1325D：（异或）位运算：判断是否有-n-个数，异或和为-u-和为-v"><a href="#1325D：（异或）位运算：判断是否有-n-个数，异或和为-u-和为-v" class="headerlink" title="1325D：（异或）位运算：判断是否有 $n$ 个数，异或和为 $u$, 和为 $v$"></a><a href="https://codeforces.com/contest/1325/problem/D" target="_blank" rel="noopener">1325D</a>：（异或）位运算：判断是否有 $n$ 个数，异或和为 $u$, 和为 $v$</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    LL u,v;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v||((v-u)&amp;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(u == v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(u)  <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;u&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            v = (v-u)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(u&amp;v) <span class="built_in">cout</span>&lt;&lt;<span class="number">3</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;u&lt;&lt;<span class="string">" "</span>&lt;&lt;v&lt;&lt;<span class="string">" "</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;u+v&lt;&lt;<span class="string">" "</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到 $a+b = a \wedge b + 2(a \&amp; b)$，并且 $(a \wedge b) \&amp; (a\&amp;b) = 0$ 当且仅当 $a b = 0$</p>
</blockquote>
<h3 id="1358D：给定区间最值问题，但是可以写的很漂亮"><a href="#1358D：给定区间最值问题，但是可以写的很漂亮" class="headerlink" title="1358D：给定区间最值问题，但是可以写的很漂亮"></a><a href="https://codeforces.com/problemset/problem/1358/D" target="_blank" rel="noopener">1358D</a>：给定区间最值问题，但是可以写的很漂亮</h3><blockquote>
<p>注意到区间最值一定在左或者右端点达到局部最大值（极值）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span>+<span class="number">102</span>;</span><br><span class="line"><span class="keyword">int</span> n,n2;</span><br><span class="line">LL a[N],b[N],s[N];</span><br><span class="line"><span class="function">LL <span class="title">f</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x+<span class="number">1</span>)*x)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sumx</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> it = lower_bound(b,b+n2,x) - b;</span><br><span class="line">    <span class="comment">// 这里注意是it, 比赛的时候没减，搞得怀疑人生</span></span><br><span class="line">    <span class="keyword">return</span> s[it<span class="number">-1</span>]+f(x-b[it<span class="number">-1</span>]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    LL d;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;d;</span><br><span class="line">    n2=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        a[i+n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">0</span>] = a[<span class="number">0</span>];s[<span class="number">0</span>] = f(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n2;++i)&#123;</span><br><span class="line">        b[i]=b[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+f(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,sumx(b[i]+d<span class="number">-1</span>)-s[i]+a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;n2;++i)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,s[i]-sumx(b[i]-d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1358E：很有意思的数据处理题目，官方题解"><a href="#1358E：很有意思的数据处理题目，官方题解" class="headerlink" title="1358E：很有意思的数据处理题目，官方题解"></a><a href="https://codeforces.com/problemset/problem/1358/E" target="_blank" rel="noopener">1358E</a>：很有意思的数据处理题目，<a href="https://codeforces.com/blog/entry/77869" target="_blank" rel="noopener">官方题解</a></h3><blockquote>
<p>注意到如果 $k$ 满足答案，则 $2k$ 也满足，所以不妨设 $k&gt; \lfloor \frac{n}{2} \rfloor$，另一方面题目中要求若 $i&gt;  \lceil \frac{n}{2} \rceil$，则 $a_{i} = x$</p>
</blockquote>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line">LL a[N],s[N],m[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> n2 = (n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    LL x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n2+<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        a[i]=x;</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)&#123;</span><br><span class="line">        m[i+<span class="number">1</span>] = <span class="built_in">min</span>(m[i],x*i-s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=n2;k&lt;=n;++k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[k]+m[n-k+<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1359C-读题被坑…-反正就是倒冷热水接近给定温度）"><a href="#1359C-读题被坑…-反正就是倒冷热水接近给定温度）" class="headerlink" title="1359C:  读题被坑…(反正就是倒冷热水接近给定温度）"></a><a href="https://codeforces.com/contest/1359/problem/C" target="_blank" rel="noopener">1359C</a>:  读题被坑…(反正就是倒冷热水接近给定温度）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="keyword">int</span> h,t,c;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;h&gt;&gt;c&gt;&gt;t;</span><br><span class="line">        h-=c;t-=c;</span><br><span class="line">        <span class="keyword">if</span>(h&gt;=<span class="number">2</span>*t)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            LL n = (h-t)/(<span class="number">2</span>*t-h);</span><br><span class="line">            <span class="keyword">auto</span> f = [](LL n,<span class="keyword">int</span> h,<span class="keyword">int</span> t)&#123;</span><br><span class="line">                <span class="keyword">return</span> (n+<span class="number">1</span>)*(<span class="number">2</span>*n+<span class="number">3</span>)*h+(<span class="number">2</span>*n+<span class="number">1</span>)*(n+<span class="number">2</span>)*h&gt;(<span class="number">2</span>*n+<span class="number">1</span>)*(<span class="number">2</span>*n+<span class="number">3</span>)*t*<span class="number">2</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span>(f(n,h,t)) ++n;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>*n+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后对于奇数项，单调递减趋于平均问题，然后判断的时候转化成整数的判断</p>
</blockquote>
<h3 id="1359D：线段树，但是由于数据特殊，可以不用线段树"><a href="#1359D：线段树，但是由于数据特殊，可以不用线段树" class="headerlink" title="1359D：线段树，但是由于数据特殊，可以不用线段树"></a><a href="https://codeforces.com/contest/1359/problem/D" target="_blank" rel="noopener">1359D</a>：线段树，但是由于数据特殊，可以不用线段树</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;=<span class="number">30</span>;++m)&#123;</span><br><span class="line">        <span class="keyword">int</span> suml =<span class="number">0</span>,sum=<span class="number">0</span>,maxa = <span class="number">-31</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;m)&#123;</span><br><span class="line">                sum = suml = <span class="number">0</span>;</span><br><span class="line">                maxa = <span class="number">-31</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=a[i];</span><br><span class="line">                <span class="comment">//这里取全局最大是因为，我们枚举了最大值的可能</span></span><br><span class="line">                maxa = <span class="built_in">max</span>(maxa,a[i]);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,sum-suml-maxa);</span><br><span class="line">                <span class="comment">//相当于前面是全0的部分删了！并且这样不会避免中间负的情况</span></span><br><span class="line">                suml = <span class="built_in">min</span>(sum,suml);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到 $-30&lt;a_i&lt;30 $</p>
</blockquote>
<h3 id="1359E：找到公式后就是模素数组合数"><a href="#1359E：找到公式后就是模素数组合数" class="headerlink" title="1359E：找到公式后就是模素数组合数"></a><a href="https://codeforces.com/contest/1359/problem/E" target="_blank" rel="noopener">1359E</a>：找到公式后就是模素数组合数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL=<span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line">LL inv[N],frac[N];</span><br><span class="line"><span class="function">LL <span class="title">powmod</span><span class="params">(LL x, LL n, LL p)</span> </span>&#123;</span><br><span class="line">    LL r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        x=x*x%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    frac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">        frac[i] = frac[i<span class="number">-1</span>]*i%M;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[N<span class="number">-1</span>] = powmod(frac[N<span class="number">-1</span>],M<span class="number">-2</span>,M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-2</span>;i;--i)&#123;</span><br><span class="line">        inv[i] = inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==m||m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> frac[n]*inv[m]%M*inv[n-m]%M;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    init();</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = n/i;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;k) <span class="keyword">break</span>;</span><br><span class="line">        ans += C(x<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans%M&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先考虑$k=2$ 的情况知道 $a_1|a_2$，然后发现对于任意$k$，仅需 $a_1|a_i$ 即可。</p>
</blockquote>
<h3 id="1363E：有根数，互换子树的节点位数到预定值，dfs-和图存储范例"><a href="#1363E：有根数，互换子树的节点位数到预定值，dfs-和图存储范例" class="headerlink" title="1363E：有根数，互换子树的节点位数到预定值，dfs 和图存储范例"></a><a href="https://codeforces.com/contest/1363/problem/E" target="_blank" rel="noopener">1363E</a>：有根数，互换子树的节点位数到预定值，dfs 和图存储范例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="comment">// head[u] 和 cnt 的初始值都为 -1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[N];</span><br><span class="line"><span class="keyword">bool</span> b[N],c[N];</span><br><span class="line"></span><br><span class="line">tuple&lt;int,int,LL&gt; dfs(int u,int parent,int mn)&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    LL cost=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(b[u]!=c[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[u]) ++l;</span><br><span class="line">        <span class="keyword">else</span> ++r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v == parent) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">auto</span> [sl,sr,scost] = dfs(v,u,<span class="built_in">min</span>(mn,a[u]));</span><br><span class="line">        l+=sl;r+=sr;cost+=scost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[u]&lt;mn)&#123;</span><br><span class="line">        <span class="keyword">int</span> take = <span class="built_in">min</span>(l,r);</span><br><span class="line">        cost += LL(a[u])*(take*<span class="number">2</span>);</span><br><span class="line">        l -= take;</span><br><span class="line">        r -= take;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;l,r,cost&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n,u,v;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        g[u].push_back(v);</span><br><span class="line">        g[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> [l,r,cost] = dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2e9</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(l||r?<span class="number">-1</span>:cost)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码写得呢，就很优雅，哈哈！</p>
</blockquote>
<h3 id="1361E-：下面代码至今没过我也是没懂为什么"><a href="#1361E-：下面代码至今没过我也是没懂为什么" class="headerlink" title="1361E ：下面代码至今没过我也是没懂为什么"></a>1361E ：下面代码至今没过我也是没懂为什么</h3><blockquote>
<p>模仿进制的操作，最后用其他代码过的题。多设几个变量没坏处的其实。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">LL a[N],p;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">powmod</span><span class="params">(T x,U n,T p)</span></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=x*x%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;(n&amp;<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">        LL ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans==<span class="number">0</span>)&#123;</span><br><span class="line">                ans = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[n]==a[n<span class="number">-1</span>]) --ans;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(a[n]&gt;a[n<span class="number">-1</span>])&#123;</span><br><span class="line">                        ans*=p;</span><br><span class="line">                        --a[n];</span><br><span class="line">                        <span class="keyword">if</span>(ans&gt;n) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(a[n]!=a[n<span class="number">-1</span>]) <span class="keyword">break</span>;</span><br><span class="line">                    --ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans%M*powmod(p,a[n],M)%M;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            ans-=powmod(p,a[i],M);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (M+ans%M)%M;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1349F-：神奇的对应"><a href="#1349F-：神奇的对应" class="headerlink" title="1349F ：神奇的对应"></a><a href="https://codeforces.com/contest/1349/problem/F1" target="_blank" rel="noopener">1349F</a> ：神奇的对应</h3><p>我们称一个长度为 $n$ 的序列 $p$ 为<strong>好序列</strong>，如果对任意正整数$k&gt;1$，存在 $1 \leq i &lt; j \leq n$ 使得，$p_i = k-1, p_j = k$</p>
<p>存在 <strong>好序列</strong> 和长为 $n$ 的排列一一对应：</p>
<ul>
<li>给定排列 $a_1,a_2,\cdots, a_n$ ， 相邻两个之间添加 <code>&gt;</code> 或 <code>&lt;</code> ,那么 $p_{a_i}$ 就定义为 $a_1,\cdots,a_i$ 中 <code>&lt;</code> 个数加一</li>
<li>给定好序列 $p$，从右到左依次标记出 <code>1,2,...</code> ，直到标记完所有数即得到了排列</li>
</ul>
<p>因此 <strong>好序列</strong> 中最大值对应这排列中单调递减区间的个数！</p>
<blockquote>
<p>答案要求的是：所有好序列中出现 $k$ 的个数之和。</p>
</blockquote>
<p>代码下次再写吧…</p>
<h3 id="1365E：这题其实没啥，但是比赛的时候竟然把-想成了-，很烦"><a href="#1365E：这题其实没啥，但是比赛的时候竟然把-想成了-，很烦" class="headerlink" title="1365E：这题其实没啥，但是比赛的时候竟然把 | 想成了 ^ ，很烦"></a><a href="https://codeforces.com/problemset/problem/1365/E" target="_blank" rel="noopener">1365E</a>：这题其实没啥，但是比赛的时候竟然把 <code>|</code> 想成了 <code>^</code> ，很烦</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        LL a[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a,a+n,greater&lt;LL&gt;());</span><br><span class="line">        LL ans = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*a[i]&lt;=a[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                LL t = a[i]|a[j];</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,t);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;n;++k)&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,t|a[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1312D：计算满足条件的数列个数"><a href="#1312D：计算满足条件的数列个数" class="headerlink" title="1312D：计算满足条件的数列个数"></a><a href="https://codeforces.com/contest/1312/problem/D" target="_blank" rel="noopener">1312D</a>：计算满足条件的数列个数</h3><p>计算满足下列条件的数列个数：</p>
<ul>
<li>数列项数为 $n$，且每一项都是不超过 $m$ 的正整数，$2\cdot 10^5 =N&gt;m \geq n \geq 2$</li>
<li>数列中有且仅有两项是相同的</li>
<li>数列在 $i$ 项前严格单调递增，$i$ 项后严格单调递减</li>
</ul>
<p>我们枚举 $i$ 的位置和 $i$ 的值，以及相同的项，则显然有如下计算式</p>
<script type="math/tex; mode=display">
\sum_{i=2} ^ {n-1} \sum_{j=n-1} ^m {j-1 \choose 1} {j-2 \choose i-2} {j-i \choose n-i-1} = \sum_{i=2} ^{n-1} \frac{1}{(i-2)!(n-i-1)} \sum_{j=n-1}^m \frac{(j-1)!}{(j-n+1)!}</script><p>预处理一下阶乘和阶乘逆，我们就可以在 $O(N)$ 解决问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="function">LL <span class="title">powmod</span><span class="params">(LL a,LL n)</span></span>&#123;</span><br><span class="line">    <span class="function">LL <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*a%M;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  a=a*a%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">LL fac[N],ifac[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=N;++i)&#123;</span><br><span class="line">        fac[i] = fac[i<span class="number">-1</span>]*i%M;</span><br><span class="line">    &#125;</span><br><span class="line">    ifac[N<span class="number">-1</span>] = powmod(fac[N<span class="number">-1</span>],M<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-2</span>;~i;--i)&#123;</span><br><span class="line">        ifac[i] = ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%M; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        LL x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            x+=fac[i<span class="number">-1</span>]*ifac[i-n+<span class="number">1</span>]%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i)&#123;</span><br><span class="line">            y+=ifac[i<span class="number">-2</span>]*ifac[n-i<span class="number">-1</span>]%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(x%M)*(y%M)%M&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是<a href="https://codeforces.com/blog/entry/74640" target="_blank" rel="noopener">官方题解</a>给了一个更简单的方法</p>
</blockquote>
<p>首先把 $n=2$ 时无解，所以考虑 $n&gt;2$ 的情况，首先把所有用到的数字选好：$m \choose n-1$，然后选择好相同的数字：$n-2$，然后剩下的非最大的数，要么放在最大的数左边要么放在最大的数右边：$2^{n-3}$，即最终答案是 ${m \choose n-1}(n-2)2^{n-3}$</p>
<h3 id="1312E：经典-DP，解释放在"><a href="#1312E：经典-DP，解释放在" class="headerlink" title="1312E：经典 DP，解释放在 "></a><a href="https://codeforces.com/contest/1312/problem/E" target="_blank" rel="noopener">1312E</a>：经典 DP，解释放在 <a href="/dynamicProgramming/" title="动态规划">动态规划</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1022</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">502</span>][N],b[<span class="number">502</span>][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans,inf,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        ans[<span class="number">0</span>][x] = <span class="number">1</span>;</span><br><span class="line">        b[<span class="number">0</span>][x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;N;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i<span class="number">-1</span>][j]!=inf)&#123;</span><br><span class="line">                    ans[i][x] = <span class="built_in">min</span>(ans[i][x],ans[i<span class="number">-1</span>][j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                b[i][x]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> s = i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(s&gt;=<span class="number">0</span>&amp;&amp;ans[s][x]!=inf)&#123;</span><br><span class="line">                ans[i][x+<span class="number">1</span>] = ans[s][x];</span><br><span class="line">                b[i][x+<span class="number">1</span>] = b[s][x];</span><br><span class="line">                s = b[s][x]<span class="number">-1</span>;</span><br><span class="line">                ++x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;</span><br><span class="line">            r = <span class="built_in">min</span>(r,ans[n<span class="number">-1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1295E：题解，相当精彩的线段树实例"><a href="#1295E：题解，相当精彩的线段树实例" class="headerlink" title="1295E：题解，相当精彩的线段树实例"></a><a href="https://codeforces.com/contest/1295/problem/E" target="_blank" rel="noopener">1295E</a>：<a href="https://codeforces.com/blog/entry/73467" target="_blank" rel="noopener">题解</a>，相当精彩的线段树实例</h3><blockquote>
<p>下面代码取自：<a href="https://codeforces.com/profile/jiangly" target="_blank" rel="noopener">jiangly</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="built_in">min</span>, tag;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">long</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">min</span>[p] += v;</span><br><span class="line">        tag[p] += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        add(<span class="number">2</span> * p, tag[p]);</span><br><span class="line">        add(<span class="number">2</span> * p + <span class="number">1</span>, tag[p]);</span><br><span class="line">        tag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pull</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">min</span>[p] = <span class="built_in">std</span>::<span class="built_in">min</span>(<span class="built_in">min</span>[<span class="number">2</span> * p], <span class="built_in">min</span>[<span class="number">2</span> * p + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rangeAdd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y)</span><br><span class="line">            <span class="keyword">return</span> add(p, v);</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        push(p);</span><br><span class="line">        rangeAdd(<span class="number">2</span> * p, l, m, x, y, v);</span><br><span class="line">        rangeAdd(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, v);</span><br><span class="line">        pull(p);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SegmentTree(<span class="keyword">int</span> n) : n(n), <span class="built_in">min</span>(<span class="number">4</span> * n), tag(<span class="number">4</span> * n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rangeAdd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        rangeAdd(<span class="number">1</span>, <span class="number">0</span>, n, l, r, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p, a, pos;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    p.resize(n);</span><br><span class="line">    a.resize(n);</span><br><span class="line">    pos.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">        --p[i];</span><br><span class="line">        pos[p[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="function">SegmentTree <span class="title">t</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        t.rangeAdd(pos[i], n - <span class="number">1</span>, a[pos[i]]);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = t.getMin();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        t.rangeAdd(pos[i], n - <span class="number">1</span>, -a[pos[i]]);</span><br><span class="line">        t.rangeAdd(<span class="number">0</span>, pos[i], a[pos[i]]);</span><br><span class="line">        ans = <span class="built_in">std</span>::<span class="built_in">min</span>(ans, t.getMin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1295F：给定区间的非降序列概率（个数）"><a href="#1295F：给定区间的非降序列概率（个数）" class="headerlink" title="1295F：给定区间的非降序列概率（个数）"></a><a href="https://codeforces.com/contest/1295/problem/F" target="_blank" rel="noopener">1295F</a>：给定区间的非降序列概率（个数）</h3><blockquote>
<p>下面代码取自：<a href="https://codeforces.com/profile/jiangly" target="_blank" rel="noopener">jiangly</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> P = <span class="number">998'244'353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="number">1L</span>L * res * a % P;</span><br><span class="line">        a = <span class="number">1L</span>L * a * a % P;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l, r, v, inv, dp;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    l.resize(n);</span><br><span class="line">    r.resize(n);</span><br><span class="line">    v.reserve(<span class="number">2</span> * n);</span><br><span class="line">    inv.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        inv[i] = power(i, P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">        ++r[i];</span><br><span class="line">        v.push_back(l[i]);</span><br><span class="line">        v.push_back(r[i]);</span><br><span class="line">        total = <span class="number">1L</span>L * total * (r[i] - l[i]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    v.erase(<span class="built_in">std</span>::unique(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        l[i] = <span class="built_in">std</span>::lower_bound(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), l[i]) - v.<span class="built_in">begin</span>();</span><br><span class="line">        r[i] = <span class="built_in">std</span>::lower_bound(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), r[i]) - v.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    c.assign(v.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(v.<span class="built_in">size</span>()) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            c[i][j] = <span class="number">1L</span>L * c[i][j - <span class="number">1</span>] * (j - <span class="number">1</span> + v[i + <span class="number">1</span>] - v[i]) % P * inv[j] % P;</span><br><span class="line">    &#125;</span><br><span class="line">    dp.resize(n + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">int</span>(v.<span class="built_in">size</span>()) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = n - <span class="number">1</span>; a &gt;= <span class="number">0</span>; --a) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a; b &lt; n; ++b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; l[b] || i &gt;= r[b])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                dp[b + <span class="number">1</span>] = (dp[b + <span class="number">1</span>] + <span class="number">1L</span>L * dp[a] * c[i][b - a + <span class="number">1</span>]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1L</span>L * dp[n] * power(total, P - <span class="number">2</span>) % P &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1364C：已知-a-i-MEX-b-1-cdots-b-i-为不出现在-b-1-cdots-b-i-中的最小非负整数，在给定-0-leq-a-i-leq-i-a-i-lt-a-i-1-的情况下，给出一种-b-i-的方案"><a href="#1364C：已知-a-i-MEX-b-1-cdots-b-i-为不出现在-b-1-cdots-b-i-中的最小非负整数，在给定-0-leq-a-i-leq-i-a-i-lt-a-i-1-的情况下，给出一种-b-i-的方案" class="headerlink" title="1364C：已知 $a_i=MEX({b_1,\cdots,b_i})$ 为不出现在 $b_1,\cdots,b_i$ 中的最小非负整数，在给定 $0\leq a_i \leq i,a_i&lt;a_{i+1}$ 的情况下，给出一种 $b_i$ 的方案"></a><a href="https://codeforces.com/contest/1364/problem/C" target="_blank" rel="noopener">1364C</a>：已知 $a_i=MEX({b_1,\cdots,b_i})$ 为不出现在 $b_1,\cdots,b_i$ 中的最小非负整数，在给定 $0\leq a_i \leq i,a_i&lt;a_{i+1}$ 的情况下，给出一种 $b_i$ 的方案</h3><p>方案就是：设当前最大值为 $n$，从尾部开始，先标 <code>a[i]</code> 的值被访问，然后看 <code>a[i]</code> 是否等于 <code>a[i-1]</code>，如果是就在没被访问的点中给一个最大给 <code>b[i]</code>，否则 $b[i]=a[i-1]$。然后边界判断！ <code>i=1</code> 时，当作不等处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="keyword">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ma = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">        v[a[i]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>||a[i]==a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">while</span>(ma&gt;=<span class="number">0</span>&amp;&amp;v[ma]) --ma;</span><br><span class="line">            v[ma] = <span class="literal">true</span>;</span><br><span class="line">            b[i] = ma--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b[i]=a[i<span class="number">-1</span>];</span><br><span class="line">            v[b[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;b[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codeforc.com/contest/1353/problem/D" target="_blank" rel="noopener">1353D</a>：有趣的标准优先队列+BFS 题目</p>
<blockquote>
<p>初始值为 0 的长度为 n 的数组，每次在连续 0 中长度最大的那一段的中点编号，直到编完。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (r-l)&lt;(A.r-A.l)||((r-l)==(A.r-A.l)&amp;&amp;l&gt;A.l);</span><br><span class="line">    &#125;</span><br><span class="line">    Node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r)&#123;</span><br><span class="line">        l = _l;</span><br><span class="line">        r = _r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        LL n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> a[n+<span class="number">1</span>];</span><br><span class="line">        priority_queue&lt;Node&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">1</span>,n&#125;);</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> u = q.top();</span><br><span class="line">            <span class="keyword">int</span> l=u.l,r=u.r;</span><br><span class="line">            q.pop();</span><br><span class="line">            a[(l+r)/<span class="number">2</span>] = ++now;</span><br><span class="line">            <span class="keyword">if</span>(l==r) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((r-l)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                q.push(Node(l,(l+r)/<span class="number">2</span><span class="number">-1</span>));</span><br><span class="line">                q.push(Node((l+r)/<span class="number">2</span>+<span class="number">1</span>,r));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                q.push(Node((l+r)/<span class="number">2</span>+<span class="number">1</span>,r));</span><br><span class="line">                <span class="keyword">if</span>(l&lt;(l+r)/<span class="number">2</span>) q.push(Node(l,(l+r)/<span class="number">2</span><span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" \n"</span>[i==n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codeforc.com/contest/1353/problem/E" target="_blank" rel="noopener">1353E</a>：在 <code>01</code>序列中改变最小的位，使得其中的所有 <code>1</code> 都是连续的。</p>
<blockquote>
<p>设 <code>dp[i]</code> 为使得前 <code>i</code> 位中 1 连续出现，且第 <code>i</code> 位为 1 的最小改变位数，状态转移就显然了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        <span class="built_in">string</span> a;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;a;</span><br><span class="line">        <span class="keyword">auto</span> solve = [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = s.length();</span><br><span class="line">            <span class="keyword">int</span> all = count(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="string">'1'</span>);</span><br><span class="line">            <span class="keyword">int</span> s1=(s[<span class="number">0</span>]==<span class="string">'1'</span>);</span><br><span class="line">            <span class="keyword">int</span> ans = all-s1,res = <span class="number">1</span>-s1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = (s[i]==<span class="string">'1'</span>);</span><br><span class="line">                s1+=cur;</span><br><span class="line">                res = <span class="number">1</span>-cur+<span class="built_in">min</span>(res,s1-cur);</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,res+all-s1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> all-ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j+=k)&#123;</span><br><span class="line">                s+=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx,solve(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;count(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="string">'1'</span>)-mx&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1367E：不难但是很有趣的数学题"><a href="#1367E：不难但是很有趣的数学题" class="headerlink" title="1367E：不难但是很有趣的数学题"></a><a href="https://codeforces.com/contest/1367/problem/E" target="_blank" rel="noopener">1367E</a>：不难但是很有趣的数学题</h3><blockquote>
<p>在给定一些元素中取出最大数量构成一个 k 旋转不变的圈</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> c[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:s) ++c[i-<span class="string">'a'</span>];</span><br><span class="line">        sort(c,c+<span class="number">26</span>,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">auto</span> check=[&amp;](<span class="keyword">int</span> m)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = __gcd(m,k);</span><br><span class="line">            <span class="keyword">int</span> md = m/d;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">                x+=c[i]/md;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x&gt;=d;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span>(!check(n)) --n;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1367F：给定规则最小步骤使得数列有序"><a href="#1367F：给定规则最小步骤使得数列有序" class="headerlink" title="1367F：给定规则最小步骤使得数列有序"></a><a href="https://codeforces.com/problemset/problem/1367/F1" target="_blank" rel="noopener">1367F</a>：给定规则最小步骤使得数列有序</h3><blockquote>
<p>只允许将数列中某一个数最前或者最后，问最少多少步使得数列有序。</p>
</blockquote>
<p>我们称数列中两个数 $a_i \leq a_j$是<strong>相接</strong>的，如果 $i&lt;j$ 且排好序后 $a_i,a_j$ 相邻。那么我们的答案就是 $n-$ 最长相接子列的长度。</p>
<p><strong>原因</strong>：首先它是一个可行的答案，其次答案的方案去掉数列中被移动的数，剩下的数必然是相接的！</p>
<blockquote>
<p>因为数列中的数的大小并不影响结果，影响结果的是相对关系，因此可以通过预处理，让数列的取值范围是一个区间。</p>
</blockquote>
<p>记 <code>dp[i]</code> 为以 $i$ 结尾的最长相接子列。状态转移是好写的。</p>
<p>如果数列中元素两两互异，会很简单，因为有相同元素的时候要考虑 <code>0 1 0 2</code> 这种数列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> cas;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> a[n],id[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        iota(id,id+n,<span class="number">0</span>);</span><br><span class="line">        sort(id,id+n,[&amp;](<span class="keyword">int</span> &amp;i,<span class="keyword">int</span> &amp;j)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[i]==a[j]?i&lt;j:a[i]&lt;a[j];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            a[id[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[n],ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;<span class="number">0</span> &amp;&amp; id[a[i]<span class="number">-1</span>]&lt;i) dp[i] += dp[id[a[i]<span class="number">-1</span>]];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n-ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>否则，我们就要考虑 $i$ 之前 <code>a[i]</code> 严格小的相接元的 <code>dp</code> 最小值加上这些元的元素个数。</p>
<p>但是也可以直接求不用 DP 参考 <a href="https://codeforces.com/contest/1367/submission/83985710" target="_blank" rel="noopener">jiangly 的代码</a>，直接找包含第 $i$ 位最长的相接子列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">2e5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; z;</span><br><span class="line">    <span class="keyword">while</span> (z--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">std</span>::iota(p, p + n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">std</span>::sort(p, p + n, [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;<span class="keyword">return</span> a[i] &lt; a[j] || (a[i] == a[j] &amp;&amp; i &lt; j);&#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r; l &lt; n; l = r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (r = l + <span class="number">1</span>; r &lt; n &amp;&amp; p[r] &gt; p[r - <span class="number">1</span>]; ++r)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">int</span> res = r - l;</span><br><span class="line">            <span class="keyword">if</span> (l)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; a[p[i]] == a[p[l - <span class="number">1</span>]]; --i)</span><br><span class="line">                    <span class="keyword">if</span> (p[i] &lt; p[l])</span><br><span class="line">                        ++res;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; n &amp;&amp; a[p[i]] == a[p[r]]; ++i)</span><br><span class="line">                    <span class="keyword">if</span> (p[i] &gt; p[r - <span class="number">1</span>])</span><br><span class="line">                        ++res;</span><br><span class="line">            ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, m, r; l &lt; n; l = m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (m = l; m &lt; n &amp;&amp; a[p[m]] == a[p[l]]; ++m)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">if</span> (m == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (r = m; r &lt; n &amp;&amp; a[p[r]] == a[p[m]]; ++r)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = m; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; r &amp;&amp; p[j] &lt; p[i])</span><br><span class="line">                    ++j;</span><br><span class="line">                ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, i + <span class="number">1</span> - l + r - j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n - ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1368B：简单的问题比赛的时候无语的想复杂了！然后就是参看-tourist-男神的优雅代码"><a href="#1368B：简单的问题比赛的时候无语的想复杂了！然后就是参看-tourist-男神的优雅代码" class="headerlink" title="1368B：简单的问题比赛的时候无语的想复杂了！然后就是参看 tourist 男神的优雅代码"></a><a href="https://codeforces.com/contest/1368/problem/B" target="_blank" rel="noopener">1368B</a>：简单的问题比赛的时候无语的想复杂了！然后就是参看 tourist 男神的优雅代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  tourist</span></span><br><span class="line"><span class="comment"> *    created: 18.06.2020 17:46:48       </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  <span class="built_in">string</span> s = <span class="string">"codeforces"</span>;</span><br><span class="line">  <span class="keyword">int</span> n = (<span class="keyword">int</span>) s.<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> prod = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> it = <span class="number">0</span>; prod &lt; k; it = (it + <span class="number">1</span>) % n) &#123;</span><br><span class="line">    prod = prod / a[it] * (a[it] + <span class="number">1</span>);</span><br><span class="line">    ++a[it];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i]; j++) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1368D：一眼看出！哎要不是-B-题被卡了，我决定能上大分！好气"><a href="#1368D：一眼看出！哎要不是-B-题被卡了，我决定能上大分！好气" class="headerlink" title="1368D：一眼看出！哎要不是 B 题被卡了，我决定能上大分！好气"></a><a href="https://codeforces.com/contest/1368/problem/D" target="_blank" rel="noopener">1368D</a>：一眼看出！哎要不是 B 题被卡了，我决定能上大分！好气</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;,x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x&amp;<span class="number">1</span>) ++a[j];</span><br><span class="line">                x&gt;&gt;=<span class="number">1</span>; ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            LL t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;i&lt;<span class="number">20</span>;++i,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i])&#123;</span><br><span class="line">                    t+=j;</span><br><span class="line">                    --a[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r+=t*t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1285D：比赛的时候想到了，但是怕复杂度过补了，能过复杂度是因为每个元素-a-最多递归-log-a-次"><a href="#1285D：比赛的时候想到了，但是怕复杂度过补了，能过复杂度是因为每个元素-a-最多递归-log-a-次" class="headerlink" title="1285D：比赛的时候想到了，但是怕复杂度过补了，能过复杂度是因为每个元素 $a$ 最多递归 $\log a$ 次"></a><a href="https://codeforces.com/contest/1285/problem/D" target="_blank" rel="noopener">1285D</a>：比赛的时候想到了，但是怕复杂度过补了，能过复杂度是因为每个元素 $a$ 最多递归 $\log a$ 次</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> <span class="built_in">bit</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bit</span>&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l,r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;<span class="built_in">bit</span>)&amp;<span class="number">1</span>) l.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> r.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> solve(r,<span class="built_in">bit</span><span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(r.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> solve(l,<span class="built_in">bit</span><span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(solve(l,<span class="built_in">bit</span><span class="number">-1</span>),solve(r,<span class="built_in">bit</span><span class="number">-1</span>))+(<span class="number">1</span>&lt;&lt;<span class="built_in">bit</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;solve(a,<span class="number">30</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1285C：找出使得-max-a-b-最小并使得-lcm-a-b-x-的最小-a-b"><a href="#1285C：找出使得-max-a-b-最小并使得-lcm-a-b-x-的最小-a-b" class="headerlink" title="1285C：找出使得$\max(a,b)$最小并使得$lcm(a,b)=x$的最小$a,b$"></a><a href="https://codeforces.com/contest/1285/problem/C" target="_blank" rel="noopener">1285C</a>：找出使得$\max(a,b)$最小并使得$lcm(a,b)=x$的最小$a,b$</h3><blockquote>
<p>将 $x$ 分解素因子可知，$\max(a,b)$ 最小的前提是，$\gcd(a,b)=1$，又因为 $x$ 的因子个数不超过$2\sqrt{x}$，搞定</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        LL r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(LL i=<span class="number">1</span>;i*i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>&amp;&amp;__gcd(i,n/i)==<span class="number">1</span>)&#123;</span><br><span class="line">                r=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="string">" "</span>&lt;&lt;n/r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本来不想写这个题，但是由于下题都是 <code>lcm</code> 问题，又是同一场，所以就记录一下</p>
<h3 id="1285F：一道很秀的-lcm-题，计算-displaystyle-max-1-leq-i-lt-j-leq-n-lcm-a-i-a-j"><a href="#1285F：一道很秀的-lcm-题，计算-displaystyle-max-1-leq-i-lt-j-leq-n-lcm-a-i-a-j" class="headerlink" title="1285F：一道很秀的 lcm 题，计算 $\displaystyle \max_{1\leq i&lt; j \leq n} lcm(a_i,a_j)$"></a><a href="https://codeforces.com/contest/1285/problem/F" target="_blank" rel="noopener">1285F</a>：一道很秀的 lcm 题，计算 $\displaystyle \max_{1\leq i&lt; j \leq n} lcm(a_i,a_j)$</h3><blockquote>
<p>参考这里：<a href="https://www.xht37.com/codeforces-round-613-div-2-题解/#Classical" target="_blank" rel="noopener">https://www.xht37.com/codeforces-round-613-div-2-%E9%A2%98%E8%A7%A3/#Classical</a></p>
</blockquote>
<p>通过加入 $a_i$ 的所有因子，我们可以改成计算 $\displaystyle \max_{\gcd(a_i,a_j)=1} a_ia_j$，我们将 $a_i$ 从大到小排序，然后开始遍历，用堆 s 保存之前的内容，注意到，如果堆 s 中有一个元素 t，跟当前需要遍历的元素 $a_i$ 互素，那么小于 s 中小于 $t$ 的元素讲不再能为结果做贡献。因此可以踢出栈中，现在问题是我们如何快速的记录<strong>堆 $s$ 中是否有与$a_i$ 互素的元素</strong>。记 $c_i$ 为堆中是 $i$ 的倍数的元素个数，那么堆中和$x$互素的个数为 $cop = \sum_{d|x} \mu(d) c_d$，这是因为包容排斥原理，首先所有数都是 1 的倍数，然后减去和 $x$ 的最小公约数为素数的，在加上和 $x$ 的最小公约数为两个素数相乘…。若 $cop$ 不为 0，那么就一个个的剔除，剔除的时候可以计算一下乘积（虽然不一定互素，但是不会影响的最终结果）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">bool</span> a[N]=&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            a[x]=<span class="number">1</span>;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[mx+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> mu[mx+<span class="number">1</span>]=&#123;&#125;,c[mx+<span class="number">1</span>]=&#123;&#125;;</span><br><span class="line">        mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)&#123;</span><br><span class="line">            p[i].push_back(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=mx;j+=i)&#123;</span><br><span class="line">                p[j].push_back(i);</span><br><span class="line">                a[i]|=a[j];</span><br><span class="line">                mu[j]-=mu[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        LL ans = mx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mx;i;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> cop = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:p[i]) cop+=mu[x]*c[x];</span><br><span class="line">                <span class="keyword">while</span>(cop)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:p[s.top()])&#123;</span><br><span class="line">                        --c[x];</span><br><span class="line">                        <span class="keyword">if</span>(i%x==<span class="number">0</span>) cop-=mu[x];</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,LL(i)*s.top());</span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:p[i]) ++c[x];</span><br><span class="line">                s.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1370D：在长为-n-的序列中找一个长为-k-的子列，子列中奇数项最大值和偶数项最大值的最小值最小"><a href="#1370D：在长为-n-的序列中找一个长为-k-的子列，子列中奇数项最大值和偶数项最大值的最小值最小" class="headerlink" title="1370D：在长为 n 的序列中找一个长为 k 的子列，子列中奇数项最大值和偶数项最大值的最小值最小"></a><a href="https://codeforces.com/contest/1370/problem/D" target="_blank" rel="noopener">1370D</a>：在长为 n 的序列中找一个长为 k 的子列，子列中奇数项最大值和偶数项最大值的最小值最小</h3><blockquote>
<p>比赛的时候，我很快就知可以二分查找答案，但是顾前不顾尾，下面代码没过，因为当最后一个数正好是满足 <code>a[i]&lt;=m</code> 时答案就不行了！<strong>应该按照原来的逻辑去叠加啊！</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此代码是错误代码！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> a[n],r=<span class="number">0</span>,l=<span class="number">1e9</span>+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        r = <span class="built_in">max</span>(r,a[i]);</span><br><span class="line">        l = <span class="built_in">min</span>(l,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> m)&#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">-2</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k%<span class="number">2</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;=m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;now+<span class="number">1</span>)&#123;</span><br><span class="line">                    ++s;</span><br><span class="line">                    now = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s&gt;=k/<span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(m)) r=m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=m+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是修正的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    <span class="keyword">auto</span> g = [&amp;](<span class="keyword">int</span> m,<span class="keyword">bool</span> cur)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">                cur = !cur;</span><br><span class="line">                ++s;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&lt;=m)&#123;</span><br><span class="line">                    ++s;</span><br><span class="line">                    cur = !cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s&gt;=k;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> l = *min_element(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> r = *max_element(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">   	<span class="comment">//auto lr = minmax_element(a.begin(),a.end());</span></span><br><span class="line">    <span class="comment">//int l = *lr.first,r = *lr.second;</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(g(m,<span class="number">0</span>)||g(m,<span class="number">1</span>)) r=m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=m+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1370E：找出最少的轮换使得字符串-s-变成-t"><a href="#1370E：找出最少的轮换使得字符串-s-变成-t" class="headerlink" title="1370E：找出最少的轮换使得字符串 s 变成 t"></a><a href="https://codeforces.com/contest/1370/problem/E" target="_blank" rel="noopener">1370E</a>：找出最少的轮换使得字符串 s 变成 t</h3><p>我一开始知道是贪心，然后我以为 <strong>是找到其中最长的连续 0 或者 1</strong>，然后发现并不是！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此代码是错误代码！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">int</span> ab=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a) <span class="keyword">if</span>(x==<span class="string">'1'</span>) ++ab;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:b) <span class="keyword">if</span>(x==<span class="string">'1'</span>) --ab;</span><br><span class="line">    <span class="keyword">if</span>(ab)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i]) s.push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    s+=s;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,t;i&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i == <span class="number">0</span>)||(s[i]!=s[i<span class="number">-1</span>])) t=<span class="number">0</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,++t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看了<a href="https://codeforces.com/blog/entry/79107" target="_blank" rel="noopener">官方题解</a>！</p>
<p>在有解的前提下，我们可以构造取值在 $\{-1,0,1\}$ 的数组 $a$： if  $s_i = t_i,a_i = 0$，else if $s_i = 1,a_i=1$ else $a_i=-1$。因此答案就是</p>
<script type="math/tex; mode=display">
\max _{1 \leq l \leq r \leq n} |\sum_{i=l} ^r  a_i| = max(\max _{1 \leq l \leq r \leq n} \sum_{i=l} ^r  a_i,\max _{1 \leq l \leq r \leq n} \sum_{i=l} ^r  -a_i)</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> s,t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==t[i]) <span class="keyword">continue</span>;</span><br><span class="line">        a.emplace_back(s[i]==<span class="string">'1'</span>?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(accumulate(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> sign)&#123;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:a)&#123;</span><br><span class="line">            cur += sign*x;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx,cur);</span><br><span class="line">            cur = <span class="built_in">max</span>(cur,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mx;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">max</span>(f(<span class="number">1</span>),f(<span class="number">-1</span>))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1263D：Set-lt-int-gt-集合操作范例"><a href="#1263D：Set-lt-int-gt-集合操作范例" class="headerlink" title="1263D：Set&lt;int&gt; 集合操作范例"></a><a href="https://codeforces.com/problemset/problem/1263/D" target="_blank" rel="noopener">1263D</a>：<code>Set&lt;int&gt;</code> 集合操作范例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin)</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s) a[c-<span class="string">'a'</span>].insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[x].<span class="built_in">size</span>()==<span class="number">0</span>) ++x;</span><br><span class="line">    q.insert(a[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x+<span class="number">1</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:q)&#123;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">            set_intersection(x.<span class="built_in">begin</span>(),x.<span class="built_in">end</span>(),a[i].<span class="built_in">begin</span>(),a[i].<span class="built_in">end</span>(),inserter(t, t.<span class="built_in">begin</span>()));</span><br><span class="line">            <span class="keyword">if</span>(t.<span class="built_in">size</span>())&#123;</span><br><span class="line">                set_union(x.<span class="built_in">begin</span>(),x.<span class="built_in">end</span>(),a[i].<span class="built_in">begin</span>(),a[i].<span class="built_in">end</span>(),inserter(t, t.<span class="built_in">begin</span>()));</span><br><span class="line">                a[i] = t;</span><br><span class="line">                p.insert(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; t;</span><br><span class="line">        set_difference(q.<span class="built_in">begin</span>(),q.<span class="built_in">end</span>(),p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),inserter(t, t.<span class="built_in">begin</span>()));</span><br><span class="line">        t.insert(a[i]);</span><br><span class="line">        q = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1369D-组合计数问题"><a href="#1369D-组合计数问题" class="headerlink" title="1369D:  组合计数问题"></a><a href="https://codeforces.com/contest/1369/problem/D" target="_blank" rel="noopener">1369D</a>:  组合计数问题</h3><blockquote>
<p>题解写在官方的 <a href="https://codeforces.com/blog/entry/79235#comment-648996" target="_blank" rel="noopener">教程里面</a>，代码也不想 copy 过来了。</p>
</blockquote>
<p>补充一个更好的生成函数的做法：已知 $a_n$，满足 $a_n = a_{n-1} + 2 a_{n-2} + (n \% 3==0?4:0)$，$a_0 = a_1= a_2 = 0$，计算$a_n$。</p>
<p>设 $f(x) = \sum_{n=0} ^ {\infty} a_n x^n$，则我们有</p>
<script type="math/tex; mode=display">
f(x) = \sum_{n=0} ^ {\infty} (a_{n-1} + 2 a_{n-2} ) x^n + \sum_{n=1} ^ {\infty} 4x^{3n} = xf(x) + x^2f(x) + 4 \sum_{n=1} ^ {\infty} x^{3n}</script><p>所以</p>
<script type="math/tex; mode=display">
f(x) = \frac{4 \sum_{n=1} ^ {\infty} x^{3n}}{(1-2x)(1+x)}</script><p>由于 $\frac{1}{1-x} = \sum_{n=0}^{\infty} x^n$，所以 $\frac{1}{(1-2x)(1+x)} = \frac{2}{3(1-2x)} + \frac{1}{3(1+x)} = \sum_{n=0}^{\infty} \frac{2^{n+1}+(-1)^n}{3}x^n$（推荐），$\frac{1}{(1-2x)(1+x)} = \sum_{n=0}^{\infty} (2x)^n \sum_{n=0}^{\infty}(-x)^n = \sum_{n=0}^{\infty} \frac{2^{n+1}+(-1)^n}{3}x^n$（不推荐），因此</p>
<script type="math/tex; mode=display">
f(x) = \frac{4}{3} \sum_{n=0} ^ \infty (\frac{2^{n \% 3 +1} (8^{n/3}-1)}{8-1} + \frac{(-1)^{n \% 3 +1} ((-1)^{n/3}-1)}{-1-1}) x^n</script><h3 id="1369F：博弈题"><a href="#1369F：博弈题" class="headerlink" title="1369F：博弈题"></a><a href="https://codtforcts.com/conttst/1369/probltm/F" target="_blank" rel="noopener">1369F</a>：博弈题</h3><blockquote>
<p>给定两个正整数 $s \leq t$，$A,B$ 两人依次玩游戏，每次可以从$s$变成 $s+1$ 或 $2s$，谁先严格大于 $t$，谁输了。</p>
<p>现在给你一堆的 $s_i,t_i$，$A,B$ 两人依次玩游戏，每一局输了的人作为下一局开始的人。问 $A$ 能否最后一局必赢，能否最后一局必输</p>
</blockquote>
<p>先考虑单个 $s,t$ 的情况。</p>
<p>用$f(s,t)$ 分别表示$A$ 是否有必胜策略。</p>
<ul>
<li>$t$ 为奇数，若 $s$ 为偶数，那么 $A$ 就让它变成 $s+1$，那么无论 $B$ 如何操作只能变成偶数，所以此时 $f(s,t) = 1$，若 $s$ 为奇数，显然若 $B$ 用 $A$ 刚刚的策略，则 $A$ 输，$f(s,t) = 0$。</li>
<li>$t$ 为偶数，若 $2s&gt;t$，此时只能做加法，$f(s,t) = s \mod 2$，若 $4s&gt;t \geq 2s$，此时 $f(s,t)=1$ ，因为总可以变成 $f(2s,t)=0$。若 $4s \leq t$，若 $f(s,\lfloor \frac{t}{4} \rfloor) = 1$, 则 $A$ 必有策略到达区间 $(\lfloor \frac{t}{4} \rfloor,2\lfloor \frac{t}{4} \rfloor)$ 的某一点，从而 $f(s,t)=1$, 同理若 $f(s,\lfloor \frac{t}{4} \rfloor) = 0$，则 $B$ 有 $A$ 的策略，从而 $f(s,t)=0$ （<strong>比赛的时候能想出来的人是真的虎</strong>) 。</li>
</ul>
<p>用 $g(s,t)$ 分别表示 $A$ 是否有必输的策略：若 $2s&gt;t$，则 $g(s,t)=1$，同理，若 $2s \leq t$，$f(s,\lfloor \frac{t}{2} \rfloor)=1$，则必有策略使得 $B$ 到达 $(\lfloor \frac{t}{2} \rfloor,2\lfloor \frac{t}{2} \rfloor)$ 的某一点，所以 $g(s,t) = f(s,\lfloor \frac{t}{2} \rfloor)$</p>
<p>有了这两个函数后，我们就可以从后往前依次来决定最后能否有必胜或必输的决策。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in","r",stdin)</span></span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    function&lt;<span class="keyword">bool</span>(LL,LL)&gt; f = [&amp;](LL s,LL t)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> s%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*s&gt;t) <span class="keyword">return</span> s%<span class="number">2</span>==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">4</span>*s&gt;t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> f(s,t/<span class="number">4</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    function&lt;<span class="keyword">bool</span>(LL,LL)&gt; g = [&amp;](LL s,LL t)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*s&gt;t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> f(s,t/<span class="number">2</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">bool</span> win=<span class="number">0</span>,lose=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        LL s,t;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(win^lose==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(lose)&#123;</span><br><span class="line">            win = f(s,t);</span><br><span class="line">            lose = g(s,t);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            win = !f(s,t);</span><br><span class="line">            lose = !g(s,t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;win&lt;&lt;<span class="string">" "</span>&lt;&lt;lose&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以认为一开始仅有必输策略所以让$A$先选，然后如果$A$原来有必胜且有必败策略，这后面必然一直有，若没有必胜也没有必败策略，则后面也是。所以只用考虑仅有其中之一的情形。</p>
</blockquote>
<h2 id="补充和强化知识"><a href="#补充和强化知识" class="headerlink" title="补充和强化知识"></a>补充和强化知识</h2><ul>
<li>需要补充：图论</li>
<li>需要强化：二分法，动态规划，代码能力，找公式速度，读题速度。</li>
<li>需要模板：高斯消元法 C++ 版。</li>
<li>水题刷题速度太慢！（题刷少了，每天一套 Codeforces since 2020/6/8）</li>
<li>不细心坑自己，让自己不自信！</li>
<li>系统的学习了一下 STL，总结出好用的部分！（2020/6/21） </li>
<li><code>vector&lt;bool&gt;</code> 不是容器！</li>
<li><strong>用指法敲代码</strong></li>
<li><strong>急需各种图论算法好用的模板: 看 Jiangly 的代码找模板？</strong></li>
</ul>
<blockquote>
<p>在 <a href="https://oi-wiki.org/" target="_blank" rel="noopener">OI-wiki</a> 复习和学习算法，在 <a href="https://codeforces.com" target="_blank" rel="noopener">codeforces</a> 训练算法和编程能力。</p>
</blockquote>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><ul>
<li>直接 tuple 类型数组直接存边，vector 类型直接 <code>push_back</code> 貌似不错啊！（见上面 1363E 的例子）</li>
<li>邻接矩阵（只能用于无重边的图）</li>
<li>链式前向星（推荐，优雅）</li>
</ul>
<p>前两种都很基础，我们一般用 <strong>链式前向星</strong> 来存储，<a href="https://oi-wiki.org/graph/save/" target="_blank" rel="noopener">oi-wiki 上的例子</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head[u] 和 cnt 的初始值都为 -1</span></span><br><span class="line"><span class="keyword">int</span> head[N],to[M]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    nxt[++cnt] = head[u];  <span class="comment">// 当前边的后继</span></span><br><span class="line">    head[u] = cnt;         <span class="comment">// 起点 u 的第一条边</span></span><br><span class="line">    to[cnt] = v;           <span class="comment">// 当前边的终点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 u 的出边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = nxt[i]) &#123;  <span class="comment">// ~i 表示 i != -1</span></span><br><span class="line">    <span class="keyword">int</span> v = to[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，自从我会 C++17 后，我们可以这么写（优雅）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N =<span class="number">1e5</span>;   <span class="comment">// 顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>;  <span class="comment">// 边数，在树中是 2*(n-1)</span></span><br><span class="line"><span class="comment">// head[u] 和 cnt 的初始值都为 -1</span></span><br><span class="line"><span class="keyword">int</span> head[N],cnt,nxt[M];</span><br><span class="line">tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; edge[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    nxt[++cnt] = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    edge[cnt] = &#123;v,w&#125;; <span class="comment">// 也可以存入u但没必要</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历 u 的出边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vis</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];~i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [v,w] = edge[i];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;u&lt;&lt;<span class="string">" "</span>&lt;&lt;v&lt;&lt;<span class="string">" "</span>&lt;&lt;w&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>存双向边时 <code>i ^ 1</code> 即是 <code>i</code> 的反边。</p>
</blockquote>
<h3 id="DFS（深度优先搜索）"><a href="#DFS（深度优先搜索）" class="headerlink" title="DFS（深度优先搜索）"></a>DFS（深度优先搜索）</h3><p>递归的调用自己，要用到 <strong>栈</strong></p>
<p>在 Windows 上，通常的方法是在 <strong>编译选项</strong> 中加入 <code>-Wl,--stack=1000000000</code> </p>
<p>在 Linux 上，通常的方法是在运行程序前 <strong>在终端内</strong> 执行 <code>ulimit -s unlimited</code> （WSL 下无法设置可惜）</p>
<h3 id="BFS（广度优先搜索）"><a href="#BFS（广度优先搜索）" class="headerlink" title="BFS（广度优先搜索）"></a>BFS（广度优先搜索）</h3><p>用 <code>queue</code> 保存节点，先进先出。队列为空。</p>
<p>用 <code>priority_queue</code> 保存节点，可用于优化 Dijkstra 算法。</p>
<h3 id="无根树的-Prufer-序列"><a href="#无根树的-Prufer-序列" class="headerlink" title="无根树的 Prufer 序列"></a>无根树的 Prufer 序列</h3><blockquote>
<p>$n$ 个节点的无根树和长度为 $n-2$，数值在 $1 \to n$ 的序列有一一对应</p>
<p>构造方式：删除编号最小的叶子节点，并记录它的父节点。</p>
</blockquote>
<p>之前在<a href="/catWithPy/" title="猫咪状态数">猫咪状态数</a> 中有记录过，代码可以见 <a href="https://oi-wiki.org/graph/prufer/" target="_blank" rel="noopener">这里</a></p>
<h3 id="有根树的-Euler-序列"><a href="#有根树的-Euler-序列" class="headerlink" title="有根树的 Euler 序列"></a>有根树的 Euler 序列</h3><p>通过 DFS，可以把一个有根树转化成长度为 $2n-1$，数值在 $1 \to n$ 的序列。</p>
<h3 id="最近公共祖先简称-LCA（Lowest-Common-Ancestor）"><a href="#最近公共祖先简称-LCA（Lowest-Common-Ancestor）" class="headerlink" title="最近公共祖先简称 LCA（Lowest Common Ancestor）"></a>最近公共祖先简称 LCA（Lowest Common Ancestor）</h3><ul>
<li>策略 1：其中一个节点一直往上标记父辈到根，然后另一个节点往上找父辈，直到找到首次被标记过的节点</li>
<li>策略 2：标记没个节点的深度，深度高的往上到同一层，然后一起一步步上去，直到是公共节点</li>
<li>策略 3：做一次 DFS 得到 Euler 序列，然后就变成找区间最小值问题了（可以使用线段树）</li>
<li>其他：倍增（记录 <code>fa[u][i]</code>：表示 <code>u</code> 的第$2^i$祖先），Tarjan 算法，动态树</li>
</ul>
<h3 id="有向图的拓扑排序之-Kahn-算法"><a href="#有向图的拓扑排序之-Kahn-算法" class="headerlink" title="有向图的拓扑排序之 Kahn 算法"></a>有向图的拓扑排序之 Kahn 算法</h3><p>给定有向图，然后把节点按照顺序排列，使得任意有向边的起点在终点前。</p>
<p>做法：维护一个入度为 0 的节点集合，一次删除节点（加入拓扑序列），删除的时候它连接的所有点入度减 1，为 0 就加入节点集合。</p>
<blockquote>
<p>一个有向图是无环图，当且仅当它存在拓扑排序。</p>
</blockquote>
<h3 id="有向图最小生成树的-Kruskal-算法（更推荐）"><a href="#有向图最小生成树的-Kruskal-算法（更推荐）" class="headerlink" title="有向图最小生成树的 Kruskal 算法（更推荐）"></a>有向图最小生成树的 Kruskal 算法（更推荐）</h3><p>把边排序，每次加入最短边，如果加入不构成环，就加入，否则不加。</p>
<p>需要（带路径压缩）并查集维护。</p>
<h3 id="（有向图）最小生成树的-Prim-算法"><a href="#（有向图）最小生成树的-Prim-算法" class="headerlink" title="（有向图）最小生成树的 Prim 算法"></a>（有向图）最小生成树的 Prim 算法</h3><p>讲节点分为两类：已加入和未加入。每次从未加入的节点中找一个和已知节点最近的边，然后加入该节点，连接这条边。(初始加入节点任意)</p>
<h3 id="（有向图）的次小生成树（下次一定）"><a href="#（有向图）的次小生成树（下次一定）" class="headerlink" title="（有向图）的次小生成树（下次一定）"></a>（有向图）的次小生成树（下次一定）</h3><h3 id="最小树形图（有向图的最小生成树）的-朱刘算法"><a href="#最小树形图（有向图的最小生成树）的-朱刘算法" class="headerlink" title="最小树形图（有向图的最小生成树）的 朱刘算法"></a>最小树形图（有向图的最小生成树）的 <a href="https://blog.csdn.net/dajiangyou123456/article/details/105137781?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">朱刘算法</a></h3><ol>
<li>找入度为 0 的 root 节点（唯一，否则不存在最小树形图）</li>
<li>除了 root 节点外，找出每个点的最小入边</li>
<li>检测是否有环，有环则缩点，更新新节点的距离</li>
<li>重复上述过程</li>
</ol>
<h3 id="强连通分量的-Kosaraju-算法"><a href="#强连通分量的-Kosaraju-算法" class="headerlink" title="强连通分量的 Kosaraju 算法"></a><a href="https://oi-wiki.org/graph/scc/#_3" target="_blank" rel="noopener">强连通分量的 Kosaraju 算法</a></h3><p>Kosaraju 算法依靠两次简单的 DFS 实现。</p>
<p>第一次 DFS，选取任意顶点作为起点，遍历所有未访问过的顶点，并在回溯之前给顶点编号，也就是后序遍历。</p>
<p>第二次 DFS，对于反向后的图，以标号最大的顶点作为起点开始 DFS。这样遍历到的顶点集合就是一个强连通分量。对于所有未访问过的结点，选取标号最大的，重复上述过程。</p>
<p>两次 DFS 结束后，强连通分量就找出来了，Kosaraju 算法的时间复杂度为 $O(m+n)$。</p>
<p>实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// g 是原图，g2 是反图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u])</span><br><span class="line">    <span class="keyword">if</span> (!vis[v]) dfs1(v);</span><br><span class="line">  s.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  color[u] = sccCnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : g2[u])</span><br><span class="line">    <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sccCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) dfs1(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (!color[s[i]]) &#123;</span><br><span class="line">      ++sccCnt;</span><br><span class="line">      dfs2(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以将一张图的每个强连通分量都缩成一个点，然后这张图会变成一个有向无环图</p>
</blockquote>
<h3 id="强连通分量的-Tarjan-算法"><a href="#强连通分量的-Tarjan-算法" class="headerlink" title="强连通分量的 Tarjan 算法"></a>强连通分量的 Tarjan 算法</h3><h3 id="二分图的匈牙利算法：dfs-硬搞"><a href="#二分图的匈牙利算法：dfs-硬搞" class="headerlink" title="二分图的匈牙利算法：dfs 硬搞"></a>二分图的匈牙利算法：dfs 硬搞</h3><h3 id="Kirchhoff-矩阵树定理：解决了一张图的生成树个数计数问题"><a href="#Kirchhoff-矩阵树定理：解决了一张图的生成树个数计数问题" class="headerlink" title="Kirchhoff 矩阵树定理：解决了一张图的生成树个数计数问题"></a>Kirchhoff 矩阵树定理：解决了一张图的生成树个数计数问题</h3><h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><p>在 codeforces 上 <code>zscoder</code> 大佬给了一个 <a href="https://codeforces.com/blog/entry/77468" target="_blank" rel="noopener">入门教程</a> 和 <a href="https://codeforces.com/blog/entry/77551" target="_blank" rel="noopener">进阶教程</a> 还有 <code>MiFaFaOvO</code> 的 <a href="https://codeforces.com/blog/entry/76447" target="_blank" rel="noopener">终极教程</a></p>
<p>生成函数分两种：Original generating function，Expentional generating function，选择哪一种是看问题中是否牵扯组合数。无论哪一种都能保存原数列的全部信息，并且由于级数可以使用微积分和常微分方程的技术，所以会变得更好处理。然后大概率可以优化算法复杂度 $O(n^2) \to O(n \log n)$ </p>
<p>关于生成函数多项式的处理：<a href="https://cp-algorithms.com/algebra/polynomial.html" target="_blank" rel="noopener">https://cp-algorithms.com/algebra/polynomial.html</a></p>
<p>多项式高效运算模板：<a href="https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp" target="_blank" rel="noopener">https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp</a></p>
<p><strong>生成函数一般的处理思路</strong>：计算生成函数，分解成有分母不超过二次的分式之和，然后每一个二次的分母部分找一个递推数列来搞定。</p>
<p><a href="https://oi-wiki.org/math/poly/intro/" target="_blank" rel="noopener">OI-wiki 多项式运算</a></p>
<h2 id="耻辱记录"><a href="#耻辱记录" class="headerlink" title="耻辱记录"></a>耻辱记录</h2><ul>
<li>2020/5/24 水题竟然也能被卡，傻子吧我！</li>
<li>被 <code>lower_bound</code> 坑了，也怪自己，<code>lower_bound(a.begin(),a.end(),x)-a</code> ：对于单调递增的序列，返回第一个大于等于<code>x</code>的序号。<code>upper_bound</code> 返回的是第一个大于 <code>x</code> 的序号，所以讲道理，upper_bound 更好用！</li>
<li>2020/6/1 低级错误，把 <code>int</code> 型变量放在 <code>bool</code> 型后面定义了！结果找了半天的错误！！导致少做一题。给了自己几巴掌</li>
<li><a href="https://codeforces.com/contest/1379" target="_blank" rel="noopener">Codeforces Round #657 (Div. 2)</a>：只做了一题？？？被 A 题卡了一个多小时？？？</li>
</ul>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ul>
<li><a href="https://codeforces.com/contest/1366" target="_blank" rel="noopener">Educational Codeforces Round 89 (Rated for Div. 2)</a>：我竟然有做 5 题的实力！，但是因为网络原因我只做了 4 题。最后一个差一点，后面 1A 补上了。可惜。不过也还行加油！</li>
<li><a href="https://codeforces.com/contest/1367" target="_blank" rel="noopener">Codeforces Round #650 (Div. 3)</a>：第一次两小时内做 5 题，全部 1A，虽然是 div3！(竟然最后只加了 131 分)</li>
<li><a href="https://codeforces.com/contest/1370" target="_blank" rel="noopener">Codeforces Round #651 (Div. 2)</a>：唯一一次<del>不加不减</del>（过几小时之后它又减了我一分），但是，收获颇多的一次。</li>
<li><a href="https://codeforces.com/contest/1373" target="_blank" rel="noopener">Educational Codeforces Round 90 (Rated for Div. 2)</a>：做了 4 题，因为第五题没做出来，所以没交题！</li>
<li><a href="https://codeforces.com/contest/1371" target="_blank" rel="noopener">Codeforces Round #654 (Div. 2)</a>：好烦啊，又是结束后 5 分钟做出第五题。</li>
<li>目前，打字（代码）速度是限制我做 5 题的瓶颈！</li>
<li>提高码字速度，多总结，最近不要主动刷新题了。（2020/7/5)</li>
<li><a href="https://codeforces.com/contest/1251" target="_blank" rel="noopener">Educational Codeforces Round 75 (Rated for Div. 2)</a>: 第一次补完题目 （2020/7/9)</li>
<li><a href="https://codeforces.com/contest/1399" target="_blank" rel="noopener">Codeforces Round #661 (Div. 3)</a> 补完题目</li>
<li>图论，树上的问题也没那么可怕，就是麻烦点</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Math</tag>
        <tag>Codeforces</tag>
        <tag>图论</tag>
      </tags>
  </entry>
</search>

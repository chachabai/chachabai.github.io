<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++ 图论模板 | dna049</title><meta name="description" content="图论还是一个特别强的工具。 为什么没有图论的 STL？代码更新汇总。 其他人的图论模板可做参考（其实我自己的够用了目前看） Nisiyama_Suzune 的图论模板 DQ9911 的模板 HDU 模板 也可以作为参考  存边方式 不涉及删边和反边（最简单常用的情况），可以直接用 vector 邻接表 std::vector&lt;std::vector&lt;std::pair&lt;int,"><meta name="keywords" content="C++,图论"><meta name="author" content="dna049"><meta name="copyright" content="dna049"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/dna049.png"><link rel="canonical" href="https://dna049.com/graph/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="C++ 图论模板"><meta property="og:url" content="https://dna049.com/graph/"><meta property="og:site_name" content="dna049"><meta property="og:description" content="图论还是一个特别强的工具。 为什么没有图论的 STL？代码更新汇总。 其他人的图论模板可做参考（其实我自己的够用了目前看） Nisiyama_Suzune 的图论模板 DQ9911 的模板 HDU 模板 也可以作为参考  存边方式 不涉及删边和反边（最简单常用的情况），可以直接用 vector 邻接表 std::vector&lt;std::vector&lt;std::pair&lt;int,"><meta property="og:image" content="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><meta property="article:published_time" content="2021-01-26T08:13:41.000Z"><meta property="article:modified_time" content="2021-05-09T16:49:58.726Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = '2'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?79cbe4231606af28625413fd5210e0b3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '4.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"18px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2021-05-10 00:49:58'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="dna049" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/dna049.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">88</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">23</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/templateOfCpp"><i class="fa-fw fas fa-heart"></i><span> C++模板</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-calendar"></i><span> 工具类网站</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#其他人的图论模板可做参考（其实我自己的够用了目前看）"><span class="toc-number">1.</span> <span class="toc-text">其他人的图论模板可做参考（其实我自己的够用了目前看）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存边方式"><span class="toc-number">2.</span> <span class="toc-text">存边方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#链式前向星-（弃用）"><span class="toc-number">2.1.</span> <span class="toc-text">链式前向星 （弃用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接矩阵存边（太简单就不写了）"><span class="toc-number">2.2.</span> <span class="toc-text">邻接矩阵存边（太简单就不写了）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接-map-or-unorder-map-存边（同上）"><span class="toc-number">2.3.</span> <span class="toc-text">邻接 map or unorder_map 存边（同上）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector-版本链式前向星（见后面网络流的做法）"><span class="toc-number">2.4.</span> <span class="toc-text">vector 版本链式前向星（见后面网络流的做法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树上问题转化成序列问题"><span class="toc-number">3.</span> <span class="toc-text">树上问题转化成序列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无根树的-Prufer-序列"><span class="toc-number">3.1.</span> <span class="toc-text">无根树的 Prufer 序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有根树的-dfs-序"><span class="toc-number">3.2.</span> <span class="toc-text">有根树的 dfs 序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有根树的-Euler-序列（长度为-2n-1）"><span class="toc-number">3.3.</span> <span class="toc-text">有根树的 Euler 序列（长度为 2n - 1）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树链剖分-Heavy-Light-decomposition"><span class="toc-number">3.4.</span> <span class="toc-text">树链剖分 Heavy-Light decomposition</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重链剖分求-LCA-的模板例题：LOJ-3379，我的实现"><span class="toc-number">3.4.1.</span> <span class="toc-text">重链剖分求 LCA 的模板例题：LOJ 3379，我的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重链剖分求任意两点路径上所有节点的点权和，求子树的点权和（利用-dfs-编号和-sz-直接区间查询或区间修改）"><span class="toc-number">3.4.2.</span> <span class="toc-text">重链剖分求任意两点路径上所有节点的点权和，求子树的点权和（利用 dfs 编号和 sz 直接区间查询或区间修改）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#长链剖分优化-DP，例题：1009F"><span class="toc-number">3.4.3.</span> <span class="toc-text">长链剖分优化 DP，例题：1009F</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树上启发式算法（dsu-on-tree）"><span class="toc-number">3.5.</span> <span class="toc-text">树上启发式算法（dsu on tree）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树上问题"><span class="toc-number">4.</span> <span class="toc-text">树上问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#树的直径：先从任意点开始寻找最远距离点（bfs-遍历一下），然后再找一次就是了（易证）"><span class="toc-number">4.1.</span> <span class="toc-text">树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的中心-：所有点到该点的最大值最小（直径的中点）"><span class="toc-number">4.2.</span> <span class="toc-text">[树的中心]：所有点到该点的最大值最小（直径的中点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的重心：去掉这个点后连通分支的节点数量的最大值最小"><span class="toc-number">4.3.</span> <span class="toc-text">树的重心：去掉这个点后连通分支的节点数量的最大值最小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最近公共祖先简称-LCA（Lowest-Common-Ancestor）"><span class="toc-number">4.4.</span> <span class="toc-text">最近公共祖先简称 LCA（Lowest Common Ancestor）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有向无环图的拓扑排序之-Kahn-算法"><span class="toc-number">4.5.</span> <span class="toc-text">有向无环图的拓扑排序之 Kahn 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无向图的-Euler-路-的-Hierholzer-算法"><span class="toc-number">4.6.</span> <span class="toc-text">无向图的 Euler 路 的 Hierholzer 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有向图的-Hamiltonian-路的启发式算法"><span class="toc-number">4.7.</span> <span class="toc-text">有向图的 Hamiltonian 路的启发式算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#笛卡尔树-：我去，竟然是-O-n-复杂度的建树（弃用没必要直接学单调栈即可）"><span class="toc-number">4.8.</span> <span class="toc-text">笛卡尔树 ：我去，竟然是 $O(n)$ 复杂度的建树（弃用没必要直接学单调栈即可）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小生成树-prim-算法"><span class="toc-number">4.9.</span> <span class="toc-text">最小生成树 prim 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小树形图的-O-nm-刘朱算法"><span class="toc-number">4.10.</span> <span class="toc-text">最小树形图的 $O(nm)$ 刘朱算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最短路"><span class="toc-number">5.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#知乎上看到-YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）"><span class="toc-number">5.1.</span> <span class="toc-text">知乎上看到 YYYYLLL 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd-带路径-—-未测试"><span class="toc-number">5.2.</span> <span class="toc-text">Floyd 带路径 —- 未测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆优化-Dijkstra"><span class="toc-number">5.3.</span> <span class="toc-text">堆优化 Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆优化-Dijkstra-弃用"><span class="toc-number">5.4.</span> <span class="toc-text">堆优化 Dijkstra (弃用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bellman-Ford"><span class="toc-number">5.5.</span> <span class="toc-text">Bellman-Ford</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spfa"><span class="toc-number">5.6.</span> <span class="toc-text">spfa</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无向图染色问题"><span class="toc-number">6.</span> <span class="toc-text">无向图染色问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-color"><span class="toc-number">6.1.</span> <span class="toc-text">2-color</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Chromatic-Polynomial"><span class="toc-number">6.2.</span> <span class="toc-text">The Chromatic Polynomial</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连通性问题"><span class="toc-number">7.</span> <span class="toc-text">连通性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kosaraju-缩点算法"><span class="toc-number">7.1.</span> <span class="toc-text">Kosaraju 缩点算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SAT"><span class="toc-number">7.2.</span> <span class="toc-text">2-SAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#割点（无向图中删除该点使得连通分量数量增多的节点）"><span class="toc-number">7.3.</span> <span class="toc-text">割点（无向图中删除该点使得连通分量数量增多的节点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#割边（无向图中删除该边使得连通分量数量增多的边）"><span class="toc-number">7.4.</span> <span class="toc-text">割边（无向图中删除该边使得连通分量数量增多的边）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图的匹配算法"><span class="toc-number">8.</span> <span class="toc-text">图的匹配算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络流"><span class="toc-number">9.</span> <span class="toc-text">网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#有向图-S-T-最大流-Dinic-算法-O-n-2-m-（对偶问题：S-T-最大流等于-S-T-最小割）"><span class="toc-number">9.1.</span> <span class="toc-text">有向图 S-T 最大流 Dinic 算法 $O(n^2 m)$（对偶问题：S-T 最大流等于 S-T 最小割）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-unordered-map-直接存边的-Dinic-算法（注意结果是否超-int）"><span class="toc-number">9.2.</span> <span class="toc-text">使用 unordered_map 直接存边的 Dinic 算法（注意结果是否超 int）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有向图-S-T-最大流-ISAP-算法-弃用"><span class="toc-number">9.3.</span> <span class="toc-text">有向图 S-T 最大流 ISAP 算法 (弃用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有向图-S-T-最大流的最高标号预流推进算法（HLPP）-O-n-2-sqrt-m-算法"><span class="toc-number">9.4.</span> <span class="toc-text">有向图 S-T 最大流的最高标号预流推进算法（HLPP） $O(n^2 \sqrt{m})$ 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无向图全局最小割-Stoer-Wagner-算法"><span class="toc-number">9.5.</span> <span class="toc-text">无向图全局最小割 Stoer-Wagner 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无向图全局最小割-Stoer-Wagner-算法，邻接矩阵-O-n-3-实现"><span class="toc-number">9.6.</span> <span class="toc-text">无向图全局最小割 Stoer-Wagner 算法，邻接矩阵 $O(n^3)$ 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无向图全局最小割-Stoer-Wagner-算法，邻接-unorded-map-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法）"><span class="toc-number">9.7.</span> <span class="toc-text">无向图全局最小割 Stoer-Wagner 算法，邻接 unorded_map + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无向图全局最小割-Stoer-Wagner-算法，邻接表-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法还是-TLE-属实可惜）"><span class="toc-number">9.8.</span> <span class="toc-text">无向图全局最小割 Stoer-Wagner 算法，邻接表 + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法还是 TLE 属实可惜）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小费用最大流"><span class="toc-number">9.9.</span> <span class="toc-text">最小费用最大流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上下界网络流"><span class="toc-number">9.10.</span> <span class="toc-text">上下界网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#无源汇上下界可行流"><span class="toc-number">9.10.1.</span> <span class="toc-text">无源汇上下界可行流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有源汇上下界可行流"><span class="toc-number">9.10.2.</span> <span class="toc-text">有源汇上下界可行流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有源汇上下界最大流"><span class="toc-number">9.10.3.</span> <span class="toc-text">有源汇上下界最大流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有源汇上下界最小流"><span class="toc-number">9.10.4.</span> <span class="toc-text">有源汇上下界最小流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（有-无）源汇上下界最小费流"><span class="toc-number">9.10.5.</span> <span class="toc-text">（有&#x2F;无）源汇上下界最小费流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（有-无）源汇上下界最小费用最大流"><span class="toc-number">9.10.6.</span> <span class="toc-text">（有&#x2F;无）源汇上下界最小费用最大流</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">dna049</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/templateOfCpp"><i class="fa-fw fas fa-heart"></i><span> C++模板</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-calendar"></i><span> 工具类网站</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">C++ 图论模板</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-26T08:13:41.000Z" title="发表于 2021-01-26 16:13:41">2021-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-09T16:49:58.726Z" title="更新于 2021-05-10 00:49:58">2021-05-10</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>67分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>图论还是一个特别强的工具。 为什么没有图论的 STL？<a href="https://github.com/izlyforever/cf/blob/master/include/graph.hpp" target="_blank" rel="noopener">代码更新汇总</a>。</p>
<h2 id="其他人的图论模板可做参考（其实我自己的够用了目前看）"><a href="#其他人的图论模板可做参考（其实我自己的够用了目前看）" class="headerlink" title="其他人的图论模板可做参考（其实我自己的够用了目前看）"></a>其他人的图论模板可做参考（其实我自己的够用了目前看）</h2><ul>
<li><a href="https://uoj.ac/submission/160478" target="_blank" rel="noopener">Nisiyama_Suzune</a> 的图论模板</li>
<li><a href="https://github.com/DQ9911/icpc_template_2020" target="_blank" rel="noopener">DQ9911</a> 的模板</li>
<li><a href="HDU_ACM-ICPC_Templates.pdf">HDU 模板</a> 也可以作为参考</li>
</ul>
<h2 id="存边方式"><a href="#存边方式" class="headerlink" title="存边方式"></a>存边方式</h2><ul>
<li>不涉及删边和反边（最简单常用的情况），可以直接用 vector 邻接表 <code>std::vector&lt;std::vector&lt;std::pair&lt;int, T&gt;&gt;&gt;</code></li>
<li>仅涉及反向边，不涉及删边（如网络流问题），可以使用 vector 版本的链式前向星（写法特别简洁）</li>
<li>不涉及重边（即使涉及重边也可以！其它操作随意，无向图其实也可以操作），都可以使用 vector 邻接表 <code>std::vector&lt;std::unordered_map&lt;int, int&gt;&gt;</code>（更快）或<code>std::vector&lt;std::map&lt;int, T&gt;&gt;</code>，当然了各种操作都要带个 log </li>
<li>如果涉及重边（逻辑上没法合并的那种），就不存在反边的概念了。此时可以用链式前向星，也可以使用 最简单情况的 vector 邻接表（也支持删边，只是比较慢）无论怎么，即使不用链式前向星，这种思想还是值得学习的。</li>
</ul>
<h3 id="链式前向星-（弃用）"><a href="#链式前向星-（弃用）" class="headerlink" title="链式前向星 （弃用）"></a>链式前向星 （弃用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head, nxt, to;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; w;</span><br><span class="line">	LinkStar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		nxt.<span class="built_in">clear</span>();</span><br><span class="line">		to.<span class="built_in">clear</span>();</span><br><span class="line">		head = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL val)</span> </span>&#123;</span><br><span class="line">		nxt.emplace_back(head[u]);</span><br><span class="line">		head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">		to.emplace_back(v);</span><br><span class="line">		w.emplace_back(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="邻接矩阵存边（太简单就不写了）"><a href="#邻接矩阵存边（太简单就不写了）" class="headerlink" title="邻接矩阵存边（太简单就不写了）"></a>邻接矩阵存边（太简单就不写了）</h3><h3 id="邻接-map-or-unorder-map-存边（同上）"><a href="#邻接-map-or-unorder-map-存边（同上）" class="headerlink" title="邻接 map or unorder_map 存边（同上）"></a>邻接 map or unorder_map 存边（同上）</h3><h3 id="vector-版本链式前向星（见后面网络流的做法）"><a href="#vector-版本链式前向星（见后面网络流的做法）" class="headerlink" title="vector 版本链式前向星（见后面网络流的做法）"></a>vector 版本链式前向星（见后面网络流的做法）</h3><h2 id="树上问题转化成序列问题"><a href="#树上问题转化成序列问题" class="headerlink" title="树上问题转化成序列问题"></a>树上问题转化成序列问题</h2><h3 id="无根树的-Prufer-序列"><a href="#无根树的-Prufer-序列" class="headerlink" title="无根树的 Prufer 序列"></a>无根树的 Prufer 序列</h3><blockquote>
<p>A.Cayley 在 1889 年首先公布并证明 $n$ 个节点的无根树和长度为 $n-2$，数值在 $1 \to n$ 的序列有一一对应</p>
<p>构造方式：删除编号最小的叶子节点，并记录它的父节点。</p>
</blockquote>
<p>曾在 <a href="/catWithPy/" title="猫咪状态数">猫咪状态数</a> 中有记录过。<a href="https://cp-algorithms.com/graph/pruefer_code.html" target="_blank" rel="noopener">CP-algorithm</a> 中有详细的讲解和代码 无根树 和 Prufer 序列 互转的 $O(n \log n)$ 和 $O(n)$ 两类代码。</p>
<h3 id="有根树的-dfs-序"><a href="#有根树的-dfs-序" class="headerlink" title="有根树的 dfs 序"></a>有根树的 <strong>dfs 序</strong></h3><blockquote>
<p>本质作用： 将树上问题转化成序列问题，dfs 序是基础，Euler 序可以认为是推广。</p>
</blockquote>
<p>树节点按 dfs 过程中的访问顺序排序（进入记录一次，出去记录一次），称为 dfs 序。处理子树的问题很有用。</p>
<p><a href="https://www.cnblogs.com/bytebull/p/5929137.html" target="_blank" rel="noopener">这里</a> 给出了 dfs 序的一些应用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DfsTour</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, cnt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l, r;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DfsTour(<span class="keyword">int</span> _n) : n(_n), e(n), l(n), r(n), cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">		l[u] = ++cnt;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			dfs(v, u);</span><br><span class="line">		&#125;</span><br><span class="line">		r[u] = cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 u 的子树的编号正好是区间 $[l_u, r_u]$</p>
</blockquote>
<p>关于子树的问题，可以考虑一下 dfs 序。</p>
<ol>
<li>在节点权值可修改的情况下，查询某个子树里的所有点权和。<blockquote>
<p>由于在上述 dfs 序中子树 x 是连续的一段 $[l_x, r_x]$，所以用树状数组：单点更新，区间查询。</p>
</blockquote>
</li>
<li>节点 X 到 Y 的最短路上所有点权都加上一个数 W，查询某个子树里的所有点权和。<br>可以理解为更新 4 段区间，根节点到 X，根节点到 Y，根节点到 lca(X, Y)，根节点到 fa[lca(X, Y)]，可以用 线段树 或 带区间更新的树状数组。</li>
</ol>
<h3 id="有根树的-Euler-序列（长度为-2n-1）"><a href="#有根树的-Euler-序列（长度为-2n-1）" class="headerlink" title="有根树的 Euler 序列（长度为 2n - 1）"></a>有根树的 Euler 序列（长度为 2n - 1）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 rt 为根的树，只记录进入的 Euler 序（长度为 2n - 1)</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">EulerTour</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; e, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		r.emplace_back(u);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			dfs(v, u);</span><br><span class="line">			r.emplace_back(u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	dfs(rt, rt);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先观察到这个树的 Euler 序列首尾都是根的编号，如果把首尾连接起来，就会发现：<strong>这个序列中元素出现的次数正好是它的度</strong>。并且我们可以轻松的<strong>换根节点</strong>!!!，以谁为根就以谁开始转圈！并且如果删除某个节点，那么就会形成<strong>以这个节点为度的个数的连通分支</strong>。</p>
<p>问题 1：求 最近公共祖先（LCA）</p>
<p>求完 Euler 序列后，求 <code>lca(u, v)</code> 那就是 $E[pos[u], \cdots, pos[v]]$ 的最小值，其中 <code>pos[u]</code> 为 u 首次出现在 E 中的标号。那么显然我们可以用线段树 $O(n)$ 预处理，单步 $O(\log n)$ 在线查询 lca。</p>
<p>问题 2：求树上任意两点的距离</p>
<p>求完 Euler 序列的同时，我们先求出根节点和其它点的距离，由上述步骤我们能求 lca，那么树上任意两点 $u, v$ 的距离就是 <code>d[u] + d[v] - d[lca(u, v)]</code></p>
<blockquote>
<p>如果求树上任意两点距离之和：只需统计每条边经过多少次就行，显然等价于每条边左右两边节点个数，就不用上述做法了。</p>
</blockquote>
<p>问题 3：求树上节点到根节点的最短路径点权和</p>
<h3 id="树链剖分-Heavy-Light-decomposition"><a href="#树链剖分-Heavy-Light-decomposition" class="headerlink" title="树链剖分 Heavy-Light decomposition"></a><a href="https://oi-wiki.org/graph/hld/" target="_blank" rel="noopener">树链剖分 Heavy-Light decomposition</a></h3><p>重链剖分可以理解为 dfs 序和 Euler 序的增强优化拓展版本。</p>
<h4 id="重链剖分求-LCA-的模板例题：LOJ-3379，我的实现"><a href="#重链剖分求-LCA-的模板例题：LOJ-3379，我的实现" class="headerlink" title="重链剖分求 LCA 的模板例题：LOJ 3379，我的实现"></a>重链剖分求 LCA 的模板例题：<a href="https://www.luogu.com.cn/problem/P3379" target="_blank" rel="noopener">LOJ 3379</a>，<a href="https://www.luogu.com.cn/record/45492112" target="_blank" rel="noopener">我的实现</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LCA</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa, dep, sz, son, top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LCA(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="keyword">int</span> rt = <span class="number">1</span>) : n(e.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		fa.resize(n);</span><br><span class="line">		dep.resize(n);</span><br><span class="line">		sz.resize(n);</span><br><span class="line">		son.resize(n);</span><br><span class="line">		fa[rt] = rt;</span><br><span class="line">		dep[rt] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			sz[u] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa[u]) &#123;</span><br><span class="line">				dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">				fa[v] = u;</span><br><span class="line">				sz[u] += pdfs(v);</span><br><span class="line">				<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sz[u];</span><br><span class="line">		&#125;;</span><br><span class="line">		top.resize(n);</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> t) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">			top[u] = t;</span><br><span class="line">			<span class="keyword">if</span> (son[u] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">			dfs(son[u], t);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa[u] &amp;&amp; v != son[u]) dfs(v, v);</span><br><span class="line">		&#125;;</span><br><span class="line">		pdfs(rt);</span><br><span class="line">		dfs(rt, rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">				u = fa[top[u]];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				v = fa[top[v]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("C:\\Users\\dna049\\cf\\in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m, rt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; rt;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LCA <span class="title">g</span><span class="params">(e, rt)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g.lca(x, y) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重链剖分求任意两点路径上所有节点的点权和，求子树的点权和（利用-dfs-编号和-sz-直接区间查询或区间修改）"><a href="#重链剖分求任意两点路径上所有节点的点权和，求子树的点权和（利用-dfs-编号和-sz-直接区间查询或区间修改）" class="headerlink" title="重链剖分求任意两点路径上所有节点的点权和，求子树的点权和（利用 dfs 编号和 sz 直接区间查询或区间修改）"></a>重链剖分求任意两点路径上所有节点的点权和，求子树的点权和（利用 dfs 编号和 sz 直接区间查询或区间修改）</h4><p>例题：<a href="https://www.luogu.com.cn/problem/P3384" target="_blank" rel="noopener">LOJ 3384</a>，参考：<a href="https://www.cnblogs.com/chinhhh/p/7965433.html" target="_blank" rel="noopener">ChinHhh’s blog</a>，用加强版树状数组而非线段树算的：<a href="https://www.luogu.com.cn/record/45509401" target="_blank" rel="noopener">提交记录</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line">LL M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeArray</span> &#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; s;</span><br><span class="line">	TreeArray() &#123;&#125;</span><br><span class="line">	TreeArray(<span class="keyword">int</span> n) : s(n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (id &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			(s[id] += p) %= M;</span><br><span class="line">			id += lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (id) &#123;</span><br><span class="line">			(r += s[id]) %= M;</span><br><span class="line">			id -= lowbit(id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeArrayPlus</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// c[i] = a[i] - a[i - 1], b_i = (i - 1) * c_i</span></span><br><span class="line">	TreeArray B, C;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		C.add(id, p);</span><br><span class="line">		B.add(id, (id - <span class="number">1</span>) * p % M);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	TreeArrayPlus() &#123;&#125;</span><br><span class="line">	TreeArrayPlus(<span class="keyword">int</span> _n) : n(_n), B(n), C(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		add(l, p);</span><br><span class="line">		add(r + <span class="number">1</span>, -p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (id * C.sum(id) + M - B.sum(id)) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ((sum(r) - sum(l - <span class="number">1</span>)) % M + M) % M;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HLD</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa, dep, sz, son, top, dfn;</span><br><span class="line">	TreeArrayPlus Tree;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	HLD(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> rt = <span class="number">1</span>) : n(e.<span class="built_in">size</span>()), Tree(n + <span class="number">1</span>) &#123;</span><br><span class="line">		fa.resize(n);</span><br><span class="line">		dep.resize(n);</span><br><span class="line">		sz.resize(n);</span><br><span class="line">		son.resize(n);</span><br><span class="line">		fa[rt] = dep[rt] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			sz[u] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa[u]) &#123;</span><br><span class="line">				dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">				fa[v] = u;</span><br><span class="line">				sz[u] += pdfs(v);</span><br><span class="line">				<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sz[u];</span><br><span class="line">		&#125;;</span><br><span class="line">		top.resize(n);</span><br><span class="line">		dfn.resize(n);</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> t) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">			top[u] = t;</span><br><span class="line">			dfn[u] = ++cnt;</span><br><span class="line">			<span class="keyword">if</span> (son[u] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">			dfs(son[u], t);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa[u] &amp;&amp; v != son[u]) dfs(v, v);</span><br><span class="line">		&#125;;</span><br><span class="line">		pdfs(rt);</span><br><span class="line">		dfs(rt, rt);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) Tree.add(dfn[i], dfn[i], a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// u 到根的最短路径上所有边权值加 c</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (u) &#123;</span><br><span class="line">			Tree.add(dfn[top[u]], dfn[u], c);</span><br><span class="line">			u = fa[top[u]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// u 到根的最短路径上所有边权值之和</span></span><br><span class="line">	<span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (u) &#123;</span><br><span class="line">			r += Tree.sum(dfn[top[u]], dfn[u]);</span><br><span class="line">			u = fa[top[u]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// u, v 的最短路径上所有边权值加 c（可以通过 lca 和根来搞，但是会很慢）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">				Tree.add(dfn[top[u]], dfn[u], c);</span><br><span class="line">				u = fa[top[u]];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				Tree.add(dfn[top[v]], dfn[v], c);</span><br><span class="line">				v = fa[top[v]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dep[u] &lt; dep[v]) &#123;</span><br><span class="line">			Tree.add(dfn[u], dfn[v], c);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Tree.add(dfn[v], dfn[u], c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// u, v 的最短路径上所有边权值之和（可以通过 lca 和根来搞，但是会很慢）</span></span><br><span class="line">	<span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">				r += Tree.sum(dfn[top[u]], dfn[u]);</span><br><span class="line">				u = fa[top[u]];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				r += Tree.sum(dfn[top[v]], dfn[v]);</span><br><span class="line">				v = fa[top[v]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dep[u] &lt; dep[v]) &#123;</span><br><span class="line">			r += Tree.sum(dfn[u], dfn[v]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r += Tree.sum(dfn[v], dfn[u]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addSon</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		Tree.add(dfn[u], dfn[u] + sz[u] - <span class="number">1</span>, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">querySon</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Tree.sum(dfn[u], dfn[u] + sz[u] - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">				u = fa[top[u]];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				v = fa[top[v]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("C:\\Users\\dna049\\cf\\in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m, rt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; rt &gt;&gt; M;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">HLD <span class="title">g</span><span class="params">(e, a, rt)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> op, x, y, z;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">			g.add(x, y, z);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g.query(x, y) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; z;</span><br><span class="line">			g.addSon(x, z);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g.querySon(x) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// auto start = std::clock();</span></span><br><span class="line">	<span class="comment">// std::cout &lt;&lt; "Time used: " &lt;&lt; (std::clock() - start) &lt;&lt; "ms" &lt;&lt; std::endl;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="长链剖分优化-DP，例题：1009F"><a href="#长链剖分优化-DP，例题：1009F" class="headerlink" title="长链剖分优化 DP，例题：1009F"></a>长链剖分优化 DP，例题：<a href="https://codeforces.com/contest/1009/problem/F" target="_blank" rel="noopener">1009F</a></h4><p>这个题显然可以用重链剖分来做，或者说下面的 dsu on tree 来做（$O(n \log n)$），但是<a href="https://codeforces.com/blog/entry/60630" target="_blank" rel="noopener">官方题解</a> 用长链剖分可以优化到 $O(n)$！太强了。主要原因是因为，每个轻儿子节点最多被合并一次（它第一次合并之后，它的信息就被和他同深度的重兄弟节点给吸收了），后面再合并的时候就不算它被合并而算当前重儿子节点的合并了（妙不可言）。但是父节点占据儿子节点的时候有个问题就是用 std::map 或 std::unordered_map 本质上都会带一个 log，因此我们需要用 vector 保存信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始。</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dsuOnTree</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 预处理出重儿子</span></span><br><span class="line">	std::vector&lt;int&gt; sz(n), son(n);</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			pdfs(v, u);</span><br><span class="line">			<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		sz[u] = sz[son[u]] + <span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> (son[u] == <span class="number">0</span>) &#123;</span><br><span class="line">			ans[u] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> a = dfs(son[u], u);</span><br><span class="line">		ans[u] = ans[son[u]];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			<span class="keyword">auto</span> tmp = dfs(v, u);</span><br><span class="line">			<span class="comment">// 这里需要对齐</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> ai = a.<span class="built_in">size</span>() - <span class="number">1</span>, ti = tmp.<span class="built_in">size</span>() - <span class="number">1</span>; ti &gt;= <span class="number">0</span>; --ti, --ai) &#123;</span><br><span class="line">				a[ai] += tmp[ti];</span><br><span class="line">				<span class="keyword">if</span> (a[ai] &gt; a[ans[u]] || (a[ai] == a[ans[u]] &amp;&amp; ai &gt; ans[u])) &#123;</span><br><span class="line">					ans[u] = ai;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		a.emplace_back(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (a[ans[u]] == <span class="number">1</span>) ans[u] = sz[u] - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;;</span><br><span class="line">	pdfs(rt, <span class="number">0</span>);</span><br><span class="line">	dfs(rt, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) ans[i] = sz[i] - <span class="number">1</span> - ans[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> r = dsuOnTree(e);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; r[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树上启发式算法（dsu-on-tree）"><a href="#树上启发式算法（dsu-on-tree）" class="headerlink" title="树上启发式算法（dsu on tree）"></a><a href="https://oi-wiki.org/graph/dsu-on-tree/" target="_blank" rel="noopener">树上启发式算法（dsu on tree）</a></h3><p>先处理轻儿子，但是不保留影响，再处理重儿子保留，再暴力处理所有其它情况，再看次节点是否需要保留。</p>
<p>复杂度分析真的太妙了！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了代码简洁，树的编号以 1 开始，参考：https://www.cnblogs.com/zwfymqz/p/9683124.html</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">dsuOnTree</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 预处理出重儿子</span></span><br><span class="line">	std::vector&lt;int&gt; sz(n), son(n), cnt(n);</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; pdfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">		sz[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">			sz[u] += pdfs(v, u);</span><br><span class="line">			<span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sz[u];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 这个函数具体问题具体分析</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> mx = <span class="number">0</span>, Son = <span class="number">0</span>;</span><br><span class="line">	LL sm = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; deal = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		++cnt[a[u]];</span><br><span class="line">		<span class="keyword">if</span> (cnt[a[u]] &gt; mx) &#123;</span><br><span class="line">			mx = cnt[a[u]];</span><br><span class="line">			sm = a[u];</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt[a[u]] == mx) &#123;</span><br><span class="line">			sm += a[u];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; v != Son) &#123;</span><br><span class="line">			deal(v, u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; del = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		--cnt[a[u]];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa) del(v, u);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">bool</span> save) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa &amp;&amp; v != son[u]) &#123;</span><br><span class="line">			dfs(v, u, <span class="number">0</span>); <span class="comment">// 先计算轻边贡献，但最终要消除影响，防止轻边互相干扰</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>);  <span class="comment">// 统计重儿子的贡献，但不消除影响</span></span><br><span class="line">		Son = son[u];</span><br><span class="line">		deal(u, fa); <span class="comment">// 暴力处理除重儿子外的贡献</span></span><br><span class="line">		Son = <span class="number">0</span>;</span><br><span class="line">		ans[u] = sm;</span><br><span class="line">		<span class="keyword">if</span> (!save) &#123;</span><br><span class="line">			del(u, fa);</span><br><span class="line">			sm = <span class="number">0</span>;</span><br><span class="line">			mx = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	pdfs(rt, rt);</span><br><span class="line">	dfs(rt, rt, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思想是这样的，到时候具体问题灵活运用，不必死套模板，例如 <a href="https://codeforces.com/gym/102832/problem/F" target="_blank" rel="noopener">gym 102832F</a> 我的另样做法 <a href="https://codeforces.com/gym/102832/submission/105273241" target="_blank" rel="noopener">submission 105273241</a> 更加优秀，快速。</p>
</blockquote>
<h2 id="树上问题"><a href="#树上问题" class="headerlink" title="树上问题"></a>树上问题</h2><h3 id="树的直径：先从任意点开始寻找最远距离点（bfs-遍历一下），然后再找一次就是了（易证）"><a href="#树的直径：先从任意点开始寻找最远距离点（bfs-遍历一下），然后再找一次就是了（易证）" class="headerlink" title="树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）"></a>树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）</h3><p>例题：<a href="https://codeforces.com/contest/1405/problem/D" target="_blank" rel="noopener">1405D</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> bfs = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	d[x] = <span class="number">0</span>;</span><br><span class="line">	Q.push(x);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (d[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">			d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">			Q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::max_element(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>()) - d.<span class="built_in">begin</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="树的中心-：所有点到该点的最大值最小（直径的中点）"><a href="#树的中心-：所有点到该点的最大值最小（直径的中点）" class="headerlink" title="[树的中心]：所有点到该点的最大值最小（直径的中点）"></a>[树的中心]：所有点到该点的最大值最小（直径的中点）</h3><h3 id="树的重心：去掉这个点后连通分支的节点数量的最大值最小"><a href="#树的重心：去掉这个点后连通分支的节点数量的最大值最小" class="headerlink" title="树的重心：去掉这个点后连通分支的节点数量的最大值最小"></a><a href="https://oi-wiki.org/graph/tree-centroid/" target="_blank" rel="noopener">树的重心</a>：去掉这个点后连通分支的节点数量的最大值最小</h3><p>根据 DFS 子树的大小和“向上”的子树大小就可以知道所有子树中最大的子树节点数。：<a href="https://codeforces.com/contest/1406/problem/C" target="_blank" rel="noopener">例题 1406C</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中 e 表示树的边，n 为数的数量</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; degree = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">	d[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (d[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">		d[u] += degree(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[u];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> barycenter = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">int</span> cnt = degree(x);</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n, n)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(x);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		w[u] = cnt - d[u];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (w[v] == n) &#123;</span><br><span class="line">			w[u] = <span class="built_in">std</span>::<span class="built_in">max</span>(w[u], d[v]);</span><br><span class="line">			Q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="built_in">std</span>::min_element(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>()) - w.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::make_pair(r, w[r]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最近公共祖先简称-LCA（Lowest-Common-Ancestor）"><a href="#最近公共祖先简称-LCA（Lowest-Common-Ancestor）" class="headerlink" title="最近公共祖先简称 LCA（Lowest Common Ancestor）"></a>最近公共祖先简称 LCA（Lowest Common Ancestor）</h3><ul>
<li>策略 1：其中一个节点一直往上标记父辈到根，然后另一个节点往上找父辈，直到找到首次被标记过的节点</li>
<li>策略 2：标记没个节点的深度，深度高的往上到同一层，然后一起一步步上去，直到是公共节点</li>
<li>策略 3：做一次 DFS 得到 Euler 序列，然后就变成找区间最小值问题了（可以使用线段树）</li>
<li>策略 4：树链剖分（见下面做法，目前我的做法）</li>
<li>其他：倍增（记录 <code>fa[u][i]</code>：表示 <code>u</code> 的第$2^i$祖先），Tarjan 算法，动态树<br><a href="https://oi-wiki.org/graph/lca/" target="_blank" rel="noopener">OI-wiki</a> 给了很多做法，竟然有标准 $O(N)$ 时空复杂度的 RMQ 做法还支持在线，太强了，太强了，mark 一下，有模板，但是并不想学。</li>
</ul>
<h3 id="有向无环图的拓扑排序之-Kahn-算法"><a href="#有向无环图的拓扑排序之-Kahn-算法" class="headerlink" title="有向无环图的拓扑排序之 Kahn 算法"></a><a href="https://oi-wiki.org/graph/topo/" target="_blank" rel="noopener">有向无环图的拓扑排序之 Kahn 算法</a></h3><p>给定有向图，然后把节点按照顺序排列，使得任意有向边的起点在终点前。</p>
<p>做法：维护一个入度为 0 的节点队列，丢出队列时它连接的所有点入度减 1，为 0 就加入节点集合。</p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/U107394" target="_blank" rel="noopener">LOJ U107394</a>。</p>
<blockquote>
<p>一个有向图是无环图，当且仅当它存在拓扑排序（有重边就用 set 存边自动去重，否则直接用 vector 即可）。</p>
</blockquote>
<h3 id="无向图的-Euler-路-的-Hierholzer-算法"><a href="#无向图的-Euler-路-的-Hierholzer-算法" class="headerlink" title="无向图的 Euler 路 的 Hierholzer 算法"></a>无向图的 Euler 路 的 Hierholzer 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求字典序最小的 Euler 路，没有的话输出 空（允许重边，不允许就修改成 set）</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">EulerPathS</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&gt; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="built_in">std</span>::count_if(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> x) &#123;</span><br><span class="line">		<span class="keyword">return</span> x.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">if</span> (cnt &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; Hierholzer = [&amp;](<span class="keyword">int</span> u) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!e[u].empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = *e[u].<span class="built_in">begin</span>();</span><br><span class="line">			e[u].erase(e[u].<span class="built_in">begin</span>());</span><br><span class="line">			e[v].erase(e[v].<span class="built_in">find</span>(u));</span><br><span class="line">			Hierholzer(v);</span><br><span class="line">		&#125;</span><br><span class="line">		ans.push(u);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!e[i].empty() &amp;&amp; ((e[i].<span class="built_in">size</span>() &amp; <span class="number">1</span>) || (cnt == <span class="number">0</span>))) &#123;</span><br><span class="line">			Hierholzer(i);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求 rt 开头的字典序 Euler 路（保证存在且不允许重边，允许重边就修改成 multiset 即可）</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">EulerPath</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; e, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; Hierholzer = [&amp;](<span class="keyword">int</span> u) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!e[u].empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = *e[u].<span class="built_in">begin</span>();</span><br><span class="line">			e[u].erase(e[u].<span class="built_in">begin</span>());</span><br><span class="line">			e[v].erase(e[v].<span class="built_in">find</span>(u));</span><br><span class="line">			Hierholzer(v);</span><br><span class="line">		&#125;</span><br><span class="line">		ans.push(u);</span><br><span class="line">	&#125;;</span><br><span class="line">	Hierholzer(rt);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有向图的-Hamiltonian-路的启发式算法"><a href="#有向图的-Hamiltonian-路的启发式算法" class="headerlink" title="有向图的 Hamiltonian 路的启发式算法"></a><a href="https://codeforces.com/blog/entry/90513" target="_blank" rel="noopener">有向图的 Hamiltonian 路的启发式算法</a></h3><h3 id="笛卡尔树-：我去，竟然是-O-n-复杂度的建树（弃用没必要直接学单调栈即可）"><a href="#笛卡尔树-：我去，竟然是-O-n-复杂度的建树（弃用没必要直接学单调栈即可）" class="headerlink" title="笛卡尔树 ：我去，竟然是 $O(n)$ 复杂度的建树（弃用没必要直接学单调栈即可）"></a><a href="https://oi-wiki.org/ds/cartesian-tree/" target="_blank" rel="noopener">笛卡尔树</a> ：我去，竟然是 $O(n)$ 复杂度的建树（弃用没必要直接学单调栈即可）</h3><blockquote>
<p>从<a href="https://oi-wiki.org/ds/cartesian-tree/" target="_blank" rel="noopener">OI - wiki</a> 中看到的讲解和复杂度分析!，注意到右链是从尾巴往上查找的。<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506" target="_blank" rel="noopener"><strong>hdu 1506</strong></a><br>这就给出了一个 $O(n)$ 复杂度求出包含 <code>i</code>且以 <code>a[i]</code> 为最大值的区间的方法（最小值保存的时候取负数即可），太强了！<br>求上述对应的最大值区间，需要修改 0 节点的值，以及 build 的大于号改成小于号。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="meta-string">" is "</span> &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id, val, par, ch[<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _id, <span class="keyword">int</span> _val, <span class="keyword">int</span> _par)</span> </span>&#123;</span><br><span class="line">		id = _id, val = _val, par = _par, ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cartesian_build</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; &amp;tree, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (tree[k].val &lt; tree[i].val) k = tree[k].par;</span><br><span class="line">		tree[i].ch[<span class="number">0</span>] = tree[k].ch[<span class="number">1</span>];</span><br><span class="line">		tree[k].ch[<span class="number">1</span>] = i;</span><br><span class="line">		tree[i].par = k;</span><br><span class="line">		tree[tree[i].ch[<span class="number">0</span>]].par = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tree[<span class="number">0</span>].ch[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; <span class="title">tree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">		tree[<span class="number">0</span>].init(<span class="number">0</span>, INT_MAX, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			tree[i].init(i, x, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> root = cartesian_build(tree, n);</span><br><span class="line">		LL ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> sz = dfs(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">			sz += dfs(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">			ans = <span class="built_in">std</span>::<span class="built_in">max</span>(ans, LL(sz + <span class="number">1</span>) * tree[x].val);</span><br><span class="line">			<span class="keyword">return</span> sz + <span class="number">1</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		dfs(root);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 下面是求以 a[i] 为最大值且包含 i 的最大区间</span></span><br><span class="line">		std::vector&lt;int&gt; l(n + 1), r(n + 1);</span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; getinterval = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (tree[tree[x].par].ch[<span class="number">0</span>] == x) &#123;</span><br><span class="line">				r[x] = tree[x].par - <span class="number">1</span>;</span><br><span class="line">				l[x] = l[tree[x].par];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l[x] = tree[x].par + <span class="number">1</span>;</span><br><span class="line">				r[x] = r[tree[x].par];</span><br><span class="line">			&#125;</span><br><span class="line">			getinterval(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">			getinterval(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">		&#125;;</span><br><span class="line">		l[root] = <span class="number">1</span>;</span><br><span class="line">		r[root] = n;</span><br><span class="line">		getinterval(tree[root].ch[<span class="number">0</span>]);</span><br><span class="line">		getinterval(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">		<span class="comment">// 要考虑有相同值的情形，必须要分两次搞，不然有bug</span></span><br><span class="line">		<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; updateinterval = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (tree[tree[x].par].ch[<span class="number">0</span>] == x) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tree[x].val == tree[tree[x].par].val) r[x] = r[tree[x].par];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (tree[x].val == tree[tree[x].par].val) l[x] = l[tree[x].par];</span><br><span class="line">			&#125;</span><br><span class="line">			updateinterval(tree[x].ch[<span class="number">0</span>]);</span><br><span class="line">			updateinterval(tree[x].ch[<span class="number">1</span>]);</span><br><span class="line">		&#125;;</span><br><span class="line">		updateinterval(tree[root].ch[<span class="number">0</span>]);</span><br><span class="line">		updateinterval(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; l[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; r[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>洛谷 T126268 「SWTR-05」Subsequence 有一个典型的应用</p>
</blockquote>
<h3 id="最小生成树-prim-算法"><a href="#最小生成树-prim-算法" class="headerlink" title="最小生成树 prim 算法"></a>最小生成树 prim 算法</h3><p>任取一个节点，然后开始找相邻边中边最小的节点加入，然后继续。<a href="https://baike.baidu.com/item/Prim/10242166" target="_blank" rel="noopener">百度百科</a>里的图解一看就懂，怎么明确证明正确性呢？（在保证连通的前提下每次删除图中最大的边，不会影响最终结果，而我们每步得到的是当前节点构成的子图的最小生成树）当然了堆优化常规操作，另外不连通输出 <code>INT64_MAX</code>, 例题：<a href="https://www.luogu.com.cn/problem/P3366" target="_blank" rel="noopener">LOJ3366</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function">LL <span class="title">Prim</span><span class="params">(<span class="keyword">const</span> edge &amp;e)</span> </span>&#123;</span><br><span class="line">	LL r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">	Q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [w, u] = Q.top();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		++cnt;</span><br><span class="line">		r -= w;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : e[u]) <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">			Q.push(&#123;-c, v&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt == n ? r : INT64_MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小树形图的-O-nm-刘朱算法"><a href="#最小树形图的-O-nm-刘朱算法" class="headerlink" title="最小树形图的 $O(nm)$ 刘朱算法"></a>最小树形图的 $O(nm)$ <a href="https://www.luogu.com.cn/blog/i207M/shu-xing-tu-shu-liu-suan-fa-xue-xi-bi-ji-xie-ti-bao-gao-p4716-post" target="_blank" rel="noopener">刘朱算法</a></h3><ol>
<li>对每个点，找入边权值最小的边构成集合。</li>
<li>如果这些边构成有向环，缩点后进入 1，否则结束，找到了。</li>
</ol>
<p>例题：<a href="https://www.luogu.com.cn/problem/P4716" target="_blank" rel="noopener">LOJ4716</a></p>
<p><strong>问题变形</strong>：如果不指定根节点，那么可以建一个根节点，然后它和所有其它点连特别大的边即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Edge = <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function">LL <span class="title">LiuZhu</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; e, <span class="keyword">int</span> n, <span class="keyword">int</span> rt)</span> </span>&#123; <span class="comment">// e 中无自环</span></span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 寻找入边权值最小的边</span></span><br><span class="line">		std::vector&lt;int&gt; in(n, INT_MAX), pre(n, -1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [u, v, w] : e) <span class="keyword">if</span> (u != v &amp;&amp; in[v] &gt; w) &#123;</span><br><span class="line">			in[v] = w;</span><br><span class="line">			pre[v] = u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判定是否无解</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i != rt &amp;&amp; pre[i] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判定是否有环</span></span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		std::vector&lt;int&gt; vis(n, -1), id(n, -1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i != rt) &#123;</span><br><span class="line">			ans += in[i];</span><br><span class="line">			<span class="keyword">int</span> v = i;</span><br><span class="line">			<span class="comment">// 注意到可能出现 6 型的路径，所以两个指标很必要</span></span><br><span class="line">			<span class="keyword">while</span> (vis[v] != i &amp;&amp; id[v] == <span class="number">-1</span> &amp;&amp; v != rt) &#123;</span><br><span class="line">				vis[v] = i;</span><br><span class="line">				v = pre[v];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (id[v] == <span class="number">-1</span> &amp;&amp; v != rt) &#123;</span><br><span class="line">				<span class="keyword">int</span> u = v;</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					id[u] = cnt;</span><br><span class="line">					u = pre[u];</span><br><span class="line">				&#125; <span class="keyword">while</span> (u != v);</span><br><span class="line">				++cnt;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 更新节点和边，也可以重开一个 vector，然后 swap 一下</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (id[i] == <span class="number">-1</span>) id[i] = cnt++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v, w] : e) &#123;</span><br><span class="line">			<span class="keyword">if</span> (id[u] != id[v]) w -= in[v];</span><br><span class="line">			u = id[u];</span><br><span class="line">			v = id[v];</span><br><span class="line">		&#125;</span><br><span class="line">		rt = id[rt];</span><br><span class="line">		n = cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="知乎上看到-YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）"><a href="#知乎上看到-YYYYLLL-关于-Floyd-算法的解释挺好的，再次记录-稍加修改）" class="headerlink" title="知乎上看到 YYYYLLL 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）"></a>知乎上看到 <a href="https://www.zhihu.com/people/yyyylll-37" target="_blank" rel="noopener">YYYYLLL</a> 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">j</span>] 表示只经过 1～k 号节点优化，i 点到 j 点的最短路径长度。</span><br><span class="line">则 DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">j</span>] = min( DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">j</span>], DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">k</span>]+DP[<span class="string">k-1</span>][<span class="symbol">k</span>][<span class="string">j</span>] ) </span><br><span class="line">= min( DP[<span class="string">k-1</span>][<span class="symbol">i</span>][<span class="string">j</span>], DP[<span class="string">k</span>][<span class="symbol">i</span>][<span class="string">k</span>]+DP[<span class="string">k</span>][<span class="symbol">k</span>][<span class="string">j</span>] ) </span><br><span class="line">DP[<span class="string">0</span>][<span class="symbol"></span>][<span class="string"></span>] 是初始图的邻接矩阵，DP[<span class="string">n</span>][<span class="symbol"></span>][<span class="string"></span>] 就是最终求得的最短路长度矩阵了</span><br></pre></td></tr></table></figure>
<p>本来一开始是没法做空间优化的， 但是第二个等式， 就保证了可以做空间优化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1003</span>;</span><br><span class="line">LL dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> cmin = [](<span class="keyword">auto</span> &amp;x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; y) x = y;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != n; ++k)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j != n; ++j)</span><br><span class="line">				cmin(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd-带路径-—-未测试"><a href="#Floyd-带路径-—-未测试" class="headerlink" title="Floyd 带路径 —- 未测试"></a>Floyd 带路径 —- 未测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1003</span>;</span><br><span class="line">LL dp[N][N], path[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(path, <span class="number">-1</span>, <span class="keyword">sizeof</span>(path));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != n; ++k)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j != n; ++j) <span class="keyword">if</span> (dp[i][j] &gt; dp[i][k] + dp[k][j]) &#123;</span><br><span class="line">				path[i][j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path[x][y] == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;x&#125;;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;x, y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> left = getPath(x, path[x][y]);</span><br><span class="line">	<span class="keyword">auto</span> now = getPath(path[x][y], y);</span><br><span class="line">	left.insert(left.<span class="built_in">end</span>(), now.<span class="built_in">begin</span>(), now.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Floyd 算法其它用途：</p>
<ul>
<li>找最小环（至少三个节点）考虑环上最大节点 $u$，$f[u - 1][x][y]$ 和 $(y, u), (u, x)$ 构成最小环（值小于 INF 才是真的有环）</li>
<li>传递闭包：跟最短路完全类似，只是这里加法改成 或运算，可用 bitset 优化成 $O(\frac{n^3}{w})$，其中 $w = 32, 64$。<h3 id="堆优化-Dijkstra"><a href="#堆优化-Dijkstra" class="headerlink" title="堆优化 Dijkstra"></a>堆优化 Dijkstra</h3></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> edge &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;LL, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">d</span><span class="params">(e.<span class="built_in">size</span>(), INT64_MAX)</span></span>;</span><br><span class="line">	d[s] = <span class="number">0</span>;</span><br><span class="line">	Q.push(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [du, u] = Q.top();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">if</span> (d[u] != -du) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : e[u]) <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">			d[v] = d[u] + w;</span><br><span class="line">			Q.emplace(-d[v], v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆优化-Dijkstra-弃用"><a href="#堆优化-Dijkstra-弃用" class="headerlink" title="堆优化 Dijkstra (弃用)"></a>堆优化 Dijkstra (弃用)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> edge &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;LL, <span class="keyword">int</span>&gt;&gt; h;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; <span class="title">dist</span><span class="params">(e.<span class="built_in">size</span>(), INT64_MAX)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(e.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">	dist[s] = <span class="number">0</span>;</span><br><span class="line">	h.push(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!h.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [d, u] = h.top();</span><br><span class="line">		h.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		dist[u] = -d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : e[u]) h.emplace(d - w, v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(edge &amp;e, <span class="keyword">int</span> n, <span class="keyword">int</span> x = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">	dist[x] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">bool</span> judge = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [u, v, w] : e) <span class="keyword">if</span> (dist[u] != INT_MAX) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dist[v] &gt; dist[u] + w) &#123;</span><br><span class="line">				dist[v] = dist[u] + w;</span><br><span class="line">				judge = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!judge) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> edge = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(edge &amp;e, <span class="keyword">int</span> x = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	std::vector&lt;int&gt; dist(n, INT_MAX), cnt(n), inQ(n);</span><br><span class="line">	Q.push(x);</span><br><span class="line">	inQ[x] = <span class="number">1</span>;</span><br><span class="line">	dist[x] = <span class="number">0</span>;</span><br><span class="line">	++cnt[x];</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		inQ[u] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [v, w]: e[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dist[v] &gt; dist[u] + w) &#123;</span><br><span class="line">				dist[v] = dist[u] + w;</span><br><span class="line">				<span class="keyword">if</span> (!inQ[v]) &#123;</span><br><span class="line">					Q.push(v);</span><br><span class="line">					inQ[v] = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (++cnt[v] == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无向图染色问题"><a href="#无向图染色问题" class="headerlink" title="无向图染色问题"></a>无向图染色问题</h2><h3 id="2-color"><a href="#2-color" class="headerlink" title="2-color"></a>2-color</h3><blockquote>
<p>仅用两种颜色给无向图染色，使得相邻节点不同色，每个连通块考虑即可，每个连通块要么是 2，要么是 0（判断依据有无奇圈）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LL M = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// 图以 0 开始编号</span></span><br><span class="line"><span class="function">LL <span class="title">color2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">val</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> bfs = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		Q.push(x);</span><br><span class="line">		val[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (val[v]) &#123;</span><br><span class="line">					<span class="keyword">if</span> (val[v] != -val[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					val[v] = -val[u];</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	LL r = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (val[i] == <span class="number">0</span>) &#123;</span><br><span class="line">		r = r * bfs(i) % M;</span><br><span class="line">		<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Chromatic-Polynomial"><a href="#The-Chromatic-Polynomial" class="headerlink" title="The Chromatic Polynomial"></a><a href="https://www.whitman.edu/mathematics/cgt_online/book/section05.09.html" target="_blank" rel="noopener">The Chromatic Polynomial</a></h3><blockquote>
<p>对于一般的 $n$-color 问题对应的 <a href="https://www.whitman.edu/mathematics/cgt_online/book/section05.09.html" target="_blank" rel="noopener">The Chromatic Polynomial</a> 可在书 <a href="https://www.whitman.edu/mathematics/cgt_online/book/" target="_blank" rel="noopener">Combinatorics and Graph Theory</a> 中找到。思想就是破圈和缩点的做法。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> BINT = boost::multiprecision::cpp_int;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chromaticPoly of a tree with n node</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">chromaticPoly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">r</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	BINT now&#123;n % <span class="number">2</span> == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		r[i + <span class="number">1</span>] = now;</span><br><span class="line">		now = -now * (n - <span class="number">1</span> - i) / (i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">colorConnect</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	std::vector&lt;bool&gt; v1(n), v2(n);</span><br><span class="line">	<span class="keyword">auto</span> r = chromaticPoly(n); <span class="comment">// 可以先预处理出来</span></span><br><span class="line">	<span class="keyword">auto</span> subtract = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; &amp;a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; b) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != b.<span class="built_in">size</span>(); ++i) a[i] -= b[i];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(<span class="number">0</span>);</span><br><span class="line">	v1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> enow = e;</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		v2[u] = <span class="number">1</span>;</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!v2[v]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v1[v]) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; ed;</span><br><span class="line">				<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, now = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">					<span class="keyword">if</span> (i != u &amp;&amp; i != v) &#123;</span><br><span class="line">						p[i] = now++;</span><br><span class="line">					&#125; <span class="keyword">else</span> p[i] = n - <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i != u &amp;&amp; i != v) &#123;</span><br><span class="line">					<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">auto</span> x : enow[i]) tmp.insert(p[x]);</span><br><span class="line">					ed.emplace_back(tmp);</span><br><span class="line">				&#125;</span><br><span class="line">				enow[u].erase(v);</span><br><span class="line">				enow[v].erase(u);</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> x : enow[u]) tmp.insert(p[x]);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> x : enow[v]) tmp.insert(p[x]);</span><br><span class="line">				ed.emplace_back(tmp);</span><br><span class="line">				subtract(r, colorConnect(ed));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				Q.push(v);</span><br><span class="line">				v1[v] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		e = enow;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">color</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> <span class="built_in">connect</span> = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visc(n);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		Q.push(x);</span><br><span class="line">		visc[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!visc[v]) &#123;</span><br><span class="line">				visc[v] = <span class="number">1</span>;</span><br><span class="line">				Q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, now = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (visc[i]) &#123;</span><br><span class="line">			p[i] = now++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; ec;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (visc[i]) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> x : e[i]) tmp.insert(p[x]);</span><br><span class="line">			ec.emplace_back(tmp);</span><br><span class="line">			vis[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ec;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">auto</span> mul = [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; &amp;a, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; b) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; c(a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != b.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">				c[i + j] += a[i] * b[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BINT&gt; <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">		r = mul(r, colorConnect(<span class="built_in">connect</span>(i)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">	<span class="keyword">while</span> (cas--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">e</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">			<span class="keyword">int</span> u, v;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			--u; --v;</span><br><span class="line">			e[u].insert(v);</span><br><span class="line">			e[v].insert(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : color(e)) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连通性问题"><a href="#连通性问题" class="headerlink" title="连通性问题"></a>连通性问题</h2><h3 id="Kosaraju-缩点算法"><a href="#Kosaraju-缩点算法" class="headerlink" title="Kosaraju 缩点算法"></a>Kosaraju 缩点算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Scc</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, nScc;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis, color, order;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; e, e2;</span><br><span class="line">	Scc(<span class="keyword">int</span> _n) : n(_n * <span class="number">2</span>) &#123;</span><br><span class="line">		nScc = <span class="number">0</span>;</span><br><span class="line">		e.resize(n);</span><br><span class="line">		e2.resize(n);</span><br><span class="line">		vis.resize(n);</span><br><span class="line">		color.resize(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e2[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!vis[v]) dfs(v);</span><br><span class="line">		order.emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		color[u] = nScc;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e2[u]) <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!vis[i]) dfs(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = order.rbegin(); it != order.rend(); ++it) <span class="keyword">if</span> (!color[*it]) &#123;</span><br><span class="line">			++nScc;</span><br><span class="line">			dfs2(*it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h3><p>Kosaraju 算法通过两次 dfs，给强连通分量进行染色，染色数就是强联通分量数，最后缩点后得到的就是一个有向无环图(DAG)，如果有相邻（仅取一个）节点在同一个强连通分量中，那么显然不存在解，否则我们取颜色编号大的连通分量（一定有解！）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n / 2 对 (2i, 2i + 1)，每对选出一个元素，使得无矛盾</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twoSAT</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, nScc;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis, color, order;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; e, e2;</span><br><span class="line">	twoSAT(<span class="keyword">int</span> _n) : n(_n * <span class="number">2</span>) &#123;</span><br><span class="line">		nScc = <span class="number">0</span>;</span><br><span class="line">		e.resize(n);</span><br><span class="line">		e2.resize(n);</span><br><span class="line">		vis.resize(n);</span><br><span class="line">		color.resize(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		e[u].emplace_back(v);</span><br><span class="line">		e2[v].emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (!vis[v]) dfs(v);</span><br><span class="line">		order.emplace_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		color[u] = nScc;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e2[u]) <span class="keyword">if</span> (!color[v]) dfs2(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!vis[i]) dfs(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = order.rbegin(); it != order.rend(); ++it) <span class="keyword">if</span> (!color[*it]) &#123;</span><br><span class="line">			++nScc;</span><br><span class="line">			dfs2(*it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Kosaraju();</span><br><span class="line">		<span class="comment">// 选择颜色编号大的强连通分量</span></span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">choose</span><span class="params">(nScc + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> c1 = color[i], c2 = color[i + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (c1 == c2) <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">			<span class="keyword">if</span> (choose[c1] || choose[c2]) <span class="keyword">continue</span>;</span><br><span class="line">			choose[<span class="built_in">std</span>::<span class="built_in">max</span>(c1, c2)] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(n / <span class="number">2</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * <span class="number">2</span> &lt; n; ++i) r[i] = (choose[color[i * <span class="number">2</span>]] ? <span class="number">1</span> : <span class="number">-1</span>); </span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此内容包含 <a href="https://oi-wiki.org/graph/scc/" target="_blank" rel="noopener">强连通分量</a>，采用其中的 Kosaraju 算法缩点。参考 <a href="https://oi-wiki.org/graph/2-sat/" target="_blank" rel="noopener">OI-wiki</a> 和 <a href="https://wenku.baidu.com/view/31fd7200bed5b9f3f90f1ce2.html" target="_blank" rel="noopener">百度文库</a>。<a href="https://codeforces.com/contest/1239/problem/D" target="_blank" rel="noopener">例题 1</a>：<a href="https://codeforces.com/contest/1239/submission/98425115" target="_blank" rel="noopener">答案</a>，<a href="https://codeforces.com/gym/101987" target="_blank" rel="noopener">例题 2: K-TV Show Game</a>：<a href="https://codeforces.com/gym/101987/submission/98427737" target="_blank" rel="noopener">答案</a>，有些特殊的 2-SAT 可以用奇偶性解决，例如: <a href="https://codeforces.com/contest/1438/problem/C" target="_blank" rel="noopener">1438C</a></p>
</blockquote>
<p><a href="https://oi-wiki.org/graph/cut/" target="_blank" rel="noopener">OI-wiki 割点割边讲解</a></p>
<h3 id="割点（无向图中删除该点使得连通分量数量增多的节点）"><a href="#割点（无向图中删除该点使得连通分量数量增多的节点）" class="headerlink" title="割点（无向图中删除该点使得连通分量数量增多的节点）"></a>割点（无向图中删除该点使得连通分量数量增多的节点）</h3><p>首先 dfs 序给出每个节点的编号记作 <code>dfs[i]</code>，再来一个数组 low，表示不经过父节点能够到达的编号最小的点。显然如果至少有一个儿子满足的 low 值不超过它的 dfs 值，那么此节点就是割点（但是根节点除外，根节点始终满足，如果根节点有大于一个真儿子，那么必然是割点）。不难看出这是割点的冲要条件，因此问题就转化成求 dfs 和 low 了。</p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/P3388" target="_blank" rel="noopener">LOJ3388</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cutVertex</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = e.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">	std::vector&lt;int&gt; dfs(n), low(n), flag(n), r;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; Tarjan = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> fa) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">		low[u] = dfs[u] = ++cnt;</span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dfs[v] == <span class="number">0</span>) &#123;</span><br><span class="line">				++ch;</span><br><span class="line">				Tarjan(v, u);</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">				<span class="keyword">if</span> (u != fa &amp;&amp; low[v] &gt;= dfs[u]) flag[u] = <span class="number">1</span>; </span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], dfs[v]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (u == fa &amp;&amp; ch &gt; <span class="number">1</span>) flag[u] = <span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (dfs[i] == <span class="number">0</span>) Tarjan(i, i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (flag[i]) r.emplace_back(i);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="割边（无向图中删除该边使得连通分量数量增多的边）"><a href="#割边（无向图中删除该边使得连通分量数量增多的边）" class="headerlink" title="割边（无向图中删除该边使得连通分量数量增多的边）"></a>割边（无向图中删除该边使得连通分量数量增多的边）</h3><p>与割点处理同理，只是不用特判根节点。注意到做一次 dfs 后，—<strong>不在 dfs 路径上的边不可能为割边</strong>！但是为了处理重边的情况，没办法只能用 vector 版链式前向星存边了。</p>
<p>模板例题：<a href="https://www.luogu.com.cn/problem/T103481" target="_blank" rel="noopener">LOJ T103481</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CutEdge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, cnt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e, flag, dfs, low;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> inEdgeNum)</span> </span>&#123;</span><br><span class="line">		low[u] = dfs[u] = ++cnt;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i];</span><br><span class="line">			<span class="keyword">if</span> (dfs[v] == <span class="number">0</span>) &#123;</span><br><span class="line">				Tarjan(v, i);</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">				<span class="keyword">if</span> (low[v] &gt; dfs[u]) flag[i] = flag[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((i ^ <span class="number">1</span>) != inEdgeNum) &#123;</span><br><span class="line">				low[u] = <span class="built_in">std</span>::<span class="built_in">min</span>(low[u], dfs[v]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CutEdge(<span class="keyword">int</span> _n) : n(_n), g(_n), dfs(n), low(n), cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v);</span><br><span class="line">		flag.emplace_back(<span class="number">0</span>);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u);</span><br><span class="line">		flag.emplace_back(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (dfs[i] == <span class="number">0</span>) Tarjan(i, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : flag) r += x;</span><br><span class="line">		<span class="keyword">return</span> r / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="图的匹配算法"><a href="#图的匹配算法" class="headerlink" title="图的匹配算法"></a><a href="https://oi-wiki.org/topic/graph-matching/graph-match/" target="_blank" rel="noopener">图的匹配算法</a></h2><p>OI-wiki 上有专题专门讲这个的，分最大匹配和最大权匹配，对于特殊的图（例如二分图）有<a href="https://oi-wiki.org/topic/graph-matching/bigraph-match/" target="_blank" rel="noopener">特殊的算法</a>，例如可以增加源点和汇点转化成网络流问题，用下面 Dinic 算法在 $O(\sqrt{n} m)$ 解决。</p>
<blockquote>
<p>其中一般图的最大匹配可以参考 <a href="https://uoj.ac/submission/221981" target="_blank" rel="noopener">Min_25 的模板</a></p>
</blockquote>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="有向图-S-T-最大流-Dinic-算法-O-n-2-m-（对偶问题：S-T-最大流等于-S-T-最小割）"><a href="#有向图-S-T-最大流-Dinic-算法-O-n-2-m-（对偶问题：S-T-最大流等于-S-T-最小割）" class="headerlink" title="有向图 S-T 最大流 Dinic 算法 $O(n^2 m)$（对偶问题：S-T 最大流等于 S-T 最小割）"></a>有向图 S-T 最大流 Dinic 算法 $O(n^2 m)$（对偶问题：S-T 最大流等于 S-T 最小割）</h3><p>参考资料：<a href="https://oi-wiki.org/graph/flow/max-flow/" target="_blank" rel="noopener">OI-wiki</a> 和 <a href="https://www.cnblogs.com/owenyu/p/6852664.html" target="_blank" rel="noopener">最大流算法-ISAP</a>，<a href="https://blog.csdn.net/lym940928/article/details/90209172?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">需要反向边的原因的例子说明</a>，下面代码借鉴于 jiangly。注意代码本质上是支持动态更新的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur, h;</span><br><span class="line">	<span class="comment">// h[i] 表示 bfs 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路。</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		h.assign(n, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		h[s] = <span class="number">0</span>;</span><br><span class="line">		Q.push(s);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">					h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] != <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// f 表示从 u 点出发拥有的最大流量，输出的是 u 到 t 的最大流量</span></span><br><span class="line">	<span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, LL f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t || f == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">		LL r = f;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i &lt; g[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = g[u][i];</span><br><span class="line">			<span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">			<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> a = dfs(v, t, <span class="built_in">std</span>::<span class="built_in">min</span>(r, LL(c)));</span><br><span class="line">				e[j].second -= a;</span><br><span class="line">				e[j ^ <span class="number">1</span>].second += a;</span><br><span class="line">				r -= a;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f - r;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dinic(<span class="keyword">int</span> _n) : n(_n), g(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (bfs(s, t)) &#123;</span><br><span class="line">			cur.assign(n, <span class="number">0</span>);</span><br><span class="line">			r += dfs(s, t, INT64_MAX);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用-unordered-map-直接存边的-Dinic-算法（注意结果是否超-int）"><a href="#使用-unordered-map-直接存边的-Dinic-算法（注意结果是否超-int）" class="headerlink" title="使用 unordered_map 直接存边的 Dinic 算法（注意结果是否超 int）"></a>使用 unordered_map 直接存边的 Dinic 算法（注意结果是否超 int）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dinic</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator&gt; cur;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">	<span class="comment">// h[i] 表示 bfs 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路。</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		h.assign(n, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		h[s] = <span class="number">0</span>;</span><br><span class="line">		Q.push(s);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : g[u]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">					h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] != <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// f 表示从 u 点出发拥有的最大流量，输出的是 u 到 t 的最大流量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t || f == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">		<span class="keyword">int</span> r = f;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it = cur[u]; it != g[u].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = it-&gt;first;</span><br><span class="line">			<span class="keyword">if</span> (it-&gt;second &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> a = dfs(v, t, <span class="built_in">std</span>::<span class="built_in">min</span>(r, it-&gt;second));</span><br><span class="line">				it-&gt;second -= a;</span><br><span class="line">				g[v][u] += a;</span><br><span class="line">				r -= a;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f - r;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dinic(<span class="keyword">int</span> _n) : n(_n), g(n), cur(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 注意这里一定要这样！</span></span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u][v] += c; </span><br><span class="line">		g[v][u] += <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (bfs(s, t)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cur[i] = g[i].<span class="built_in">begin</span>();</span><br><span class="line">			r += dfs(s, t, INT_MAX);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="有向图-S-T-最大流-ISAP-算法-弃用"><a href="#有向图-S-T-最大流-ISAP-算法-弃用" class="headerlink" title="有向图 S-T 最大流 ISAP 算法 (弃用)"></a>有向图 S-T 最大流 ISAP 算法 (弃用)</h3><p>核心就是一句话，Dinic 算法中，每一轮需要进行一次 BFS，可以被优化，并且还有许多细节上的优化。</p>
<blockquote>
<p>折腾了半天发现并没有比 Dinic 快，本质原因是计算 dfs 完之后更新 <code>d</code>，按照上面的做法会极大的增加 <code>aug(s, INT_MAX)</code> 次数。但是确实比 <a href="https://codeforces.com/contest/1473/submission/104862713" target="_blank" rel="noopener">直接更新 d</a> 更快（可能时因为直接更新高度代码会写的很绕，因为可能变换的高度不止自己一个，父节点的高度也可能要更新），而在下面 HLPP 中用这这技巧又会特别慢，可惜~</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结合 https://www.cnblogs.com/owenyu/p/6852664.html 在实现上进行了相应的修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISAP</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, s, t;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="comment">// cur[u] 表示以 u 为起点当前没被增广过的边</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur, d, gap;</span><br><span class="line">	<span class="comment">// d[u] 表示残余网络中 从 u 到 t 的最短距离，注意到可以把 d[u] 理解成连续变化的（否则很难正确的更新 d)。</span></span><br><span class="line">	<span class="comment">// gap[x] 表示 d[u] = x 的节点个数, 用于优化</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span> </span>&#123;</span><br><span class="line">		s = _s;</span><br><span class="line">		t = <span class="keyword">_t</span>;</span><br><span class="line">		d.assign(n, n);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		d[t] = <span class="number">0</span>;</span><br><span class="line">		Q.push(t); </span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">int</span> v = e[i].first, c = e[i ^ <span class="number">1</span>].second;</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; d[v] == n) &#123;</span><br><span class="line">					d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		gap.assign(n + <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : d) ++gap[x];</span><br><span class="line">		cur.assign(n, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从 u 开始到汇点 t 不超过 f 的最大流，如果取到了 f 说明后面还有增广的可能</span></span><br><span class="line">	<span class="function">LL <span class="title">aug</span><span class="params">(<span class="keyword">int</span> u, LL f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == t) <span class="keyword">return</span> f;</span><br><span class="line">		LL r = f;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i &lt; <span class="keyword">int</span>(g[u].<span class="built_in">size</span>()); ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = g[u][i];</span><br><span class="line">			<span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">			<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; d[u] == d[v] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> a = aug(v, <span class="built_in">std</span>::<span class="built_in">min</span>(r, LL(c)));</span><br><span class="line">				e[j].second -= a;</span><br><span class="line">				e[j ^ <span class="number">1</span>].second += a;</span><br><span class="line">				r -= a;</span><br><span class="line">				<span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cur[u] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (--gap[d[u]] == <span class="number">0</span>) d[s] = n;</span><br><span class="line">		++gap[++d[u]];</span><br><span class="line">		<span class="keyword">return</span> f - r;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ISAP(<span class="keyword">int</span> _n) : n(_n), g(_n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> _s, <span class="keyword">int</span> <span class="keyword">_t</span>)</span> </span>&#123;</span><br><span class="line">		init(_s, <span class="keyword">_t</span>);</span><br><span class="line">		LL r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (d[s] &lt; n) r += aug(s, INT64_MAX);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="有向图-S-T-最大流的最高标号预流推进算法（HLPP）-O-n-2-sqrt-m-算法"><a href="#有向图-S-T-最大流的最高标号预流推进算法（HLPP）-O-n-2-sqrt-m-算法" class="headerlink" title="有向图 S-T 最大流的最高标号预流推进算法（HLPP） $O(n^2 \sqrt{m})$ 算法"></a>有向图 S-T 最大流的最高标号预流推进算法（HLPP） $O(n^2 \sqrt{m})$ 算法</h3><p>1988 年 <a href="https://www.cs.princeton.edu/courses/archive/fall07/cos521/handouts/p921-goldberg.pdf" target="_blank" rel="noopener">Tarjan, Goldberg</a> 提出次方法，1989 年 <a href="https://www.sciencedirect.com/science/article/pii/S0020019099000198" target="_blank" rel="noopener">Joseph Cheriyan, Kurt Mehlhorn</a> 证明了该方法时间复杂度为 $O(n^2 \sqrt{m})$，直接看 <a href="https://oi-wiki.org/graph/flow/max-flow/" target="_blank" rel="noopener">OI-wiki</a> 最后一张图（下载下来放大）还是很好理解的，Push-Relabel 那段没讲清楚，跳过的看就行，再结合 <a href="(https://www.cnblogs.com/owenyu/p/6858123.html">cnblog</a>) 理解一下优化（不要看代码）就掌握了。然后自己写代码即可。</p>
<p>个人理解其实此算法 ISAP 的优化，Dinic 和 ISAP 都要递归找可行流，但是此算法，先给了再说，多了的再取出来即可，这样不用递归了。</p>
<p>模板例题：<a href="https://vjudge.net/problem/LibreOJ-127" target="_blank" rel="noopener">LibreOJ-127</a>，跑的太慢，有待提升。</p>
<p>注意到每次推流的时候，当前节点时有水的（且高度小于 n 的，高度为 n 说明水是积水）里面高度最高的，因此更新高度的时候就不会出现问题！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HLPP</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LL&gt; ex;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFlow</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		ex[e[i ^ <span class="number">1</span>].first] -= a;</span><br><span class="line">		ex[e[i].first] += a;</span><br><span class="line">		e[i].second -= a;</span><br><span class="line">		e[i ^ <span class="number">1</span>].second += a;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 首先初始化 u 到 t 的距离得到 d[u]</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">		Q.push(t);</span><br><span class="line">		h[t] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = Q.front();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">int</span> v = e[i].first;</span><br><span class="line">				<span class="keyword">if</span> (e[i ^ <span class="number">1</span>].second &gt; <span class="number">0</span> &amp;&amp; h[v] == n) &#123;</span><br><span class="line">					h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] == n;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	HLPP(<span class="keyword">int</span> _n) : n(_n), ex(n), h(n, n), g(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">maxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (init(s, t)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		std::vector&lt;int&gt; gap(n + 1, 0), vis(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : h) ++gap[x];</span><br><span class="line">		<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">		<span class="comment">// push 之后 ex[u] 还大于 0 就说明当前超载了，需要提升高度</span></span><br><span class="line">		<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ex[u] == <span class="number">0</span> || h[u] == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">				<span class="comment">// 注意 push(s) 的时候不用管高度的问题</span></span><br><span class="line">				<span class="keyword">if</span> (c == <span class="number">0</span> || (h[u] != h[v] + <span class="number">1</span> &amp;&amp; u != s)) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">int</span> a = <span class="built_in">std</span>::<span class="built_in">min</span>(ex[u], LL(c));</span><br><span class="line">				addFlow(i, a);</span><br><span class="line">				<span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">					pq.push(&#123;h[v], v&#125;);</span><br><span class="line">					vis[v] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (ex[u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		ex[s] = INT64_MAX;</span><br><span class="line">		push(s);</span><br><span class="line">		h[s] = n;</span><br><span class="line">		vis[s] = vis[t] = <span class="number">1</span>; <span class="comment">// 起点和终点不会丢进队列中</span></span><br><span class="line">		<span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> u = pq.top().second;</span><br><span class="line">			pq.pop();</span><br><span class="line">			vis[u] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (push(u)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (--gap[h[u]] == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (h[i] &gt; h[u]) h[i] = n;</span><br><span class="line">				&#125;</span><br><span class="line">				h[u] = n - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">					<span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">					<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[u] &gt; h[v]) h[u] = h[v];</span><br><span class="line">				&#125;</span><br><span class="line">				++gap[++h[u]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ex[t];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="无向图全局最小割-Stoer-Wagner-算法"><a href="#无向图全局最小割-Stoer-Wagner-算法" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法"></a><a href="https://www.cs.dartmouth.edu/~ac/Teach/CS105-Winter05/Handouts/stoerwagner-mincut.pdf" target="_blank" rel="noopener">无向图全局最小割 Stoer-Wagner 算法</a></h3><p>无向图的 S-T 最小割可以通过 S-T 最大流来做（在 addEdge(u, v, c) 中两个边的权值都是 c 即可！）。<br>对任意给定的 S 和 T，全局最小割必然是 S-T 最小割或者 S-T 结合成一个节点后得到新图的最小割。Stoer-Wagner 的论文给了一种简单的方式给出某两个点的 S-T 最小割的办法，那么这个最小割的答案存下来，之后再合并这两个点再继续搞即可。而这个方式叫做 cut-of-the-phase，具体说就是，任取一个点，然后每次往这个点中丢 most tightly connected 点，论文中证明了这种方式得到的图，每一步都是最后两个节点的当前图最小割，所以所有点丢进来之后，最后两个节点的割就是原图的这个两个点的最小割。（直接图原论文很好理解，而且有例子说明）</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P5632" target="_blank" rel="noopener">LOJ5632</a></p>
<h3 id="无向图全局最小割-Stoer-Wagner-算法，邻接矩阵-O-n-3-实现"><a href="#无向图全局最小割-Stoer-Wagner-算法，邻接矩阵-O-n-3-实现" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法，邻接矩阵 $O(n^3)$ 实现"></a>无向图全局最小割 Stoer-Wagner 算法，邻接矩阵 $O(n^3)$ 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 做完 minCut 之后原图就毁了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoerWagner</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; del;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		del[s] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			g[i][t] = (g[t][i] += g[s][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StoerWagner(<span class="keyword">int</span> _n) : n(_n), del(n), g(n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n)) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u][v] += c;</span><br><span class="line">		g[v][u] += c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> cnt, <span class="keyword">int</span> &amp;s, <span class="keyword">int</span> &amp;t) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis(n), d(n);</span><br><span class="line">			<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">				vis[x] = <span class="number">1</span>;</span><br><span class="line">				d[x] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!del[i] &amp;&amp; !vis[i]) d[i] += g[x][i];</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">				push(t);</span><br><span class="line">				s = t;</span><br><span class="line">				t = <span class="built_in">std</span>::max_element(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>()) - d.<span class="built_in">begin</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> d[t];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, r = INT_MAX;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">			r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, f(i, s, t));</span><br><span class="line">			merge(s, t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r == INT_MAX ? <span class="number">0</span> : r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="无向图全局最小割-Stoer-Wagner-算法，邻接-unorded-map-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法）"><a href="#无向图全局最小割-Stoer-Wagner-算法，邻接-unorded-map-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法）" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法，邻接 unorded_map + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法）"></a>无向图全局最小割 Stoer-Wagner 算法，邻接 unorded_map + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 做完 minCut 之后原图就毁了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoerWagner</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d, del;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;s, <span class="keyword">int</span> &amp;t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (g[s].<span class="built_in">size</span>() &gt; g[t].<span class="built_in">size</span>()) <span class="built_in">std</span>::swap(s, t);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [x, c] : g[s]) &#123;</span><br><span class="line">			g[x][t] = (g[t][x] += c);</span><br><span class="line">			g[x].erase(s);</span><br><span class="line">		&#125;</span><br><span class="line">		g.erase(s);</span><br><span class="line">		g[t].erase(t);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StoerWagner(<span class="keyword">int</span> _n) : n(_n), d(n), del(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u][v] += c;</span><br><span class="line">		g[v][u] += c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> &amp;s, <span class="keyword">int</span> &amp;t) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">fill</span>(del.<span class="built_in">begin</span>(), del.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span> [i, c] : g[x]) <span class="keyword">if</span> (!del[i]) &#123;</span><br><span class="line">					Q.push(&#123;d[i] += c, i&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">				del[x] = <span class="number">1</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				push(t);</span><br><span class="line">				s = t;</span><br><span class="line">				<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">					t = Q.top().second;</span><br><span class="line">					<span class="keyword">if</span> (!del[t]) <span class="keyword">break</span>;</span><br><span class="line">					Q.pop();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> d[t];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, r = INT_MAX;</span><br><span class="line">		<span class="keyword">while</span>(--n) &#123;</span><br><span class="line">			r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, f(s, t));</span><br><span class="line">			merge(s, t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r == INT_MAX ? <span class="number">0</span> : r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="无向图全局最小割-Stoer-Wagner-算法，邻接表-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法还是-TLE-属实可惜）"><a href="#无向图全局最小割-Stoer-Wagner-算法，邻接表-优先队列-O-nm-n-2-log-n-实现（仅稀疏图跑的快-稠密图还不如-O-n-3-的算法还是-TLE-属实可惜）" class="headerlink" title="无向图全局最小割 Stoer-Wagner 算法，邻接表 + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法还是 TLE 属实可惜）"></a>无向图全局最小割 Stoer-Wagner 算法，邻接表 + 优先队列 $O(nm + n^2 log n)$ 实现（仅稀疏图跑的快, 稠密图还不如 $O(n^3)$ 的算法还是 TLE 属实可惜）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Edge = <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function">LL <span class="title">StoerWagner</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; e, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> f = [&amp;]() -&gt; <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">		<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">		std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; in(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [u, v, w] : e) <span class="keyword">if</span> (u != v) in[v].emplace_back(u, w);</span><br><span class="line">		std::vector&lt;int&gt; del(n), d(n);</span><br><span class="line">		<span class="keyword">auto</span> push = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> [i, c] : in[x]) <span class="keyword">if</span> (!del[i]) &#123;</span><br><span class="line">				Q.push(&#123;d[i] += c, i&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			del[x] = <span class="number">1</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">int</span> s, t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			push(t);</span><br><span class="line">			s = t;</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Q.empty()) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!del[i]) Q.push(&#123;d[i], i&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">				t = Q.top().second;</span><br><span class="line">				Q.pop();</span><br><span class="line">				<span class="keyword">if</span> (!del[t]) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &#123;d[t], s, t&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>, r = INT_MAX;</span><br><span class="line">	<span class="keyword">while</span>(n &gt; <span class="number">1</span> &amp;&amp; r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> [dt, s, t] = f();</span><br><span class="line">		r = <span class="built_in">std</span>::<span class="built_in">min</span>(r, dt);</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">id</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i != s &amp;&amp; i != t) id[i] = ++cnt;</span><br><span class="line">		id[s] = id[t] = ++cnt;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v, w] : e) &#123;</span><br><span class="line">			u = id[u];</span><br><span class="line">			v = id[v];</span><br><span class="line">		&#125;</span><br><span class="line">		--n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r == INT_MAX ? <span class="number">0</span> : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h3><p>在最大流的前提下，追求费用最小。一般通用的做法：每次找一条费用最小的可行流。<br>反向边的费用是原边的相反数，这样就会出现负边，但是因此初始反向边容量为 0，所以初始情况可以理解为图中没有负边。从源点到汇点的费用必然是非负的（因为我们每次走最小费用，所以每次的费用都是非降的，而初始没有负边。）当然这并不代表途中没有经过负边。至于为什么可以用 Dijkstra，很多博客都有介绍。下面代码中 h 为真实的距离，注意到 <code>h[s]</code>始终为 0，对于同一个点，每次的真实距离不减，它将作为下一次求最短路的势。这种思想也称为 Johnson 最短路径算法算法。可以 $O(n m \log m)$ 解决全源最短路问题。</p>
<p>我们这样再看一次：每次我们找一条最短路径，取流了之后，相当于给这条路径加了反向边，其它的都没有变化，如果我们把当前距离当作势，那么加的这些反向边，其实都可以看作加入了长度为 0 的边。那么我们一直这样搞，就相当于一直没有加入负边！搞定。</p>
<p>由于一般费用最小的路径只有一条，所以我们不妨在求最小费用的时候把前缀边找到，这样就可以直接求路径的最大流了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flow</span> &#123;</span></span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span></span><br><span class="line">	<span class="comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h, path;</span><br><span class="line">	<span class="comment">// h[i] 表示 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路，作为下一次求距离的势。</span></span><br><span class="line">	<span class="comment">// path[v] 表示从 s 到 v 的最短路中，path[v] 的终点指向 v</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">fill</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n, INF)</span></span>;</span><br><span class="line">		d[s] = <span class="number">0</span>;</span><br><span class="line">		Q.push(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> [du, u] = Q.top();</span><br><span class="line">			Q.pop();</span><br><span class="line">			<span class="keyword">if</span> (d[u] != -du) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[u]) &#123;</span><br><span class="line">				<span class="keyword">auto</span> [v, c, w] = e[i];</span><br><span class="line">				w += h[u] - h[v];</span><br><span class="line">				<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; d[v] &gt; d[u] + w) &#123;</span><br><span class="line">					d[v] = d[u] + w;</span><br><span class="line">					path[v] = i;</span><br><span class="line">					Q.push(&#123;-d[v], v&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((h[i] += d[i]) &gt; INF) h[i] = INF;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> h[t] != INF;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Flow(<span class="keyword">int</span> _n) : n(_n), h(n), path(n), g(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">		g[u].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(v, c, w);</span><br><span class="line">		g[v].emplace_back(e.<span class="built_in">size</span>());</span><br><span class="line">		e.emplace_back(u, <span class="number">0</span>, -w);</span><br><span class="line">	&#125;</span><br><span class="line">	std::pair&lt;LL, LL&gt; maxFlow(int s, int t) &#123;</span><br><span class="line">		LL flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (Dijkstra(s, t)) &#123;</span><br><span class="line">			<span class="keyword">int</span> f = INT_MAX, now = t;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">			<span class="keyword">while</span> (now != s) &#123;</span><br><span class="line">				r.emplace_back(path[now]);</span><br><span class="line">				f = <span class="built_in">std</span>::<span class="built_in">min</span>(f, <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(e[path[now]]));</span><br><span class="line">				now = <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(e[path[now] ^ <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : r) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(e[i]) -= f;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(e[i ^ <span class="number">1</span>]) += f;</span><br><span class="line">			&#125;</span><br><span class="line">			flow += f;</span><br><span class="line">			cost += LL(f) * h[t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &#123;flow, cost&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a><a href="https://zhuanlan.zhihu.com/p/324507636" target="_blank" rel="noopener">上下界网络流</a></h3><h4 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h4><p>首先每条边先满足下界，那么对应两个节点的入流都要改变，那么为了让每个节点平衡，我们可以起源点和汇点。比如入流多了，那我们可以把它从源点给它连这么多流的边，求最大流的时候，自然就会有出的跟他中和。</p>
<p>这样只需在差网络中求一下最大流得到的必然是可行流</p>
<h4 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h4><p>从汇点到源点建一个 下界为 0，上界无穷大的边，就变成了无源汇情形</p>
<h4 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h4><p>求完可行流之后，再根据原始的源汇求一次最大流即可。</p>
<h4 id="有源汇上下界最小流"><a href="#有源汇上下界最小流" class="headerlink" title="有源汇上下界最小流"></a>有源汇上下界最小流</h4><p>求完可行流之后，再根据原始的源汇（源汇互换）求一次最大流即可。</p>
<h4 id="（有-无）源汇上下界最小费流"><a href="#（有-无）源汇上下界最小费流" class="headerlink" title="（有/无）源汇上下界最小费流"></a>（有/无）源汇上下界最小费流</h4><p>附加边费用为 0，然后按照最小费用最大流跑一次就可以了。</p>
<h4 id="（有-无）源汇上下界最小费用最大流"><a href="#（有-无）源汇上下界最小费用最大流" class="headerlink" title="（有/无）源汇上下界最小费用最大流"></a>（有/无）源汇上下界最小费用最大流</h4><p>附加边费用为 0，然后按照最小费用最大流跑一次就可以了。然后再根据原始的源汇跑一次最大流即可。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">dna049</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dna049.com/graph/">https://dna049.com/graph/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dna049.com" target="_blank">dna049</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/rewardAlipay.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/rewardAlipay.png" alt="下次"/></a><div class="post-qr-code-desc">下次</div></li><li class="reward-item"><a href="/img/rewardWechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/rewardWechat.png" alt="一定"/></a><div class="post-qr-code-desc">一定</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/string/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 字符串模板</div></div></a></div><div class="next-post pull-right"><a href="/simplex/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">线性规划的单纯形法</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/codeforces/" title="Codeforces 汇总"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-22</div><div class="relatedPosts_title">Codeforces 汇总</div></div></a></div><div class="relatedPosts_item"><a href="/calculatorWithC/" title="计算器程序"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2015-12-15</div><div class="relatedPosts_title">计算器程序</div></div></a></div><div class="relatedPosts_item"><a href="/persistableAlgorithm/" title="可持久化算法"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/31/3K2pQYJoyl81Cwf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-06</div><div class="relatedPosts_title">可持久化算法</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"> <div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://hexo.io/" target="_blank" title="由 Hexo 强力驱动" data-pjax-state=""><span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://github.com/chachabai/hexo-theme-butterfly" target="_blank" title="主题" data-pjax-state=""><span class="badge-subject">Theme</span><span class="badge-value bg-blueviolet">Butterfly</span></a></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="https://github.com/" target="_blank" title="静态网页托管于 GitHub Pages 和 Coding Pages" data-pjax-state=""><span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen">GitHub</span></a></div><div class="footer_custom_text"></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="/" target="_blank" title="运行时间" data-pjax-state=""><span class="badge-subject">Since</span><span class="badge-value bg-orange">2015</span></a></div><div class="github-badge"><a style="color:#fff" rel="external nofollow noopener noreferrer" href="/" target="_blank" title="本人博客" data-pjax-state=""><span class="badge-subject">Author</span><span class="badge-value bg-gradient">dna049</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'chachabai/chachabai.github.io')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  if (document.querySelector('.utterances-frame')) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    const iframe = document.querySelector('.utterances-frame');
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !false) {
  if (false) loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN@latest/js/fish.js"></script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script></div></body></html>